Course Overview
Course Overview
[Autogenerated] Hi, everyone. My name's Jonathan Mills and welcome to my course using mongo d. B with no J s. I'm a technology advisor worldwide technologies in a frequent speaker on JavaScript topics around the globe. Now it's rare in a back end a p I that you won't end up having to make a call to a database or something on the back end. And Mangane be is one of the most popular back in databases for know Js and this course I want to show you everything you need to know toe work with Amangani be did a layer for your know Js applications. So in this course, we're going to get a manga D B database set up and loaded with data will create a repositories object that will use to work with Mongo. We'll build out all of the crowd commands in the repo, get ad update removed, and finally will build out a use of the aggregation framework from by the end of this course, we'll have all the information you need to connect Your know Js application to mongo. Now, this is not an interest among of course, and I'm going to assume you understand document databases and how they work. Now, if you don't that's OK. Just follow along with me and then maybe go back and watch one of the interest among old D B courses later. I hope you'll join me on this journey to learn about using Mongo D. B with no Js here and Paul site.

Getting MongoDB Running
Introduction
[Autogenerated] welcome to using mongo D. B with no Js and this course I'm gonna give you everything you need to know in order to build a know Js application wired up to mongo D B now specifically in this module. We're just going to get started with mongo, do some basic work like we're going to set the stage. We've got a a scenario that we're working through for this course that gives us some meaning and some context for what it is we're trying to do. I'm gonna work with you while installing mongo D. B. Now, I'm not going to actually walk through installation because it's gonna be different for every machine out there. But I'm gonna show you what to download and and where to go. And then I'll work you through one of the most common issues associated with doing an install of manga D B. And then we're gonna end by loading some data. I've actually provided a data set that we're going to use, and we're gonna write the shell of an application. We're gonna load some data into Mongo to be using that application in order to get us started for the rest of this course. All right, let's go get some work done.

Setting the Stage
[Autogenerated] what we're going to do just to make this more interesting and compelling is set up a scenario where we work for a company called Global Man Ticks and Global Man ticks. If you recall, if you happen to see my modules course I used the same company over there. There are conference website. Well, they are adding to their site, an article section on their website and it's gonna be our responsibility to build a repositories of newspaper data that they're going to use for one of their articles. And actually, if you look right here on this trail aboard, this is the to do that we are going to be working on, so we'll just drop it into doing now. What we're gonna do is pair program on this thing in order to get it done. And when I say pair program this, actually, my expectation is I would love you to pull up your I d. E right next to mine on the screen and work through this with me. It's gonna be much easier for you to understand everything we're talking about and play around with some of this around it. If you've got the code up and running and running through and fact throughout the course. I may just call out to you. Hey, did you notice this? All right, Now, if we open this up and we get to see all of the things we're going to do over the course of this course and we're going to start by loading some data, that's gonna be this module. And then in the next month, you will do all of these get get my i d at all the crunch operations. We'll get all those done in the next module, and then when we're done with all event, we're going to go last module and work on the aggregation framework with average finalists and finalists by circulation change. And those things will make sense once we start looking at what this data looks like. All right, now that we've got this going, let's get mongo D be installed in the next clip.

Installing MongoDB
[Autogenerated] All right, Now, let's take some time to actually go and install Bongo D B so we can get things up and running. All right, The way we're going to do that is run out to mongo d b dot com, and then we're gonna download it from here. We're actually going to go to software, and we're just gonna download mongo D B Now, depending on what machine you're on, Lennox or Mac or Windows, it's gonna be a completely different install process. So what I actually want you to do is just view the documentation on how to install and work through that as you go. Now, when you're done, you should be able to pull up a terminal and tight mongo D. When you run that, you should get something like this. No, not exactly like this, cause I'm gonna point out another issue. If you take my goody and it runs, you're in good shape. If you type mongo D and you get come in, not found, then you need to get Mongo de added to your path for whatever machine it is you're running now. This didn't work, and this is a common thing that I get from my other courses where I'm using mongo D B. We have this data directory data d be not found. That's really common because it doesn't create it automatically sometimes. And so you just need to create this directory, so just make directory slash data de bean. Ah, Permission denied. Now, this is something that you're gonna want to pay attention to because I don't permission to do this, but I'm gonna now do it with Sudo, and now it should be there. But when I run now, I get this attempted to read a locked file. I can't because my permissions air all wrong. So there's one more step that you have to do, which is to change the permissions on that folder, and we're actually going to do to commands. We're gonna pseudo the change mind 2755 identity be So this is only Mac and Linux. Um, and then we're going to pseudo the change owner of data D. B to the currently installed user. So we're gonna run that. And now I have Mondo di be up and running, ready to go. And now let's go get some data loaded into this system.

Starting Your Project
[Autogenerated] so open up a new V s code window and I'm going to use V s code because it seems to be becoming the de facto standard for JavaScript and new development. You're not obligated to use this, but it's going to make it easier for everybody if if you're kind of seeing the same thing I am. So we're gonna use V s code and just open up a new editor and whatever folder you're gonna actually do all your coding in When I pull up a terminal window, we're just going to do an M p m in it. And that's just going to kind of get everything going for us and ready to go and create this package that Jason that you'll see right here and then we're going to N b m install only one package. We're gonna m p m. It's all mongo D B. And when that's done, installing you should see it pop up is a dependency. And this is the version we're using three dot for for this course three dot for you can actually just do at 3.4 dato. If there's been breaking changes. Toe manga. If there's a new version. You just npm missile at 3.4 dot zero and that'll get you this specific version so you can follow along with this course. All right. Now, before we create our repositories and we start putting everything into the repositories, which is what we're trying to accomplish, we're going to create a file that we're going to use Abject, yes, that were really usedto put our repositories through its paces. So basically, we'll put some worker good in here. That isn't part of the official global Mantex project, but it'll test our repositories out for us as we go. You know what we're gonna do here? Let's start out by pulling in mongo D. B. So we'll just do bongo client require mongo, d B mongo client, and that gets us the basic manga client that we're gonna use to go through everything. Now, before we do anything, actually, we're gonna try something, and I'm gonna show you some admin comedians that are gonna let us inspect our database or our server so that we can see what's going on, and then we can We can see how things change where we start making some changes. So we need two pieces of information we need. Are you Earl? Which, if you installed it locally, should be local hosts. 27 0 17 If you ended up doing something else, like your attaching to a cloud server somewhere or something, then you put the u R l n right here, whatever it may be. But if you did it local, this is what you're going to use. And then we'll just put this in here to our Di Beanie. For this course we're gonna we're gonna be creating a new database in Mongo called Circulation. That's gonna be the name of our database, because we're gonna do some some newspaper circulation stats, and that's what we're going to drop in here. So we're just gonna create a new function called Maine, which we're gonna drop in here and to do all of our our work with, and then we're just gonna execute me. All right, let's go get some mongo D B code working. So the first thing we do is actually open up a client when we're dealing with mongo. So const client equals we're gonna create a new mongo client, and we're gonna point to the u R l That you kind of see right there. It gives us a hint that says, Hey, we need the U R I. So we're gonna pass that in the URL Now we need to connect. And if you're used to call backs and promises and all that kind of stuff, this is where things become a little bit tricky. And I don't I don't want to do all that for this. We're just going to do a weight, and that lets us hold processing right here on this main function until client not connect comes back. And so, in order to use, await their we're gonna do a sink right here, which is why I dropped it into a main function. And if you're not familiar with a single weight, that's fun. You don't really need to understand the whole premise of it other than if we have something that returns a promise. So client that connect returns a promise we can say a weight, and that's just gonna wheat. It's gonna stop processing until this gets done, and it lets our code look a lot nicer as we're coming down through this main function instead of nesting everything all _____ and we just get a straight line of code that does everything we need to do now the first thing we're gonna do is we're gonna gonna look and make sure our servers up and running. We're gonna check to see what databases are associated with our server and then we'll go load data and we'll run it again to see that we have a new database. So let's do const. Admin equals client, not D B d b name dot admin and what admin is is a an object that lets us do some introspection on our server. And that's what we're gonna do here. And we're just gonna run to things so that I can show you what this looks like. And then we'll go load a whole bunch of data and we'll run it again and see what new kind of information we have. So we're just gonna console dialogue to things admin dot server status and admin dot list databases, and this is gonna give us all kinds of information about our server end the databases in that server so we'll save and then let's run this and see what we get, Node abject. Yes. Okay, now we got a whole bunch of stuff when we ran to commands. And so let's look at the 2nd 1 First list databases you'll see right down here we have a list of databases, admin, config and local. You may say, Wait a second. We did client daddy be that d be name and that d be named was circulation. But circulation is not listed as a database, and that's because we haven't actually created that database yet. So that's Ah, an interesting thing about Mongo is the databases are created as you data to them on the flock. And so we can even connect here to a database that doesn't exist yet. Until we add data to it. It's not there now. This server status actually gives us a lot of information. I'll just kind of scroll all the way back up to the top here to kind of give you an idea of what we've got. So it's my Mac book pro. That's the host. I'm running version 361 I've got up time. I've got local time, all kinds of stuff. I've got connections. There's one connection. Currently, it's the one thing that's connected and running, and you can just kind of look through here and see all of the stuff you go in and work on any of those things to get the information that you want about the server that's running. Okay, now that we see the list of databases, though, let's go actually load data into Armando de Be database and then run that list databases again and see if we've added our new database.

Loading Data
[Autogenerated] All right, let's go ahead and get some data loaded into our database so we can see how this all works. All right? Now, if you go out to the course materials on this course, there is going to be a file called circulation dot Jason. And basically, it's circulation data for a whole bunch of newspapers, daily circulation rates, Pulitzer Prize winners, those types of things. And that's what we're going to use to do are repositories. So there's our circulation data now, in orderto load this data, we're gonna we're gonna start the process of building out our repositories. Well, actually, add the load data Method two are repositories, so we can just call circulation repo dot low data and pass that data in. Let me close this to give us more room. And then we'll come over to this side and we're gonna create a new folder called Repose and then in repose, we're gonna create a new file called circulation repo dot Js Now, we're not gonna do anything in here just yet. I'm gonna go ahead and write the code on the outside and then we'll go implement that code over on here on the circulation site. So basically what I want to do as I want to come right here and do constant circulation, repo equals require repose. Circulation repo. Okay, so that's going to give our are repositories that we haven't written yet, but it's going to give it to us. The other thing we need to do is actually pull that data. We're gonna do that with Constance. Data eagles require circulation. DA Jason. Okay, so now we have a repo and we have data. When we come down here in the main, What I really want to do is I just want to do const. Results equals await circulation. Repo got low data. So that's what we want to do. And when that is run, I'm gonna comment out server status and just go list databases When that's done. Lis databases should now have a circulation database in it, and it should be full of data. Results also should have a whole bunch of data added to it. So let's actually look at that. Well, just long out. How many results were were inserted, So we get that. So we'll see a whole bunch of stuff inserted and a list of databases. All right, let's go build our circulation Repo on our load data method. So we're gonna do the same thing we did before. We're going to have to include bongo d B. We're gonna do this a slightly different way, though. See, over here in APP Js where we said require mongo d b dot mongo client There's a slightly easier way in the new JavaScript called the structuring. Or I can just pull manga clan indirectly just like that. Now we're gonna create a function called Circulation Repo. And what this is going to do is build out our circulation object. This is called the revealing module pattern in JavaScript. So we've got a function that's gonna build out our repo, and then from there will put all of our stuff in here and just return the object. And then down here, we'll do module that exports equals circulation. Repo. But then, since when we execute it is going to return that ripple object, we're just gonna execute it right there. And so when you do a require circulation repo over here and up J s, you're going to get that repo object. So let's let's start building that out and see what that looks like. So we're gonna create a function called load data, and that's gonna be the function that we pass data into and then drop that into mongo and then down here at the end, when you execute circulation Repo, we're going to actually return the low data function inside this object. And then as we add the new they get, they get my i d. All those will just kind of add those right there. Okay, Now loaded is gonna go off and do a whole bunch of Mongo D B stuff. And we are doing the a single weight that lets us do it, you know, sequentially. But we still need tohave app Js colds and and wait for the awaken. The way we do that is by by still using a promise. And so we're actually going to return the new promise on the way a promise works is it takes a call back a method here with resolve and reject. And now we're going to do all of our mongo stuff. And so we're gonna do const client equals knew mongo client just like we did over on the abject site. Now, if you remember from the other side, this requires the u R l Right. And so let's come back overto Js, and we're gonna pull these two things and drop him up there. Okay? And now, in theory, when we go pull repo in, we can pull these two things out of process that environment or something like that. But for right now, we'll just leave him there because we're not gonna go build a mechanism to run this to give us our environmental variable. So we're not gonna worry about that right now. Now, in here in the repositories, we're going to do this, right? We're gonna build a try, catch block and and reject our error and all of that that we need to do for a for a normal system. Now that we're in here, I wanted I want to open up our connection. Remember here over an abject Yes, We did this await client, not connect. I want to do that to the problem is I am not inside an a sink function. And the cool part about it is on Lee. The function I'm inside has to be a sink, not everything. So I just come up here in my new promise and make that in a sink function, and now I can use a single weight throughout the whole thing. So I've got my await client connection and then we opened up our database. So our circulation database that remember doesn't exist yet because we haven't added any thing to that database yet. Now, here's where we're going to actually insert all of our data into our circulation repo. And so results equals await D B dock collection. Everything that happens inside a manga DVD database happened inside a collection. And so, in this case, our collection is gonna be newspapers. So we have a newspaper's collection inside the circulation database. That's the way this is gonna work. Now, in orderto load data in, we're gonna use a method called insert Many. Now there's a whole bunch of methods attached to collection, and over the course of the rest of this course will work through quiet. A few of them will do, add and remove and and all of those And for right now, though, we're just doing insert many which the idea is insert, many is gonna take a Jason object which happens to be what we're passing in on data and it's going to return the results of the insertion of that data so well, actually, just do resolve. We'll resolve results. So that should be everything. We need to get this load Data dat's run through it. We've got our circulation repo function that has a low data function inside of it. And when you execute circulation repo your returning an object that has this low data method on it and then our exports for module is the entire circulation reports Owen out, J Yes, that function is executed, so it just has not one load data object on it. And so if we start looking through this, we've got our circulation. Repo coming back with low data on it are Davis from circulation DA Jason. And then we do our load data with our data. Now, when this comes back, let's actually add results 0.0 p s onto our consul that log so we can see the actual data that's being returned by our execution. All right, let's save that. Open this back up and you might notice the node instance didn't shut down, and you actually have to do. Ah, control C to close that out. We'll fix that in the next clip on. I'll show you why that happens. Because you may run into that as you work through. All right, let's run this and see what we get. Okay, so in first, look at our databases. We now have a circulation database. Congratulations. That works. Hooray! And then you also will see the list of objects that were included and run. If we scroll all the way up to the top of this, we will see that we added 50 of them. There's 50 right there. You might also notice we haven't underscore i d for everything. If you look in circulation, Jason, there's no underscore ideas there. What that means is mongo successfully inserted that object, assigned an i d to it and then returned that object with the i d back to the client. And so we are now in shape. We've got data loaded and we're ready to go. So just for the fun of it, let's pull our troll aboard. Back up. Check off load data. We are 13% done with what we need to do to get through this course

Summary
[Autogenerated] all right, we are 13% of the way done with getting this repositories set up in this course about mongo. D be now in this module. Specifically, we took a couple of steps to get us 13% of the way done as we walk through building on this repositories for our express application. So we started by setting the stage, we are working on building out a repositories for a larger know Js application that will pull data out of a mongo D B database. We've installed Mongo D B, or we've hooked up to it. At least we've got that piece running and we've loaded some data. So we built the repositories object and has one method on it that loads data. And so now we've got data existing in Armando de Be database and we are ready to go. So when this next module will build out the guts of this object will do gets and inserts and all of those pieces that need to be done I will keep it wrapped inside this this app Js that will let us run through it, make sure everything's working

Working with CRUD
Introduction
[Autogenerated] all right, now that we've got our basic shells set up and we've got mongo to be installed with some data, we're going to start building out our repositories. Now. What that means basically is we are working through the process of building out a repositories of Mongo D B data for a larger no. J s application. We don't care about what the bigger application looks like. We're just focusing just on the repositories and in this module we're going to do crowd. And what that means is we're gonna create data, read data update and delete data, and we're not gonna do it in that order. But that's what the acronym is. And we're going to kind of build out R J s that what we have going so far into a little bit of a test harness. So it's gonna create some data. It's gonna run a whole all of our stuff, and then it's gonna clean itself up when it's all done, so we can run it over and over again to see how things are working. All right, now that we've got an understanding of what we're doing, let's go back into our app Js and set it up so that we can run it over and over again and do some asserting to make sure things are working right.

Building a Test Harness
[Autogenerated] All right. So the first thing we're gonna do is take our app Js file and wire it up. So it's more of a test harness. Four hour repositories. All right, so the first thing we're gonna do is pull in, assert so that we can just do a test to make sure things are working. So I'm going to say, const assert equals, require assert. And what assert gives us is the ability to just test things and make sure that right, Like, the first thing we're gonna do is if we come down here and when we do our load data right here online 14 then I want to make sure that the amount of inserted items equals the amount of items I sent in so we could do, assert, got equal data dot length and results dot inserted count. And what that's gonna do is allow us to make sure that we inserted the right amount of stuff. So let's get rid of this council that log, and we'll run this to make sure it worked. All right, now it worked, but we don't really know whether it actually is doing what we wanted to or not so let's do it not equal. And that way you'll get an idea of whether or not it actually worked or not. Ah, see, running this way we get an assertion mirror right here. 50 does not equal 50 because we wanted to do not equal while they do equal so through an air. So that's how asserts gonna show itself. And so we're going to actually just do. We'll go back to equal. I will just put one of these asserts, After everything we do and when they When things don't work, it'll alert us and let us know. All right, we'll get rid of that and we still want our list of databases. Now two things are happening that we want to to fix and make sure we have things set right before we move on and do the rest of the stuff we're doing. The 1st 1 is notice it's not ending, and I mentioned that in the previous module It's not ending when we're done running, and the reason for that is because we're not closing our connection, our connections hanging open, and so no Js isn't going to end its process until our connection is closed. So down here we can just do client dark clothes. And then actually, we have to do it. Also over in our repo when we're all done here, we'll do a client dot close There is, well, control, See running again. And now you'll see it ended on its own. The other thing it's doing is adding 50 records to our database every time we do it, and we don't necessarily want that. So what we're gonna also add in here is we're gonna clean up our database every time we run this, cause we don't really need the database. There were going to run everything kind of in order. So right down here, we're gonna do a weight client dot d b dot drop database and then we're gonna run that on what you'll see when we run. That is, we don't have a circulation database anymore. Now, if that scares you, uh, good. I'd be careful with this one. Notice we don't have a database anymore. So there you go. So now, basically, what's gonna happen? Every time we run this, the first thing we're gonna do is we're gonna drop 50 records into a circulation database then we're gonna do a whole bunch of stuff to it. That's where the crowd comes in. And then we're gonna drop that database so that we could run it over and over and over again. And I have to worry about over populating a database or having junk. Dana database is just something we could easily build this circulation Repo on top off. All right, now that we've got this harness built, let's go start the process of building out the rest of this repositories.

Get
[Autogenerated] All right, Now it's time to actually start building out this repo that we've been talking about for all of this course that will actually start getting some work done by getting some work done. I mean, let's build out this, get that we need in our newspaper repositories, this next requirement that we have to get moving. All right, Now, what get means is right here. I want to be able to say, Let's say get data equals await circulation. Repo not get. And what get data should be at this point is just 50 records. It should be the same 50 records that I inserted up above one. We're not gonna add any searches yet. That's gonna come next. But right now, I just want get to give me everything so I should be able to actually take the same assert and run it again with get data dot length and I should get 50 on both sides. Now. Obviously, that's not gonna work. And actually, if I run this right now, it's gonna fail. Saying circulation repo dot get is not a function, so we know it's broken. Now let's go build this thing. So, in circulation repo. I'm gonna fold up load data. We don't need that one right now. We're gonna create a new function called get. And then before, before we go any further, I always forget to do this. So we're going to remember to do this. We're gonna come down here and add that get function to the output. All right, Now gets gonna work the same way as Low Data did. The first thing we need to do is return. The new promise on that promise is gonna be a sink resolve rejects and then the guts of our function. Go ahead. Said Armando Client, these pieces that we're doing right now, we're going to do over and over again as we go all the way through, just to call out specifically the steps that we're gonna take. There were two are Try catch block. And then the last two pieces that we need the same as we've done before, await client connect and then get our d B name, which is circulation. All right, now this is get, which means I want to go to my collection and I want to get data out of it and the way we're gonna do that? Start with cots. Items equals D B dot collection newspapers remember, that's where we loaded our date into If I expand this back out Well, see, we we dropped it in the newspapers, so we'll pull it out of newspapers, and they were going to say dot Find. Now, what that's going to return to us is a cursor. It's not gonna return anything else, Just a cursor and that's not going to get us anything yet. It hasn't executed, hasn't done anything in order to actually get items back. We need to call items dot to array. And I'm gonna move it down here because we're gonna do something else. Were they here in just a minute? But know that d be that collection newspapers not find doesn't actually execute. It doesn't hit the database. It does nothing until you actually call to array. So here, we're going to do resolve, await items dot to array. I noticed I didn't need a wait up at the dot find I needed to wait down at the two array because that's where the work's gonna be done. So let's save that. And don't forget to close our client and then run and see what we get. We got Munger client side to find, because that's not even right. Right? There we go now. Ironic. All right. One more thing we want to look at, see how our assertion failed. 50 equals 150. Well, the reason for that, I kind of want I'm tryingto to demonstrate a couple of things that you'll find as you're building out your own repose and Bill doing your own things. In this case, when the assert fails, we're not dropping our date. So we want to come appear, build our try, catch block. But those in our try and these are finally now the problem with this is that we're swallowing the error from the A. Certain because remember, all in assert does is it throws an error so we don't necessarily want to throw in error. So what we do want to do, it's just spit out that air. So now when we run, we see our database and we see our assertion error 50 equals equals 200. So when that means is now where at least we're still showing the error. But we're allowing everything to clean itself up as we go. And so I wanted to get the point made as we went through this, that a search throw errors. But when we throw in error, we lose all of our cleanup. And so we've got to do this in a way that allows us to service the error but still allows us to new clean up. And that's what this way's gonna do. And so here we have 5200. But now if I run this again, it works on. The reason why it works is because we allowed it to clean up last time, so we it failed a 52 100 but then it cleaned itself up. Okay, so now that's working and we're in good shape. But there's two other things I want to add. I want to allow you to do a search, so I want you to pass something in to get and pull back what we want. And I want to play around a little bit with this cursor mentality and maybe allow you to limit the number of items that come back. So let's let's run that next in this next clip

Filter
[Autogenerated] All right, now that we've got get working, let's actually work on filtering some data and see how that works. All right, So if I go into my ab Js right here, let's take this, Get data. What we actually want to do now, his filter data from with get But we're gonna pass in a query. And this query is basically just a representation of the data we're looking for. So in this case, I want to look for a newspaper and something, and so what? I can actually leverages this. Get data up here. This data we've pulled back out, I can say, Hey, find me only one of these items that matches this new newspaper. So I can say get data sub four dot newspaper, and that's gonna pull the fourth item that came back. I'm gonna go pull that newspaper, and I want to basically go pull that 4th 1 again. And then I can just assert that Get data sub four equals filter data sub zero. Basically the 1st 1 because get always returns in the race. So it's going to return me an array even though it's only one item, but it's gonna return back filter data. If I run this, it's gonna fail because filter data sub zero is actually this first item because I'm not applying a query at all, and so this should blow up. And if we run this, we'll see it did fail because we expected Washington Post and we got us a today, so that's not gonna work out. So now let's go over to our Repo and apply this query, and it's actually super easy to do. We're just gonna get we're gonna put Queary there and then in our find, we're gonna book. Were you there? Done. That was it. That's how hard it wa ce if I run this, it's still failed even though there they're kind of the same. And so what we actually need to do is, instead of equal, we're gonna do a deep equal have that works so deep equal is gonna compare the objects because equal, they're two different objects, right deep equal compares. The objects are the object contents, and that's what we really wanted to do. So okay, that works were now filtering data based upon a query that you pass in and it was it was literally just that easy. Just dropped query in there and we're done. Now, I want to do one additional thing. Um, I want Thio play around a little bit with this idea of a limit. So let's add one more. Basically, what I want to do is I want to pass in my query empty, so that should return 50 items with the limit of three. I'm only want to return three item, and so I should say, limit dated that length should equal three. Now, if I run this, it blows up because I got 50 actual and I expected three. All right, so how do we do this? How do we implement this idea of a limit? On are our repo and you could do this a bunch of different ways. But I'm doing it this way just to kind of show you the concept and then defer the way you want to do it. You go implement it, how you want to. But if I go to circulation, Repo and I go into my get, I'm gonna add a limit. And then after my find, I'm gonna upend to that a limit using this idea of a cursor and so first things first is that of a constant. I've got to do a let because I know I'm gonna change it. And I'm actually going to say if limit is greater than zero so you can't pass in a negative limit or anything like that. We're going to say, Where's the items equals items dot limit limit and that's it. And so this introduces an interesting idea. I'm going to save this so you can see that it worked and notice no errors. So that's good. But the thing to understand here is there's all kinds of additional things like limit. You can drop onto your query and what will actually do. Just so you have them right here. So it'll be in than in the course materials. I'm gonna actually add all of the things that you can do. Let me close this so you can see it. So we've got collection, don't find out, project so and to add something or skip or limit or filter or comment or all of those types of things. And there's a comment here that lets you know what those things are in reference to, and I'm just gonna drop these in here. So you know, the types of things you conduce do as as you're working with this idea of this cursor that isn't yet an array of data. So I'm just gonna drop those there and those are we in the course materials, You can just go pull those out and you can play around a little bit. And so in this idea of coding along with me, you can use the skip do skip limit to go get the next three or like implement paging If you want to. You can you skip to implement paging or you can project. So project basically just adds another item to your query. So all of that kind of stuff that's all in there and you can play around with that as you want. So now we have querying. We have paging, you've got limit. So not true paging yet because you've got to do skip to do paging. But we've got at least a limit. Give me the 1st 25 items or give me the 1st 5 items get is done. But if I pass in an I d, it doesn't work. It actually breaks. And the reason Why? Because an I d isn't an i d And you can try that if you want to just go try passing an I D. But what I really want and if we look at our requirements, get is done. So we checked that off for 1/4 of the way through. But get by. I d should return just one item. I'm gonna pass you in the I d and I should get back to the item, Not an array with the first item is the item. But I should get just the item back, and so that's the next thing we're gonna implement.

Get by ID
[Autogenerated] all right, now that we've got getting and filtering and limiting data done, let's add get by I d our second method in our repositories. All right, we've got low data we've got Get data, Get by i d That's the next requirement that we've got to get done. So I'm gonna minimize get right below that. We're gonna do our get by i d. Now we're doing the kind of ah test driven ish kind of approach. So let's let's finish that out. Let's come back overto app. We've got low data get get with a filter, get with the limit. Let's do const by I d equals we want get by i d and what we actually want to do similar toe what we did up here in filter data I want to pass in Let's just say the fourth item and handed the underscore i d That's the i d that we got back on that and I want buy I d So a certain de be cool. I want buy I d to equal Get data four. Now there's a couple of things we're doing here, one by ideas. The item itself remember up on upon the filter data when we had to say sub zero because get always returns, an array will get my i d returns a single item. So by doing deep equal by I d. I'm saying, Hey, it's got to be the single item, not an array of items. And we're comparing it to get Data four, which I believe is the Washington Post. Right, 01234 Is The Washington Post All right? We'll save that. I'm head over to circulation Repo. And in here you've got to do the whole function, get my i d. And we're gonna pass in an I d and then the same stuff, right? Returning to promise client await client connects all of that stuff. And then down here in the bottom, we have to remember, get my i d. All right, so the trick of it comes right here in the middle. Right? So we've got const. Item is going to have to be the get right. So we're gonna do a weight just like we do every other time. D b dot collection newspapers dot Okay, So the way find works, right? So if we do find if the way find works is you pass in a query and it returns and a ray and actually returns a cursor that we kind of deal with, Right? But that's many items. If we do find one, it takes the same query, the exact same thing. But instead of returning the array and just immediately executes and returns the first item. So if I do find one, I don't have to deal with the two array or all that stuff. I can just do the resolve of just this item. Now we're doing by I d I'm not expecting you to pass in anything other than just the i d. So I'm gonna pass s So I'm gonna create a new object called Underscore Edie, I'm gonna pass in the i d. Now we're gonna run this and it's gonna work. It weren't everything's good, and that is horribly misleading. And so I wantto wantto talk through exactly what this means. So what an underscore ideas if if you understand how Mongo works and and as you're doing this course, I said I wasn't gonna do kind of intro to Mongo thing, but an underscore idea is actually a specific type. It's a type of object i d. And when we passed in tow app right here, we passed in Not a string of numbers, but we passed in an actual object, i d And that's not actually how this repo will work in the real world in the real world. Kind of like an arrest. Full FBI, You get the slash i d. You're gonna copy That idea's a string. They're gonna pass it in. And so that's kind of what I want to do right here. So instead of doing that, I'm going to do const I d equals don to string. And now we're just gonna pass and I d. Now, when I run this, it all fails on. The reason why it failed is because notice I got no back instead of the Washington Post. And the reason why that happened is because I need actually search by an object. I d not by the string. Representation of an idea doesn't actually work that way. So we're going to go back over into the circulation Repo, and we've gotta pull one other thing in if I come up here instead of just mongo client, which is why I changed it to be this way because I knew this was coming. We're just also gonna pull in object. I d just like that. We're gonna copy that. And instead of underscore i d he goes, I d We're going to say object. I d i d just like that. And basically, what that's gonna do is gonna convert this. I d the string into an object. I d Now, when I run it now, it'll go back to working again. Yep. Everything's fine. No issues. So now we've implemented to get by i d. And the key point here is find one takes the same query that fine does. But instead of returning the cursor, itjust returns the object, just the single object. And if you pass it an I d. It works fine. But if you pass in a string representation of I d. It fails. And so that's where we had to pull an object. I d to make that work. All right, so we're gonna come back over here. We're gonna check off, get by. I d. Excellent. All right, Now, let's look at ad item

Add
[Autogenerated] all right. Now that we've got our gets and filters done, let's take a minute to start adding items because, remember, we're working through building out a newspaper repositories. We've got low data done and get and get my i d. Now we're just gonna do add item, which basically means I'm gonna come in here and I want to actually have a method on my repo just dot ad And that's going to add a new item to the repo. So it's something like const added item it goes, await circulation repo dot and I'm gonna actually add a new item. So I I need a new item to add and the way we're going to get that is by, actually, just let's just copy something out of circulation. Don't, Jason. Let's just take this one. We'll use that so constant new item equals this thing we copy. So let's just change. This data will go. I don't know my paper and then change our circulation. We don't get a whole lot of it, but we doubled in circulation, so that's kind of awesome. Will do 100 then I have never won a Pulitzer Prize or ever met a Pulitzer Prize finalist. So that's our new data right there. But now that we've got add new item, we need to assert something. So how do we know that this new item was added And we can actually say assert added item the underscore i d. Because if added item has an underscore, I d. That was good. It's added, And if it doesn't that it hasn't been at it. And so that's that's what we're gonna actually look for is just check to see if underscore i d. Has been added to the item. Alright, so let's let's implement this ad. So what we're gonna do is we're gonna come down here, we're gonna do function, add item, just kind of like we've done all all along, and then we'll just drop this boilerplate in here for right now. Return to promise Call all of that stuff that we've done a couple of times, but we actually want to do now is call insert one, right? So I haven't item. I want to insert it. So what we're gonna do is const added item equals D B collection and our collection is newspapers dot insert one and Basically what this means is I'm gonna pass in one item. It's gonna hand me back one item if we look back down. When we did our low date, I see we did insert many. Now we're just doing an insert one we're gonna add Idol, and then we're gonna resolve added item. So let's save that. That should be it. We have now added an item. If I run, I get my ad is not a function why they didn't add it down here. Always remember revealing module to add down here. Right? So now if we run this again, it still doesn't work. And And I'm doing this toe to show and remind you of of what this thing actually looks like and works like right, because results is not the same as the thing that that's coming back. So it's actually at our concert there, but But we'll also add console that long so you can see added item. Now, when I run this, there's two things you're going to see. I kind of wanna walk through what some of these errors look like. So the 1st 1 is if I scroll back up, we get promise pending Onda reason we get promised pending is because we didn't put a wait right here. And so when you forget to do your weight, that's what that's gonna look like. It's gonna look at at that and say, Hey, this is a promise. Remember, all the weight does, is it fixes. Is that time? You promise dot Then it just just let you take the return. So why don't we wait there and it's still not gonna work. But now I'm gonna show you another error. So here is the object that we inserted. We've got ops, remember, from down here when we did load data ops was what the actual items are and then inserted count is one, and then the inserted I d. What? I actually want a hand back to the calling function is the item itself. So I need to do added item dot ops. But ops is an array, right? And so we've got to remember to do sub zero to get just the item. All right, now, everything works as it were pulling that item back. But what I actually want to do is I don't necessarily trust that right here, just that we have the item dot i d. Let's actually go and do and go pull it back out of the database and then assert this added item query equals new item on a deep equal. We'll rerun this real quick to see if they're equal and they are excellent. Everything's good. We're working through the right thing. And now we are successfully adding new items to the database. All right, so let's go over. Let's mark that one off. Bry, we are almost on 50 50 in order to keep with our flow. Let's go and update that item we just inserted and then we'll delete it to clean it all up.

Update
[Autogenerated] All right, Now, let's add the second to last sighted. We got two things left. We've got update and then we've got delete. So let's get update done, and then we'll do delete, and we'll be in good shape. All right? We've successfully done at item. Now we're gonna do remove item will be good. Good to go. So what I want to do is I want to come in here and I want to add a new method to circulation. Re poll called update. Now I've got to tell it what update? And I've got to tell it what I'm updating it with and what we're actually gonna do. I think with this in order to put some restrictions around are repositories. We're going to require the first parameter to be the I d. So let's actually just say, Hey, we're gonna update this thing. We just added, we're gonna pass the whole item in, but we're gonna change this item to be my new paper. So basically, what we're doing is we're saying, Hey, this thing we just added Now I'm going to update it with my new paper instead of my paper, and then I should be able to do the same to lines again. I'm going to go get that that one back out of the database again. And then instead of doing a deep equal, I'm just gonna say a certain equals will say this new added item dot newspaper should be my new paper. So basically, we're just checking to see I'm gonna call update with on this I d and then I'm going to go get it out of the database again. With that, I d I just Hey, it should have updated. All right, so now let's go in and create this update method in our re posit in our repositories. All right, so right here, we're going to create aren't function of update. And before we do anything else just so we make sure we do it, let's come down here and at it. All right. Was that our boiler plate? All right, So we've got i d a new item and then are trying our catch block. Now, what we're going to use here to do our updated item is we're gonna use the mongo, find one, and replace. So basically, we're going to find the item by I d and then we're gonna replace that item with a new I'd find one. An update is also available. The sin taxes is a little more clue g. So I wanna keep it as simple as possible. So find one of replace is the way we're gonna do it. Now find one and replace. Let's actually move this to a new line. So you've got some space to see. It takes two items. It takes a query just like fine does. And then it takes the new item just like that. Now, in this case, the query is gonna be bye, I d. We're only allowing you to pass the idea in, So we've got to do I d object I d. And then down here instead of added item from our boiler plate, we're gonna do updated item, not value, which of course, is different than everything else. But that's fine. Instead of ops, its value. All right, now we're going to run this and it's gonna work. So we have updated the item, but in this case, it's a little misleading and and now that we know we've got something working, I want to come back over to AP Js and I had one more assert because if I copy this assert and just check updated item. So if I say updated item dot newspaper So what's coming directly back from update should actually still be my newpaper. Right? So we went, got my i d. It works. If I do circulation repo Doubt update and just check that one. It fails, and it fails for a weird reason. So it says that updated item still has my paper instead of my new paper. And that's a weird little idiosyncrasy with find one and replace because it actually returns the find one, not the replace, which we can work around. And we can fix pretty easily with one new set of items. So we're going to do is come in here and say and pass in a new object of parameters into this and so say return original is false. And now I'm going to get the new updated item. And there you see now it all works. Excellent. Okay, so that's update. Now we just have to do remove and we're done with this module. So, actually, let's go and click update. Well, we're getting there now. We just have to do a move and we're done with this module. Let's make that happen

Remove
[Autogenerated] all right, Now it's time for the last item in our repositories the remove item function. So we've got get get my i d At item update Remove is the last piece of crowd that we're gonna do So let's go over to our code and in our app Js we'll close that for you in our app Js we have over the last couple of clips, we have created a new item with ad. Then we updated that item with update and now we want to remove that item with removed. So we're gonna do removed equals, await circulation repo dot removed and then the i d. Now here's the deal with remove right If an item is removed, it doesn't exist anymore. Like I can't return that new item because it it's gone. So what we're gonna do instead is just say true or false. It either removed or didn't remove, and then so we're just gonna assert removed just like that. Excellent. So if we go over to our circulation repositories, we're gonna come down and we're gonna create a new function. Remove. Drop our boiler plate in there. We've got our client are try our catch you know all of that stuff and remove Takes an I d. Now, the way remove works in mongo is you pass in a query, just like always. And we have two options. We have delete one, and we have delete many. In this case, we're going to do a delete one, and that'll be it. So let's say const removed equals DVD collection dot newspaper d b dot collection newspapers dot delete one. Or we could do find one in delete or delete one. Those are your options. Were just going to delete one. And we're gonna pass into delete a query, and we're gonna use the same quarry we've used before. We're gonna say underscore I d equals object. I d i d. And that should delete the item. Now, what removed is going to pass back is account of the deleted. In this case, it should be one. So if it removed deleted one great. Otherwise, we've got a problem before we run this. Don't forget to add Remove to our object down here. All right, let's run this on before we run it. Don't forget to drop a weight in there. All right, now, let's run this all right? And it worked. Now do we? How do we know it worked right? Because we're just asserting removed is one. Let's let's actually go do or get my I d and see what we get back. Let's actually look at what happens when we go and pull this back. So let's change this to deleted item and then console that log. Well, actually, just counsel that log the deleted item and we'll see what that looks like. All right, we run this, we get no. Which means that it wasn't it wasn't there, which is right. We've run. There's a whole bunch of times, it's right. So we want to do assert dot equal deleted item and no, run it and it works. Everything's good. We have a full blown repositories and let's let's do the celebration Boom. We are done with all of the initial items that we need. We've got these two for the next module, but for right now we are done with the base repositories. So let's do a quick summary before we end this module

Summary
[Autogenerated] All right, We have completed the main crux of are repositories in in this module. Basically, we work through our creator. Read our update, our delete. We've got all of that stuff built in. We did filtering. We did. Limiting all of that now exists, and a repositories that will hook up Whatever the main know Js application is into our repositories that we've built now because we don't We don't have the overarching application. We're just building up the depository. We've wrapped this little test harness around it, and we've played with some different asserts. And we've called functions and then done some more things and asserted So now all of this stuff is up and running and working. Now, sometimes the basic create, read, update, delete aren't enough. We want to do some aggregation, and Mongo has aggregation built in to its framework. And so what we're going to do in this next module is we're gonna pick up one aggregation pipeline item, and we're going to create a new repositories function that's going to average some things so we can understand how you implement the aggregation framework into your know Js applications

Working with the Aggregation Pipeline
Introduction
[Autogenerated] we have made it to the last module working with the aggregation pipeline in this course using mongo d B with no J s. And we are working our way through building out a repositories for a modern TB database of newspaper circulation data that's going to be used by a larger know Js application. We haven't been building the bigger application. We're just building the repositories as we kind of work through how this works. Now. Our last two requirements deal with the aggregation pipeline, and this is not again a Mongo D B course. It's more howto leverage it and node. And so I'm going to assume that you understand the aggregation pipeline. Now it's very reasonable to suggest that you don't and so I'm gonna point you, it's a resource is instead of talking through the whole thing. Ah, punch. It's, um, resource is on how to figure that out, and you can just code along with me. You don't necessarily have to understand it before you work through this module, but I would highly recommend understanding the aggregation pipeline if you start working with Mongo in know Js

Resources
[Autogenerated] all right. Before we jump into code, I'm gonna take just a minute to point out a couple of resource is that are available to you to work through the the pipeline itself before I start jumping into how to actually implement the aggregation pipeline in manga d. B. So we have a requirement here. Thio, calculate the average finalists from the data that we have. And there's two resource is that I'm gonna point you two. One of them is just the doc's write aggregation on Doc Stop lago di b dot com. And this will be a good resource if you just want to kind of understand all of the different options. This is a great document for helping you understand what all the pieces are and how they fit together and how they work and just kind of an overarching understanding of what's going on. This picture right here kind of sums it up. You've got a query that you could map it, then you would do sitting and all of those types of things. If you don't want to read docks, that's great. There's another option for you. My friend Nuri has a great monger d B course out there called Big Data and reporting with Mongo D B, which ultimately is just the aggregation pipeline. Now, this course isn't with no Js, so it's not gonna show had implemented in node. But this is a good one that helps you understand the aggregation pipeline. So once you're done writing some code with me, you can pop over to his course and look at how the aggregation framework works. Now that you've got some resource is, let's go write a whole bunch of code and then you go read those resource is

Using Aggregation
[Autogenerated] all right. It's time to start building on the aggregation pipeline, and we're gonna start with a simple one averaging finalists. Now, the basic idea here is I wanna build a method in my circulation Repo. That's going to return the average number of finalists. So if I go into circulation on Jason, we have this year Pulitzer Prize winner finalists 1992 2014 with the average number of fire finalists over the entire thing. That's it. So it's pretty easy to do if I just did it in code. But I want to do it in manga because it could be hundreds of thousands of rose and in practice on, I just want to be able to use mongo toe aggregate that all on its own. So if we go to circulation Repo, we're going to go average finalists. We're just gonna create a function. We use the same boilerplate that everybody else is, so we'll just drop that in. There we go Now. The way we're going to interact with the aggregation framework is just a constant average equals and then most of it's the same. So we just do a wait bebe collection newspapers, but then here's the new part dot aggregate. So remember, up here in like, get my i d We had d b that collection not find one or dot update or dot delete one and so on and so forth here we're just gonna do dot aggregate the aggregation pipeline or the aggravation framework that we're using here takes an array of items, and this array of items is just different steps along the aggregation pipeline. And for this one, we're only going to do one. We're gonna group all the newspapers together, just all of them, and we're going to average the finalists. And so it should be pretty easy inside this array. The first step and the only step is dollar group, and that's to group by. And we are grouping everything together so that the I d on this is gonna be all of it, areas they know, and what I d no means is I'm just group by everything. So to pull everything together and were going to say the average finalists is the new key that we're gonna put on, that's just gonna say, Hey, here's an average finalists that's gonna come across the whole thing actually, we'll just make this a little bigger here. Now the average finalists is going to use the average operator, which we use just by saying dollar A V G. We're going to average the Pulitzer Prize winners and finalists 1992 2014. Now, when were inside this type of scenario, we have to use a dollar sign here that lets it know what column, if you will, or which item on this objects we are averaging. So we're averaging the Pulitzer Prize finalists, and that's it that's going to return your average. Now what it's actually gonna return is because AGGREGATE is gonna work like finds is gonna return a cursor. So we want to resolve with average dot to array. Now, really, that's going to return an array that says, you know, idea of null and average finalists of whatever the average is. So really, I don't need the whole array. I just need the first item and I only need average finalists. So basically it's we're executing this whole thing to average the finalists. So whole aggregation framework we're turning that endure an array. But we only need the 1st 1 because it's only gonna return one. So I've taken the zero, and that's gonna return an object that looks like this. And so all I want is the average finalists. So we're gonna save that copy and drop that in there. All right, Now, let's try it. So we're gonna come down here and run through the same thing we always do will run through our whole tests. Now, I don't really want to test this one right now, because I don't necessarily know what the answer is, and it might change, So I'm just gonna console about log it. Right. So I'm gonna do caused average finalists equals circulation. Repo Average finalists. We're just gonna log this. That should spit out with number of the average number of finalists is So we run this. Everything breaks and it breaks with the weird error. Right? Cannot re property average finalists of undefined. So let's go back over to circulation Repo and kind of highlight What's going on? So, like, if you look right here, we did our await. But remember, this doesn't actually do anything. And down here, we're doing our to arraign, but we're not a waiting. So this is just a promise and that we're trying to do zero. It's another that works, right. What I want you to pay attention to through all of this is remember, it's the two array that needs to be awaited. And so if we stick that to array right there and then say average sub zero and average finalists now everything works. But it's all about where there's a way. It is so remember that as you're working through this and you're hitting errors, that's the part that matters. And that is one thing that becomes a little bit painful about a single weight, just kind of remembering where to stick that. But let's run this now. And how is the average finalist? 15.6 So now I'm getting my average and we're averaging 15 and that's the right answer. You can take my word for it, or you can go do the math by hand. That's fine if you want to do that. But that's a simple aggregation scenario. Let's do one that's a little bit more complicated next, but first we completed our average finalists. We have one requirement left, and that is all. So let's go over and do a slightly more complicated one in the next clip

More Complicated Aggregation
[Autogenerated] All right, let's do a slightly more complicated example that has multiple steps just so you can see how that works out as well. Now the requirement is average finalists by circulation change. And what that means is, if we go to our data, sometimes we have negative circulation change, and sometimes we have positive circulation change. And so what I want to look at is it Is there a difference on average of whether the number of finalists is higher or lower, depending on the circulation change? Let's just copy the one from before cause we're going to re use most of it. And we'll change the name to average finalists by change, because everything is gonna be the same except for our aggregation here. And I'll actually drop our aggregation out. There we go, and everything else is gonna be the same. So what we want to do as do two steps as we do this. So remember, it's Justin Array. We have stepped one we're gonna have stepped to The first step we're gonna do is a project. What project is going to do is allow us to modify the contents of an object. And so we've got a couple items that we just want to hold on to. We want to hold on to the name of the newspaper. How many Pulitzer Prize winner finalists they have and what the change in the early daily circulation is The way we do this is we just do Colin one and then just says, Hey, keep that keep this thing that exists already in place the way it is. But then we're gonna add another thing called overall change. Overall change is gonna do is it's going to look at whether or not that change in daily circulation is positive or negative and actually dropped positive or negative as the value for this overall change. And the way we do that is with an operator called Conditional. So dollar condition that actually just just NFL. So if dollar greater than or equal changing daily circulation, scroll over a little bit and zero. So if changing daily circulation is greater than zero, we'll cover because it's either positive or negative. We're gonna stay positive. Otherwise, negative. We close this explorer windows. You kind of try and see the whole thing. We're projecting newspaper bullets arise and change and then overall change with just this conditional statement. Hey, if greater than equal, positive otherwise negative. Now, the second thing we're gonna do is the same group by that we had up here, right? We're gonna just do another group by actually, let's just copy this group because we still want average the bullets rise. Winners from 1990 2014. We wanted the average, but instead of the I d being null instead of saying, Hey, I want to average everything I want a group it by the overall change. So here you see a situation where two steps I've got the projection which adds a conditional overall change of either positive or negative. And then I've got a group by on top of that that's gonna now group by this overall change and then average the finalists. So now I have average finalists by change, and we're gonna add that to our return. All right, now, I kept my resolve from before, and this time I don't want that. I'm just gonna actually want to take the whole thing. I want to take the whole array because I'm gonna have to items in it now. All right, so let's come over here. Average my change. An average finalists by change. Well, console dot Log our average by change. Okay, let's run this and see what we get. There you go. So our average finalists for the 1st 1 and then we have our more complicated Hey, if it was ah, positive circulation change. They had Maur average finalists than a negative circulation change. So if if overtime if we go to our city their circulation went down like say, here on average, they had fewer Pulitzer Prize winners or finalists. The people who had a positive. Here's this one's a positive they had significantly more. So if you look through the data, you might question our results, and that's fine. But overall, that's how that shakes out. Okay, so there's Ah, there's a simple, just one step aggregation use right here in average finalists and then a more complicated multi step aggregation, using with average finalists by change using project and group. All right, that's it. Let's actually go ahead, click our average finalists by change and notice. We are 100% done. Let's just sly that card over to done. We are done. Let's hop over for a quick summary

Summary
[Autogenerated] All right, That's it for this course we have closed out are repositories object and we've learned a lot over the course of this course, we started out by installing monger D B and loading some data into it. Ah, data of newspapers and circulation changes and Pulitzer Prize finalists and all that. We loaded all this data in to Armando de V database, and then we worked and built a full repositories object In this repo object that you have, you can take an apply to whatever you've got in terms of data. The basic shell of it should be about the same. You're gonna open a connection. You're gonna d'oh get get by i d at update all of that stuff and then return date about. And then we use aggregation just right there at the end. The aggregation, pipeline eyes, something you might go explore a little bit more using using Nouri's course or going out to the documentation. But we implemented that aggregation pipeline in Mongo, and the little caveats associated with that we did it all in a repeatable way. So we built an apt on J s. That kind of wraps are repositories object and lets us run it over and over and over again by deleting a date. The date after we load the date and just kind of working all the way through and and that's the way I like toe work is if I'm working on just a little piece, I just write a little wrapper that that lets me run it over and over again. So I know it all works and I and I get there and I go. So now that you're done here like I said, pop over to Mary's course and watch the aggregation so you understand a little bit more about how aggregation works and then go drop this code somewhere into a real live application.
