Learning npm is important because it is one of the most widely used developer tools. In this course, Getting Started with npm, you’ll learn to use npm with your development. First, you’ll explore the basic tasks in npm that will be used on a frequent basis such as creating a project and installing dependencies. Next, you’ll discover advanced scenarios for npm such as installing from alternate locations, pruning, and auditing. Finally, you’ll see how to publish your own packages to npm. When you’re finished with this course, you’ll have the skills and knowledge of npm needed to handle both common scenarios and advanced tasks & skills.

Course Overview
Course Overview
Hi, everyone. My name is Joe Eames and welcome to my course getting started within PM I'm a friend and developer, teacher and author. Learning and PM is important because it is one of the most widely used developer tools, and the concepts behind it are very valuable to just about every developer. In this course, we're going to learn the basics of using NPM in your daily work flow, advanced topics like auditing and dealing with specific versions, and finally, how to create and publish our own packages to the N. P M repositories. By the end of this course, you'll know how to do everything within PM to get your job done and use NPM to its fullest before beginning this course, you should be familiar with using a terminal. I hope you'll join me on this journey to learn NPM with the getting started within PM course at Pluralsight.

npm Basics
Introduction
Hello, I'm Joe Weems and welcome to Pluralsight, Getting Started with NPM course. I'm excited to present this course to you. I've been doing open source development for quite a while now, and MPM is one of the basic tools used in almost all open source and Fran and development. It's the package manager against which all package managers are measured, so it's definitely a tool with which all open source and Web developers need to be familiar. This course is organized into three different parts. We'll start by looking at the basics of N. P. M. This includes not only the basic vans but also the basic usage of N. P. M. The type of things you'll do on nearly a daily basis within PM After that, we'll look at some advanced topics within PM These are the topics he probably won't use very often, But they're still good to know about, because under certain circumstances they could be very valuable. Finally, we'll talk about publishing your own package within P. M. Most the time when we're using in P M, we'll be building a product for user's, but occasionally we may want to build a product for other developers to consume, and an easy way to do that is to publish that code through in P. M. So the other developers can easily add it to their own projects. This section will show you exactly how to do that and how to keep it up to date. And with that, we'll get started with our course.

What Is a Package?
[Autogenerated] it's useful to understand the difference between a package and a module. A module is a single JavaScript file that has some reasonable functionality. A package is a directory with one or more models inside of it and a package dot Jason file, which has meta data about the package. A package can be very simple. For example, Underscore just has a single JavaScript file. We see the two versions of it, the regular version and the modified version and a package dot jace on file. Where is the more complex package like Express has one. Jobs got file in the route, but inside it's subdirectories has quite a few more Java script files and more within subdirectories of that. So this is a much more complex package that's very common for people to refer to a package as a module. She shouldn't be confused or thrown off when somebody does this, but when we use in P. M, we're actually working with packages, which is why it's called the node package. Manager

Typical npm Usage
[Autogenerated] one of the common things you'll use MPM for is to look at other people's sample or starter projects. When dealing with projects like this, there's a very typical flow that we'll go through. The first thing we'll do is we will clone the project using get. Once we have the project cloned, we'll move into the directory and then we always install using NPM. Install this one stall any dependencies noted in the package dot Jason file for that project. Now we have everything installed. We want to see it in action, and we'll do that using the N. P. M Start command. This is only going to work of the project that you downloaded has created a start script to determine if the project does have a start script. He just opened up the package dot Jason file here. I'm showing the package dot Jason file for this project, and you can see under the script section we have a start script and attest script. Let's run that start script. In this case, this project starts up a server running on Port 3000. Another typical thing that we want to do is run the test for the project, and we can do that with NPM test again. This only works if the project has created a test script. But if it does support tests and there's a good chance they did create a test script, oftentimes we don't care if the tests are passing. Unless the demo is specifically about testing so frequently, we will skip this step, and that's the typical flow that we use when dealing with sample and starter projects.

npm Help
[Autogenerated] getting help with MPM is actually pretty cool. You have several options, obviously, within PM, just like most manly utilities, you can do in P M. Dash H and that will give you a list of the typical and PM commands and some minor information about them. You can also do N P m and then a command, for example, install and dash H, and that will give you more information about that specific command, usually just the different kinds of usage for that command. But there is another option that's very cool, which is in P m help. And then the command. This will actually open a browser to the official HelpAge for that command on in p. M. This not only gives you the syntax, but also a lot more information because the help documents are a lot more complete than just the command line. Help that you can see

npm Shourtcuts
[Autogenerated] There's one specific help document that you should be aware of, and you'll probably want to refer back to multiple times, and that is right here, the miscellaneous config page. The reason for that is that if you scroll down on the page, you will come into a list of shorthand commands. Foreign PM There's really nice to refer to frequently so that you can learn and memorize thes shorthand commands for the different longer commands in N. P. M. And this doesn't actually list out all the shorthand commands it lists at all the shorthand for the flags. But there are other short hands that aren't listed here. For example, NPM install can be shortened up to just N. P. M I. So not every shorthand command is listed on this page, but a whole bunch of them are, and that's really convenient to be able to refer back to this whenever you need. Thio

Creating a package.json
[Autogenerated] when you're working with NPM, there's really two kinds of projects you're gonna be working on. The 1st 1 is gonna be your typical project, where you're building something for user's. It's a website, Ah, Web application, something of that nature where there's going to be users that are using it a some kind. The other kind of project that you deal with within PM is 1/3 party package, something you're gonna build for other developers to consume. We'll talk about building packages for third party consumption later on. But for now, let's talk about the first kind of project a project they're gonna build, probably for other users or yourself to use with this kind of project. There's a couple of reasons that you'll want to create a package that Jason file The first is to track the dependencies of the packages that you're using. So whatever packages that you download and install through in P. M. You want to keep track of those. And the other reason is it's a quick and easy way to create some little scripts. This will help you avoid having to install, grant or gulp just to save you a little bit of typing every time you want to start your project up, we'll talk about scripts later on. But for now, let's talk about just creating the package dot Jason file. The command to do that is NPM, innit? This command is going to walk you through a series of questions. Now, those questions they're going to change as versions of N P m change, so you may not see the exact same questions that you'll see here, but even so, the differences will be fairly minor. One nice thing about NPM in it is that it will give you defaults for every answer, so nothing is truly required. You could just hit enter at every point and create a default package dot Jason file. Now, the nice thing about the fact that it gives you all these defaults is that these questions really don't matter if you're not publishing. This is a package in N. P. M. Then this information is completely for your own benefit. If you publish your project on get hub, other people may see this information, but the accuracy of this information really isn't going to make a difference. So for the name, I'm just going to accept the default here by hitting Enter version 1.0 is just fine. Description. I'll just leave blank for the entry point. Alex at the default test. Command default. Get repositories default keywords. Default author for this, I'm gonna fill in my own name just for vanity purposes. But again, this really doesn't matter. License looks at the default at this point. It actually shows me the package that Jason that it's going to create. And one thing that you'll notice is it's a little smart. I've already installed Express and its pick that up and put that into the dependency section for me. So if I create this package that Jason after I've been developing for awhile, whatever packages have already installed are going to show up there in the dependency section, then I just hit Enter to accept this as being okay, and my package dot Jason file has been created. Now you can always create a package that Jason filed by hand, but I find that it's so quick to type in N p m in it, and then just hit enter a whole bunch of times, have it create my package that Jason file for me. And if that's what you're going to do, is just accept all the default. There's actually a faster way. If you type in N P M in it and dash, why that M. P. M. Will quickly create a package of Jason file for you with all the default answers accepted.

Installing Packages
[Autogenerated] installing a package with MPM is pretty straightforward. We just used the N P M Install command, and then we give it the name of the package we want to install now. Most of the time, the name of the package is probably the name that you refer to that product. For example, if you want to install express, it's just express if we want to install low dash that slowed ash. But sometimes the package names don't actually match with what we call them. For example, there might be, theoretically speaking, a package out there that represents an ion drive, which could be useful in taking a trip to Mars. And internally, they might just call that product ion. But because the word ion was already taken, we actually have to install it using Ion Dash Dr. In order to find out what the name of the packages to install. Generally, it's best to just go to the packages home page and look for their set up instructions. Now, if we would install something like express after that's been installed, NPM will automatically add it to our package dot Jason file, and you could see that listed here has been listed in the dependencies. This is an automatic thing. We don't have to do anything extra in order to get that functionality. But if he wanted to install something into the depth dependency section, for example, Js hint. Then we'll need to use another flag to tell N. P m to listed in the deaf dependency section. And that is Dashed ___ Save Dash, Dev. Or for sure you can use Dash D and now we can see that that's been listed in the dead dependency section and Express is still listed up in the dependency section.

The package-lock.json File
[Autogenerated] Now that we've installed a couple of packages, you may or may not have noticed that there is a new file that has appeared in our directory, and that is the package dash locked out Jason File. That file got created when we installed some packages. If we were to look inside of the package lock Jason File, we will see ah, lot of Jason. And what all this data is actually specifying is the exact versions of every package that got installed. There's a very important reason for this. Let's say that you have installed the ion drive package and the eye Andrea package actually depends on the particle package, the accelerator package and the navigation package. And so when you install ion drive 1.8 dot to it installs particle to doubt 1.0, accelerated 114 and navigation 071 But a few days later, one of your coworkers installs that same project, and when they install, they actually get particle 2.1 dot one. Because a new version has been released in the time since you installed. Now there's a difference between your two installation directories and that can sometimes run you into trouble. And so the package locked out Jason Files. Purpose is to specify exactly what reasons were installed, and you check that file in the source control, and everybody else uses that same package like Jason. When they do the typical flow of just running in p m install, it will look at the package, locked out Jason file and installed those specific versions, and that makes sure that everybody on your team is running off the same exact versions of all packages so they don't get any weird issues where something works for one person, but not for another.

Listing Installed Packages
[Autogenerated] when we have some packages installed, we often want to find out what packages are actually part of our project, and MPM provides a list command for that. So if you just type in NPM list, we'll get listed out all the packages that we've installed plussed all of their dependent packages. Now, if I scroll through this list, you'll see that this is incredibly long. But yet if we look at our package Dodge a son file, we could see that I've only installed two packages expressing GS hint. And yet just those two packages have installed a lot of other packages so often times using list can be just a nen comprehensible mess. Thankfully, there's quite a few different arguments you can add to the list to command, to make it a bit more usable, for example, there's a depth command, and this specifies the number of levels deep you want to go. So if you want to just see our two libraries expressing Js hint and just the packages that they directly depend on, we can use a level of one for depth, and that will then show each of the two main packages that we've installed Express adjacent and just what they depend on the most common by far usage of this is to do depth of zero, and that will just list the ones that you've directly installed. In addition to that, there is a long flag, which will print out a lot of detailed information on each of the libraries or packages that's getting shown, so you can see here what that looks like. There's also Jason, which puts it out in a Jason format. There's a parcel for Matt, and you could see that basically just lists out the directories. We can also limit one of these two just are deaf defenses by putting Dash, Dash, Dev, and we could limit it to just our production dependencies, our regular dependencies by using dash, dash prod. And finally, when doing this command, there is a very common alias for it, which is in P. M. L s

Installing Global Packages
[Autogenerated] there are times in no need to install NPM packages globally. The reason for this is not to be able to avoid having to install them in every project that you need that package, but instead, this allows the package to create a command that can be used from the command line. For example, if you want to run gulp, you're going to need to install it globally. Otherwise, the Gulp command doesn't work from your command line. So in order to install a package globally, used the same command NPM. Install the name of the package and then you used the dash G flag. This will install the package globally. When the package is installed globally, it doesn't get installed into the node Montel subdirectory of your current directory. Instead, it goes into a special directory on your computer. So if you want to know what global libraries you've got installed instead of locating that directory and looking at the contents of it, it's much easier to use the list command, adding the dash G flag. And then, of course, you want to use a depth of zero. So you just see the library's even stalled

Removing a Package
[Autogenerated] now that we've installed some packages, we might want to uninstall some packages, too. And that is, as you would expect, done with the N. P M uninstall command. And, of course, we give it the name of the library wantto uninstall. So if we want Wanna Stall Express, we just do it like this. At this point, it's been removed from our Node Models directory and also from our package dot Jason file. There are a few aliases for in P m uninstall, and those are N p m r m in P. M. U N and N p m r. And lastly, if you want to install some package globally, you're going to have to add the dash G or Dash dash Global flag in orderto uninstall it from your global note package depository.

Installing Specific Versions
[Autogenerated] most the time when we install a package, we want the very latest version, and that's what happens when we just give the name of the package. In this case, if I install underscore, I'm going to get version 1.8 dot three. But there are times when you want to install a specific version of a package. This is especially important in critical applications. Were updating a package to new version might break your product and the consequences could be catastrophic. In those cases, you want to make sure that you're only installing specific versions of libraries. This is particularly important in mission critical applications, but it could be important and other kinds of applications as well when dealing with specific versions of packages. It's important, understand semantic version ing semantic version. ING is a system of version ing whereby each of the three numbers means something to everybody, and not just to the developers who decide what three numbers mean. So in the case of Underscore, which is currently at 1.8 dot three, each of these numbers means something very specific. One is the major. Version eight is the minor version, and three is the revision or patch number. We'll start with the patch number first. The patch numbers on Lian committed when you make something like a bug fix or performance improvement to a product, something that doesn't change functionality. So, for example, if there was a bug and underscore that they fixed or a new performance improvement, they might revision it toe one body not for Meanwhile, the minor version means that there are new features involved, so if a new feature was added to underscore, then they would update the version toe 1.9 dot zero. In this case, no existing functionality is broken. But new functionality is added in the case that you actually break functionality and do something that's no longer backwards compatible. That is the time when you update the major version. So, if underscore, were you going to do something as simple has changed the signature of one of its functions and reverse the parameters that would break existing code, in which case are 1.9 dot zero would now become 2.0 dot zero. Understanding this, we can now understand how version ING works within PM an MP and I want to install a specific version of a package. We can just use the install command with the name of the library than at sign and then the number of the specific version we want to install. So in our case, you might want to install 1.8 dot too. But we can get a lot more complex than this. For example, we might want to install the latest version of 1.8, in which case we can change the two to an ex or weaken. Just delete the patch number itself. In this case, Underscore will install the latest version of 1.8. If we change this twin 0.7, we will install the latest version of 1.7. If we change this 21 dot X, then we'll install the latest version of Underscore One, which at this point would be one dot a 1.0.3. We can also just remove the dot X and get the same functionality. But we can be even more complex than this. For example, by introducing quotation marks, we can use things like a greater than sign and then give a version number to say that we want anything past version 1.1 dot zero. This would not include 1.1 dot zero itself. Unless we added an equal sign, We can also say that at the same time you want anything before 1.4 dot zero. This will in general install the latest version of 1.3. We can even get more complex than this by adding in an or operator and another range. But in most cases, we really don't need all this functionality. There are three main cases that we want to handle the first cases to simply install the latest version of a library, which we do with syntax like this. The second case is to install a very specific version, which we do like this by adding the version number after the outside. Finally, we might want to install the latest in a specific major version. For example, Express is currently on version four, and if we wanted to install the latest version of Express three, we could say anything before four or three dot exe or just three, and that would give us the latest version of Express three. And if we know that express three works, we can trust the authors of the library that they won't break any functionality in any version of Express three. Now, if I just want to install the latest version of Underscore, then my package dot Jason file would be modified. We could see that underscores been added as a dependency. But this little carrot right here means that if Underscore publishes a new version and goes to version 1.8 dot four or 1.9 dot zero, the M p M will install that latest version and not 1.8 dot three. In most cases, that's just fine. But if I want to install a specific version of UNDERSCORE and not let NPM upgrade me to the latest version than when I install, underscore and give it a specific version number. But I'll also need to add the dash dash save dash exact flag If I install like this Now, my package that Jason lists 1.8 dot to without the carrot. That means that N. P. M will only ever install 1.8 dot two for me and not automatically upgrade me to a later version of Underscore. This is the kind of thing you want to do on mission critical applications with large teams. For you only want to upgrade your dependencies to newer versions under very specific circumstances after evaluating and testing that the new dependencies don't break any existing functionality.

Installing Existing Dependencies
[Autogenerated] It's very important to understand how dependencies are installed based on what specified in the package dot Jason. So we're just gonna take a quick minute and look at a couple scenarios. Let's first install a simple library like underscore and noticed that it reports out to us that we've installed one dot Tenn 1.0.2. If we go look at our package dot Jason, we can see that it's specified one dot Tenn 1.0.2 with the carrot. Now let's remove the node modules directory and let's also delete our package lock file, and we're gonna go back into our package. Die, Jason. Let's change this toe 1.8 Got zero. Say that change come back and now we're going to install a thin PM install. And what do you think's going to happen? Let's look and see what actually got installed. All right, you can see there we have underscore one dot Tenn dot to. Still, it's because of the carrot that we're getting the latest minor version of Underscore one that had not to Its current time is the latest version of one. So we're getting that if we want to get the latest version of 1.8. We gotta change this carrot to it till the then we'll go back to the command line, remember, move our node Modules directory and the package like Jason File And then we'll install and let's see what version we have now. And so now we're getting one today about three, which was the latest minor version of 1.8 because of the Tilda that we used instead of the carrot notice every time I had to remove the package lock Jason file. That's because whenever you install, if there's a lock file is going to use whatever specified in there and ignore our package. Dodge a son file. That's very important to understand. You could end up messing around forever with your package da Jason file. And as long as you still have a package locked file, it's just gonna stall whatever specified in there. Now if I just want the latest version underscore and I don't care whether it's a minor version of Patch Furs and or even and brand new major version, then the way to do that is to change this whole thing to either an asterisk or an ex. Either one will let me install the latest version. No matter what it is of underscore, we'll stall really quick and list again and we're back to one dot Tenn dot to understanding these things about how the package dot Jason file works and its specifications those air really one of the key parts of working with NPM.

Updating Packages
[Autogenerated] one of the great features of N. P. M is the ability to easily update your dependencies to their latest version. Here in this sample, I've got a package dodge, a sawn file that specifies that I've got underscore is a dependency at version 182 and Js hint at version 2.7 dato. Both of these have a carrot, which means we can take to the latest minor version, but we're not going to update to a new major version. I've actually got installed versions to 0.7 dato and one dot a dot to now. Both of these libraries have a newer version than this. So in this scenario, we installed these earlier on, and now they've been updated to a newer version within PM Whenever I want to update to the latest version, I'll have to do is type in N. P M update. At that point, NPM goes out and grabs the latest compatible version of all your dependencies and updates thumb. If I now check and see what I've got installed, we can see that I got Gs and 2.8 dato on underscore 1.8 dot three, which is currently the latest versions of those two libraries

Setting Defaults
[Autogenerated] after you've used in P M in it a few times, you'll find there several sittings that you'll keep the same every time Using the N. P. M set command, you can set some defaults for in P M in it. For example, if you want to set the author name, you could use NPM set in it Dash Author, Dash name and then put in your name as you'd like it to appear to get a list of these defaults you can set if you go over to the m. P M documentation on they're using NPM under the CONFIG section and search for innit, Dash. You'll find a list of these settings. There's a NIT module, which isn't too useful. Author, Name, author, email author, Your L license and version. We've already said the author name to a default. It's also set the license. We'll set this de mai thi and now if we use NPR Net and we just accept the defaults, it will include our author name and the default for the license is now M i. T. If you want to check and see what one of your settings was set to meetings, MPM get and the name of the setting. You wanna check if you like to remove a specific setting, use NPM config fleet and then the name of the setting. The reason we have config in there is because the n P M set AM PM get commands are actually short for NPM Config set and NPM config. Get all these settings go into your N P M R C file, which is in the root of your user directory, and we can see this file by looking at the root of our user directory, and that's where all those settings are contained.

Advanced npm
Installing from a Git Repo
[Autogenerated] Let's talk about installing packages from get hub. When you find a module on get hub that you want to use, almost all of them will tell you the command to install them. Here is the Skid Hub Repo for express, and you can see right here the command to install it using an P M. But what if you found a module on get hub you wanted to use, but it hasn't been published in PM yet, Or what if you fork somebody else's library and made some changes that are specific to your business? Maybe you want to run an express Web server on the next Mars Rover, or what? If you wanted to try out some unreleased features of a package, you can do that by giving NPM install a U R L instead of a package name, for example, this command will install not the latest published version of Express, but instead the current head of the depository. So whatever, the last thing that got checked in is you'll get it. No. One thing to note is that this actually isn't limited to just get hub. This will actually work with any girl that has a package at the Oriole you give it So, for example, if you have a private package that you have on your own server, you could just give NPM install the correct your L NPM will happily install a package from that location. You could even stall package that's been published on Dropbox. Just give it the Earl and NPM will install it from that location.

Installing from a Gist
[Autogenerated] Sometimes we need to install a gist as a model. This can happen when, instead of forking an existing package, you created just out of it and make some changes. And then you want to test those changes as a dependency of an existing project here have created a very simple just with just two files, an index dot gs that does nothing more than log out the message. Hello, Mars And that package dot Jason, which has the basic information about this package. Notice that every just has, ah, hash up here in the Earl. If we copy this hash, then go to our project and type in NPM, install just a colon and then paste in the hash. This will actually install. That just isn't MPM package. Now it's very important that the just itself have the package dot Jason. This will not work without it. And if we look in our package dot Jason is listed there. But instead of a version number, we see that it's a just with a hash

Installing from a Folder
[Autogenerated] Sometimes you may need to install packages that are private and not publish to the N. P M registry. This is more common in larger organizations, which may have a very large software base of closed source software that they don't want to publish. 10 p.m. But they still want to create components is packages and allow other developers to be able to use those packages and install them, just like regular packages from the N. P M registry. A great way to do this is to create these packages and then store them on a shared folder somewhere on the company's network, or put them in Dropbox and then use Dropbox is sync them up on the developers, computers or even published them to a private website. In the case of publishing them either to share drives or using drop boxes folder sink option, the package is going to be in a folder somewhere on your computer and you want to install from that location. NPM is just fine handling this. It could install from a folder somewhere else on the same computer, or even from a network drive. All you need to do is give NPM install the path to the folder. In our case, we're going to install our hello Mars package from a sibling to our current directory. This is successfully installed that package and if we list our packages out, we'll see. Hello. Mars is listed.

The npm Registry
[Autogenerated] the N. P M registry is basically just a big, huge list of every package that has been published through NPM. The main piece of the registry is the package dot Jason for each package, when you go to N. P. M. G s dot com and searching this find packages box you're actually searching through the registry. Once you select a package, you're seeing the registry information about that package. There's a couple of other things you can do with the registry that can be useful. For example, if you go to registry dot n p, m Js dot or GE and type in the name of a package, you'll actually see a Jason version of the M. P M information for that package. Another nice thing that you can do is if you type in n p m dot I am slashed in the name of a package. It will take you directly to the page for that package. This could be really useful when you know the exact thing with the package. You want to see that you don't want to take the extra time to go to n. P. M Js dot com and use the search box

Searching for Packages
[Autogenerated] NPM has a search feature that's just NPM search, and then any key words you wanna search for, say, for example, want to search for packages that are related. To underscore this will search for any package with the word underscore, either in the package dame or in the package of description. Unfortunately, the MPM search facility can be quite slow, and the results aren't necessarily the most useful results you can get. Due to the fact that you're looking through a lot of information on the command line, the search function searches Thean PM registry. Thankfully, there's another way to search the MPM registry. That's actually quite a bit better if you just go to n. P. M Js dot com. There's the search box right here that you can type in a search phrase and not only will give you suggested results underneath it, but if he had enter, then it will search and list all results. And if you search for something a lot more specific, like underscore mix ins get a much more limited set of results and they come back instantly and now you couldn't go and click on one of these results and see the detail page for that particular package

Pruning
[Autogenerated] sometimes in really large projects, you install packages that you don't mean to install, or you stop using a package and want to remove it. Or maybe you try out a package and decide that you don't need it. You can always use the N P M Remove command. But if the package isn't specified in your package dot Jason file, either because it was never in there or you deleted it from your package, not Jason, file yourself. Then you can use the Prune Command instead. Let's go ahead and run an N P M list with a depth of zero on this project, and you can see that I've got Grant Js hint and underscore installed. But you'll notice that there's an air the N P M. Is reporting. That grunt is extraneous. And next to grant is this little green extraneous. This means that Grant is not specified in our package. Dodge a cinephile. Indeed, if we look at it, we can see that we've got underscoring Js hint specified, but no grant. So if I were to run NPM Prune, NPM will go through, compare the packages I've got installed with my package dot Jason file and remove anything that shouldn't be there. And now, if we list out our packages again, we're clean. You can within PM prune ad on the name of a library, my grunt, and then it will prove just that one. But that's essentially the same is doing a remove. The other scenario that prune could be useful in is when preparing to deploy the production. In that case, if you add the dash dash production flag, this is going to remove all of your death dependencies, which will leave your package ready to go to production. You can see that it's rude Js hint, and now the only package that I've got installed is underscore, which is the only one that specified in my production dependencies list.

The "npm repo" Command
[Autogenerated] sometimes in working with a package, we want to go and see the official website or go look at the source code for the package. That's where the N P M. Repo Command can come in handy. Repo works by typing in N. P M Repo and in the name of a package. This case, let's do underscore and that will ask NPM to take you to the official repositories for that package so you can see it's opened up a browser and navigated us directly to the underscore depository. From there, I could look at the source code. I can go down and get links to the official website and other information, so this could be really handy. Of course, you can usually find the same thing by using Google, but sometimes especially for more obscure packages, this is a lot easier than trying to find it with Google

Upgrading npm
[Autogenerated] you may at some point discover that you need to upgrade NPM itself. This is actually fairly easy because you could install a new version of N. P M. Just executives you can with any other package by using the N P M Install command. There's just a few things you need to keep in mind the name of the packages and P M. Of course. And to be clear, we'll use at latest to get the latest stable version of N. P. M. It's a global package. We had the DASH G, but most important, you must run this with administrator privileges. You notice that I'm in a plane Windows Command prompt, and at the top it indicates that I'm an administrator, especially on a Windows box. If you do this without administrator privileges, it possibly can mess up your entire installation and you'll find the only remedy is to reinstall note itself. So as long as you do that, then this is the command that you can use to upgrade and P. M.

Using Simple Scripts
[Autogenerated] the ability to write your own scripts. Using NPM is a very useful future. One of the nice things about it is the M P M Support simple scripts, and there are some customary scripts you can write that easily supported by MPM when you first start off with a default package dot Jason file created by in P a minute. This is roughly what the script section will look like. It'll have a default test script that when Run will simply echo out. No tests, air specified and then exit. Let's first look at how to run scripts and the two main default scripts that MPM supports. We'll start with our test script. In order to run the test script, you simply type in N. P m test that executes the script, which we saw, which simply prints out to the console. N P M E r. Test failed. Now, if we want this script actually do something, we can go in and change the script itself. So in our case, let's run our test file by typing node Space test dot Js, which will execute the test RGs file in note. And now if we go out and run the same script. We can see that it's one our test script, which prints out that five of five tests have been run on zero failures. Now, of course, in a more typical project, he'll probably be running something like karma, In which case, you put the karma command here inside the test script. The next trip to want to create is the start script. This is the other default script that you will commonly see in most projects by convention. The START script is the script that you'll run in order to launch the project. In our case, we wanna run our index dot Js file with notes. We'll just use the script node index dot Js. And now if you're in N p. M. Start, it will execute our index dot Js file, which prints up to messages. Let's go to Mars and hello Mars again. In a more typical project, you might do something like launch http server telling it what port and subdirectory to start from, or maybe even life server or something to that effect. These are two of the default supported scripts and the two most common ones that you want to use There's actually a large set of other script names that are supported besides just tests and start, and you could see that list here in the N. P M documentation. There's quite a few here the by far. Most of these are not scripts that you're going to use yourself. In most cases, you're only gonna be using test and start, and then you'll be using your own custom script names. For example, if you wanted a special script that would ugly if I your code, you could put in the key ugly if I and then a script for that. In this case, we use gulp compress, which uses gulps ugly fight task. I've already specified the necessary information in my gulp file, which we can see here. This is just a very simple, compressed task, and now if I want to run, this task will go back to the command line. But instead of hyping in N P M ugly fi, which is how we might think we call the script. Instead, we have to use NPM run and then the name of the script, which one's the compressed task and gulp, which then creates this disc folder that has compressed our index dot Js file and you can see that here. Now, you might look at this and say, Well, if I'm going to type in NPM run ugly fi from the command line, I can instead just type in gulp compress, which is what ultimately gets run. So why bother with the longer command? Well, that's true to a point. But remember, this script section inside of your packages at Jason File is a central place for all the scripts that you need, and they're all right together, one line after the next. That way, somebody doesn't have to go into your gulf. I'll look through it and find the task that they want to use. You can give them prompts by creating this script section inside of your package that Jason file. And of course, if you're not even using gulp it all, then you can still do a lot of simple tasks using simple commands like the ones that we've seen here

Using npx
[Autogenerated] now that we know how to write our own scripts in order to run the various utilities that we might have in our project. It's also useful to talk about N P X. Sometimes we need to run a utility, but we don't necessarily want toe take the effort to write a script for it. Let's say it our little project here, that we've got a foul that we want to run a little glinting on him and install Js. Hint now that I have Js hint if I want to run that GS into the command line tool. But if I just run Js hint from the command line and type in the name of the Johnson file, I want Toe limped over. It's going to air out on me and tell me that the command is not found. If I go over to the package dodge a son file, I can write a script to run the Js in command. But I might not want to take that effort, so instead I could just run N p X J s hint server dot Js and that will actually run Js hint and we can see the output there I've got three lines that are missing semi colons, and now that's useful for me and I can go on. So that's what M P X is for is to run those utilities that have command lines, but you don't actually want to write a script for them.

Auditing
now you may or may not have noticed before, but NPM runs a security check on the packages you have installed. What it does is it actually checks the packages you have installed against a database of known security vulnerabilities that rates each of the vulnerabilities at low, medium or high. So let's see an example of this we're gonna stall Express. But I wanna stole a specific version. I'm gonna get on a slightly older version for not one dot exe. It'll be the latest version of Ford Out one, and we can see down here that after installed that it's found 21 vulnerabilities and it tells us how many of each ate low vulnerabilities six moderate and seven high. And it even tells us exactly what to dio. It tells you to either right NPR audit fix to fix them or npm audit for details. Let's start by running in P m on it and see what the output is. And it's this really long output where it tells you each item what the rating is, what the actual vulnerability that was found was what package it was in what package? That's the dependency of could see that here in this last one and even tells you a recommended way to fix that one vulnerability. But for the most part, if you just run in Piemonte fix, NPM will go ahead and try to update the latest versions of all of these various things and fix the issues. And so, in this case, Express has fixed all of its issues in its latest version, at least all the known issues. And so we see the message down here that we have fixed 21 of 21 vulnerabilities in all the packages Now, occasionally that doesn't actually happen. In fact, you'll usually find that you won't be able to fix all your vulnerabilities. But certainly trying to get the high ones fixed is very important now how to address it if in p m on it fixed doesn't fix everything which is very common is well beyond the scope of this course. But you can check out my other course on addressing security vulnerabilities in MPM within PM audit, also here on Pluralsight.

Publishing Your Own Package
Setting up Your npm User for Publishing
[Autogenerated] in order to get ready to publish within PM, you've got to prepare your user for publishing. For most people, that means they'll actually have to create a user account within PM first. In order to do that, you go to N. P. NGS dot com and click. Sign up from here. Simply follow the prompts in order to create your user account. And be sure to remember your user name and password. At that point, you can go out to command line. You'll need to add the user using the N. P M ad, the user command. Executing this will prompt you to type in your user, name your password and enter your email address. Once you've done all that, we'll add an M. P M. Authentication took into your N. P. M. R C file and the users now set up and you could begin publishing packages

Preparing Your Project for Publishing
In order to get your project ready for publishing, you've got to do two main steps. One is set up your project and get and two is create the package that Jace on file. We'll start off by setting up our project. Forget. Right now, my project is blank. All it's got is my index dot Js file. So I'm going to create a git repositories for this using. Get in it now I've got my repositories created. You may have already done this. Step yourself. In my case, I've already created my get help depository. But if you haven't created your depository, you simply go to your get home page and create a new repositories for the project that you're going to be creating. Fill in the name and description and click the create depository button. If you're not familiar with get hub, you can check out one of Pluralsight's courses on using get hub. Once the repositories created, you'll need to associate your local files with that repositories. And we do that using get remote, add origin and the girl to the repo. My case This is my girl. Of course, yours will be different for whatever package you're creating. This is the critical piece we need set up before we create our package dot Jason file, which I'm going to do next using NPM, innit? Now, this time through NPM, innit? I've really gotta pay attention to every question asked because they really matter when you're creating a package that you're going to be publishing. So the name matters because that's going to be its name and in p. M. And that's going to be the name that people use when they want to install using NPM install. In my case, Hello, Dash Mars is just great. The version can really matter if you are in pre release, you may want to start with a 0.1 dot zero or something like that. Although 1.0 dot zero is really just fine. So I'm gonna go with that. I'll give it a description. And for the entry point, if this is a module that's going to be consumed by other people, which it typically is when you're publishing within PM, then you really need to make sure that you get the right entry point. Of course, mine is index dot Js. I believe that is the default for a test command. I don't have tests, but your project may have tests, In which case you want to put in what your test command is to get repositories automatically filled in for me. I can override this if this isn't correct. And a list of key words I'm just gonna put in Mars for the author filling my name and finally for license. All except the default. And now it prints out to me. What? My package dot Jason file is going to look like I can double check it all. Make sure it all looks good and then hit. Okay? And now I've got my package that Jason file created, and my product is ready for publishing. Of course, if you walk through these same steps that I have, you're going to probably want to check in all your files and push them up anyway with a get ad dot get commit dash M and your comment. And then I get pushed. If you haven't set Europe steam like I haven't, you'll want to get push origin master, and our project is set up and ready for publishing.

Publishing Your Package
[Autogenerated] publishing our project is a really simple matter of just using the N. P M. Published command. Once we have our project, all set up NPM publish is all we have to do in order to publish it to N. P. M. And you can see that after I've executed that command, it's gone ahead and publish my project. You'll also see the version number that you've published mindset at 102 but yours will be set at whatever you've got in your package dot Jason file. And now that we've got that published weaken, do things like NPM info with our package name, you can also use in P m. Repo and that will take you to the depository for your project. And if you want to go to it's in P m site directly, you can do in p m dot I am slash name of your project, and it will take you to the packages homepage. Publishing to the pact is great, but that's really only half the story because your package was also on get and you want to release on get. That's the same as the version you just published 10 p.m. So go back to the command line to do that, and we're going to issue the get command, get tag and then the name of our version. In my case, it's 1.0 dot to. In your case, it will be whatever version you just published. Now only do this after you've already committed and pushed your changes to your files that you've published through in P m issuing that will tag the release. And now you can push that tag up to get have using git push dash dash tags. And now, if we go back to get hub, we can see that tag by clicking under the branches button. And there's both of branches and a tags tab will click the Tags tab and we'll see our 102 tag. If I click on that, we can see this version 10 to tag, and we'll also note that this is marked as a release in Get Hub. So people who come to your depository for your package wanting to look at the source concomitant here and find the Associated release with the version that they're working with. This is something you really must do in order to play nice with the ecosystem of N. P. M. You don't want users coming over to your get hub depository and not knowing what version of files match aversion they're using on in P. M. That will create problems not only for them but also for you as the submit issues on Get help. And that's the basic process for publishing. Just used the Indian published command, tag it and push the tag up to get him.

Publishing an Update
[Autogenerated] publishing an update to a package is a really straightforward process. It basically involves three steps. First, making the changes to your code. Second, updating your version and then three walking through the same published process that we did when we were publishing our package. Initially, let's make a small change to our code. Let's assume that we're going to add an extra exclamation mark. We'll save that change and we're going to need to update the version of our package. We can go directly to our package dot Jason file and manually update the version by just changing it here. Now we need to look at the nature of the changes that we've made in order to understand which part of the version of her we need to change. In our case, we haven't changed any functionality. There's no new functionality. We haven't broken anything, so this is more like a bug fix, in which case we're just going to change the revision or patch number. But if we had added new functionality, say we'd put in a language parameter here and then based on the language, we're going to print out a different message to the console. Then we might want to update the minor version so long as we include a default so that if they don't pass in a language that is still prints out a message now, if we made language required would actually be breaking functionality, in which case we're going to want to update the major version now. We could do all this manually by just adjusting the package dot Jason file. Or we can let MPM adjust the version number for us. So let's go back to our index, and we'll just make the one change that we're going to have two exclamation marks in our message. Then we'll go out to the command line and we're going to commit our changes. You get ad, don't get commit. And now that we've got our changes committed, we can use the N P M Command version, which takes one of three options either patch, meaning that we're going to change the patch number or minor, meaning that we're going to change the miners number or major, meaning that we're going to change. The major version number on our case will just change the patch number, and now you can see it's printed out version 1.0 dot three. And if we go back to our code and look at our package dot Jason file, it's been updated automatically toe 103 Now, if you've been following along closely, you may have noticed something. We checked in our changes to the index dot Js file. But we didn't check in any changes to the packages out Jason file yet we've changed it. So if we go back out to the command line and we do get status, you may expect to see the Packers out. Jason has been changed, but we're going to see that are working areas clean? There's nothing to commit, although you may notice that it says that we're ahead of origin by two commits. If we do get log, you can see that our last two commits are fixed message commit and then after that is a commit with just the message of 1.0 dot three. So what's happened is NPM itself has made a committee for us. Anything that MPM did for us is it actually tagged that version. So if we just do get tag, we can see that we've got our 1.2 and the V 1.3 the N p. M. Created for us. There's a small difference in there. The M P M uses a prefix of V. That's fine for our purposes. That really doesn't matter. Let's go ahead and push our changes and at the dash dash tags option that would push up our new tag for us. We've also got to issue just get push in order to push up the file changes. Know that those have to be done separately unless you dig into get and set a configuration parameter. But that's beyond the scope of this course and now with everything pushed up to get her. But we can simply issue in p m. Published, and we just released version 1.0 dot three of our hello Mars package to N. P. M.

Releasing a Beta Version
[Autogenerated] Finally, let's talk about releasing Alfa and Beta versions, hair face and changes to the code to actually support languages. The changes should be backwards compatible because even if you don't pass in a language, you're still going to get the default message we were getting before. But if you happen to pass an E s for Spanish, you're going to get hello Mars in Spanish. So I like to publish this, but I'm not really sure how this is going to be received. I'd like to let users try this out and give me feedback, so I want to release a beta version. Well, beta versions air well supported by NPM. You just have to follow the semantic version in conventions. In this case, we're going to update this toe 1.1 dot zero, but we're also going to add a dash beta 00.0. This version lets people know that the product is currently in beta, and this is the initial version of beta as we adjust it and try new versions, but are still in beta weaken increments. Zero toe 1 to 2. No, n. P m does not support adding beta to the version like this, So we have to do this manually. Let's say this change and we'll go out to the command line and I'm going to add those changes and then commit them and what changes committed. I also want to tag this and get, and I'm going to give it the same version for the tag as I gave it inside of my package dot Jason. And now I can push my changes and push up the tag now, just like publishing a regular version. I'm going to use NPM publish, but I'm going to add on the dash dash tag with a label of beta. This is going to publish this version, but tag it as a beta version. Let's go ahead and do that and then we'll talk about what that means Tags a really interesting feature that NPM supports, and we can see their use when we install a version. So if we were to install hello Mars using NPM, I hello Dash Mars, we can use an at and then a tag name and when this case is going to be beta and that would install the beta version of hello Mars if we use latest there could be other tags that we could put in place of this. Or we can use, of course, just a version number. Let's see where those tags come from. If we use NPM info, we can see the information about that package. And if we scroll up a little bit and look at this dissed dash tags key, you can see two entries. There's Latest, which is set at 1.0 dot three, and Beta said at one one zero dash beta zero by default. Whenever we publish a version, N. P M. Will update our latest tag with that version, but if we specifically tag it when we publish, then it will create that tag or update that tag Twitter version we're publishing. So by default, every package already has a latest tag, but we can add our own tags like we did with the beta tag. Now, of course, it's conventional to use beta, but we could use any tag that we wanted. We could call this trialled or test, of course, stay away from non standard names like that. Alfa and Beta are the kinds of tags that you want to use things other than that are really not conventional, and you should stay away from them. So now if we were to go out to our trip to Mars and we were to NPM install hello Mars and put the at latest tag, then you can see that we've installed Hala Mars version 1.0 dot three. This is exactly the same as just NPM installing hello Mars without the latest tag. But if we want to specifically install the latest beta version, we add the at beta tag. You could see that we've installed Hello, Mars 110 beta version this is showing up is invalid because it doesn't match our dependency specifications inside of our packaged out Jason file, which we can fix by going into our trip to Mars and adding in this version number one, not 1.0 dash beata zero. And now if we list this out, it shows up without the invalid flag. So this is how you can publish beta versions of your package to N. P. M.

Course Summary
[Autogenerated] in this course, we learned the complete scope of N P m. Its features how to use it on both large and small development projects and how to use it to publish our own packages to the N. P. M. Depository. Here are the key takeaways from this course. Just knowing NPM install is often the only thing you need to know how to do the key syntax to understand is the meaning of the carrot and the tilde and the difference between them when listing ______ numbers in your package dot Jason file And finally the package dot lock Jason overrides the package. Dodge Ace on file when doing in P. M install. Thank you for taking the time to go through this course. I hope he gained a lot from it. Please reach out to me on social media and say hi and tell me what you thought of the course. I'd love to hear from you
