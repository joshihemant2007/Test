Node.js was built to run on a single thread using non-blocking I/O calls. Building apps for this environment requires extensive use of asynchronous code. In this course, Async Patterns in Node.js, you'll learn multiple techniques to write efficient asynchronous code using modern JavaScript. First, you’ll explore how the Node event loop works and how to write asynchronous code with callbacks that adhere to conventions followed in the Node community. Next, you’ll discover how to use Promises and the async/await keywords to write asynchronous code that’s easier to read. Finally, you’ll learn how to write event-driven code with EventEmitters and use worker threads to tackle CPU-intensive tasks in your Node apps. When you’re finished with this course, you’ll have the skills and knowledge of asynchronous programming necessary to build performant Node apps using accepted best practices.

Course Overview
Hey, everybody. My name is Bryce Wilson and welcome to my course, a sink patterns in Know Js I'm a server and client side Web developer. Note is an increasingly popular choice for developers that want to build fast, responsive server applications. The single threaded nature of the note event Luke makes writing a synchronous code, an essential skill for every no developer. The techniques for writing a synchronous code in JavaScript have evolved over the years, and I'll show you some classic syntax as well as all of the most modern approaches. Some of the major topics that will cover include using callback functions, promises and the A sinking away keywords, creating and responding to events with event emitters and taking advantage of worker threads. By the end of the course, you'll have a solid understanding of asynchronous programming patterns and node and when to use different techniques in your own projects. Before beginning this course, you should be familiar with the basics of Java script, but you certainly don't need to be an expert. I hope you'll join me on this journey to learn a synchronous programming with E a sink patterns in know Js course at Pluralsight.

The Event Loop and the Need for Asynchronous Code
The Need for Asynchronous Code
[Autogenerated] everybody. I'm Bryce Wilson. Welcome to my course on a sink patterns in no. J s. I'm a big fan of note, and there is nothing quite so fundamental to know development as the use of asynchronous code except maybe Java script itself. You can often build perfectly good APS in C sharp, Java, python and other languages with no real knowledge of how to execute task a synchronously. That's not really the case with Java _______. Is it possible to build a note out that only contained synchronous code? Technically, sure it is. However, you'll likely run into performance problems very quickly in your ability to learn from others, use popular libraries and read and understand technical documentation will all be greatly limited. Asynchronous code is so essential to JavaScript and node that not understanding how it works and using it in your APs kind of feels like you're doing it wrong. In software development, we've all heard someone asked if they should use this technique or that technique and heard the standard answer of Well, it depends if someone asked if they should use a synchronous code in there. No taps. There are no qualifications. The answer is Yes. In this course, I'm going to show you several different techniques for writing a synchronous code in your node APs. But we're also going to go a little beyond just the Java script syntax and look at how to use notes, event emitter class to write event driven code. And we'll also look at a relatively new feature in no known as Web workers that let this write code that truly executes in parallel. To appreciate what a neat trick that is. You need to fully understand how the JavaScript event loop works. The event loop is really at the heart of everything we're going to do in this course, so let's nail take a few minutes to understand what it is and how it works.

Understanding the Event Loop
[Autogenerated] Java script a single thread so it can only execute one chunk of code at a time. I'm going to refer to those chunks of code. Here is task, but sin tactically, a task is usually a JavaScript function. The event loop synchronously executes task in the synchronised task you. This is effectively the call stack for your application. Your program starts to execute and, as one function calls, another tasker added to the Q and the JavaScript runtime will execute them synchronously until there are no more task in the queue. However, since only one thing can execute a time relatively long running tasks like disk io, our network calls will block any other code from executing. If you run them synchronously, the node runtime and Web browsers, for that matter minimized. It's blocking by allowing us to execute code A synchronously. The runtime includes a set of AP eyes for common long running task and will execute them for us and notify us when they're done. By adding task to an asynchronous task, you the's a synchronous task or call back functions. They exist to call back into our single threat of execution and run some code that we write to process the results of the A. P. I call when the event loop has processed all the items in the synchronised. Ask you it will look for task in the asynchronous task you. If it finds one, it will run it and then look to see if there any more waiting to execute. In addition to the a sink task you There is also something known as the micro task you asynchronous task added to it, will be prioritized higher than task in the regular a sink task you. So when the event loop is done with all the synchronous work, if their task waiting in the micro task you, they'll be executed ahead of any task waiting in the regular a sink task you. It's possible to add items directly to the micro task you, but probably the most common way task it added to it is with the resolution of promises which will look at in next module. At this point, you may be wondering if JavaScript, a single threaded where these asynchronous task running while the event Luke executes other parts of my application code. Well, the only part of all this that's limited to a single thread is your JavaScript code. When you use node modules like F s to access the file system or the Net module to make network calls, you're actually calling into code written in c++ that can and does use multiple threads to perform that work. Those modules will add your callback functions to the A sink use I showed you on the last slide. So the goal is to all float as much of the I O. And other long running task is possible, leaving our single threaded event loop, Frito handle new requests from our users. Let's now start looking at some code and the techniques available for us to do that.

Demo Project Overview
before we start writing some new code, I want to show you the demo app will be working with and how the project is structured. You've probably seen this website for carved rock fitness in other Pluralsight courses. Carved Rock is a fictional company that sells outdoor clothing and equipment. We're going to imagine in this course that we've been working on this prototype for their website redesign. The user interface is mostly done and looks really nice, but it's our job to start converting the proof of concept server code into something more performance and ready for a production environment. Right now, only the clothing link here, the top of the page actually returns data from our node server app. Before I click on it, I'm going to open the browser developer tools so we can see the request is generated. With that open, I'll click on clothing. You can see I get a few items here on the page. I'll screw love just a bit in the developer tools, and you can see the link here for the A P I request that was sent to the server. I'll hover over it and you can see that the fool you are. L is local host Port 3000 slash AP I slash clothing, I'll click on it and we can now see the Jason data that was returned. Each item has an I. D. A name and a price with some simple formatting. The same data is shown on the page here. You can see that climbing shoes air $59 down in the developer tools. I can expand the third element and you can see the raw data. Let's no go have a look at the project in the actual code that returning this data. I'm going to use visual studio code in this course, but feel free to use your favorite editor. The first file I want to show you is the package dot Jason file here in the root of the project. You can see I'm not using very many packages right now. I've only got five items in the dependency section and they're all pretty standard for a no doubt. The one I really want to point out is express. I've added the express framework to help me build the AP, I for the app. The one day of dependency I have is knowed mon. If you're not familiar with Node Mon, it's just a little program that runs your no doubt and then watches for changes to any of the code files. If it sees a change to a file, it will automatically restart the server. This is nice because it saves you the trouble of constantly stopping and restarting your server after every little change while you're working, I've got one in P M script named Start that uses Node Mon to execute the server dot Js file. Let's take a look at how this works in the visual studio terminal. You can see that my server is already running on Port 3000. Ah, press control. See to stop that for just a minute, Okay? If you want to run the app like I'm about to, you can download all the code from the course page on Pluralsight.com, or you can get it from my get hub account at the link here on the screen. The gift of repo is also a good place for me to post small updates and bug fixes between updates of the course. However, you choose to get the code before you run it, you'll need to install all of the N P M packages. You can do that by running the command in P m install inside a terminal in the main project directory that will install knowed Monte and the other packages you saw in my package dot Jason file. I'm not going to run it now, since I've already got all the packages installed. Instead, I'll restart the server with the command in P. M start. You can see that executed the command node mon space server dot Js, which ultimately started my server running on Port 3000. You can also see that node Moniz watching for changes to files in my project directory. Okay, now that the servers running again, let's have a look at the other files in the project. The dot V s code folder just contained some settings for my editor. The dist folder contains all of the static assets for the site, the HTML files, CSS files and things like that. We won't be doing much with all of this. Below that is the Node Modules folder where the n p M packages air installed before I show you the server folder. I'm first going to open the server dot Js file in the root of the project. I've tried to keep this relatively short and simple. This is the file that will run to start the server. I'm not going to go over every line here, but I will quickly point out that I'm requiring express using it to create an app and then configuring it to run on Port 3000 online. Six. You can see that I'm requiring a file name clothing inside the server slash routes directory, and we'll look at it in just a minute. Online 16. I configure the APP to use the code in the clothing file whenever a request is made to slash a p I slash clothing. Toward the end of the file, I start the app listening on the configured port and just log a message to the console with that information. Let's now look inside the server folder were all right. Most of our code inside the data folder is a single file named clothing dot Jason. It just contains the clothing data that gets returned to the browser. Rather than complicating the application with the database, you have to install on configure. I'm just during the data in a jace on file, our server code will read and update it as requested by the client inside the Routes folder. I'll open the clothing dot Js file. This is the file I required in server dot Js and will handle all requests to slash a p I slash clothing. Right now, it's only programmed to handle get request. The slash here refers to the root of the route configured for this code, which is a P I slash clothing. When I get request comes into that you are ill. The code inside this callback function will execute the request parameter will contain data about the http request and I'll use this response parameter to send data back to the client. Currently, the coat uses the node F s module to read the data from the clothing dot Jason file. The data from that file is then par stas Jason and returned to the browser by passing it to the send method on the response object noticed that the method I'm currently using to retrieve the data is named reed file sink. As the name suggests, that method will execute synchronously and will block the event Luke, preventing any other code from executing while the Fowler's rid. This is obviously not how we want the production version of our new website to work. So in the next clip I'll start converting this synchronous code to a synchronous code.

Converting Synchronous Code to Asynchronous Code
[Autogenerated] Now that you've seen how the APP works, let's start turning the synchronous proof of concept code into a synchronous code more appropriate for a production environment. The callback passed to the get method is currently programmed to read the clothing that Jason file synchronously using the reed file sink method of the F S module. Before I convert this code to execute a synchronously, I want to add a couple of logs statements so we can more clearly observe when particular lines are executing just before the data sent back to the browser. Ah, log that I'm returning clothing data right after the data's sent. I'll log that the APP is now doing more work. How quickly glance at my terminal in V s code and you can see that node mon recognized the change to the code and automatically restarted my server on Port 3000. I'll know. Hop back over to my browser and refresh the page that calls to get method and displays the clothing data. Since I added the log statements to my server side code, I'll now go back to V s code and look at the output in my terminal. You can see here that the code basically executed in the order it was written. We first got the message that the clothing data was being returned and then the message that the APP is doing more work, let's know, rewrite this code to execute a synchronously. The simplest way to do that is to use a different method in the F S module that's designed to read files a synchronously. I'm first going to remove all but the last log statement here. I'll then call the reed File method on the F S module. Noticed that the 1st 2 parameters to read file are exactly the same as the 1st 2 parameters I passed to read file sink the variable containing the path of the file and the filing coding to use. However, I'm also passing an arrow function as the third parameter here. This function will be called after the contents of the file have been rid. While if I was being read the rest of the code inside the get method will continue to execute. This function is a callback function and is the most basic way to handle the completion of an asynchronous task. Technically, a callback function is no different than any other function. However, when using callbacks with a synchronous code and node, there is a very well established convention of passing two parameters to the callback. The first is any error that occurred while the asynchronous code was executing, and the second is any date of the code returned. You will see this pattern all over the place in node apse. So for your own sanity and the sanity of your fellow developers, I strongly suggest you follow it yourself. It's also a convention to name these parameters Air, E. R. R. And Data. As I've done here inside the call back, The first thing you want to do is use an if statement to see if an actual error was passed in. If so, you can handle it. However you like. I'm just going to log it here. If there was no error than no will be passed for that parameter and the code in the ELTs block and process, the data returned, I'm going to add nearly identical code here, too, that I was using when the data was returned synchronously. I'll parse it, logged that I'm returning it to the client and then send it to the browser. I'll nail hot back over to my browser and refresh the page again. The data still gets returned. However, back in my terminal, you can see that the log statements executed in a different order. This time we first see that the code is doing more work, and sometime later we got the message that the APP was returning clothing data because I changed the code to use the asynchronous read file method. The event loop wasn't blocked, and the code in the get method continued to execute while the contents of the foul were ripped. This is a much better solution. However, there are still improvements we can make. Let's do that next.

Accepting Callbacks as Parameters
[Autogenerated] In the last clip, I wrote some asynchronous code by calling an F s method that was passed a call back as a parameter. In this clip, I'll re factor that and write my own a sink method that accepts a callback. The CO That road in the last clip works fine, and there's nothing terribly wrong with it. However, I think with a little re factoring, it could be better. What I want to do is extract the code that reads the data file out into its own function. I can call from other places. The first thing I'll do is stub out a new function name, get clothing data. I'll then copy everything but the last log statement from the get function and pasted inside the new function. I can't directly return the data to the client from here, so I'll remove this log statement. And instead of calling the sin method on the response object, I'll just use a return statement to pass the data back to the color I'll now and a call to the new function inside the get method above. I'll assign the value. It returns to a variable name clothing data. I'll then log that I'm returning the clothing data to the client and then call the sin method again with the data. This looks pretty similar to what I had before, but I've just extracted the reading of the file into its own method. Let's see what happens when I run it. I'll go back to my browser and refresh the page. The page loads fine, but I no longer have any data being displayed back in my editor. I'll open the terminal and you can see that the log statements executed in the order they appear in the code. So what's going on here? Why didn't I get any data in the browser to understand what's happening? Let's look closely at the code in the get method. First, there's really nothing a synchronous about this code. It's going to execute from top to bottom. It calls the get clothing data function, and as soon as it returns, the first log statement will execute in the clothing data Variable will be sent to the client. The problem is in the get clothing data function below. The first line of that function calls the asynchronous read file function the rest of the code here is all part of the callback function passed to read file. It won't execute until the file is done being read from the disk. While that's happening, the rest of the get clothing data function continues to execute. However, there's no more code in the function, so it effectively just ends and returns undefined to its collar. That means the clothing data variable is assigned undefined, which is ultimately what gets sent to the client online. 13. The solution to this problem is, instead of trying to use a return statement to pass the data back to the caller, we need to pass our own callback function to get clothing data that can notify the collar when the data is actually ready. I need to pass that call back as the parameter to get clothing data. I'm going to pass it as an arrow function. Remember the Convention for node callbacks I mentioned earlier? They should take two parameters. The first will be for any error that occurs, and the second is for any data being returned in the body of the call back. I'll first check to see if there was an error. If so, I'll just log it to the console. Otherwise, I want to take the data that was returned and send it back to the browser. I've already got a couple of lines of code that do that, so I'll copy and paste them inside this else block. I know. Just need to change the variable I'm sending to the client from clothing data to just data. Okay, that's all I need to do here. But I now need to re factor get clothing data to accept this function as a parameter. I'll add a new parameter to the function declaration and just name it. Call back. I now need to call this function with the appropriate error and data values somewhere inside the body of get clothing data. I've already got an If block that checks for any air that occurred when reading the file. Instead of logging that air, I'll now call the callback function and passed the air that occurred as the first parameter and know as thes second parameter. Since we know we don't have any data to return since the callback parameters stores a function, I can call that function by just adding a pair of parentheses around the parameter names and pass it any values that needs. I'm going to do something similar inside the else block. I'll overwrite the return statement with a call to the callback function. In this case, I don't have an error, so I'll pass No as the first parameter and the parsed clothing data as thes second parameter, we now have in place the proper mechanism for notifying the collar that the get clothing data function is done doing its work. Since we're now communicating with a callback function and not a return statement, I can remove the variable receiving a return value from get clothing data. Okay, let's give it a try. I'll go back to my browser and refresh the page again. The data reappears. This time I'll go back to V s code and check my terminal again. You can also see that the order of the log statements is back to what we want as well. It first logged that it was doing more work, which means the event loop was not blocked while the foul was being read from disk. After the file was red, we see the log message that the data is being returned. The result is the same as the code in the last demo, but we've now re factored the reading of the file out into its own method that accepts a callback function. It makes that code more reusable, and the collar of the new function can pass in any call back they like. I've covered a few important topics in this module, but the number one thing I want you to take away from it is don't block the event. Luke. I showed you how the event loop works at a high level and explained that the code you write runs in a single thread. Therefore, if you want to keep your APS responsive, you need to keep that event loops, looping and picking up new code to execute. The best way to do that is to write a synchronous code. A sink code will keep your app responsive and is practically required when writing production quality node applications. The oldest and most fundamental way to write a synchronous code is with callback functions, and you've now seen how to use them to communicate the results of asynchronous work. However, callbacks aren't the only way to communicate those results in the next module. I'll show you how promises and the a sinking await. Key words are a more modern approach to processing asynchronous results that also come with a few additional small benefits. The stay tuned for that.

Writing Asynchronous Code with Promises and async/await
Alternatives to Callbacks
[Autogenerated] in the last module, I showed you how to write and use callback functions. Callbacks have been around forever and JavaScript and of the most fundamental way to handle the results of asynchronous operations in this module, we're going to look at a couple of more modern techniques for writing a synchronous code promises and a sink away. Well. First, take a look at promises. I think you'll quickly see that even though the syntax is a little different for promises there conceptually similar to call back functions, since you effectively registered different functions to process the results of your asynchronous operations. A discussion of promises often very naturally leads to a discussion of the even newer, a sinking away keywords. But before I discuss those, we're going to take a brief detour and talk about a lesser known feature of modern JavaScript. No Nas generators. Even though you won't often use generators directly, they enable the functionality we get with the A sinking away keywords. So I think it's important to give you an overview of what they are and how they work. Well, then look at how to use a sinking a wait and I'll show you how they're really built on top of promises and generators and let you write a synchronous code in a much more readable style. Let's get started with a look at promises.

Understanding Promises
[Autogenerated] the Mozilla documentation defines a promise as an object representing the eventual completion or failure. Oven asynchronous operation code that performs asynchronous operations can return a promise to the caller. The color com'on register functions that should execute when the promises either resolved or rejected resolved is the term used to describe the successful completion of the asynchronous task and rejected is the term used to describe the state of a promise that reports an error in the asynchronous code. Promised libraries have been available in Java script for years, but the feature was finally made a native part of the language in the E S 2015 version. They include a basic A P I for attaching what are essentially callback functions to an object and the methods on promise. Objects also return promises so they can easily be chained together. I think most developers first encounter promises as the return type for some library function they're calling, but it's not terribly difficult to create your own, and I'll show you how to do that in the demo app in just a couple of minutes. Let's first look at the basic syntax for promises. I'll first show you how to create a promise, and then we'll see how to process the resolution and rejection of one. To create a promise. You pass a function to the promise constructor. I'm first going to create a declaration just for that function. This is the function that will actually perform the asynchronous work. So I've named this one. Do a sink work. It will automatically be passed to functions as parameters. The first is the function to call if the asynchronous work complete successfully, and the second is the function to call. If you need to reject the promise with an error inside this function, I'm just going to add a bit of pseudo code. You would normally perform some asynchronous work, and if it's successful, you call the resolve function and pass it the data you want return to the caller. If the work was not successful, you call reject and past the reason for the rejection. That could be an error object, a simple air message, string or whatever makes sense for your app. Do you actually create the promise you would pass this function to the Promise Constructor, which returns a new promise object? I've declared the function past of the constructor separately here, but it's more common to just pass an arrow function to the promise constructor here. I'm still assigning the result of In Stan. She ating a new promise to a variable, but I'm passing an arrow function to the constructor instead. The arrow function takes the same resolve and reject parameters we saw a minute ago, and the body of the function looks just like the body of the earlier function. I call resolve if it's successful and reject. If it's not, let's now look at how to process the results from a promise. Let's imagine that I call a method that returns a promise object. I could capture the object in the variable and then call methods own it. But it's more common to just chain calls onto the method that returns the promise. You change on a call to a method named then to handle the successful resolution of the promise you passed the function, another function that will execute when the promise is resolved. This function will be passed one parameter, that is, the data passed to the resolve method I showed you earlier. You can do with it whatever you like. here. I'm just logging it. The handle a rejected promise. You chain on a call to a method name catch. That method also accepts a function as a parameter. In this case, the function passed, a catch will be passed. The reason for the rejection instead of the data that parameter is named air here and will contain the value past of the reject function I showed you earlier. 1/3 method you can chain onto the others is named. Finally. All the methods are optional, and this one is certainly the least used of the three. The then myth, it is only called it. The promises resolved catches only called if it's rejected, however, finally is called. In both cases, it's a good place to put any cleanup code or really anything that you always want to run. After the promise is done, let's no go back to the demo app and replace the callback code I wrote earlier with promises

Replacing Callbacks with Promises
[Autogenerated] I'll know remove the earlier call back code. I added the demo app and show you how to create and use promises for the same asynchronous work. Instead, the first example I want to show you is using a promise inside the get clothing data function. Instead of reporting the results to the collar with a callback function at the top of the function, I'll write the code to create and return a new promise all on one line. Remember that the Promise constructor takes a function as a parameter. I'm going to pass it a narrow function. This function takes two parameters, which are the resolve and reject functions. We need to call to either resolve or reject this promise and report the results to the caller. The asynchronous work I want to do really hasn't changed, so I'm going to copy and paste all of this existing code. Inside the function past of the Promise Constructor, I only need to make a couple of small changes to it. Instead of calling the callback function. When there's an error, I'm going to call the reject function and pass it the reason for the air. I'm just going to pass it the entire error. If the file was red successfully, rather than passing the results to the call back, I'll call the resolve function and passed them to it instead. Since I'm no longer using the callback function, I can delete it as a parameter to get clothing data. Okay, that's all I need to do to this function. Tohave it. Create and return a promise I know need to update the calling code to process the promise it returns. I'm first going to delete all of the existing code inside the get method. Except for the last log statement, it's helpful for us to verify that the code above it isn't blocking the event loop. I'll now call get clothing data just like I would call any other function. I could capture the promise it returns in a variable. But as I showed you earlier, it's conventional to just chain on calls to the promise methods that will let you register the functions that will process the results. I'll first at a call to the then method. It takes a function as a parameter, and that function will be past whatever was passed to the resolve method in the asynchronous code. In this case, that will be the clothing data. I'm just going to log a message to the console and then use the response object to send the data back to the browser to handle the rejection of the promise. I'll nail chain on a call to the catch method. It's also passed to function. The parameter to it will contain whatever was passed to the reject function in the asynchronous code. This obviously means something went wrong. So I'm going to use the response object to send an http 500 status back to the browser, along with the air reported by the promise many times, These are the only two methods you'll use to process the results of our promise. However, you can also change on a call to the finally method. If you have some code you want to execute. In both the resolution and rejection cases, the function past it takes no parameters, so I have to include an empty pair of parentheses in my marrow function. I'll keep the body simple and just log a message to the console. Everything should be in place. Now. I'll go back to my browser and refresh the page again, the functionality remained the same, and I still get all the clothing data on the screen. Back in V s code, I'll open the terminal. The order of the log messages confirms that the code is still executing a synchronously and not blocking the event loot. While the data file is red, the doing more work message still appears first, even though it's the last line of the get method. Once the data is done being read from the disk, we see the messages that it's being sent to the browser, followed by the message I added to the finally method. That was a good test of the successful reading of the file. However, I also want to test that when there's an error the promises rejected and reports the air back to the collar as it should. How force an error by changing the name of the data file. The code is looking for here. At the top of this file, I'll change clothing that Jason too bad name dot Jason, which doesn't exist. I'll go back to the browser again before I refresh the page. This time, I'm going to open the browser developer tools to the network tab. Remember that in the case of a rejected promise, I'm attempting to return a 500 server error to the browser. I'll now refresh the page, and you can immediately see I no longer have any data on the screen. I'll scroll, look just to bid on the list of network requests, and here you can see the request for the data. And it did, in fact, return a 500 server error. Back in my editor, I'll open the terminal again just to show you that even though this promise was rejected, the code inside the finally method executed just a zit did for the resolve promise. I still have the message in the console reporting that the processing is all done. I don't want to leave the air in the code, so I'll quickly change the name of the data file back to clothing that Jason. Okay, At this point, it wouldn't be an unreasonable next step to talk about the A sink and await key words and how they work with promises. But I want to go a little deeper and lay the groundwork for that discussion by first giving you an overview of a relatively new feature in JavaScript, known as Generators. I'll do that in the next clip

Understanding Generators
[Autogenerated] generators were added to the E S 2015 version of Java script and, along with promises, form the technical foundation for the A. Sinking away. Keywords will examine shortly. I think going into that presentation with a basic understanding of generators will be helpful. Though generator objects are produced by generator functions, they're a special type of function that can be paused in the middle of execution and resumed at some point in the future. This is very different from the normal function behavior you're probably used to in which a function runs to completion from top to bottom and only executes again if you call it again. As if pausing a function wasn't enough of a trick. Generator functions also store the state of the function while it's paused so that when it resumes, all of the variables have the same values, and it's a ziff. It never stopped executing in the first place. Generator functions return generator objects. The most important thing to know about generator objects is that they're also it aerators. That means they implement the generator protocol, which means they have a method named next. You can call the next method over and over until the object reports it doesn't have any more values. This is really what happens under the hood when you use a four each loop to iterated over a collection of some sort. In the case of generators calling next is what restarts a pause generator function. I'll show you some examples in just a minute. Another important thing to point out about generator functions is that they employ a technique known as lazy execution. This really just means that values air computed on demand. If a function is paused, it's not doing any work until you explicitly resume it. The benefit here is that it's not doing any unnecessary work. Let's hop into a very quick demo so you can see the syntax for generator functions and what the new behavior actually looks like. I'm not going to work with the demo app code directly in this demo, because I want to keep this a simple as possible and just demonstrate how you can Paul's code execution with a generator function. Even though I'm not going to modify the existing demo code, I am going to do this demo in the project just so the generator could I'm going to show you stays with the rest of the project, and you don't have to do anything extra to download it. I've got my visual studio code terminal open to the right side of the window now, just to make it a little easier to show you what's happening. As I run the code, I'll start by adding a new file to the root of the project. I'm just going to name it generator function dot Js right at the top of the file. I'm going to write a new generator function. There are a couple of new bits of Syntex I'll point out along the way. The first is that generator functions, including asterisks between the function, key word and the name of the function. It doesn't matter where you put the asterisk. It can appear right after the function key word with no space in between or, as I have it here just before the name of the function. Both are valid, but I think I see them written this way more often. I've named my function generator function, and other than the asterisk, it really looks like any other function. The first line of code. I'll add to the function is a log statement reporting that the function is actually running. Below that, I'll declare a variable name X and a sign in the value. Five. I'm then going to use a special JavaScript keyword to Paul's execution of the function. The yield keyword will return the value after the key word, and then Paul's the function until I explicitly resume it. Since I'm yielding the value of X here, and I know that X is five at this point, the value five Would we passed back to the calling code below this I'll increments X and then return its new value. Let's no call this function and observe how it behaves. Since generator functions return generator objects that implement the IT aerator protocol, I'll call the function and assign the return value to a variable name it aerator. I'll then just add a log statement reporting that the code is all done. I'll run the code in this file over here in my console window by typing the command node space generator function dot Js noticed that the only output I get is the all done message. I called the generator function, but I don't see the message I logged at the beginning of it. The reason for this is another of the differences between generator functions and regular functions. When you call a generator function, you're returned and it aerator and the body of the function won't actually begin to execute until you call the next method. On that it aerator. I'll add a new line of code here. To do that, I'll call the next method on the generator, object and passage return value to console dot log. I'll never run the programme again in the terminal. This time I get more output. I first see the log statement I included at the beginning of the generator function. Below that, I see the value return by the call to next. It's actually an object that has a value property and a done property. Any object that implements the generator protocol returns an object with this structure when you call the objects next method. So what happened here is that I called next on the generator and the first line inside the function logged a message. The variable was declared and assigned a value, and then we hit the yield expression. Since we're yielding the value of X, an object was returned that had the value property set to five. Since we're not at the end of the function yet, the done property was set to false. At this point, the function is paused and will only be resumed with another call to the next method. I'll copy and paste Line 13 so that I now have two calls to the next method and then run the code again. The 1st 2 lines in the output this time look just like they did before. However, when I called next a second time, the function resumed. Executing on Line five. It then incriminated X and returned the new value. The object log shows that the value is now six and the done property is true. The done property was sent to true because the new value was passed back with return instead of yield. So the caller knows the function has done executing. It's also possible to pass values into a Paul's generator function. I'll add a new line after I increments X. It will again yield X, but assign the value to a new variable. Why the value that gets assigned to why here will be whatever I pass to the next method to resume execution, I'll change the return statement to return the sum of X and y and then at another call to the next method below and pass it the value. Four. I'll now run the code one more time. This time, the second call to next causes the code to run to the yield expression on Line eight that returns the second object in the output with the value six and done, said defaults. It's important to note that the function is Paul's before the assignment to why has taken place. When I call next 1/3 time, the function resumes online. Eight. And the value I pass to next will be assigned to why, at this point, the value of X is six, and the value of why will be four. The following line returns the sum of those, which is how we get the last object in the output. Reporting the value is 10 and done is true. This also demonstrates the lazy evaluation I mentioned earlier. The calculation online nine didn't happen until I explicitly called next 1/3 time. Only then was the additional work done. There's much more to generators than what I've shown you here. But they're not a language feature you're likely to use directly on a daily basis. However, the ability to Paul's a function and resume it at a later time is what enables the A thinking. Await key words will look at next.

Writing Cleaner Code with async/await
[Autogenerated] Now that you have a high level understanding of how generators work, it's finally time to take a look at the A sink and await keywords. As I've already mentioned, they're built on top of promises and generators. The A Saint keyword marks a function as one that can be paused while it awaits the resolution of a promise. I'll show you the syntax in just a second, but one of the advantages of using a sinking away is that it lets you write a synchronous code that reads more like synchronous code. It reads more top to bottom without you having to mentally follow the path of a callback or a handler. Method registered with a promise promises air still being used, though the data you return from a sink function is automatically wrapped in a promise, and the calling code can process that promise. Using the methods I showed you earlier in this module, applying the await key word to a function that returns a promise Will Paul is the function. While it waits for the promise to be resolved once it is resolved, that data will automatically be unwrapped from the promise and assigned to a variable Let's take a look at the syntax to do this. Earlier, I showed you how to process in return a promise with code similar to this. Here, I've got a function name. Get data that will return a promise inside it. I'm calling another function that also returns a promise. And I'm using the then method on that promise to parse the Jason returned. The then method will wrap the parse data into a new promise that will be returned from the get data function. Let's nail See how it can rewrite this code using a sink away here, I've still got a function name. Get data. However, in front of the function declaration, I've added the A saint keyword this effectively. Let's any code that calls this function know that it will execute a synchronously and return a promise inside it. I'm still calling another method that returns a promise. But rather than changing on a call to the then method and registering a function to parse the Jason returned here, I've just added the await key word in front of the function call similar to the yield expression I showed you in the generator demo. The await key word will pause this function while it waits for the promise to be resolved. Since we know this method returns a promise you might expect that promise to be assigned to the raw data variable, However, the awake keyword does a little extra work for us. You can only use it in front of a function that returns a promise, and it will automatically unwrap the data in the resolve promise. And that's what we'll get assigned to the raw data variable. I then take that role data passively Jason Par Smith and return the object. It returns, however, even though it looks like this will return the parse data object. Because this function is declared with E a sink keyword, the data object will automatically be wrapped in a promise, and the promise is what will be returned to the caller. The code that calls this a sink function will then process that promise just like any other promise. Using the then and catch method you've already seen. Let's no go back to the demo app and update the Promise code I wrote earlier to use a sinking await

Utilizing async/await
[Autogenerated] let's now take the next step in the evolution of the asynchronous code I've been riding in the course and updated to use the A sinking awake keywords Before I opened the code backup. I want to show you a new node function I'm going to use to read the data file in this demo. So far I've been using the F S module and using methods that take callbacks as parameters. However, there's also an AP I inside the F S module that returns promises. I'm here on the documentation page for the version of note I'm using. I'll scroll down just a little and then click on the link for the file system module on this page, all scroll down a bit and here you can see the section for the F S promises a p I. I want to read the data file using this ap I. So I'll stroll down a bit inside this section and then click the link for the read file method. You can see that it's pretty similar to the function I've been using. It takes a path to the file and some options. But instead of passing at a call back it returns a promise. I'm going to update the code in the demo app to use this version. In order to use it, I need to add a new import at the top of my code file. I've already got F s, so I'll call this one F s promises and require F s dot promises. I'll kneel, scroll down to the get clothing data function and make some changes. I want to make sure this promise code I've already got stays in the download materials for you, so I'm just going to come in all of it out rather than delete it. I'll knew I had some new code. I'll first call the reed file function. I just showed you that returns a promise I'll chain on a call toe, then to parse the data into an object. The result will be wrapped in a new promise. I'll capture that promise in a variable, and then I'm going to log it to the console. I want to do this to show you how it compares to logging the data. I'll await from a promise in just a minute. Lastly, I'll return it to the caller. Remember that the get method above is already coated to process a promise and return the clothing data to the browser. So this should still deliver the correct data to the browser. Let's try it out. I'll go back to the browser and refresh the page. I do, in fact, still get the data I expected back in my editor. I'll open the terminal and take a look at the output that was generated. Noticed that my log statement did try to log the actual promise object. I don't see any actual data, and the status of the promise at that time was pending, meaning it hadn't yet been resolved. Let's new update the code to a sink. Await rather than capture the promise. Return from the reed file function. I'm going to add the await key word in front of it. This is valid because the function returns a promise I can only await code that returns a promise. I'm going to assign the result of this statement to a new variable named Raw data. I still want to parse the data, but I no longer need to pass a function to the then method to do it. I'll store the parsed object in the clothing data variable. Just to confirm we're no longer dealing with a promise at this point in the code, I'm going to change this log statement toe log the clothing data object instead of the earlier promise. Also return the data instead of the promise you can only use the awake keyword inside functions declared with E a sink keyword. So the last thing I need to do is add that at the beginning of my function declaration. Okay, let's now run it again. I'll refresh the page and then go back to the editor and look at the output in the terminal. This time it was the actual data that got logged, not the promise object. This is the same data I return from the A sink function. But remember that I didn't change anything about the colon code. It's still written to process a promise. This all worked because functions declared as a sync automatically rat return data in a promise and return the promise to the caller because it actually returns a promise. I could also await it in the calling code that's going to look just a little bit different. So let me show it to you real quick. I'll scroll back up to the get method that calls get clothing data again. Come in out all of this existing code so it stays in the course downloads. For your reference, I'll leave the last log statement online. 19. Remember, I can only await a promise inside and a sink function. This is an anonymous callback function, but I can still add the A saint keyword in front of it in the body. I'll await a call to get clothing data and assign the result to a variable named data just to help us follow the flow of the execution at a log statement that I'm about to return the A sink data to the browser. I'll then call the sin method on the response object to return it. One thing you may have noticed about this way of processing promises is that I haven't shown you an equivalent to the catch method that can handle errors. The await key word only handles the successful resolution of the promise. In order to catch any errors that are thrown, we need to wrap the call and I try catch block. I'll catch any errors that are thrown and just return a 500 status code to the client like you saw me do earlier. I think I'll test the air case first. This time again, change the name of the data file, does something that doesn't exist and go back to the browser. I'll open the developer tools to the network tab and then refresh the page. As expected. I don't get any data, and if I scroll up just a bit, you can see the request for the clothing data. Return to 500 server error. I'll go change the name back to clothing that Jason and try it one more time. Much better. I again have data on the screen, but let's go look at the output in the terminal. The thing I want to point out here is that are doing more work. Log message is no longer the first thing being logged. It's the last. The reason for that is the function passed to the get myth. It is now being Paul's online 12 while it awaits the resolution of the promise. Instead of continuing to execute while some a synchronous code runs elsewhere, it is the asynchronous code, since I'm not actually doing any useful work later in this myth. It I'll just leave it as is, and delete the log statement at the end, the a thinking await key words are the newest tools for working with a synchronous code and JavaScript. If you haven't encountered them out in the world yet, you surely will soon. I personally think they make your code more readable, but you may decide you prefer using promises directly, and there's nothing wrong with that. We looked at both techniques in this module, and you've seen how they each enable you to do the same work you might have previously done with call bags. In the next module, we're going to shift gears a little bit and look at writing event driven, a synchronous code with event emitters.

Writing Event-driven Code with EventEmitters
The Importance of Event-driven Code in Node.js
[Autogenerated] so far in this course, I've mainly focused on the syntax for writing a synchronous code and node in this module. We're going to look at control flow of a slightly different sort, and I'll show you how to write event driven code using event emitters. Event driven programming basically describes a style of programming in which the flow of your program is, at least in part, determined by the events that occur as the program executes. These could be events somewhat external to your programs, such as a user clicking a button in the APP, or they could be internal events, such as a notification that a new connection to a server has been made. I think most people associate event driven programming with graphical user interface is common events or things like clicking a button, moving a mouse and selecting a menu item. However, this style of programming is not limited to client side coot. In fact, it's used heavily in note, right only about page of the node website. We're told that as an asynchronous event driven runtime know, Js is designed to build scalable network applications. The built in the venom inter class is what makes event driven code possible and note. It's what allows you to easily register functions that will execute in response to events, as well as create your own classes that, um, it events. Other code can respond to many node modules. Use of n emitters to omit events you can handle. Browsing through the official documentation reveals lots of events included, with many popular built in modules that you can handle and respond to in your own code. The file system H, C, G, P and net modules I'm cooking through. Here are just a few of the examples of modules that expose events you can use in this course module. I'm going to show you how you can handle emitted events, but also how you can extend the event a middle class and emit events in your own code.

Understanding EventEmitters
[Autogenerated] They're a bunch of methods available on Eve any metal objects. But most of them exist to support the two primary functions of a venti matters emitting events and responding to events. That's the functionality I'm going to focus on in this module. Let's imagine I want to emit a new event when some new data is received. In my APP, events are given names that are just strings. You can name them whatever you like. Well, imagine I named this one data I can register code to execute when that event is emitted by calling a method on the Avent emitter named on, I'll show you the exact syntax in a minute. But the idea is that you can write code that says on the occurrence of the data event, run this function process data. In this case, one nice thing about a vent emitters is that you can wire Oppa's many listeners for a particular event, as you'd like, and they can eat respond to the event with their own function, appropriate to the test they need to accomplish This second handler will respond to the same data event by executing the log data function, and I might also have 1/3 listener that executes still a different function. When the event is emitted, all three listeners will be notified and they're registered. Functions will be executed. Let's now look at the actual syntax required the use of in emitters. The first thing you need to do is include the Events module. At this point, you really have a couple of options of emitter is a class you can extend if you want to create a custom class that includes everything you need to support events. However, if all you need is the ability to admit in handle events, you can use the event emitter class directly and just create a new instance of it like you would any other class. Once you have an instance, you register an event listener by calling the on method and passing it the name of the event you want to listen for and the function that should execute when the event is emitted. Here I'm listening for the wrote code event, and when it's emitted, I'll execute an arrow function that just logs the message. Somebody wrote some code, as I showed you on the last slide. You can also register more than one listener. This one will listen for the same event, but log a slightly different message to the console. I admit the event by calling the E MIT method on the event emitter instance and passing at the name of the event. Remember that event names. They're just strings, and you can name them whatever makes sense for your app. When the road code event is emitted, I'll get these two messages in the console as the two listeners execute the functions I registered. It's also possible to pass parameters to event listeners here. I'm listening for the same road code event but noticed that the arrow function I registered toa handle it accepts one parameter. I've named language. The value for that parameter is specified when the event is emitted. You passed any parameters after the name of the event. When you call the omit method on the event a matter, I'm passing javascript here so the output from the listener will look like this. Let's now go back to the demo app and add a new feature to it that uses event emitters

Creating and Using an EventEmitter
[Autogenerated] I'm now going to use in a vent emitter in the demo app to create and respond to changes in the application data. I've added some new code to the absence the last module. So I want to take just a minute to show you the new bids. I've added a new link at the end of the clothing item list that goes to a new page where I can add new items. This simple form could be the beginning of a new admin page for adding new products to the carved rock database. I can type in a new item name like boots at a price and then click the add item button. Doing that since an http post request with the new data to the node server after we've been working on the server, writes the new data to the clothing dot Jason file and then returns it to the client, you can see here that boots now appears at the bottom of the list. Let me now quickly show you the code I wrote to do this inside the clothing dot Js file we've been working in throughout the course. I've added a new post method to the clothing router to handle the post Request sent from the client code. I written it using the techniques I showed you in the last module. It's Paston, a sink callback function. I read the existing clothing from the clothing dot Jason file and await the promise returned just like you've already seen me. Do I Then call a new function that will calculate the next available I d value I can use for the new clothing item. I create the new item and assign it the new I. D and the item name in price that were passed in as part of the http request body. I then pushed the new item on to the array of existing data and call another function that writes the array back out to the clothing dot Jason file again. This is not how you would want to store data in a production app, but it meets our modest demo needs Once the data has been saved, I returned in http 201 status. Back to the browser. Along with the new item that was saved. Toward the end of the file, you can see the two new functions I wrote to calculate the next I D and save the clothing data. Perhaps the only interesting bit here is that I'm using a function from the F s. Promises a p I to write out the file. I'm returning the promise it returns, which is why I was able to await the call to the function in the code above. Okay, I know it. Add a new feature to the server side code that will listen for changes being made to the data and take some action when they're detected. Obviously, this all starts with a new of in emitter. I'm going to create that in a new file inside the server directory named data monitor dot Js. As I showed you earlier, the first thing I need to do is require the built in events module. You can use Thea venom in her class directly, but it's also possible to extend it. I'll do that here by creating a new class named data monitor and just specify that it extends even emitter. That's really all there is to creating a class to do whatever you need and emit and handle events. I'm not going to spend a lot of time adding a bunch of custom code to this class now, but I will quickly give it a public field named Logue Level, which I'll just set to death. I'll then export the class from the module to use the new class. I'll go back to the clothing dot Js file and require it at the top of the file. Right below that, I'll create a new instance of the class and assign it to a variable named data monitor. I want to use the event emitting capabilities of the class to notify listeners when new data has been added. The listeners com'on take whatever action is appropriate for that event. I'll add the code to emit the event down here inside the post method. I'll add it just before I send the response to the client. I just called the omit method on my data monitor. Since it extends the event a middle class I'll name the event, Data added. Remember that I can include additional parameters to the emit method that will then be passed to the handler functions. Listening for the event I'm going to pass in the name of the clothing item that was at it. I knew need to add some code toe listen for the event. I'll do that back near the top of the file. We add event handlers by calling the on method of the event emitter. The first parameter passed to it is the name of the event. Mine is, Data added. You then pass it the function that should execute when the event is omitted, I'm going to use an arrow function. It will be passed, the name of the data item added, and I'll just logged the name of the item to the console. That's all I need for a basic implementation of my data monitor. Let's try it out. I'll go back to my browser and add another new item. I'll have a hat this time and make it $10. I'll click. Add item in the request is sent to the server and were redirected to the clothing list page, and you can see hat does appear here in the bottom bag. Envious code. I'll open the terminal and check the output. There. It looks like it worked as expected. You can see here the log message output by the event handler reporting that a new data item was added, You may also notice that Node Mon restarted my server after the log message. That's just because the new item was written to the clothing dot Jason file, which Node Monceau is a change and helpfully decided to restart the server for us. We can safely ignore that. Let's nail make this a little more interesting and add a second event listener for the data added event. I want to be able to monitor data all over my app. So I think it would be better to instant she ate my data monitor in my server dot Js file and pass it around wherever I want to use it. Since I want to be able to pass it into this file when it's required, update the module dot exports line at the bottom and assign it a function instead of the express router. That function will be passed the data monitor, which I'll assign to a variable and then return the router. This is just a bit of a trick that lets me pass an object into this module and still return the same thing it did before. I'm now going to cut all the code in this file and pasted inside this new function. Okay, I need to make two more small changes in this file. I no longer need to. Instant, she ate a new data monitor Since an instance will now be passed into the module. I also don't need to require the data monitor class at the top of the file. I'll nail open server dot Js and make some changes there. I'll know when Stan she ate the data monitor in this file, so I'll add the necessary require statement at the top of the file. I'll create the new instance right below that I'll then go ahead and at another event, listener for the data added event. This time I'll ignore any parameter passed with the event and just logged that new data was added in order to use the same data monitor instance in the clothing module, I'll pass it as a parameter. When I require that module, it will be received by the function I added to the module dot exports just a moment ago. So now what we have is a data monitor instance that should emit an event when a new clothing item is added and hopefully we'll see it handled by two different listeners. The one I just added here and server dot Js and the one we already had over in clothing dot Js Let's go back to the browser and try it out. This time I'll add a coat for $50. I'll click add item and you can see it does get added to the end of the list. Back envious code are again opened the terminal. As expected, you can see the log messages from both event listeners here. It all seems to be working fine, However, what may not be apparent from this demo is that the event listeners air actually executing synchronously when the event is omitted. In the next demo, I'll talk a little more about that and show you how to configure them for a synchronous execution.

Configuring Event Handlers for Asynchronous Execution
[Autogenerated] the event handlers I configured in the previous demo are currently executing synchronously. In this demo, I'll show you how to configure them for asynchronous execution. If that's what you determine you need in your app of emitters, automatically call their event listeners synchronously in the order they were registered in order to quickly demonstrate that I'll add a new log statement just after I omit the data added Event online 44. I'll just log that. I'm returning a new item to the browser and we'll see where this executes relative to the log statements inside the event Listener functions Remember from the previous demoed that I currently have two listeners registered for this event. The 1st 1 gets added and server dot Js as soon as the server starts and the second gets added when the clothing dot Js file is required from server dot Js, Let's go out a new item in the browser and see how this now behaves. This time I'll had a pair of gloves for $5. I'll click add item and we can see it did get saved and added to the end of the list. Back in V s code, I'll open the terminal noticed the order of the log statements. Here. You can see that both event listener functions were executed before the log statement that appeared right after the line of code that omitted the event they also executed in the order they were added. This 1st 1 is the output from the listener in server dot Js, and the next one that includes the item name was added later in clothing dot Js. The no documentation clearly explains that listeners air called synchronously in the order they were registered and goes on to say that this insurers proper sequencing of events and helps avoid race conditions and logic errors. Those are good things and good reasons to build it the way they did. However, they also acknowledged that there may be times when you want tohave a specific listener execute a synchronously for one reason or another. The recommended way to do that is to wrap the body of the listener function in a call to the set immediate function. I'll be that to the listener. I have registered here at the top of the file. The body of the function is just one line and I'll wrap the whole thing inside a call to the built in set immediate function. This essentially pushes the execution of this code into the next cycle of the event loop. Let's go at another new item and see how the behavior changes. I had a $10 scarf. This time My list is getting long, but you can see it did get added to the end. I'll now go check the output in the terminal. Noticed that this time the output from the listener I forced to execute a synchronously appears after the log statement announcing a new item is being returned to the browser. The listener was still called in the same order, but the call to set immediate cause the body of the function to execute on the next generation of the event loop. Keep that handy trick in mind in case you find yourself preferring that a handler function. Execute a synchronously notice built on an event driven architecture. The event. A middle class, enables you to respond to events admitted in many built in modules as well as a Mitch your own events by either using the event emitter class directly or extending it in one of your own custom classes in this module, you've seen how to use the event emitters, omit method to a mid events and the on method to listen for those events. I think they provide a very clean A P I that lets you easily take advantage of the event loops ability to process new events with each generation of the loop. This allows you to decentralize control, flow for your app and write code to respond to events as they happen. Coming up in the next module, I'll show you how worker threads enable you to effectively use multiple event loops to truly run code in parallel.

Utilizing Worker Threads
Understanding Worker Threads
[Autogenerated] worker threads are a relatively new addition to node, but one that gives you a straightforward A P I to deal with CPU intensive task while still maintaining a responsive application. The note event loop is great. It letting you a synchronously all flowed io operations. But the single threaded nature of the event Luke means that there's not a great way to deal with long running CPU intensive task. Until recently, worker threads give you away to send those types of workloads to another thread while keeping your main threat available for new user request. Worker threads and note are very similar to Web workers that are available in browsers. The problems they saw over the same and the AP eyes air similar. But there are some differences just due to the different runtime environments. Each worker thread instance is really a new instance of the event loop. You can think of the event loop we've been working with so far in this course is running on the main threat of the application. The application receives a request to do some work in the event Lou picks it up and takes care of it, creating a new worker three it effectively gives you another event. Luke. The benefit of this is that running a CPU bound task here leaves your event loop on the main thread free to continue handling user request. If you've done multi threaded programming in other environments, you may be surprised to find that you don't have some of the traditional mechanisms available for thread synchronization. However, you are able to pass messages back and forth between the main threat and the worker. Three. Also creating a new worker is as easy as calling the worker constructor, so if you determine you need more than one, you can easily create as many as you need. Speaking of creating workers, let's look at the syntax to do that now. In order to use worker threads, the first thing you need to do is require the worker threads module here. I'm just pulling in the worker class, but I'll show you other parts of the module as we go along. Probably the easiest way to create a worker is also the recommended approach for use in production. APs you Justin Stan. She ate a new instance of the worker class and passed to the constructor, a java script file containing the code the workers should execute. The worker will immediately begin executing the code inside the file on a different thread from the one running the main note event loop. A second option you have for creating a worker is to pass the code you wanted to execute directly inside the constructor. As a string literal, this would get pretty messy, with more than a few lines of code. But should you choose to use this technique, you also need to pass an options object as the second parameter to the constructor that has the evil property set to truth. That will let node no, that it should interpret the first parameter as the actual code to execute. There's 1/3 option that lets you use the code in the same file without passing it all to the constructor. Here I've pulled in the is main thread property. In addition to the worker class. If you reference is main thread and it returns true, then you know you're running on the main threat. If it returns faults, then you know you're running on a worker thread. Therefore, you can check to see if you're on the main thread before in Stan, she ating a new worker and passing it underscore underscore file name as the file to execute that will create a new worker that also executes the code. In this file, however, is main thread will return faults for it, so you just include the worker thread code inside the ELTs block. In the next couple of demos, I'll create a worker thread and show you how it allows the main threat to remain responsive and how you can communicate between the main and worker threads.

Creating and Receiving Messages from Worker Threads
[Autogenerated] Let's nail. Take a look at how worker threat can take the pressure off the main thread and keep your APS responsive. I'll also show you how to pass messages from the worker thread back to the main threat in order to keep the code simple and focused on the details of worker threads. I'm just going to keep all of the code in one file and focus on giving you an overview of the A P I and the functionality it enables. I'll start by adding a new file to my project named threads dot Js. I'll then paste in a short little function that will simulate work that blocks the event. Luke. I've named it Waste Time. And instead of doing any useful work, it would just loop for the specified number of milliseconds that effectively blocks the event loop and keeps any other code from executing. During that time above the function, I'll paste in some code to exercise it own lines one and nine. I've got a couple of logs, statements that just remind us the code is executing on the main thread between them. I logged that the code is getting started, and then I call the waste time function and haven't blocked for two seconds. It then reports the code is in the middle before blocking for another two seconds and finally reporting that it's all done before adding a worker thread. Let's run this in the terminal and observe how it behaves. I'll start it with the command node space threads dot Js. It does what I hope you would expect at this point in the course. It reports that it's running on the main threat, and then we get the other log messages with the delays based in between, We don't get the last log message until the very end, because none of this code was a synchronous, and it's all running on the same threat, Let's know, modify this toe, have a worker threat, execute all of the blocking code. The first thing I'm going to do is require some things we need from the worker threads module. I'll include the worker class, the is main thread property I showed you earlier, and parent port, which I'll explain shortly. I'm going to keep the main thread code and the worker thread code all here in this file, so I'll use the is main thread property. And if else blocks to keep the two separate, the if block will contain the code executed by the main thread, and I'll initially move all but the waste time function inside it. The code in the else block will execute the worker thread code, so I'll move all of the blocking code. Insight it. Okay, I nail need to actually create the worker thread. I'll do that by calling the worker constructor. Since I wanted to execute the code in this file, I'll fast underscore underscore file name to it. As a parameter, the worker thread will begin executing the code as soon as it's in. Stan. She ate it. I noticed that I created it between the two console dot log lines, reporting that this is the main threat. Before I run this, I want to make another change to show you how the worker thread can communicate back to the main threat. To do that, I'm going to use the parent port I imported at the top of the file. Rather than log messages to the console in the worker thread, I'm going to send those messages from the worker back to the main threat to handle is it pleases. I can do that by replacing consul dot log with a call to parent port dot post Message Parent Port is a communication port back to the main thread. It's also in a vent emitter, which I covered in the last module. Whatever I passed, the Post message will be passed as a message event back to the main threat. Ah, copy and Paste parent port dot post message over the other to console dot log statements and then go at an event handler to the main thread code. The event will be omitted on the worker instance. Remember that you can register event handlers by calling the on function and pass it the name of an event and a function that should execute when the event is omitted. The name of the event sent across the parent port is message all right, a handler function that just takes the string it receives and logs it to the console. That string will be whatever was passed to the post message calls below how prefix the output with the word worker. So we know it was a message received from the worker and logged inside the main threat. Okay, lets new run it and see how it behaves. You can see right away that the main event loop was not blocked this time. We immediately got the output from the two logs statements at the beginning and end of the main thread. Remember, I created the worker thread between them. The message is passed back from the worker got handled and logged later, the waste time function was still blocking an event loop. But this time it was blocking the Workers event loop, which left the main event loop free. To continue processing user requests. You just saw how to pass messages from the worker thread to the main threat. In the next demo, I'll show you how to pass data and messages from the main thread to the worker.

Sending Data and Messages to Worker Threads
[Autogenerated] you've seen how to pass messages from the worker thread back to the main thread. So let's kneel. Take a look at how to send data and messages from the main threat to the worker. Passing simple messages from the main threat to the worker isn't really much different than passing them from the worker to the parents. You still call a method named post Message, but you call it on the worker instance rather than the parent port object. Here. I'm sending a string message to the worker to let it know the main threat is done with its work. I'm sending it a string, but I could pass it just about anything. An object with lots of properties is perfectly valid. I'll handle this message at the very beginning of the worker thread code by listening for a message event on the parent port. I'm just going to log the message with a prefix of parents, so we know it was sent from the parent. I'll never run it in the V s co terminal with the command node space threads dot Js. The first part of the output looks just like what we saw in the last demo. However, the last line here does confirm that I did successfully pass a message from the main threat to the worker. One thing to note, though, is that this was the very last line output to the console. Even though I registered the handler at the very beginning of the worker thread code. The reason the message was processed that the end was because the Workers Event loop is still being blocked by the calls to the waste time function. It wasn't Frito handle the message from the main thread until after that code was done. Passing messages like this is very handy, but you may find that when you create a new worker thread, you want to pass some initial data to it that it can use right away. You can do this with a special value passed to the worker constructor named Worker Data to use it. I need to include worker data Among the list of things I'm importing from the worker threads module. I can then use it to pass data to the worker by passing an options object to the worker constructor. I'll use an object literal and give it one property named worker data. The value for that property can be whatever I want. I'm going to assign it an object, which gives me the flexibility to give it properties for any data values I want to pass to the worker. I'll give it a property named Output Prefix I can use in the handler function that logs messages from the main threat. I will sign it the value received message. I'll give it another property name timeto waste, which I'll use to pass in the number of milliseconds. I want to block the event loop with each call to the waste time function. I'll set it to 500 using these values in the worker. Three. It just requires referencing them on the worker data object. Instead of pre fixing the message from the main thread with the word parent, I'll change this template string to use worker data dot output prefix instead. Similarly, update the two calls to the waste time function to use the timeto waste value on worker data instead of the hard coded 2000 I've been using, I'll go back to the terminal and run the code one final time. You can see it using the shorter timeto waste value because it runs much faster now. You can also see the new prefix was used when out putting messages from the main threat. Passing messages air Great, but definitely keep the worker data object in mind if you need to initialize your worker threads with some data when they're in Stan, she ated worker threads or a great new feature in note. But keep in mind that there really only meant to be used for CPU intensive task for Io bound code like disc access and network calls, it's more efficient to use the asynchronous AP eyes that have been in node for years. Okay, that brings us to the end of this module and the end of the course. I hope you've enjoyed it, and I also hope you'll take a minute to rate it and leave me some feedback on the course discussion board. As always. Thanks for watching and good luck on your next node project.
