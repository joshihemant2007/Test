Finding ways to speed up your development workflow can greatly improve your efficiency in completing work. In this course, Automating Node.js with NPM Scripts, you will gain the ability to quickly and efficiently build Node.js applications with NPM. First, you will learn how to get started with creating scripts. Next, you will discover ways to automate commons tasks that are part of a developer inner loop using NPM. Finally, you will explore how to leverage these scripts within Visual Studio Code. When you are finished with this course, you will have the skills and knowledge of NPM needed to develop Node.js apps efficiently.

Course Overview
Course Overview
[Autogenerated] My name is Brian Clark and welcome to my course, automating no jazz with Jim scripts. I'm a Web developer with a background on building full stack Web applications, hacking on Io __ devices and creating developer tools as developers. Today, there is a critical need to improve productivity so that we can excel at our jobs. However, that inter loop of development tests can be very manual and repetitive. Take, for instance, a types for project need to first trans pilot your source code into JavaScript, and then you can start your application. What if we could take such tests and make them easier and quicker to complete? This would help in making sure our workflow is more efficient and automation is the core factor and providing just that. This course will show you how N. P M is a great tool for automating tests and multi step processes that are typical as a no Jess development. You'll first get acquainted with N, P M and N P M scripts. Then you'll see them used in very scenarios for different phases of a Projects Life site. That life cycle consists of building, developing, testing and deploying the project. You'll see projects using various technologies such as tight script, doctor, angular and more. Throughout each phase, you'll see how to take repetitive tasks and speed them up through MPM scripts. I hope you'll join me on this journey to learn, automating, know Js NPM scripts in this course.

Getting Started Creating NPM Scripts
Introduction
[Autogenerated] Hi, My name is Brian Clark, and this course will cover automating know Js with N P M scripts. As a developer, we may not notice it, but even the slightest delay in performing common and repetitive tasks can add up to hours of time. Wouldn't it be nice to save some of that time? Doing so would allow us to focus on more important aspects around being a developer. Things like implementing key features for our end users, finding and debugging issues and publishing our application along with subsequent updates to it. This is a case where N. P. M. And it's scripting capabilities can help us. They're ready and available for us to use to our advantage. But we may not know about its full potential, and this course will take a deeper look to see what it can do. Okay, were convinced that automation is important and helpful to us as developers. So let's talk about NPM scripts. A package Jason file axes. A manifest for describing our applications and libraries and scripts is a property found within this property allows us to describe a collection of tests along with various commands to execute them. We had them by following Jason format and using key value pairs. The key X is the name of the script by which we will invoke it, and the value contains the instructions To accomplish its purpose. You can have any number of scripts that you're required to support the development life cycle of your project. Typically, this will include task around building, developing, testing and deploying our application. Each stage in the cycle may require different actions. For instance, to build your project, you may need to transpire typescript code to JavaScript. To develop it, you may need to run your application in debug mode while adding new features or fixing issues. To test it, you may need to gather all your tests and generate coverage tables or reports, and to deploy it, you may need to men if I, your JavaScript or optimized images before publishing them to production. But enough talking about MPM scripts and what they could be used for. Let's get started writing them ourselves

Initialize Package/Project
[Autogenerated] to get started. We need to initialize a package. Jason, file. So let's open up a terminal or command prompt to start using the N P. M. C. Ally Tool. In this case, I'm going to use git. Bash for Windows is my command prompt. But you can use whichever one works best for you and your operating system. Now we need to make sure we're in the right folder where we'll be working on our project. I will change directories to my working directory for this project using the CD command, and we're all set to go creating a package. Jason file could be done using the innit command with the N P M C Ally tool. Typically, when you run this, you'll be prompted to enter values that help describe your application, as you see here. But instead, what we're gonna do is we're gonna cancel out of doing this by pressing control, See, And what we prefer right now is to just use default values for initializing our package Jason file. And the way we can do that is by using a hyphen. Why option? As part of the command I hit, enter and you can see it. Generate a package, Jason, file for me using default values. And we get to see in the command prompt here the output of what it generated.

NPM Run
[Autogenerated] Okay, so this is for when we're just starting out. But maybe you go into a project where you haven't run and PM in it. It's already been done prior to you joining the project. And you want to see what MPM scripts are available as part of the project. A great way to do that is by running the command and PM run. When we do that, we can see the N. P M prints out to the output. Here in this command line, the Lifecycle scripts included in NPM automation and the name of the script is test. And then the command value is echo error, no test specified and exit with one. So this is fine and all. But let's see what it might look like in a more involved project that's already been created and has been running for quite some time. Okay, so we're in a new project that has more scripts available to it, and we can find that out by running and PM run again. And here we can see there are many more scripts that are available to us is part of the package. Jason file. The lifecycle scripts included in T TV chat light, our pre start start and test scripts and then the other types of scripts. The ones that are run with NPM run or MPM run hyphen script are debug, pre debug, debug, break and so forth. And by running this command, we can see it's a great way to get acquainted with all the scripts that are part of the project and the type of development life cycle that's involved with that project.

Lifecycle Scripts vs. Custom Scripts
[Autogenerated] Now, if you were paying attention pretty closely, you might have noticed that NPM run in the output of this. Describe scripts as a life cycle script or a custom script. Let's take a look a little bit deeper to see. So here for this project there are three scripts that are considered lifecycle scripts pre start, start and test. And then the other scripts are considered custom scripts that are available via the run hyphen script. Commend Debug, Prix de Bug, pre build and build. All of those are considered custom scripts. And why is that? Well, let's go over to the N p m Js documentation to learn a little bit more. Okay, here we're at doc's, dot N, p, m Js dot com, and we're looking at the N P M scripts documentation. As we read through this documentation, weaken C n P m. Consider certain key words that we can use as the name of our scripts to be considered life cycle scripts. In this case, a lot of the ones that we will be typically using our start priest are in post start or tests pretest and post tests, all of which are considered lifecycle scripts. So any scripts that we include in our package Jason that used these key words as names. NPM will consider life cycle scripts. Anything outside of these key words will be considered as custom scripts.

NPM Test
[Autogenerated] Let's get back to our original project and we could see that there was a command that was created when we initialized are packaged. Jason file. The name of it was test, and the value of that script that will be executed is echo a message, and then it will exit with the status of one. So let's try doing that right now. One way we can run N P M Scripts is by using the N P M run and then the name of the script. So let's try out running the test command I hit Enter and we could see it printed out the error message, and it exited with status code of one. Now, as we mentioned before, there's a life cycle script, and then there are custom scripts. If you're gonna be running a life cycle script, you can actually remove the need for even including the run part of the command when you're using the seal I tool. So let's try that out now, too. First, I'm gonna clear my screen, and now I'm gonna run the command NPM test. You could see it outputs a little bit differently, but we're still getting the same results. We have an error message that is printed out to the output here. And then we could see that it exited with status code of one. Okay, that's pretty cool, right? But now we need to take it a step further. And typically, if we want to have an application that we're gonna be running, we need some type of command that will start the application for us. So in the next module, let's take a look at creating a star command.

NPM Start
[Autogenerated] In order to create a star command, we're gonna need to edit our package Jason file and the scripts value that's within it. So open up your favorite editor of choice that could be note pad or whatever it may be. In my case, I'm gonna be using visual studio code because that's where I'm gonna be doing a lot of my development. And I wanna work within that same context. So if you have the visual studio code software installed on your machine whether on Windows, Mac OS or Lennox, you can use a command line tool That comes part of it. To do that, I'm in that folder of my project. I'm gonna tell code to open up the current folder, and I use the period as an indication to open up the current folder I hit. Enter and we could see visual studio code opened up that hurt folder that were in and the package Jason file is there and available for us to edit. So it's maximize this. And now we could see the contents that we saw before in this Eli tool and the output it printed to the screen. Now we want to add a new script. So how can we do that? Well, we're just editing Jason here. So we have one script here with a key value pair. If we want to add a new one, we need to make sure the Atacama at the end of that it enter and type in the name of the script. In this case, we're gonna call it start. It'll do colon and enter a value for this. Now we're gonna be using know Js. That's what this project is about. In the name of the file that we want to start is what we're going to need to indicate here. So we're going to say, node, essentially run the index Js file that we will create in just a moment. Okay, We saved that. And now we need an index Js file for us to run. So let's create a new file as part of this project that we can use within the scripts here in visual studio code. There's a little icon and top right hand corner there that says new file. I'm gonna click on that and then we give it a name of the file we're gonna call in next Js I'm gonna hit Enter and we could see now V s code has opened up the index Js file showing us the contents and letting us that. So here all I'm gonna do right now is just let's console log a message to indicate that it ran. So now if we come back to our terminal in this case, I'm going to use the built in terminal that's available within visual studio code and the way you could bring that up. You see, mine is already open, but if you don't have it already open, you can use a keyboard shortcut that will open it up for you to show you how that works. I'm gonna close out the terminal and then I'm gonna open up the terminal using the keyboard shortcut on Mac and Windows and Linux. It's control back tick, and you could see it opened up the terminal for me. So now that I have the terminal, it's open within the project folder and I'm gonna tell it to run the M P M start. Come in. And this time, since it's a life cycle type command, I could just say NPM start. I hit, enter and we could see in the output the consul log message that we put inside of our index Js file The application ran.

Summary
[Autogenerated] All right, let's summarize what we learned in this getting started module. First off, we learned that automation is important as developers being able to shave off even microseconds of time that we're having to do for repetitive things is gonna save us hours of time in the long run. And so automation is extremely important to keep us productive and efficient. And one way we know now that can help us to achieve that is through MPM scripts, because it automates a lot of those tests that we may need to do. And last but not least, we learned how to create and use some of the basic scripts that are available to us. We learned about the difference between life cycle and custom scripts and how we can use them in a sample project very quickly and briefly.

Scripting for Building
Introduction
[Autogenerated] before we start developing, it's helpful to think about how we will get our application ready for running in various environments. Often we have a process that we or our company like to follow that calls for running things in development, staging and production environments. Each one serves a different purpose, and all of them have an intent to help make sure everything is executing and behaving as expected before making the application widely available. We may also need to take steps in order to prepare our applications for each of these environments, doing things like trance piling, typescript, babble or other compiler based technologies to JavaScript Min. If I ng code optimizing assets and much more become part of that work flow in these cases, getting scripts together for these task early on will make things go much smoother while developing. And when we're ready to start publishing what we've developed, let's first take a look into creating scripts that can help us in the build phase for a typescript project

CLI Tools via NPM Scripts
[Autogenerated] here we have our simple typescript server that we've created here with one endpoint that returns a message that the servers running in what port it might be running on. Now. I've already installed the dependencies needed to run this typescript project and build it. So let's take a look at the package. Jason file in here. We could see that I have some types for express and note installed as Deb dependencies. And then I have t s Lynn and typescript installed typescript in particular, having that installed as a deaf dependency allows us to compile or trans pile are typescript code into javascript and used the typescript compiler Seelye Tool in order to accomplish that. So let's try and do that. Typically, we're gonna use the T S C C ally tool in our command line or command prompt. So let's open that up. Envious code using command J or control J on Windows. And I'm gonna make this bigger so we can see it better. Okay, so now, typically, what you're gonna do is you're gonna just run TSC in the command prompt, and it will pick up your workspace that you're currently using and try to transpire, lenny dot t s files for you. Ah, but we run into an issue. We haven't installed the typescript compiler globally on our machine in order to access it like this from the command line. Now, we could go ahead and do that. But maybe not all your projects require you to have the typescript compiler, right? Maybe you don't want to pollute your global dependencies and packages that you might have with things that are specific to individual projects that you're working on. What we can do is create an M P M script that will give us access to the types from compiler cli tool. And there's a key reason why we conduce this and have access to it. So the reason will be able to leverage things like command line tools such as a typescript compiler using and P M scripts is because what MPM does is it makes these things available in our command line. In particular, it adds preexisting Seelye tools or anything that might be in your path and readily available that way to the shell and also adds anything under node modules dot bin folder. This gives us access to any third party dependencies that have some executed A LS that we might want to leverage is part of our project. Let me show you more concrete Lee what that means. If we expand our Node Modules folder, we'll see at the very top. There's a dot bin folder as well. We expand that and you scroll through here and you'll see that we have three different files. TSC TSC dot command and TSC dot ps one Each one of these is making it compatible for whatever operating system you're running on and whatever terminal or command prompt you might be using to successfully execute that tool from the command line.

TypeScript: Compile with NPM Scripts
[Autogenerated] Okay, let's close this terminal. View the built in terminal in visual studio code and open up our package Jason file to add a script that will allow us to use the typescript compiler. Okay, let's add a new script called TSC and have it called the typescript compiler from it. Make sure to add the common in there and everything will be good to go. So now if we go back to the terminal and we make it bigger and now we can run NPM, run TSC and you'll see the typescript compiler CLI Tool was able to successfully run within the scope of N. P M scripts. But the problem we can see here is a typescript. Compiler needs a few more details as to how to manage our project and work within it. So let's go ahead and do that.

TypeScript: Passing Arguments in NPM Scripts
[Autogenerated] okay. Based on the output from the typescript compiler, we can see that we have some options or examples that we could use. We could specifically tell toe compile the index dot t s file or we can set it up knowing that we're gonna probably have more typescript files that are available is part of this project. Let's set up a T s config dot Jason file to give more information to the compiler. One way we do that, we scroll down. Let's clear the screen. So, typically, the way you would do that is through T S c and the unit option. But if we're gonna be running the typescript compiled through N. P M scripts, we need a way to pass in this unit option to the typescript compiler from the script. How do we do that? Well, MPM run script has a delimit er that signifies that were done sending in arguments to N. P. M. And instead want to send in arguments to the script itself. So let's do that. Let me show you an example. If you add a hyphen hyphen at the end and then a space and then add in the arguments or options that you want to use within that script in this case is gonna be hyphen hyphen in it. The first hyphen hyphen is that delimit er I was speaking of before and that allows us to pass in arguments to the script within the script. Let's hit, enter and run this now and we could see the typescript compiler ran successfully and created a t s config dot Jason file for us. Let's take a look at it very quickly. And there we go. Here's some default options that are set up for our typescript configuration for our project so the typescript compiler can use it. So now if we run the TSC script alone without any arguments, let's see what happens. And there we have it. We were able to successfully transpire our index dot t s file here into an index dot Js file a javascript file. And here is the output of that

TypeScript: Start Script
[Autogenerated] now to round this out, we need a script that will start this node and index file this note application. So let's create a start script in our package. Jason file. We'll add. It is a new line after TSC and give it a value of node index. That way, we use note to run our index Js file that we transpired from typescript. Let's give it a shot in the terminal. Now let's clear a screen and run and P m start and there we have it. The servers running on Port 4005. If I open up my browser to that, we can see it is indeed up and running and running on Port 4005 and we could see that the A p I is logging successfully in our terminal That's running in visual studio code. Now. This is great noble. What happens if we change the code in our typescript file for this application? Let's take a look at that next

TypeScript: Building before Running with NPM Pre Hook
[Autogenerated] Okay, I'm gonna open up the index dot t s file and let's change the running message. Say to just add a little extra will text in here that we can see on the output. I saved that. And now if I come back to my browser, let's see if that message shows up, I'll refresh the screen. We could see nothing has changed. Is still showing the same message servers running on Port 4005. The reason for this is because we haven't transpired old our application into JavaScript since we made changes to the code so we can take advantage of something that's called a pre hook that's available to us in N. P M scripts. Let's open up our package, Jace on file and let me explain what a pre hook is. Essentially, if you put the prefix PR E in front of the same name as any other script that you've already defined, NPM will know that it needs to run that script as a pre hook prior to running the actual script itself. So in this case we're running and P m start, we can create a script. It's called NPM pre start and within that we can tell it that we wanted to actually compile the code using the TSC command so we can actually call another NPM script from within an M. P M script. Let's do that. We're gonna say MPM run TSC within the pre start script now, just to kind of show what is running, when and where in the output of our terminal. When we start running the script, let's add a little bit extra information so that we can see what's happening at the beginning of the script. We're gonna echo out to the console or terminal. What script is running and we combine two scripts together or multiple scripts rather using two ampersand symbols? Okay, so let's stop this from running in our terminal here. Make it a little bit bigger so we can see. And now when I run NPM start, we should see some different behavior. Okay, If you check the output, you can see that we have our message. The pre start script is running, which ran typescript compiler to compile our JavaScript code created a new index Js file and had started the server using note index so we could see it's running on Port 4005 We open up. Our browser will see if it has the new message included in there that says Hello. I'll refresh the page And there we have it servers running on Port 4005 Hello, which obviously isn't a correct port. But now we can see that this is updating and weaken do so through pre hooks that are available in and P M scripts.

Environment Variables in NPM Scripts
[Autogenerated] within the build phase of our projects. I consider environment variables to be a key aspect included within it. In this case, you could see in the project that online. Four. Here I am looking to see if there's an environment variable for the port number we should use or defaults to 4005. Let's make an update so we can control the environment variable through our N. P M scripts. One way we can do this. That makes it cross Platform, available directly in the N. P M script, is using 1/3 party module called Cross Envy. Looking at the package on m. P m Js dot com. We can see some details about it, but essentially, it's about running scripts that set and use environment variables across platforms. So that means that we can use this on Windows Mac OS and commonly use clinics distributions. Let's go back to our project the way we can set up using cross the envies by installing it as a deaf dependency. So I'm gonna use MPM install and the hyphen D option to indicate it's a dead dependency and then cross hyphen envy. Once installed, it will be readily available is a command line tool through the BIN folder in our node modules, as we discussed earlier in the course. So now I can open my package Jason file. And within this start script, let's indicate what port we want the project to run on. So use cross envy to indicate to set something, and we'll say port equal to 4000 and then I add a space so they can run the rest of the command as normal. Okay, if we go back to our terminal, try to run MPM start, let's see what happens. We can see it runs the pre script for NPM Start, which compiles are typescript code. And then now we see the output that the server is running on Port 4000. Let's double check that in the browser, and there we go. We could see the servers running on Port 4000 and then the hello message from earlier

Using NPM Config as Environment Variables
[Autogenerated] another way we can approach environment variables is through NPM configuration functionality. Let's take a look at more details on that through its documentation. As we see her, we can set up configuration through a config key in our package Jason File. Or, if we wanted to, we could set up a global configuration for what port or things like that that we want to use within N PM's configuration. Then, if we want to access that configuration item, essentially, it's delimited with underscores or low dashes based on key value pairs. So in this case, we're talking about NPM the package Jason file, the CONFIG key and the port value. Let's try this out in our project. Let's stop it from running close the terminal. Let's remove what we had with Cross the envy. Let's add some convict or package chase on file. Make it a Jason object, and let's give it a key of port in a value of 5000. All right now, we need to change our code in order to use the new N p m config environment variable. So let's change it from port to NPM underscore package underscore config and then the port we want, we'll save that. Let's open up the terminal. Try running this again and see what poured it runs on. Ah, yes, We can see it's running on Port 5000. And just to verify, let's open up our browser and go to that You are. L will changes from 4000 to 5000. And there we go. We have it. We are up and running and we're using NPM config options and environment variables to use in our project now.

CSS Pre-processors: Building with NPM Scripts
[Autogenerated] with Web development, you might be using extra technologies that will help you out with your styles. In particular, you might be using trans piling or compiling based technologies like sass less or S E. S s. In that case, you're gonna have a need to start scripting the process around, building out and compiling that styled code into just plain old CSS cascading style sheets. And so, let's taken example project here. That's very simple to give us an idea of how we can start incorporating scripts around that process. So first up, let's look at the index html to get acquainted with the project. In here, we could see it's just pretty plain html with a body tag and an H one tag in there. A header that has the text of Clark. Yeah, it is looking for a style sheet of styles dot CSS toe linked to like we see here on line eight and then Tau host all this. I'm using a know Js server. The code for that could be found in index dot Js. So we'll take a look at that really quick. And what this is doing is essentially creating an express server that will host all the files in the root directory of this project. So let's take a moment to just see what we're working with as a baseline when we run this application and what the output looks like in the browser. So I'm gonna open up my terminal, and I've already created a start script that we can use with MPM. So I'm gonna run NPM start and we could see in the output that the servers running on Port 4005 so I can come over to my browser and I can go to a local host 4005 and we could see it's just a plain html page with the clerk yo text header printed out there with a white background. So we have some style that we want to add to this and include as part of our project. But there is no styles that CSS file right now that we've generated. So let's go ahead and figure out how we can go and generate that using cess. I'm gonna stop the server from running clear my terminal output and since we're using SAS, we need to make sure we have that installed as a developer dependency. So we're gonna run MPM install hyphen d sass, and once that's done, they'll be readily available to us in and P M scripts and just a call back to what we learned earlier in the course here. When we have something like that that's available to us and has command line capabilities, it will be provided to us in node modules in the BIN folder and there we could see some of the SAS scripts that are available to us on the system after we installed the package. So knowing that that's the case, let's update our package. Jason file to incorporate a sass command, press control P or Command ___. If you're on a Mac to open up the file picker and visual studio code and type in package, Jason and Hit Enter Control J to hide the bottom panel or command J. If you're a Mac OS and then in the scripts object, we're gonna add a new script that's called sass. Make sure that a comment the end. And as for the value of it, we're gonna use the sassy Ally tool and tell it that the input file that we want to compile is styles that sass, and we want the output to be styles that CSS save that. And now let's try running that script manually in the terminal. We do that by running NPM Run sass I hit Enter, and now we could see new files were generated for us in this work space, we have a stylist ____ SS file and a mat file to map the translations between the SAS file and our CSS that was generated. So now that we have that, we could run our application and see what the output looks like. So now we're gonna run in P m start and let's go back to our browser to see what changes were made. I'll refresh the page and we could see the text has now been aligned center, and the background has been changed to blue. So we were able to successfully use ___ as a command line tool in an M. P M. Script to do that processing for us. But the downside so far of doing it this way we is. We had to do that manually. Let's incorporate this as part of our script flow and workflow so that it gets done prior to a starting the note application and picks up any changes we made, mate. So let's go back to visual studio code. So now what we'll do is we'll create a pre hook to the start script well, at a new line, give it a key of pre start. And that way MPM knows to run this before it executes the start script Atacama and said its value to run the SAS script. So NPM Run says, We'll save that. And just to show that we have changes that will be made, let's update our SAS file to do a different background color for the page. So let's open up the SAS file and changed this to a different color of red. And let's say that so now I'll open up my terminal and I'll run MPM star and let's pay close attention to the output in the terminal, and we could see that NPM ran the NPM run SAS script first, and then it ran Note Index to start our server, and we could see the servers running on Port 4005. So now let's go over to the browser and see if those changes took remember previously. It was a background of blue, and it should be read. Once I refresh the page here and there we have it. So this is a typical process that you can implement into your application your project. Whether using sass s CSS or less or any other trans piling technology for your cascading style sheets, you can apply these same techniques we used here into your project.

Bundling and Minifying: Webpack Build Tasks
[Autogenerated] Okay, So Wet Pack is a common tool that's used for bundling and men if I ng JavaScript code, especially for front end Web development, because we want to make sure our applications have the best performance as possible when it's running and being used by our end users. So let's take a look at this project that's using wet pack and get an understanding of some of the typical steps it takes to run and use wet pack within it. So really quickly the Web pack config that I have for this. Let's take a look at the contents of that file here I'm using to plug ins. One is clean, one is copied. The clean one allows me to have a clean slate every time the wet pack build my project for me, and then copy is being used to copy other assets. That wet pack is not gonna be compiling for me. Things like html CSS or my note app dot Js file. Then we're using as a server tau host this project. Speaking of which, let's take a look at that code really quick. So I have a server folder under my source code folder SRC and there is my app dot Js file and here you could see it's just using expressed static to statically host all the contents of my HTML CSS and job script files that I need from the local file system here. Then on the client side, have an index dot html And in here, things to note is that I'm referencing the styles that CSS file here on line eight and then I'm also referencing the bundle Js script that I'm gonna have. And I'm expecting Web pack to output a bundle dot jazz file for my source code for my client side application here. And then I just have some other HTML for demonstration purposes that were going to show some messages on the screen. Okay, the client dot Js file Let's take a look at that really quick. I'm just using vanilla javascript to get an element by I d. In the document and then change the inter text of it to be plural site and then again for demonstration purposes to show when we're using third party dependencies like low dash. In this case, how wet packed will bundle that into a separate job script file for us. So lines five through eight, I'm importing low dash and then I'm using Vanilla JavaScript to get another element and then lo dash to join some text together for hello message. All right, so stepping through the process that we would have to do without any M P M scripts to use wet pack, there's a couple of things that we would do. First of all, let's open up our terminal and that its control back tick on Windows and Mac OS or Lennox and I have my bash Terminal open. Now, I could use an install wet packs, Eli globally on my machine. But I don't want to do that because I don't want to pollute my global name. Spaces is specific to Justice Project, so I can use N P. X if I want to run Web pack in the context of MPM that way. And that's what I'm gonna do right now for demonstration purposes. And what that's gonna do is it's gonna wet pack is going to bundle my JavaScript code for me and then copy over all the assets that I need into a dest folder. Okay, great. It's done doing what it did has some output to show me exactly what steps it took in the results of all that. And we could see in the folder in our project here we have a disc folder now, and there's all our bundled assets and all of our application code that we're gonna need to run this application. So the next step is to run it, I'll clear my terminal and now to run it, I'm gonna run another command. I'm gonna use no to run the app dot Js file found in the dist folder like we see here. So I'm gonna run node and then tell it the folder dissed and that javascript file ap dot Js I hit Enter. We see the servers running on Port 4005. So now open up my browser to double check and see everything running as expected, we'll go to a local host 4005 and there we go. Everything is running as we expected. Now the issue here is that I have to manually run Web pack to build and bundle my job script code and my vendor code. And then I have to run the node command to start up my application and do my development. So let's see in the next clip how we can use NPM scripts to start automating and get prepared to automate that whole process and the developer workflow when using Web pack.

Bundling and Minifying: Automating Webpack Build Tasks
[Autogenerated] Let's stop running the application from before. Clear our terminal out. And let's open up the package. Jason file to start creating scripts for this project Control P or command ___ in visual studio code will open up the file picker prompt for us, and I'll type in. I want the file package Jason and hit Enter. That brings that to view. And now we're looking at her scripts that are defined between line six through eight and we have the default test one there. I'm gonna get rid of that. For now, we're gonna create one called Build, and within it, all we need to do is just call Web pack. All right, let's test that one out in the terminal. I'm gonna delete the dis folder just so we can see the and verify that it is running. What pack? For us now in the terminal run and PM run build. We see the output we saw before when we tried it in the last clip. And now we see that it generated the dis folder again for us. And we have all of our assets to run our project again. So great, we have an m p M script that will essentially do what we were doing before. Now let's take the next step. We need to run and starter application using notes. So it's critic script For that. We'll call it Start, and we'll tell it that we want No to run the APP Jess file That's in the dist. Folder. Let's clear a terminal and then we could just test this out by running and P. M start. Okay, great. So you see, it's running as we saw before, and if we want to, we could go to the browser and verify that. But we know that that's gonna happen. So how can we maybe couple these two steps together so that the build happens before we start running the note application? One way we can do that is to use the pre hooks that we learned in a previous module. In this course, let's stop the app from running. We'll add a new script. We'll call it pre start because with the prefix of pre NPM will know to run this particular script before the main script, which is start as the value of this pre start script. We'll just tell it to run Another NPM script in this case will have it run the build script. Okay, let's give this a shot and see what happens. And to make sure we can understand and see the steps that the script is taking in the output of our terminal, let's add a little bit more to that priest. Our command, actually. So I'm gonna want it to echo out just some text to know that we're in the pre start script. So we're gonna use the Echo Command, and we're gonna just type in some text to say, Hey, this is the pre start script. And then to combine that the Echo command with the N p M run command we can use to am percents we'll save that. Come over to the terminal. And now when we run NPM start, let's see what happens. Gonna make determine a little bit bigger so we can see everything better. I'll enter pre sort. Script is running, which ran Web pack. We see the results of wet pack running and bundling our application. And then after that, the server is running on Port 4005. Excellent. So there we have it. There's some scripts to put together to help us with the process and steps we might take with bundling and modifying our job script code using Web pack and then starting up the server that's gonna host that client side code for us now. This may not seem like much just yet, but as we progress through the course, you'll see how these scripts will tie into future scripts that we're gonna create as we start getting into developing testing in deploying our application.

Front-end Frameworks: Angular Build Tasks
[Autogenerated] All right. Well, let's take a look at what we can do around angular applications, the tests that are involved with building and angular application, and how we can automate those tests using MPM scripts. Nowadays, with angular, you have a tool through this Eli that will help create and scaffold out your project for you. What you typically do for that is you'll install the angular Seelye tool globally on your machine, and then you can use the N G commands that are available to it. Now. One of the first ones that you'll use when you're creating a new project is N G nu. Now I won't run this because I've running already, but let's explore the output of what happens when you run. Engine knew for the first time and went through all the options to generate your application. Specifically, let's take a look at the package. Jason file. We look here. We can see in the scripts field that the angular seal I generated the package Jason with some scripts for us right off the bat, we have n G start build test lint and e T. E. All these are very relevant specific to an angular application and some tests you might be taking on and trying to accomplish as you're creating this application and working on it. So as we can see, we have the start script here that will run N g served for us. So let's go ahead and try running that right now. I run NPM Start and hit. Enter, we can see underneath it Ran Engy serve. It does its thing behind scenes building our application. And once that script has finished running and starting the angular application for us, we can see that it tells us that it's running at local host 4200. So let's check that out and validate that this is working as expected. So type of my address bar local host 4200 and we can see the angular application is running and we get the default output and rendering of the U. Y. That comes with the angular Seelye Great now, So this is a fine approach to start developing an angular application using the N G serve that's available with the angular Seelye. However, it really doesn't emulate what the end result might be. The environment that our application will be running it. Typically, what you're going to be doing is you're gonna be hosting your annual application on a server. In this case, we're gonna be using know Js, and it's gonna just host all our static resource is that we have for the angular application index dot html all the JavaScript files, any CSS files that might be available. So being that that is the case, let's start making some modifications to the application to add a node server to it. So I'm gonna cut back over to our application and visual studio code. Let's stop this from running with control. See, enclosed the terminal and let's add a folder called Server and within that folder will add a server dot Js file. And now we're starting to edit the contents of the server dot Js file. Now, instead of having to manually type out all the code for this, I have some code already written that will host our static resource for the angular application. So let's pace that in the one thing I want to point out here that's going to be of interest and that we need to take into consideration because it correlates to other aspects of running and building. The angular application is the expectation is that there is a dest folder that will be hosting Our angular resource is from once it's been built. So that's where I set on Line seven here that the Web folder is dest. Okay, That means we need to tweak the angular Seelye configuration when it goes to build the application to send it to this folder. So we'll goto angular dot Jason file, and we'll change the output path to just dissed. We'll save that. So now we need to do two things we need to build our angular application using the M. P M run build command that's already been provided to us in our package. Jason file. Let's look at that right there on line seven and then once has been built. It should go into a dest folder. So let's double check that and run in the terminal. I'll clear our screen and run NPM run build, which in turn, is going to use the angular CLI and run the Bill command through that. Okay, great that command finish that script to finish running and we can see in our project here that a dis folder was created. If I expand that, we can see all the assets that are relevant to our project for running the angular application. So now that's working. We should be able to just run our node server so I can run that directly from the command line. But as you probably imagine and expect, let's create a script that can run this for us. Let's close the terminal now. The sea alive, angular seal. I created this start script for us, using the angular and G serve command. That's final, but we're gonna change this to be start N g instead because it's specific to the angular Seelye. And then let's create our own start script now and in it. Let's set the value to have knowed run our server Js file and make sure to add the comma. Okay, let's bring up the terminal again. Clear the screen and run and P M start. Okay, so now we could see our node server is running on Port 4000 and fingers crossed that everything goes correctly when we go to load that in the browser, we should see the same output we saw before from Angie serve, but with the note application hosting it. Okay, so this is what we had before. Let's open up a new tab and go to a local host. 4000. There we go. We have it. So now are angular. Application is being hosted on our No Jess server.

Front-end Frameworks: Automating Angular Build Tasks
[Autogenerated] Okay, so that's good. We're making progress here, but we can simplify this even more with M p m scripts, right? Because we had to run the build command separately, first on her own. And we did that manually. And then we ran this start script to start up our node server. And then we had to go into the browser and go open up our local host, 4000 euro so we can cut down on that a little bit. We're gonna use MPM to do that. Let's go back over to visual studio code and take a look at our package. Jason file again. Let's stop this from running using control. See, Clear the screen. All right. So what we want to do is start tying in the start script with the build script and a great way we can do that. And I'm sure you're probably already thinking this from past clips. If you watch those, we can use a pre hook to the start script. So let's have a pre start script that will run the m P m run, build a script. So now when we go to run the M P M start script before it actually gets executed. It's gonna run the pre start script here online seven, which in turn its value is going to say, Hey, let's go run the build script in N P m. Which is down here on line nine, which will run the angular seal I build command. And that should generate the DEST folder for us like we saw before over here. And then once that's completed, it will actually run the N P. M start script, which will start up our node server. So let's try that out. I'm gonna delete the dis folder just to verify that everything is working as we expect. Okay, let's open up our terminal again with control Back tick. And now when I run MPM start, let's monitor the output in the command line. Okay, we see MPM run, build go and g build. We see the output of energy build. Soon we should see it. This folder show up in the projects and there we go over here and shortly after that we see server is running on Port 4000. We come back over to the browser, we refresh everything is still running. Everything's looking good. We're all happy now when we only had to run one script type in one command into the command line and were able to get going with this fairly quickly. So sweet we were able to take some of the typical tests around, building an angular application and automate some of it with M P M scripts. While we use angular in this example, these same techniques can be applied to other front and Web technologies such as View, Js, react and more. Next, let's explore a docker project and get familiar with some tasks around building it and then automate them with N. P M scripts.

Containers: Docker Build Tasks
[Autogenerated] all righty. So now we're gonna take a look at a Docker project, and we're going to see how we can take some of the tests that are common to working with Dr and automate them with some NPM scripts, or at least just improve upon them. Let's get acquainted with this project that we're gonna be using. First of all, they could see we have the default initialized. Scripts that are available to us in this case is just a test one that echoes that message. Let's take a look at the know Js server that we have. It's pretty much the same one we've been using throughout the course where it just has won a P i n point that we send a request to and get a message back that this server is running. From there. We have a docker file now for some people. If you haven't used doctor before, this might be new to you, so we'll step through very quickly and briefly to give you a little bit of an overview and get you acquainted. But otherwise we're not gonna go too deep into docker itself. So this doctor file describes how we want doctor to create an image based on our project and what we need for it. First of all, we say we want to be using node version 12 here on line one. Then we tell it that within the container, we want to use a directory that's gonna be our working directory. U S r s r c ap Once we have that we tell to copy our package. Jason, file and package locked files from this current project into that root directory will run MPM install within the container, and then we'll copy over our source code for the application into this particular folder. We want to make sure we expose the port that we're gonna be running. Our node server on in this case is going to be 4005. And then we tell it to run a command in the terminal within the container node server to start our node server up, and that's it. Then we have Dr Ignore file that tells Dr to not copy over or pay attention to the node modules holder or any NPM debug logs. If we need to, we could add more things here, but for now, that's all we need. So now that we're acquainted with our doctor project, let's take a look at some of the steps that we would typically do in a docker project to build it. Now there's a lot of assumptions being made here a little bit, too, that we have dr running on Windows or Mac or whatever operating system you might be running on. And you have that all ready to go. In this case, I have already pre installed Doctor and have my environment set up to be able to use Dr. So that means I have the Docker Seal I tool available to me where I can run doctor commands. So the 1st 1 we're gonna want to do is, let's say we're done with our development or let's say you pull down this project and it's already got the code ready to go, and you need to build the image that you can then run it within a container. So the first step is to use the doctor build command with some options. Let's step through that. I'm gonna run docker build and give it a tag of Clark eoe slash node Web app. Then we'll tell it to build from the current folder directory that were in which is no doctor, and I use the period to indicate that I hit enter. We could see the output from the doctor. See, Ally is running through a few steps using that dr file that we mentioned earlier, and once it's done, it says, successfully built and tag that. Clark yo node Web app. Latest image. So now we have an image so I can clear my term and let's see that image has been created. Awesome. So now that we have an image, we want to run that image within a doctor container, and the way we could do that is using the doctor run command. So let's step through what we would have to type for that particular test going to say, Doctor, run. Then we tell what port we wanted to run on an Expos. We mentioned in the doctor file earlier that Port 4005 is where the note APP is gonna be running in it exposed. We need to make sure that that's available on our host machine in this case, the windows machine outside of the container. So we're gonna make sure we say hyphen p, and they will say 4005 map to Port 4005. We'll say We want this to run in. The backgrounds will use the hyphen D option and then we'll give it a name of Web app and tell it to use the image. Clark Yo node Web lots to type in there. But that's gonna get us rolling with running our image that we created just before in the previous command and running in a doctor container. So let's hit enter and there we go. Just like that, it's running, so we should be able to go over to our browser. Now open up local host 4005 and we'll see the message of our note server running in Docker just to remind you the messages servers running on port in the port and in Docker. Okay, then open up the browser. I'll enter in local host 4005 and there we have it. And there we have it, the servers running on Port 4005 and in Docker. So we've successively done that and we got to see a little bit of some of the common task that we would run using the doctor cli tool in the process around doing that. Now in the next clip, let's take a look at how we can use thes common tasks that would be used in a docker project, but with N. P M scripts.

Containers: Automating Docker Build Tasks
[Autogenerated] so taking a look at how we can take some doctor tests and run them in N P M scripts. Let's jump back over to visual studio code and clear the output terminal and open up our package. Jason Filing would use the keyboard shortcut Visual studio code control P or command P depending on what operating system you're on. Tell it to open a package, Jason. And there we go. So within the scripts object, let's add a new one. So add it with the name Dr Colin build and give it a value of what we were doing before, which is Docker. Build hyphen T and the name of the image and use the current directory that we're in with the period and then for the Run Command, which was very lengthy in a long thing to type. Let's make a docker run script and give it a value of as follows. Just copy and paste this in here to avoid errors. And don't forget your comments, and one thing you might be noticing throughout this course is that I tend to prefix my commands with the context that they might be used for. So in this case, it's gonna docker. And then I put a colon and then give it the idea of what I'm trying to do within the context of that. So in this case, we're gonna be building a doctor image, and then we're gonna be running a doctor container. You can apply this to any other type of projects and tests that you need to do. It's a great way to keep that convention and follow along with the purpose around these scripts. Okay, so let's go over to our terminal and build out the image. But first, before we do that, let's make some changes to our server jazz files so that we can know that it actually did take the new changes that we made ends updating the build for us. So I added to the message that it's in Docker with portal site, at least so we should see a different welcome message when we go to the browser next time. All right, so now I'm gonna run npm run, doctor build. We could see it went through a little bit quicker because we had the previous image it was building off of, and doctors able to see the difference and only have to rebuild the areas that we made changes to. So now we're gonna tell Doctor to run our updated image. So we say MPM run Dr Colin, run. Now you might be noticing. This is definitely saving us a lot of keystrokes and a lot of time that adds up throughout the development workflow. In that cycle, we keep going through it. Could you imagine having the type this out over and over again every time. It's not fun that takes a long while, And P M scripts is a great way to kind of reduce the amount of typing that we have to do in order to accomplish the test that were doing as developers. So that should be running now. And if we go over to local host 4005 in our browser, we should see the updated output message. I'm gonna refresh the page and there we have it. It included the extra message with plural site in the response now. So this is just a taste of how we can take common tasked with Docker and building things around Docker and automating them and speeding up our workflow using MPM scripts

Summary
[Autogenerated] Okay, so let's summarize what we learned in this module. First of all, we learned that we can use MPM scripts to run the seal I tools that come bundled with a lot of our dependencies, our developer dependencies in our projects. This is great way to isolate the things that we are gonna be depending upon to just the project and not have to pollute our global name space, our environment on the system that we're developing on. From there we learned about how we can use pre hooks or pre scripts that will help prepare for running and setting things up prior to running our main script. So in this case, an example was like pre start before running the start script and so forth. After that, we learned how we can use the n. P m config property within package Jason to use it as environment variables for setting things up and building and preparing our environments when building our projects. And then we went into deeper detail on specific scenarios that you might be running into your project through your job for building tasks around different project types, specifically typescript and how we can understand the tests are involved with that and automate those bill tests within it. CIA says Pre processors bundling and men if I ng we used Wet Pack is an example in this module, but you can apply those same techniques to other bundling identifying technologies you might want to use in your projects. We took a look at angular, using angular seal lile a lot of fun and frameworks and libraries come with a seal I tool now. And we were leveraging that to run the scripts V A and P M and last but not least, getting into container ization of our projects and using docker and how we can build our projects with Dr Commands. And that's Eli Tool. So now that we have this foundation in some tests that are helping us with building these types of projects in the next module, we're gonna take a step further and build upon them by creating NPM scripts that will help us in automating our workflow when we're actively developing those projects.

Scripting for Developing
Introduction
[Autogenerated] Now comes the fun part developing. At this point, we've done quite a bit of set up to prepare for writing our code. What will be doing now is leveraging the existing script we've created and expanding upon them where needed. The key during this phase is to notice when you're doing repetitive manual tasks. Each project will require different tests while developing, so use. What you learn in this module is a model for automating your workflow. Let's take a look at some examples of doing this with our demo project.

Node.js Development Tasks
[Autogenerated] let's begin with a simple node server and the typical workflow that you might be going through when developing out a note application like this. So right now I have just the one endpoint which will return back the AP. I was successfully requested a lot of that rather, and then it sends back this running message, which is servers running on port and then the port number and inserts that into the string. So when I go into my browser and I request this particular endpoint on local host and depending on what port it's running on, they'll be local, host the port and then just forward slash Then we'll get this message returned back to us. So let's just start this up and run it. Let's say we're ready to start developing and make changes to this thing, but we want to see it running first. So open up my terminal with control back tick, and I'm just gonna run. I'm gonna show you really quick and packaged. Jason, I have a start script that just says, Hey, node, open up this index dot Js file, which is my main note application entry point. So do that, and we could see the servers running on Port 4005. If I go over to my browser, I enter in local host 4005. You see the servers running a port 4005? Okay, great. So it's actively running and it's working. But now if I go over to my editor again, which is visual studio code, and I want to make some changes to the message to get sent back now instead of it being servers running on Port 4005 let's change that. So I opened up my index dot Js file, and I want to say the server is up and running on port and the port number, and I saved that. Now what I need to do is actually have to stop my server from running so that I can pick up the new changes, restart the application and then go back over to the browser to verify and see the output that is a result of my changes. So let's step through that I'm gonna press control, see in my terminal that will stop the execution of that. I made my changes to the next of Js file and I saved them. Now I can restart my application by running NPM start. Then I go over to the browser and a refresh the page to see that result. And now I could see the server is up and running on Port 4005. So, as you can see, that is an okay workflow, but wouldn't be nice to make the changes to our application code and then see the result very quickly and easily in the output that we're monitoring and actively working against. Let's see in the next clip how we can accomplish that type of workflow, that efficiency with node and using NPM scripts.

Automating Node.js Development Tasks
[Autogenerated] So if we want to be ableto actively monitor when we make changes to our source code and restart our note application, one of the most common ways to do that is using a tool called Node Mon. Let's take a look at what that's about. We'll open up mpm jazz dot com and search for Nordmann, and the first result we can see is the package we're gonna be using Node mon. It's a tool that helps develop know Js based applications by automatically restarting the note application when file changes in the directory are detected. So let's add this to our project. I'll open up visual studio code again, and in my terminal, built in terminal within visual studio coat, I'm gonna run NPM install node mon as a deaf dependency. Okay, No, Mom has been successfully installed as a developer dependency, so we can use that during our development phase. Let's add a new script that's going to use the node mon tool. Let's call this one start Dev, since we're in the active state of developing our application. So that's the name of our script. And now to use known Mom, we just say node mon Index Jazz instead of Note index. Jess. Let's save that. Go back to our built in terminal, clear the screen and now we're gonna say MPM run, start death so we can see in the output of the terminal here from Node Mon. It is watching the current directory that we're working in, which is the root directory it's watching for JavaScript, M Js and Jason Extension changes. And then it starts with Node Index for us. And then we could see the usual output for my application that servers up and running on Port 4005. So now let's just verify that it is up and running. Well, refresh the page in my browser and everything's working good. So now we can come back over to our visual studio code editor, and we went to index dot Js And let's make another change here, servers up and running on port in that port. And let's just add a little more to the message was pretend the servers talking back to us. So once we made those changes and we saved him. If we look in the terminal now, we can see Node Mon says restarting due to changes starting note index then picked it up again. And now we could see that the consul law got the new running message, which is servers up and running on Port 4005. Thanks for checking on me Now. If we go over to the browser, let's verify that is working there as well. I'll refresh my page here and there we go. So now you can see you can, actually, if you wanted to on Windows or any other operating system, you can have your browser open toe one side, your editor open to the other side and actively edit and see the results back and forth. Make another change. Bring up the terminal again. And now when we refresh the page, we should see a consul log message in the terminal and we could see yes AP. I was successfully requested Woot. All right, so great. We're getting a little bit better of a workflow now in our active development, and we're using MPM scripts to accomplish that, along with some other Seelye tools like no daemon

TypeScript Development Tasks
[Autogenerated] All right, So now that we know we can use node mon to monitor and listen for changes in our source code and restart our note application, Let's see how we can apply that tool within our typescript application. Now, Now, if you recall from earlier in the previous module, we got set up with the typescript compiler as a pre start script, as we can see here online 11 which will run the TSC script, which is just running the typescript compiler. And it's using our T s config file. And then once that's done, it will actually run the M P M start script for us, which is just note index. So let's just verify that and get re acquainted really quick. Okay, so the types compiler ran generate that index dot Js file up here and we could see the servers running on port 5000 deer in the terminal output. And let's just verify that in the browser, open up a new tab here, go to local host 5000 and then we go. We have servers running on Port 5000. Hello. So if we go to make changes to this, we want node Monta listen to the changes to index dot Js so we can try adding a start Deb script like we did in the previous clip. Go back over to visual studio coat, give this script the name of Start Colon Dev and then give it the script The value that we're gonna be running of node mon index dot Js. You might have noticed we have to actually install that first before we can use it. Let's stop our application from running in the terminal. We'll run mpm install hyphen d So it's a dead dependency. No _____. All right, a quick question and quiz for those of you that are watching this course. Do you think if we were on NPM Start Dev that that will run the pre start script? The answer is no. We need to have a priest start Colon Deb script in order to have the typescript compile a run before we run the node mon command. So let's add that into our scripts here. All right, so all we had to do was prefix our script name with the p r e prefix and that way and PM knows to run that pre start Deb script before the actual start Dead script. Now, another question for you all. Do you think this will be enough so that when we start developing and making changes to our typescript file that it will be reflected in the output of the running application? If you thought the answer is no. Well, you are correct because the typescript compiler is gonna run just at the beginning of the first time we run this. And if we make changes to our typescript, file the compilers, not actively checking to see if there's changes to the typescript file in order to re compile everything, let's verify that just to show that that is the case when we do try to do this in the way that we're doing it right now. So we're clear my terminal. Let's delete the index. That jazz file. Let's make a slight change here. Let's get rid of hello here online nine and say that we run NPM Run start Colon Dev Okay, we can see that it ran the pre Start Dev script, which is running in typescript compiler. The node one did start our note application for us and says that the servers running on Port 5000. Let's just verify that one more time we should see the different output in the view of the browser. So if I refresh this page, you see, the helo is gone Now, right now, if we go and try to add the helo back, let's see what happens. Come back into our source code going to index dot t s. We had that and save the file you notice in the output on the terminal here. No, Edmund did not pick up any changes to our file. And that's because we need the typescript compiler to also be monitoring changes to our typescript files so that it can regenerate and re compile into a new and updated index dot Js file. You'll notice in the index that Js file. If we open that up, we can see online 12 here that the running message does not include the addition of the hello string that we're trying to provide an original typescript file. So how do we go about adding this into our process here? Well, we can use the typescript watch option when we go ahead and start up the typescript compiler. Let's add that into here. I'm gonna stop the application from running. One way we can approach doing this is we can still leverage the pre start script like we have been That's then calling the typescript script, but instead will pass in some arguments that are specific to the typescript compiler. And the way we could do that is by using the hyphen, hyphen, delimit er that MPM provides to us so that we can pass in options into the underlying script. And the way the typescript compiler works is there's an option that we can pass to it called Watch. So we do hyphen, hyphen, watch. We save that and let's see what happens when we do this. So I'm gonna run at the N. P. M. Start Dev script and noticed something here in the terminal. What happens is the typescript compiler compiles are typescript code into javascript, and then it's actively watching for changes to our types from file. Now the problem with this, though, is that it stops there. It doesn't let us go into the next part of the script because it's holding up the terminal and it didn't exit successfully. It hasn't even exited yet, so we need to do is be able to run two different scripts in parallel, so let's take a look at how we can do that in the next clip here.

Automating TypeScript Development Tasks
[Autogenerated] all right, so our goal here is to be able to run the typescript compiler and have it watch for changes in our typescript files while also running the node Mon Note application. Tow watch for changes to the index that Js file our entry point for application. So we left off with the types of compile of running and watching through the pre start Deb script. So let's stop that from running Clear Terminal. And what we're gonna use is another tool and MPM package. It's available to us that allows us to accomplish what we're trying to do. Let's take a look at what that package is and what it can do for us. So here we are on N. P, m Js dot com, and we're looking at the package called MPM hyphen Run hyphen all. And what this is about is it's a seal I tool that lets us run multiple and P M scripts in parallel or in sequence. You can use various combinations of those two options that are available to us to run all of your M P M scripts. The beauty of it is you just have to create your own P m scripts and you tell MPM Renault to run them based on their names. It will read directly from the scripts configuration in your package, Jason file. Okay, so let's step back into visual studio code. Let's install the MPM run all package as a deaf dependency, so NPM Aye, Hyphen d with a capital D and PM hyphen Run. All All right. So we're gonna want to change our existing script around a little bit so they can keep consistent and how we're going to use the M. P. M. Run. All tool. So first off, if we think about what we want to do, we want to have our typescript code compiled before we actually start and run our note application using no daemon. So we need to run the typescript compiler first. And then we want to run our note application with Node mon, and then we want the compiler to watch for changes as well. Okay, so if we think about that, we need those three scripts completed for us. Well, we already have the typescript compiler script under the TSC script name here online. 10. We need one. That's gonna We're gonna call build, watch which is basically we're gonna replace the pre start, Dev, We're just gonna rename the script. Actually, we'll just call that build. Watch now and then we have our start dead like we normally do. So let's create a new script. Now that's gonna be called start death watch. All right, let's pay close attention to what we're gonna do here. We're gonna call the N P M. Run All Seelye tool. Then we're gonna tell it what script we wanted to run first. That is the typescript compiler. So we'll just say TSC. Then we can tell it that we want to run the next scripts in parallel. So we're gonna use the option hyphen, hyphen, parallel. And then the names of all the scripts that we want to run in parallel in this case is going to be two scripts. It's gonna be Start, Dev, and it's gonna be billed Watch. Okay, let's give this a shot and see what happens. So you say mpm running start, Dev, Watch. All right. The typescript compilers running. Compiling our code and very quickly you can see once that was done, it started up the build watch script and the node mon Script in parallel. No Mine's output showed up first here and says that the servers running on Port 5000 which is fine because we haven't made any changes yet to our index dot t s file and then the typescript compiler with watch option start running and we could see that it started in violation and watch mode and found zero errors. It's watching for file changes. So now if we go to our browser, let's take a look at what we see in the output for local host 5000. Refresh the page. We have the hello there we go back and make changes to our typescript file the index that t s file. So if you notice they're in the output in the terminal While I was making those changes because of auto save within visual studio code, the typescript compiler was noticing changes in her in next T s file. It was re compiling, which would therefore update the index dot Js file which Node Mon was monitoring for changes. And then it was restarting the note server based on those changes. So now let's go back to our browser. All right, so in the browser here. If we refresh the page, we should see those changes to the text that I entered before. And there we go. We're making changes and they're updating. Excellent. So there's a great example of tying in other Seal I tools to help us run things in parallel using node Montaigne, NPM run all and using some P M scripts to combine all of it together to get a nice work flow for our development of typescript projects. Now we're gonna take this a step further. There's a lot that we had to do here, and there's an even simpler way we can approach doing this with typescript projects, So let's take a look at that in the next clip.

Bonus TypeScript Development Tool
[Autogenerated] Okay, So in the last clip, we saw how we can actively watch for changes in their typescript file and have the compiler trance pile the code into an index Js file, which is being watched in turned by a node Mon process that will actively restart our note application when it detects changes in that file as well. So it creates his great development workflow. Now the one thing is, even though that's great, that's still fine. We can go that route and you can stop there if you like. But if you want, take it a step further and simplify things a bit. There is an M. P. M. Package called T s no depth, and that is what we're looking at here on NPM and what this does is it essentially combines a lot of that process that we were doing and allows us to really just create one and P M script that will handle that whole workflow for us. So let's take a look at what it's like to set this up and give it a try right back over in visual studio code. I'm gonna stop the running process from the last segment. Let's clear a terminal. We're gonna end p m install as a dead dependency. T s no depth. Okay, great. So now we have t s No Dev installed here as a developer dependency for a project. Let's add a new script just to keep things separated. I'm a cold start t s dev, and it's for the value that we put into the script will call the T s. No Dev Seelye Tool and tell it what is our entry point for our typescript Note application. In this case, it's index dot t s So we'll save this and I will go back to the sea, lie clear a terminal and run that script using NPM Run start, Kahlan T s depth hit. Enter. We could see it tells you what version of T s note it's using underneath it and the typescript version is being used. And then we see the output of our application again. Servers running on port 5000. So go back over to the browser. Here's our Ted that has local host 5000 open. I'll refresh it. Okay, Everything is running as expected. Let's go make a change your code and will remove all that extra text that we created earlier and get it back to just the original running message. You'll notice in the output that the T s no Deb tool detected the changes to our type court file and re trans piled it and restarted the note application for us. We see the servers back up and running on Port 5000 again. Now we come back over to the browser refresh, and now we get to see the original message that we had when we first started this project. So I just want to add this clip in Here is a bonus to show you that there are MPM packages out there that will abstract away and aggregate some of the tests that you might find yourself typically doing for the type of project you're working within into a s'more simple command that you can then plug into in N. P m script. So I hope you enjoyed it and maybe use this and find it helpful in your typescript projects. In the next clip, we're gonna take a look at what it's like actively developing in a project that's using CSS pre processors like sass, unless which we did in the building module, and we're gonna combine that with the bundling and modifying that we did as it builds Step using Web pack. So we're gonna find out what the tests are like when we're actively developing against a project like that and see how MPM can help us in automating those tasks.

Webpack Development Tasks
[Autogenerated] already. So let's take a look at the Web packed project that we left off from in the last module, where we're building out scripts for bundling and men. If eyeing our job script code as a build test. Now we're looking at it from the perspective of were actively developing against his project. Let's see what kind of test we're gonna need to do and ways that we can use MPM scripts to automate it. Now. The downside of where we left off of what we're having to do with the current scripts is if we run MPM start, it will only build using Web Pack, which will bundle identify our jobs from code at the beginning at start time. But if we make any changes after that, it's not going to actively update and reflect those changes in the result of the application when we're running it. So this creates a lot of repetitive tasks for us to do. Let's have wet pack watch for changes to rebuild, and we'll use Node Mon to restart our no Jess application when that file changes. So let's create another test called build watch, and the value of that is gonna be Web pack again using the ***, Eli Tool. And it has an option for watching as well. So we're going to use hyphen hyphen? Watch in this one. Okay, great. The one thing we're gonna do with note is we wantto have knowed mont available to us. So we need to install that as a developer. Dependency for this project. Well, come into our terminal run NPM install hyphen capital D so that it's a developer Dependency and note one. Okay, let's create a script that's gonna use node mon now and we'll call it Start, Dev, and we'll tell Node Mon to run the same note application in the dist. Folder under app dot Js file. Okay, So in order to run these in parallel, we learned about the n p m. A run all package that's available to us through MPM that will let us run things in parallel or in sequence. In this case, we want to run Web pack build first, and then in parallel. We're gonna run the node application using note mon and then the build watch script so that we can have it actively watch for changes as we're making updates to our source code, and that reflects in the output of the application in the browser. So it's installed the MPM run all package. And don't forget to make sure that you insult as a dead dependency. So now we're gonna change the start script a little bit in the value of that, were no longer any use note to call the app Jess directly and said, We're gonna trigger it with NPM. Run all, tell it to run the build script and then run the next scripts in parallel, using the hyphen, hyphen parallel option, and then give the name of the scripts that we want to run in parallel in this case is going to start Dev and that will start a note application. It's gonna host our website and then we want to run, build, watch. All right, let's save that. And what we can do is we can come into our terminal, clear the screen, and let's run and P m start. Okay, Excellent. Let's analyze a little bit. What? The output of our terminal shows. Let's grow up a little bit right here. Okay. So we could see it did the pre start script, which is running MPM room build. Oh, I forgot we had that. We can actually get rid of this. Look at that, folks. We learned on the fly here. Okay, So here's the deal with the pre start script. I can tell it to run the M p m run build first and then let MPM run All do that. Only the parallel tests for us. So we actually have a little bit of redundancy. Let's clean that up and get rid of the build task Here. Stop this from running clear a screen and run MPM start again. Okay, great. Let's take a look at the output again now. Okay, So we ran MPM start the pre start script Ran first, which runs MPM run build, which is just gonna run Web pack for us. And that ends up generating that dis folder here. Just great. And let's analyze what what pact did it bundled our job script code for both our source code and any vendor code and modified it. And then it copied over a lot of files for us too. Then the next script that ran was the's start script, right? And we're using MPM run all using parallel is gonna run, Start, Dev and then build watch. So Start Dev is using node mon dis tap, since that was copied over in the wet pack build process that's ready and available, starts up the note server and then we run Web pack again. But this time in the state of watching for changes to our source code and you could see its watching for extensions that our job script based. And then we could see the servers running on Port 4005 which then lets us know that why Pack is watching the files and some changes happen so that no woman would restart when we see the servers running on Port 4005. Let's open up our browser to that now and check everything out. Go to a local host 4005. Excellent. So it is running. But let's make some changes and see what happens. So I'm gonna move this window to one side and move visual studio code to the other side so we can see these both side by side. Now let's make a change in our client dot Js file. Let's have it say hello, plural site. Instead, I'll hit Save you see in the output that things changed and it restarted. Knowed what pack picked up the changes to the client side. JavaScript code and notary started as well. So now if I refresh here, we should see that this no longer says Hello. Clarky. Orbital. Say hello. Plural, say, and then plural site. Awesome. Now this is great, but I think we can take this a step even further. That would make this whole process even more efficient for us.

Automating Webpack Development Tasks
[Autogenerated] one thing that's not so fun about this current process, even though it is an improvement upon what we started out with is I have to refresh the browser in order to see the changes reflected in the output here, for instance, but changes back to say Clarky own said a plural site. Hello, Clark. Yo, I saved that. See the changes updated in the terminal, right? Everything that's watching those changes picking up on him. But we're not seeing the browser reflecting those changes just yet. If I refresh, there we go. We're back to saying Hello, Clark Plural site. Wouldn't it be nice to be able to have that automatically refreshed for us? Well, we can. There's a tool. Another MPM package called Browser Sink. Let's take a look at that now, So if you go to M. P m Js dot com and you search for browser hyphen sink, you'll find the package that we can use that will automatically notice the changes to our clients ID code and refresh. The browser essentially sinks our development environment and our browser with each other to reflect the changes automatically. So let's stop this from running. Let's make our editor full screen again. But I want to do now is installed browser sink as a dead dependency. So we're gonna run in P m I hyphen D capital D carouser hyphen sink. Excellent. So that's installed. Now we want to create a script to use browser sink. Now, I'm not gonna go into great detail into all the different options for the seal I tool that they provide through the package. But you can pretty much get away with using exactly what I'm using here just pertaining to your local environment. So let's open up our package chase on file and let's create a new script that's called Sink Watch. And in there, we're gonna use the browser sinks Eli, which is browser hyphen sink. We're gonna tell it to start. We're in. Indicate to it that we wanted to proxy our local hosts server that's running on Port 4005. Since that's what our note application's gonna be running on, then we're gonna indicate that we wanted to watch with the hyphen W option and then which files to watch for the dest holder hyphen f dot slash dist. Okay, And now all we have to do is add it to the start script as part of one of the parallel scripts that we want to run. So we'll edit after build, watch. Save that and then let's move this editor to be side by side with our browser again in the browser, we're closed the existing tabs and just keep an empty tab open. Let's hide the explorer of you in visual studio code so we get a little bit more real estate to see the command line. And now we can run NPM start. Make this a little bit bigger so we can analyze output and look at that. Did you notice how it opened up a new tab in my browser, although the port is different, but we'll explain that in just a moment and we could see it says hello, Clarky Oh, and plural site. So, looking at the output in the command line, we can see that browser sink is proxy ing our local host 4005 server and making it available on local host 3000 scrolling up. We could see the output of all the other test that we had set up prior to this that are showing us bundling and men if I ng with wet pack using node Montu starter Note application and look for changes to the files and so forth. So now let's actually go ahead and change some files and see what happens if we change the client. Jess File. Say hello World now and save that you notice in the output. All those changes were picked up, things were restarted and the browser reloaded for us automatically so we can see the outputting result of those changes. Excellent. If I make changes to the note application and how it's logging out this server message, let's see if that gets picked up a cz Well, we'll update the running message that gets council logged when the application starts. I saved that. It restarts, and we see the servers running on Port 4005 and then our extra message of hello from the server. The browser sink reloaded her application to just in case things needed to be updated for us. All right, so let's keep building off of this and incorporate some of the pre processing of our style sheets into the project here. In the next clip

Automating CSS Pre-processor Tasks
[Autogenerated] Okay, So let's take a look at adding SAS and the build process that we created in the previous module around building out our styles through cess or any other pre processor solution that's available for CSS. So first off, we're gonna want to replace the styles that CSS file in our source code with a stiles not sass file. So let's create a new file inside of the client. Here we called Styles that sass, and I'm gonna copy over the content that we did in the last module over into this file. Here, let's delete the style that CSS file and delete the dest holder. The next step is to create a script that will use ___ to process our styles, not sass file into a CSS file that we can use. So let's go over to package Jason and after sink watch list at our new script below. That will add a comma, and we'll call this one just sass. For now, we want sass to take in the styles that sass file from the client folder, so we'll say dot slash and we wanted to output in the same folder, but as styles ____ SS and we had that script, just in case. We want to run that manually as one direct script. Let's add another one that could be part of our process to start the application of for development purposes that will build and watch for style changes to that sass file. We'll add a new script below this called SAS Watch. We'll give it a value very similar to the SAS script, but we'll add the watch option to it. So I'm gonna copy this pasted in here and at the end, we'll add the watch option. It's hyphen, hyphen watch. Okay, great. Now what we need to do is add this new script into our start scripts of the N. P M. Run. All knows to kick off this script as well. So at a space and call SAS watch, kind of like Sasquatch. One last step we need to take into consideration here is that Web pack is copying. Overall, are static assets like a Stiles file or in next dot html over into our dissed folder, the Output folder for a project we need to tell it to ignore the SAS file and not include that in the DIS folder so its head overto what pac dot com fig And with the copy plug in, we're gonna tell it on this 1st 1 online 19 to ignore the any files with a sass extension. So it is part of this array in the ignore property. We saved that. Now we should be all good to go. Let's see what happens when we run. MPM start from the command line. Pre start script is running. What pack is building? We have a problem. Uh, can anyone guess what the problem is? So we need to install SAS before we start using. So let's install it as a developer. Dependency cable. Clear a terminal and run and P M start again. All right, so everything else is running as expected. We see the style is working. It did get out. Put it to the DIS folder. Let's double check on that. Yes, we see styles that CSS and the mat folder. Since we're in development, that's okay. Now, if we change something to our styles in the SAS folder, let's change the background of the page. I'm gonna move this over so we can see the browser and the code side by side right here. We have this base color variable which is responsible for the background color in our Web page. Me change to just be read. It will say F f 0000 Save that. And there we have it. Our CSS and styling is included as part of our build and development process so that we can quickly and efficiently work on this project, make changes and see the output results.

Automating Frontend Development Tasks
[Autogenerated] Okay, let's take our angular project that we used in the building module and see how we can start using and PM to automate our development work flow a little bit better for when we're actively making changes to and we want to see the output of our changes. So first thing we want to do is we want the build to watch for changes with the angular see Ally. So instead of running just energy build, it comes with a watch option. Now you might be seeing a trend here, folks. Most of these Seelye tools that are building our projects have a watch argument that's available on them to detect changes in our files. So let's create a new build script. It's called Build watch and let's give it a value of N g build hyphen, hyphen Watch. That way we're still using the angular steal lie to build our angular application, but we're just telling tow watch for changes so that it can rebuild when it detects those changes. All right, so now we have that we also need our note application that's gonna be hosting this to restart when we potentially make changes to our server side application as well. So let's create a start Dev script that's using node mon now until it to start the same file that we're using in there. Start script. And don't forget your comments. All right, so we're gonna need to install Node. Mona's a deaf dependency, so let's do that first. Okay, great. So that's installed. Now we need to update the start script so that it'll leverage these two new other scripts that we're gonna be using to watch for changes and restore her application when they do watch. So for that, we're gonna need mpm run. Also, let's make sure we have that installed as well. Okay, great. That's insult now. So now we can change the value here. Let's get rid of what we had existing in our start script. We're gonna change it to use mpm run all you tell it to run these in parallel, and we're going to start off by running, start death and then run the build watch script. Now, one thing to note is, we already have the pre start script that will start before we actually run the start script that's gonna run the angular build script for us, so that'll prep everything. Then MPM run. All will take over and it's going to start up. The Dev Server are a node application that's gonna host our angular application in the dist folder. And then we'll have build watch to detect changes and make those updates so that we can see them as a result. So that all done, we should be able to test this out by running. NPM start Angular is being built is an energy build seal I command. And then we see the servers running on port for thousands, detecting some more changes, so it'll do its thing. But while that's happening, we'll open up the browser to local host 4000. And there we go. We have our angular application with the default view that comes with generating a project from the angular Seelye. Let's make changes to update this welcome message to say hello plural site and let's see what happens. We're going to the source folder at component dot html. Okay, right here is where the welcome text is. So we're gonna change that on line 305. And when I say this, you can see that in the output on the terminal. The angular build script has detected those changes and is re compiling. If you come over to our browser, refresh the page we could see. Hello. Plural site is now showing up in the top banner. So there you have it. Now, if we wanted to, we could take this a step further. And maybe this is ah, little homework for you as the viewer of this course to try out incorporating browser sink in here in this project so that it will automatically refresh the browser for you when changes are detected. So there you have it, folks. That is automating developing an angular application with a node server using N. P M scripts.

Docker Development Tasks
[Autogenerated] all right. Now we'll move over into a docker based project, and in this case, we want to build off of what we did in the building module for Docker and begin to actively develop against our project while using Docker and containers here. So, as we saw before, we had these two scripts. Doctor building Doctor, run. Let's run those really quick and then we open up our browser and make sure everything's running as expected, will go to local host 4005. Okay, great. So that's working as we would expect from before. So now the problem with this, though, is we can't just rebuild the Docker image and then rerun it because the containers already running with Doctor, we have to stop the container from running and then remove it and then rebuild and rerun a new container using the new image whenever we make source code changes to our application. So we need two more scripts. We're gonna need a doctor stop and a doctor. Remove the doctor. Stop! We're going to do something like this. Create a new script in our package. Jason called doctor stop. And the value for that is we're gonna say Docker container stop and the name of the container that we created which we gave a name in the doctor Run command as Web app as we see here. So we just put Web app in here but a comma and then we want a doctor removes script that uses the doctor container, remove command, are in the short for removed in the name of our container and save. So if you notice if we try to build again, let's say we make some changes to where the message is different. We'll get rid of the end in Dr Part, just leave it back to port. And then if we run MPM run doctor build, that builds a new image. But we can't run and I'm gonna show you right now. And PM Doctor run It errors out and it says every response from the Doctor Daimon there's a conflict. That container with the name web app is already in use. We could potentially create a new name if we wanted to, but we want to be able to re use that same one throughout her scripts here for development purposes. So we need to come in here. We need to now run our scripts that we created. So you say MPM run, doctor, stop that'll stop the container from running And then we're gonna run NPM Doctor Remove to delete that container. So now, since we already built it before successfully, let's just do a new run of using that latest image that we built in Dr Build Script. Okay, and now when we run it, if we go back to the browser, we refresh the page. We should see this text go away, and it did so that's good and all, but it's not really the most efficient workflow. Fortunately, since we're kind of at the limitations of what's available to us through doctor, and it's not really MPM scripts that's limiting us here, there is an argument that's available to us within Docker toe. Let us more actively listen for changes and mapped those into the container. So let's take a look at that next

Automating Docker Development Tasks
[Autogenerated] Okay, so we want to more efficiently be using Docker when we're actively developing our project. So let's take a look at how we conduce that. There's another argument that's available through the doctor cli tool. That's called volume mounting. Let me explain a little bit further, but first I'm gonna create a new script that's gonna be Doctor Run Dev. Now the value of the script is going to be very similar to the doctor run script online. 10 here with one extra argument the pace of that in and you'll notice The only difference in the script is this hyphen V argument. When that does is it tells Dr Hey, I want you to volume mount from my host machine into the container and the path on the left side of this colon. From here to the left is the path to the location of your source code that you want on your host machine that you're working off of. And on the right hand side is the path inside the container that you want to mount or map your source code and kind of overlay it into the container so that it can be actively changed whenever you make changes to your source code. So in this case, the inside the container the path is described based on what we set up in our doctor file. So just to clarify and bring that together, you look at the top of the doctor file here on line four, where we set the working directory to U S R S R c ap. So that's where that's coming from. So this could be anything. You might want to change That too. And then left hand side is the path to on your local machine your development machine, where you have your source code living. In this case, my server Js file is in this directory Note a doctor So great. Now what we need to do since we left off from the last clip where there was an active image already created and running in a container, we need to stop and remove those. So let's leverage. All scripts were created before we stopped the container. We removed the container. Okay, so now that we're working from a clean slate, we need to start incorporating node mon into this process so that it can pick up on those changes and restart the application within the container for us. So let's get that set up. We need to go over to our doctor file. We need to get this installed at a global level. So that's available within the container. Because in the past, the way we've been using node Montez installing as a deaf dependency but in this case, inside the production, so to speak system we need to be able to have access to use no amount to start our application and monitor for changes to our source code. So to do that well, just after line 11 where we run MPM install will run the install for no ____ on specifically in a separate commend Well, say run. And this is Dr Specific. Now we'll run an m. P. M. Specific command, which is mpm install will indicate that we wanted installed globally and tell the package that we want install in this case ____ bomb. Then we need to change our command to start the application from using node to start the server Js file and instead use note mon. In addition to that, there is an argument that we're gonna need to use. It's specific to node mon. That indicates that it should watch for changes using the legacy approach because we're working within a container. So we'll add another argument as another string is part of this array to run as a command. That argument is hyphen capital L, which stands for Legacy Watch and make sure the Atacama and now our doctor files good to go. So next step from here is to just build a new image based on the changes we made to this doctor file. So it's open up our terminal now we have a terminal open, will run MPM run doctor build. That builds a new image based on the changes that we made. And now we can run that new script that's gonna be actively mapping over our changes into the container. Let's double check that in the package. Jason file really quick. And that is called docker Colon. Run colon Deb. So we're gonna trigger that script and hopefully everything should go is expected, so I'll run MPM Run, Doctor, Run, Dev! Okay, great. So that completed successfully created container Using that new image and its mounting our source code changes over into the container itself. So First of all, let's double check that it's running in the browser. All right, here's our browser. If we go to a local host 4005 we should see it running. And there we go. It is. Is running servers running on Port 4005. So now here comes the true test. Folks. We get to see if we make changes to our source code in the server Js file. If that gets reflected when we refresh the browser here, So let's do a side by side view with our source code and our browser, we have our server jazz file open. Let's change the running message here on line four to indicate that we're running with changes in Dr Save that and now for you refresh the browser. We should see those changes reflected. And there you have it, folks. We are now getting to see how we can use NPM scripts to minimize the amount of typing we have to do for dr specific commands. And we have a nice work flow for when we're actively developing a note application using Dr

Automating Node.js Debugging
[Autogenerated] debugging is simply something that comes with the territory when we're actively developing any kind of project, whether it's no Js or any other language or technologies you might be using, we're gonna run into problems and we're gonna have to figure out how to solve those problems. What are the issues where the bugs in our code. So let's take a look at what we can do with our M P M scripts to include being able to actively debug a note application in this case. So right now we have the ability, through the start Deb script to use Node Mon to run our note application, and it will watch for changes to the index dot Js file. Well, fortunately for us, what we can do is we can have knowed mon run the d ______ and inspect emote. Now I'm using visual studio code is my tool to actively running debug my applications. But I can use MPM scripts and tie that into my tool of choice to attach the d ______ with no jazz. So the first thing we're gonna do is let's create a new script that will indicate that we're gonna be starting debug we're gonna use node mon still because we want to be able to pick up on changes that we make. We also want to be able to step through our code and figure out what might be a problem within it. So let's start making a new script here. Let's call it start debug. And now and now really, the only thing we need Thio, this is specific to note. If you're no developer, you're already aware of this. But maybe you're not. There's a flag that we can add when we start our note application. That will indicate we want to start the d ______ process in addition to our node. And that is the inspect flag with node Mom, we can actually still use note mon and pass in that flag to it as well. So we're gonna say no daemon, hyphen, hyphen inspector and tell what filed to start with. Okay, great. So now if we run that script, let's see what happens. Open up the terminal and we run mpm Run, start debug. Okay, Great. So we see very similar messages in the output of our terminal here. But one little thing that's in addition to that is a D ______ is listening on this particular location here and now. What you can do is you can use whatever tool that you prefer. In this case, I'm gonna be using visual studio code because I'm working within the same context, and that's what I like to use. But you can use whatever you like, as long as you're able to attach to the D ______ process and you're aware of how to do that. So in this case, I'm gonna tell visual studio code to attach to the No d ______. We'll bring up the command palette with control shift, be its command shift to be on Mac. If you're on that platform and research for attach and we say debug attached to note process and then we can see visual studio code gives me some options off what's running currently in debug mode on my system right now and the one I want to run is this last one here that's in my simple note server folder. Enter and then we get the debug toolbar that shows up at the top of visual studio code, and you notice actually that once it was able to successfully attach that process Visual studio updated and is showing me all the debug view capabilities within it. We see the output of the application when it's running and prince things out to the terminal. In addition, we can go back to the terminal. We could see that the D ______ was attached. Excellent. So now if we open up the browser to our application, which is running on Port 4005 we could see the message that we have in our source code. Let's double check on that in the next hot jazz file servers. I've been running on port, and thanks for checking on me, right? And then we could see in the output here in the debug consul here in visual studio code that the message was written to the screen. A p I was successfully requested if we want to, we can place debug break points now in visual studio code by clicking this little red circle in the left hand side on my line seven. And now when I go back to my browser and I refresh the page in the browser, we can see visual studio code picked up on that break point being hit and I can start inspecting things further. And this helps me improve my development work flow when I'm actively working on my application and I need to inspect and look into things more deeply at a granular level like this. So there you have it. There's one way you could just update your M p M scripts to automate debugging a simple know Js application or even complex know Js applications. This is gonna come in really handy for when you need to narrow in on those issues and solve the problems that are coming up in your applications. So I've stopped my application here, but the point I want to get across to you all is that you can just add this inspect flag. You can also use inspect, break flag as part of your script if you like, and create a separate MPM script to take it even further. And what this one will do is it will allow you to break on lines of code that are set up lines of code. So if you're requiring certain third party modules, those kind of things, you can actually set breakpoints at that point in your application So I hope you enjoy this. And I want you to realize that you can use this in any of your M P M scripts that we've been talking about or the various scenarios and applications that you might be working on, whether it's in doctor or you're also having node with an angular application or some other front and Web application. If you need to start to actively debug and incorporate that in your scripts, this is a way that you can do that.

Summary
[Autogenerated] Okay, let's recap what we learned in this module. First of all, we took a look at what it's like developing and being ableto actively see the changes that we make to our source code as it's running and showing an output in our browser for a note application or in the command line, depending on how you might be using knowed. It was great to do that so that we can have a more efficient work flow when actively developing with note. We leveraged MPM scripts in conjunction with no daemon to accomplish that. Next we went and looked into how we can use scripts where we incorporated those previous course. We created that we're building our applications and doing a lot of the set up for applications and then added into it so that it would watch for changes and trigger rebuilds. And then we were to be able to see the actively running application when we have to make changes to it. Those get reflected in a CZ well, and we applied that to various different scenarios various different project types that you might be working with in conjunction with note. First of all, specifically, we looked at typescript and how we can use the typescript compiler and have it build and watch for changes. And then that way we can incorporate those changes in the running application. From there, we moved on to looking at wet Pack. How we can use that for bundling and men if I ng we tie that into CSS using SAS or any other CSS pre process that you like to use. We have both of those be building and watching for changes and then reflecting those changes in the output of our running application. After that, we took a look at angular, leveraging the angular Seelye tool, which is a different tool compared to Wet Pack or the CSS pre processors that you might be using that has a build command that's available within it. And from there, it can also watch for changes, rebuild our angular application and then have that out, put it into the results of aren't running application, too. Last but not least, we took a look at doctor and how we can improve upon leveraging the very verbose command options that are available within the talker, see Ally and that tool, and incorporate those into MPM scripts, in addition to have it watch for changes and mapped those changes into the container that's running our note application. And then we could see those results as well in the output of the note at running. Last but not least, we took a quick look at how we can incorporate being able to debug note applications using the hyphen, hyphen, inspect argument or hyphen hyphen inspector break and then looked into how we can use that in an M P M script and let it trigger and create a D ______ process that we can attach to with whatever tool we choose. In this case, we use visual studio code. So I hope you found this helpful. Enjoyed the module in the next module. We're going to take a look at testing our projects and how we can automate some of the tasks around that process with N. P M scripts.

Scripting for Testing
Introduction
[Autogenerated] Let's be honest. Testing is something that should be included in all of our applications, but we don't always incorporate it. Doing so can be cumbersome to set everything up and get started. But what if we could reduce the friction around that? The easier it is to get testing set up and in a repeatable manner, the more often will be able to follow this best practice. And P M scripts can aid us in reducing the friction around getting started with testing. It makes it possible to have easy access to running tools that run test once or continuously while monitoring for changes. As we write them out in this module, we will be using a test runner called Mocha and a test reporter called N Y C, formerly known as Istanbul. Thes two utility libraries are common among Know Js Projects is part of the testing life cycle. Let's take a look at how we set these tools up and leverage MPM scripts toe automate the process around them.

Running Tests
[Autogenerated] first, we're gonna take a look at the project that we're gonna be using to run our test in. It's essentially the same as the simple note server project that we've been using throughout the course for demonstrations in other modules here. But now it has tests involved with it. So we have our index dot Js file, and then we have a test folder on the right hand side here with an index dot spect that Js file. And in there we have a very simple yet contrived example to show a test running against that simple note server. So the tools that we're gonna be using to run our tests, the one in this case that is very common among note application is called mocha or mocha J s. Let me open up our package, Jason, file here to take a look at that. This is saved. Is our dead dependency here online 18 and then our assertion library to make sure that things are showing the results as we expect them were using Chai and Chai. Http, since we're dealing with a web application here, So in order to run our test, we're gonna use the test runner Mocha the way we do that from the Sea allies by running the Mocha command. But I don't have that installed globally. I want that to stay specific to my project. So let's create an M P M script that can execute the Mocha Command to run our tests. So we'll open up the package. Jason file. We could see from the initialization of her package Jason file that it created a test script and had the default value, their of echoing a message and exiting with one. So let's remove that and let's tell to run the Mocha script. Now all of this will be available to us already because I've done the installation. But if you haven't done the insulation, just make sure to do MPM install and then save as a deaf dependency the Mocha chai and Chai. Http packages. All right, So now that we have that test group set up to run Mocha as our test runner, let's try running in the terminal the way we can run this script from our terminals by running MPM run test. Or since this is a life cycle script, we can just enter NPM test when we run that, and we look at the output in the terminal here, we could see the test failed. And basically what happened is the expected response that we're supposed to see from the FBI servers running on Port 4005. It looks like I have a little bit of a typo there and I need to add a T. But before we go ahead and start fixing this, let's go into the next clip and see how we can create scripts that will actively watch for changes in our test files as we're updating them or the source code that they're testing.

Watching for Changes
[Autogenerated] all right, so we could just go to the source code, identify the problem that we're missing that tea. Is that typo there and fix it right away. But let's first go to our package. Jason file. Let's create a script that will actively watch for changes to our test files and our source code so that it can update and show us the new results and let us know whether the tests are passing or failing based on our changes. Now Mocha has an option for us that we can pass to it called Watch. So what we're gonna do is going to create a new script that's called test Watch. That leverage is that new option, and we'll say, mocha hyphen, hyphen watch. Let's clear a terminal. And now let's run that script instead of the test script. And being that it's a custom script, we need to include the run part of the command within NPM here. Enter. We could see it didn't exit out of running this in the terminal. It's still running, and if we go over to our index that Js file and we fix that typo and save it, it was very quick and probably flashed by on the screen for you all. But you'll notice that Mocha noticed the change to our index dot Js file and re ran the tests for us. And now the test is passing great. But I think we can take this a step further, too, because it's part of running our tests. We want to see how well we're covering our code. What lines of code are covered, which ones aren't how much of our statements and functions, how many branches there are covered. Those types of things are important to us to understand where we need to improve our testing approach within our projects. So let's start incorporating that into some future scripts as well in the next clip here.

Creating Coverage Reports
[Autogenerated] Okay, let's first stop the script that's currently running clear our terminal. And we want to incorporate a way that we can generate coverage reports based on the test results that mocha ran for us, and there's a tool out there that's called Istanbul, but it also is named N Y. C. So the way you would install this is at PM I hyphen D To indicates a deaf dependency and then NYC. But if you go to look it up and try to search for results and more information about it, it's Istanbul Js basically is what you want to look for. So I've already installed this and we'll take a look at the package Jason file so you can see what I'm talking about. There we go use inversion 14 that one. That one. And the way N. Y C works is that we should change up our process, such that we don't call Mocha directly, and instead we call N Y C, which will in turn call Mocha for us. So let's create a new script that's called test coverage, because the script is gonna be responsible for generating the coverage report for us. So it's a test colon coverage. And as for the value of the script, we're gonna say N y c and then we're gonna call Mocha. And that tells N Y. C to read the results from the Mocha Test runner and generate the test coverage for us. So now that we have that, let's run that script in the terminal. Let's clear that out with control. See what we currently have there and we'll run NPM run tests, colon coverage and there we have it. It ran the tests using mocha for us and generated a test coverage table here in the terminal to show us how much we're covering in terms of statements, branches, functions and lines of our source code. This is great and all, but it would be even better if we can generate some text files or an HTML covered report, which Istanbul slash N. Y. C is capable of doing for us. So let's see how we can tap into that and use that as an end result. So in order to have Istanbul or N. Y. C, generate an HTML based report for us, we just need a pass in an extra argument into the command within our script. So here will add hyphen, hyphen reporter and set that equal to HTML. Now, when we burn that script, we should see a new folder generated that includes the coverage report in HTML, CSS and JavaScript format that allows us to kind of click through our code and see things a little bit better that N. Y. C had analyzed for us on our tests. So I hit, enter and let that run. The test ran and we could see we're no longer seeing the tech space. See a live report in the terminal here from NYC. And instead, we now have this coverage folder here in our project workspace. So I'll expand that folder, and we want to open up the index dot html file in our browser. So let's go ahead and do that the way I'll do that, I'll copy the path to the file by right clicking on the file in visuals to do a code and choosing copy path and then open up my browser and paste the path into the browser. I'm gonna zoom in a little bit so we can see this a bit better, and now we have more of a graphical interface that we can interact with to see how well our tests are performing and how much of our code is covered based on the various factors that is being measured within. So if I click into index dot Js, zoom in here a little bit, too. It gives us a very detailed report within the context of our source code so we can understand what we need to improve upon in terms of our test coverage for this project. Now one thing is missing here. We had to manually do This would be great to automate the process of generating this report and then immediately opening it up so that we can analyze the coverage. Let's take a look at that next.

Opening Coverage Reports with a Post Script
[Autogenerated] Let's see how we can do that. Now let's switch back over to visual studio code. What we want to do here is have another script run at the successful conclusion of the test covered script. The way we can do that is by using a post hook. Previously, you've seen us use pre hooks when we want to run pre test or pre start. We just put the prefix PR e in front of the name of the script based on the main scripts name. In this case, we could do the same thing, but with post POS T. So we want to do is create a new script right after test coverage, recalled Post Test Colon coverage. As for the value of the script, we're gonna leverage a seal I tool called open cli What this does. It allows us to open up your l's or local file systems in a way that's cross platform compatible. So whether you're on Windows, Mac OS or linens, it will help in accomplishing that regardless of what platform you're on. So the way you can add that is by M. P. M. Installing it as a deaf dependency. I've already installed it for this project. But you would just hit, enter, let that install it. Make sure it gets saved in the dead dependencies key in your package Day, some file. Let's cancel out of that. It's all I need to do is call open Sea Ally in this script and then tell it the Ural or the file that I wanted to open up in my browser in this case is gonna be coverage folder index dot html. So we'll do dot slash coverage slash index dot html and we'll save that. Clear a terminal. And now let's run NPM tests coverage and see the post test coverage script run in action before I hit. Enter on this. Let's open up our browser and visual studio code side by side so we can see the result of this in a nice, clean view. Okay, so I'm gonna open up on new blank tam in the browser here and closed the old one. Then come back over into the terminal and visual studio code and hit Enter on this script. Okay. The test ran and you could see it opened up a new tab in the browser directly to the coverage So there you have it. We have a great example of using post hooks within NPM scripts with our test process than workflow that we're going through here to generate and view the coverage of our code based on the test that we ran using all these fun tools that are common among note application development.

Summary
[Autogenerated] Okay, let's do a quick recap of what we learned in this module. First of all, we learned about some of the common testing tools that are used for node applications like Mocha Chai, NYC or Istanbul. All have their purposes and needs within the whole workflow when it comes to testing our applications within node. From there we learned how we can automate testing those applications with those tools v. A M P M scripts. So he created a test script. We leverage watching for changes in our source code and our test code. So that would actively reflect the results of our tests running against those changes and that results in us being able to actively develop against our application, see what tests are passing, which ones are failing and adjust accordingly. After that, And last but not least, we learned about how we congenital rate test coverage reports with Istanbul or N Y C, and then see a post hook script that runs after that toe automatically open up that tests coverage report for us so we can start analyzing that and see where we need to improve things when it comes to our testing approach.

Scripting for Deploying
Introduction
[Autogenerated] At this point, we've set up our projects to automate task around building, developing and testing with N P M scripts. Now comes a point where we publish them. Tow a release environment release Environments are commonly broken up into production, staging and development categories, with each serving a specific purpose. But let's focus on production and get right into seeing how MPM scripts can help us with this step in our project life cycle.

NPM Scripts for Production
[Autogenerated] so the first thing we need to do to start preparing for production is to build off of our existing build scripts such that they're accomplishing the same tasks. But with production readiness in mind now, as you may have noticed throughout this course, there's a pattern we're following. We determine the manual tests were having to do for each project type, and then we move on to find ways to simplify and automate them with N. P M scripts. When it comes to deploying, this is no different. And rather than bore you with steps covering each project type for this topic, let's take a look at just one project. In this case, we're gonna look at the Web pack with sass Project, and here you can see the Package J some file that we have that we're using from previous module. One thing that has changed, though, with the package Jason and the scripts within it from the last time we looked at this project in the course is I added some tests to it in the test folder, and I added some tests, scripts. Let me show you really quick what they do. The pre test first runs the SAS script, which is Trans piling our cess to CSS. And then we run the build script, which is just using Web packed to bundle and modify any job script code that we have. And then it's gonna run mocha to run my tests. Then, after the tests are done, we run the post test script, which is using 1/3 party tool seal I tool called Rim Raph, which is going to remove and delete the DIS folder and the contents within it for me. And that's cross platform compatible. So that's why I'm using 1/3 party module for that. Okay, so let's test this out really quick and running it on your run NPM test. Okay, great. Everything's passing now. The idea with adding this is so that we can have a full blown process that would be kind of typical, or at least emulate a typical workflow that we would have to prepare for production for this project. You want to build your assets and then run tests to make sure everything is running up to par with your expectations before you go ahead and start deploying things. So from here, let's take that into consideration into our process. Currently, the way we have our scripts set up with Web Pack and with our SAS trans piling, it's a development type of mindset so that we can inspect the changes and inspect the mapping is between our SAS files to our CSS files and maybe not men if I our javascript code with Web pack. But we can still bundle him all the stuff. That's kind of helpful in the development phase, but we really need to minimize that and improve our projects such that it's ready for production like we mentioned earlier. So there's a couple ways that these tools allow us to do that in particular. Let's first look at cess. So when it comes to sass, we want to create a production script for it. So let's add a new one after the SAS watch script online. 14 here. I'm gonna close the terminal so we can see better read occult SAS prod short for production. So in the script, we're gonna use some arguments that are available to us to make it a little bit more streamlined for a production type of built. So first of all, we're gonna call sass like we typically would the cli tool that we're gonna pass an argument called hyphen Q. Which tells it to just be running a more silent mode so that there isn't as much being logged to the terminal. So I've been cute, and then we're gonna tell it that we don't want any source map because this is gonna be for production. So there's an argument that we can pass in. Here is an option called hyphen hyphen, no source map. And then we just used the typical What's the source file that we want to transpire? I'll and then once the output file that we want to have ___ produced for us. So we're gonna copy what we have from Line 14 and put that into the script here online. 15. And make sure it Atacama and there we go. So now we have a production ready script to translate our cess styles into regular CSS styles. Next up, we want to set up what pact to run in a production mode. The way we would do that is we need to set up a separate Web pack CONFIG file to indicate that it's gonna be using production and then we'll have a script that uses that specific Web config file. All right, so let's create a new Web pack configuration foul. We're gonna call it Web pack dot prod, not Js essentially is gonna be the same as our development configuration that we have. So let's go copy the contents over from that one and put it into this one. The main difference in this one, though, is we want to tell it which mode to be running in, and that is gonna be for production. We save that. And now we have a wet pack configuration that will be using for production builds. Let's go back over to package Jason to update our scripts to use this now. All right, so let's create a build prod script. Let's tell Webb Pack now to run in production mode and use the production configuration. Great. So now we have a foundation in place where we can bundle in men if I are JavaScript. Code trans pile are SAS styles file into a styles that CSS file and runner test so that we are preparing this project for production. The one thing I want you to note with this is that while we are focusing on just the Web pack and sass project here for this demonstration purposes, this can be applied to all your other project types. The only thing is, you just need to look at the tools that we're using for that project type tohave it build for production. All right, so now that we have that in place, let's go into the next clip here and see how we can use these for deploying this project to an environment.

Build and Release Process
[Autogenerated] before we get deep into leveraging those build scripts for production as part of a build process. When we're deploying, let's talk about some of the hosting options that are available to us or no Js applications. Now there are many hosting options available to us for no Jess applications, but here are some of the common ones that you see out there. We have azure by Microsoft, Harajuku AWS or Amazon Web service is and Google Cloud Platform. Now we're not gonna go into detail into each one of these, but I at least wanted to mention them so that you know that you have your options available to you and which ever one that you might be using for your project, your company, your team. You can leverage these same techniques and have your scripts work with whatever platform you might be hosting. Your know Js application on That said, regardless of whatever hosting provider you might be going with a lot of times, the documentation and tutorials around deploying a note application for those specific platforms go into detail on how to deploy directly from your local machine to their servers that will be hosting your note application, and this is not the best way to go about doing this is not a best practice in the industry, and the reason for that is that that's putting a lot of responsibility on you as a developer to make sure everything is going to run correctly in that remote environment. You really need tohave some checks and balances in place to ensure and improve your confidence that the code is going to run as expected in a live situation. The common way to do that nowadays is to leverage a build and release pipeline. Where that essentially means is your changes are picked up by that building release pipeline that we see here in the middle and your co changes go there. Essentially, it runs through the build process. It runs through running your tests and ensuring those all pass whenever other checks and balances. You may need to verify and validate your code before it's ready to go to production, and then, from there that build and released pipeline will handle releasing and publishing the output of that build on the server there to the remote server that is your production environment. So now that we have that out of the way. We're all on the same page with this that this is the common approach for deploying to remote environments, especially production. Let's take a look at an example pipeline that is leveraging those MPM build scripts that we created earlier, that air for production as tasks within it.

Using NPM Scripts in a Pipeline
[Autogenerated] just like with our hosting options for no Jess applications. There are a lot of build and release pipeline options that are available to us as well. In this case, for the purposes of our demonstration, I'm gonna be using Azure Dev ops. But there are plenty of other solutions that are out there and available to you that you can apply these techniques to as well, your Dev ops. I've already created a build and deployment pipeline, so I'm gonna switch over here to the next tab. I'm not gonna go into great detail on setting all of this up because you can watch them courses around, build and release pipelines for the various service providers that are out there. But specifically, I want to point out, at least that is part of the script. I'm using you. Hamel, which is a data serialization language which is common amongst build and released pipeline solutions to define what tasks are needed for the pipelines in particular, though, for my pipeline here I have a script section and then there you can see I'm doing an M. P m install. And that's where I'm starting to run and use my m p m scripts that I set up for this project. So first I'm running my tests that I'm going to run that that sass prod script and then I'm gonna run Build a Prod script. Now something that's common among pipelines as well is adding this additional argument hyphen, hyphen if hyphen present to signify that we don't want the build to completely fail if that script is not present and available to run, so that's what that is about. But you can see here I'm tying in. The M P M scripts were created in a previous clip of the course into this build pipeline, which will then help ensure that the level of quality and conference we have in our code is ready for production to show you that it ran and completed successfully. The way it's set up, at least in this pipeline, is that when I push changes or merged changes into a main branch in this case master, it will automatically trigger this build a pipeline to run. So in here we have a build stage in a deploy stage of the build stages for doing all that building like we've been talking about in leveraging those M P m scripts that we had. And then the Deploy will deploy to my host that I'm using here, in this case, azure app service. And let's first before we check it out, running in production, so to speak. Let's take a look at the specific task around NPM installed building test here. So here we could see the output of the scripts that were running is part of this build process, and we see very similar logs to what we were seeing when we were running these things locally. I run the tests. I make sure the test passed after everything was built and they do right here online, 62 to 65. And then I removed the DIS folder that was generated for the purposes of those tests. And then we run the production, build scripts. We got sass production. Then we got wet packed production and that generates what's called an artifact in this case, in this context, that will then be used to publish to my host provider, and my application will be up and running on my host, and in this case, we can see here I refresh the page. It is indeed running that note wet pack application that we built earlier in this course and just a reminder from what we mentioned earlier. This technique can be applied to any other solutions that you might be using for your team in your company when it comes to pipeline solutions. So you might be using Jenkins. Or maybe you're gonna use Travis, See I. Or there's also Circle C I and plenty of other C I. C D. Continuous integration continues deployment solutions that are out there. In any case, all of them have a means to integrating with and leveraging your NPM scripts that you created for the purposes of building to the environment you're deploying to. So just keep in mind while we used Azure Dev ops for this specific example, you can apply the same technique to leverage your NPM scripts as part of any other service that you might be using for your pipeline purposes.

Summary
[Autogenerated] All right, let's talk about what we learned in this module is mainly two things here. First off, we learned about how we can update and leverage our existing bill's scripts, but just alter them to make them more ready for production environments. From there, we took a look at how we can leverage those scripts and include them as tests or workloads within a build and release pipeline that could be implemented in a way so that we're extra careful and have checks and balances in place to ensure our code is ready to go to production. And that, ladies and gentlemen, wraps up all the different tests we might need to accomplish when it comes to building, developing, testing and deploying no Jess applications and how we can improve and automate those with N P M scripts in the next module, it's a bonus module for those of you that like to use visual studio code as your development tool, we're going to see how we can incorporate MPM scripts as part of tasks within visual studio code, so we don't necessarily have to use this Eli to execute the N P M scripts themselves. Let's go take a look at how we can accomplish that

VS Code
Introduction
[Autogenerated] throughout this course, we've been using visual studio code as our editor, and it's been helpful toe work within one tool to avoid contact switching. We can potentially take this a step further with N P M scripts by tying them into what are called tasks envious code. This could be beneficial by removing the need to open the integrated terminal command prompt within visual studio code to run our M P M scripts like we have been doing. Instead, we can run the task as a standalone execution and or include them in the application run functionality and debug functionality within visual studio coat. Let's go take a look at how we can get started doing this envious code now.

Getting Started
[Autogenerated] Okay. So for the purposes of demonstrating visual studio code, tests were going to use this typescript project that we've built throughout the course because we have some common tests that we need to execute with this build and transpire, I'll are types of code into job script for one. But first, what are tests in visual studio code? We'll just like anything we've been doing throughout this. We've been trying to automate some of the development task. The bill tests the tests, tests that were doing as part of our work flow with working on a project. And so that's essentially what visual studio code tests are there doing the same thing that we've been doing, but instead of in and P M scripts directly weaken. Do those in visual studio code and automate that process. I'm gonna bring up the command palette, which is control shift P on Windows and Linux or command shift P on Mac OS. And I'm gonna type in the keyword test. And what that does is it shows me all the commands that are available within visual studio code that have the key word task in it. And from here we can see that we can run a task, we can run a test test run, a build tests and many other options that are related to executing and setting up tests that we want to run is part of our projects. Now, with this particular project, we definitely want to run a build test. Our build process or build step for a typescript project is to transpire. Laura Typescript code into job scrip. What's great about this is we can tie some of these things to keyboard shortcuts to speed up our work flow even further we like. So if you notice on the right hand side, we can see there's a keyboard shortcut associated with this build test. That's control shift beat because I'm on Windows right now. It might be command shift be if you're on Mac. So I'm gonna choose to run that and you'll see visual studio code. Then promise me to figure out what is the bill test that I want to run because I haven't set up a default build test for this project, and it intelligently infers based on the project files and the extensions of those files. What type of tests are common for such a project. In this case, it notices that they typescript project. So it it offered a task of building based on our t s config dot Jason file. But one thing to know what that is, the expectation would be you have the typescript compiler installed globally. And if you recall from the previous modules, we only install that specifically to our projects so that we may not work as expected unless you installed typescript compiler globally. It's also picking up our scripts that we have in our package Jason file and in particular, the MPM build scrip. So I want to have it run that. So I'm gonna select that one, and then it's gonna prompt you to ask about how do you want to determine the kind of errors and warnings to scan from the output of this test running By convention, the typescript compiler will have a certain way of presenting the problems and warnings that come up when it's limiting our code or trying to transpire all our code. And so we can tell it that that's the type of tests that were executing here and use that as the problem match her so to speak for running this test. So right at the bottom second fromthe last year. We have typescript problems, so we're gonna select that one, and then it opens up the terminal to run that test. And we could see the output of that task running directly here and a couple other things changed that you might have noticed across the screen. Here, let's minimize this a little bit more. We could see it created a test. That Jason file that's visible right here in the editor and on the right hand side, looking at the File Explorer, we can see that that test that Jason files included within a folder the name of DOT V s code and what this does is creates the configuration for each test that you might have that's specific to your project and keeps them in the source of your project in a folder. Obvious code. So what you could do is you can check that into your source control management system, and that way, any other developers that pull down this code will have these tests ready and available to them, and it's already been pre configured, so it should work out of the box. In this case, we're just gonna run the typescript build and that ran. We see the output in the terminal below. Here I scroll back up. Once this isn't focused. We can press any key to close it as you see the message here. So I do that and I'm back to my usual terminal and we can see the output It created an index dot Js file in the final Explorer. So great. Now, if we try to run that again, let's say we make some changes. Assume we made some changes to our index dot t s file and we want to run that command again. Let's close the terminal quick. Bring him to command palate, Run the build task and you could see it remembered the problem naturally. Chose before and so forth and reruns The build for us. One of the way we can approach doing this as well is by configuring the default build test for this project. So we do control shift P. So we bring up the command palate type and tests, and then there's an option test configure default bill tests. In this case, we're gonna say we wanted to run NPM build, and now it knows that that is the default. You see that this configuration got updated, it says, is default true? So you can go through an update your configuration of your task of you, the prompts that air there. Or you can come in here and manually update the Jason configuration yourself if you like. So now that we set that as our default build script, we can actually just use the keyboard shortcut control shift. Be to run the build test. You see, as soon as I press that keyboard shortcut, it brings up the output terminal again of that test running. And just to show it's really working, let's delete the index of Js file. Close this press control shift, be again or command ship be if you're on a Mac and there you go, what's running in doing its job, and we should see in just a moment. Index dot Js show up and there we go. We do have so great. What if we want, though another test that can build and watch right? We have an M P M script that does that build watch and PM run TSC with the watch flag, So let's see how we can incorporate that in a test. We can add a new test by bringing up the command palate, typing and tasks and choosing the option to configure test. We're gonna choose MPM build watch, and there we go. It created this new script in the Jayson Force in the tasks that Jason Forest called MPM build watch. So the idea with all of this is to just show you how you can take your M P M scripts that you created and start running in executing them using visual studio code tests. And that way, you don't have to manually type out the execution of your scripts in a terminal, whether it's the built in one in visual studio code or an external application that we're using for your terminal or command line prompt. Now that said, let's take a look at how we can start creating more ad hoc type tests or do one off jobs that we need to do that are related to our projects. In particular, this typescript project

Adhoc Tasks
[Autogenerated] Okay, so that was pretty cool. Maybe you just want to run any tasks in the moment, right? You just want to run a specific task directly through the visual studio code. Well, the way you can do that by bringing up the command palette as you might be seeing, there's a theme here. There's a common pattern. The command palate is your friend control shift P type and tests and choose run tests. And then this is again visual studio code, inferring all the possible things that you might want to do based on your package Jason or project type that you have open in it so I could run any tests I want right now. Just ad hoc. So let's try running MPM test, for instance, and then the output of that gets shown to the screen first. And, of course, we're going to see an error as we expect, because all that script is set up to do is echo out a message and exit with the error status of one. So that's why we're seeing those error. Their air is there, but I just wanted to show you a demonstration that you don't necessarily have to create a task and configure it in order to get everything running. You could run them in an ad hoc manner so that you can accomplish test very quickly and easily on the fly if you so choose to go about that. But in the next clip, let's take a look at how we can start incorporating the build task with running and debugging our typescript project here.

Build and Run as Manual Tasks
[Autogenerated] all right. So earlier in this course we talked about the process that's involved with building watching for changes, as were actively developing a typescript project. Right? So let's see if we can accomplish that. Same result with V is code tasks here, and we're gonna be leveraging our NPM scripts that we've already created to do so. What we want to do is have a test that's going to run, build, watch for us and run the note application and update it restarted anytime there are changes happening in our source code. So let's see how we can do that. First of all, let's start from a clean slate and delete the index of jazz file here. All right, so with a typescript project, we know we need to transfer all our code, and then we can use no to run the main entry file in this case index dot Js. So if we wanted to accomplish the same workflow with V s code tests, we can do so by running tests manually ourselves. So first we can say, Hey, let's run the bill test by using the control shift v Command control should be keyboard shortcut, which will build our and trance pilo our typescript code into a job script file. So we have index, that jazz. And now we want to run our start script. Basically, we want to start the node server so I can bring up the command palate control shift P. And I could say, Hey, I want to run a test, so I'll type and tests and choose the run task option. And then I'm gonna tell it that I wanted to run and P. M start so envious code prompts us to ask about how we should handle any errors or warnings that are presented in the output with running this script. But in this case, since we're running no directly, we're just gonna say continue without scanning the task output. So in that case, you might have noticed in the output of the script, running is N. P. M. Still ran that pre start script for us which in turn, ren npm run TSC script to transpire our code. So it kind of re ran. You don't have to actually, based on the way we set up our M P M scripts. We didn't really need to run and execute that build task that rend the N P M build script for us. We could just run and P m start script as a task envious code. So just want to call that out really quick. But we can see as a result of running that test, we still have the server running, and it's on Port 4005. So let's double check in the browser to make sure that it is running. So now that I have the browser open, I'll go to a local host 5000. And there we go. We are seeing the server is up and running on Port 5000. So great, but you might be imagining. I don't really want to have to open up the command power with the keyboard shortcut type out, running that test manually and so forth. It be great to have some type of a button I can click that would just automatically do that for me or have a keyboard shortcut associated with doing that. And that way I can speed up my development workflow even more. Let's take a look at how we can do that in the next clip

Automate Build and Run Tasks
[Autogenerated] Okay, so we want to get to a point where we can just kind of click a button and go on, get developing and running our application. So let's stop this from running. I'm pressing Control C and then that stops the note application from running. And then we press any key again to stop the test and indicate that it completed and will close out the terminal. They're so with visual studio code the way you can start running your applications, your note applications is through the debug view. So there's a debug option icon here that's currently a bug icon, or you compress control shifty on Windows Lennox or commend shifty on Mac OS. And that brings up this view and from here, really, what, you conduce you to start running your application, being that we have an index that Js file already generated for us. Go back and make sure we have that there. I can click play and Visual Studio will analyze my project based on the files that are in my folder and asked me a little bit more about it so that it can understand the best way to approach running it. So I'm gonna choose that it's a no Js environment and there you go. It immediately picked up on the fact that I have an index dot Js file and using no to run the server in this case is running on Port 4005. Let's double check that that is indeed working. I enter in the Ural Local Host 4005 and hit Enter and there we go. We can see the server is running on Port 4005. Excellent. So there, with just a click of a button without setting up any configuration, were able to use visual studio code to run and launch our application. But we've already built out and Trans piled our typescript code into JavaScript code. So how can we tie that into running our application here with visual studio code and tasks? Let's see that now I'm going to stop this d ______ to sew in the debug toolbar. I'm gonna tell it to stop running and debugging my note application by clicking the stop button. Clear out the debug consul and close that. And so, as you can see here, it's saying that there are no configuration set up for my project. So we're gonna hit this little gear icon, which allows us to configure or fix a launch configuration, which is in turn, creating a launch dot jace on file. I'll tell that is a note application again. And now we can see we have this launched out Jason file that generated with some of the default values for launching a new application. It knows that the program is an index dot Js file found in the workspace folder of this application of this project. So open up the explorer of you here and we could see Now there's another file the launch dot Jason Val, That was he presented here in the editor within the dot V s code folder. Now, So again, this is something that you can check in with your source code and make it available to other developers that pull down the project from here. What we can do is we can actually tell it to include before launching the program, we can tell it to include one of the test that we can figure in this case. We want to include this build task in a way we can do that is by using what's called a pre launch test, and this is a key that's available within the configuration here. This is all Jason, by the way. So I'm gonna add a comma. I'm gonna type in, start typing out pre launch. You can see the intel sense helps us out here, and I hit Enter. And as for the value of this, we're gonna tell it to use the default build test. So if we do control space and we could choose this option here called default build tests, we save that. And now, when we come back into the debug and run view and we choose this, we can now see that it no longer says no configurations available. And instead, it shows that there's a launch program configuration, which is the name that corresponds here in the Jason file. And so what? As long as we have that selected, we click the play button, we could see its executing task. MPM run, build. Let's make that a little bit bigger so people can see which ran the NPM run TSC script and that looked like that worked all well and good. And if we go to the debug console, you could see that it is running. Okay, let's change things up in our index. Dodge it. Let's stop this. Actually, let's change the Let's delete Index. Not Jess, just to show you that it is indeed running. Let's add a coal in here so that the message a little bit cleaner in terms of showing the port that we're running on. Clear all this back to terminal. Tell it to stop running that test or clear out running that test. And now let's try and launch again and PM Run builds. Task is running that has completed successfully, and the server is running again in Port 4005. So if we go back over to the browser, we should see the new message updated to include that colon character. I'll refresh the page and there we go. We do have it now coming back over to visual studio code. We can actually take this a step further to so that if we want to keep our hands on the keyboard and not have to move one hand to the mouse to click play and start running the application, we can use a keyboard shortcut that's bound to this particular command here. So let's stop this from running. Make sure the test stops as well. Okay? And we're gonna open up the keyboard shortcuts. I'm gonna bring up the command palate again, and I'm gonna choose preferences. Open keyboard shortcuts. If you have your mouse over this play button, it's called start debugging. So let's search for that command. You could see right now there's a key bind to it that is set for a five. You can actually update this by clicking the little pencil icon for this particular command on the left hand side, and that allows you to enter in a different keyboard shortcut. I'm gonna use control shift are and then a press enter to submit that as the key combination that I want and you can see that got updated as well. Now, press control shift are you could see that it started running that launch configuration using the bill tests to run prior to launching it. We go over to the debug console and there we go. Everything is running as we expected before. So this was just a little bit of a taste of what you can do by tying in your NPM scripts into visual studio code. If you're using that as your editor and tool of choice for development, if you want to learn more about visual studio code and the capabilities of it in regards to this, I highly recommend checking out their documentation. You can go to code that visual studio dot com click on the Docks icon in the left hand side here, expand the user guide in the navigation view on the left hand side and select tasks. The documentation here is excellent, and I will give you great detail on how you can set up your tests that are specific to all your different various project types that you might be working with around No Js. So one last thing I want to add here is that if you're not using visual studio code as your editor of choice for writing no Jess applications, maybe you're using something else, like Web Storm or Adam. That's excellent to all I want to show. Here, at least, is to inspire you to look into ways that you can tie in your editor your tool of choice into leveraging those M P M scripts in a more streamlined and seamless way for your workflow. So keep that in mind and go check out some of documentation for your specific editor of choice to see if you have some capability is very similar to this That can help improve your workflow too.

Course Summary
[Autogenerated] All right, folks, that about does it for this course. Thank you so much for watching it. Let's do a quick summary of what we learned throughout it. First of all, we took a gander into how we can get started with setting up our NPM scripts by initializing a package Jason file with some of the default values There. There we learned some little tips and tricks on how we can see what scripts might be available within a project by running in p m. Run without any option of what script we want to run and that list out the scripts that are available for that project. And so forth from there, we went on to looking into ways that we can automate tests for very scenarios that are part of our project workflow in life cycle. We started with tests around building our project. So if we're working with a typescript project, how weaken transpire from typescript code to job script code? Or if you're working with Web pack in node and you're hosting a static site that way or website through know that way, you need to do things like bundle and men. If I your job script code. We figured out and built out ways to automate those tests using NPM scripts. Then we're ready to go to the point where we started actively developing our projects. And what does some of the tests around doing that? We looked into how we can incorporate those build tests as pre scripts to run prior toe. Actually, executing of running and starting our application are known application. It was a great insight into how we can speed up that process without having to write these things out manually. And as always, we covered testing and some of the tests that are involved with getting that rolling in our projects because we need to include this. This is definitely crucial to the Project lifecycle to help us ensure that our application is running the way we expect it and build a level of confidence within ourselves and the development team as a whole that everything is going to run smoothly. So in that module and in that part of the course, we leverage MPM scripts to help us with easing the friction and initial hurdle in getting started with writing tests and running our tests for our project I took a look at how we can start updating some of our previous scripts involving building but getting them ready for production and then incorporating that in the typical approach when we want to publish something and that is by using build and release pipelines so we can incorporate those scripts. And we saw an example of doing so in Azure Dev ops. Last but not least, we took a look at how we can start leveraging these scripts that we created throughout the course in visual studio code to demonstrate that we can optimize our workflow even further by minimizing the amount of context switching we might be doing to run these MPM scripts. And instead, we can have them run using the editors that we're working within day in, day out. So in conclusion, I want to take a moment to thank you so much for watching this course, especially if you made it up into this point. It means a lot to me, and I greatly appreciate it. I hope you got some value out of the course and picked up some tips and tricks that you can use in your everyday work that you're doing as a developer, building out note applications thanks again and happy code in everyone
