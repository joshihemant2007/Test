Data is the lifeblood of your business. Protect it. In this course, Practical Cryptography in Node.js, you will gain the ability to protect user data within Node.js applications using the tools Node.js provides. First, you will learn how to protect passwords. Next, you will discover how to protect data at rest and in transit. Finally, you will explore how to beef up your authentication by adding two-factor authentication to a Node application. When you are finished with this course, you will have the skills and knowledge of cryptography needed to protect data in Node.js applications.

Course Overview
Course Overview
Hi everyone. My name is Justin Boyer, and welcome to my course, Practical Cryptography in Node.js. I'm the principal consultant at Green Machine Security. As development teams are expected more and more to understand how to write secure code and do it properly, Node developers need to understand how to keep their application's data safe. Data is the lifeblood of a business, so protecting if from malicious attackers is of paramount importance. In this course, we are going to learn what practical tools Node.js has to help developers properly secure their data. Some of the major topics that we will cover include how to protect passwords, how to protect the data in your database, or files in your servers, how to protect sensitive data while it's being transported between computers, and how to add two- factor authentication to your Node.js application. By the end of this course, you'll know how to keep your Node application's data safe from prying eyes. You'll also understand how to add extra authentication methods to keep your users safe. Before beginning the course, you should be familiar with building Node.js applications. I hope you'll join me on this journey to learn simple strategies to protect your data with the Practical Cryptography in Node.js course at Pluralsight.

Introduction to Cryptography in Node.js
Introduction
Hi. My name is Justin Boyer. I'm your guide through the world of cryptography in Node.js. We'll take a tour of the ways Node.js helps developers keep their data safe. Cryptography is tons of fun, and Node.js gives developers plenty of tools to help them design secure applications. Let's get started.

Mapping out the Course
I want this course to be very practical. I want you to be able to apply what you learn in real applications. So let's look at a typical application and consider what developers are up against. Most apps begin with a database. You can't have an application without data. The data is accessed via a web server. The web server can either host a web application or a web service through which users can retrieve the data. Finally, we have different devices that display the data in different ways. Users can access data via a mobile device, desktop computer, or a laptop. This course will help you answer three important questions in terms of a basic web application. Where in the application is cryptography needed? How do you encrypt data correctly? The types of cryptography you use will change based on where in the application you're encrypting the data. And how do you make it easier? What tools exist within Node.js to make cryptography simpler and easier to use? Looking at cryptography in context will help you to know where in your application cryptography is required and how to use it properly. In this course, we'll cover four ways to use cryptography in your application. The first is protecting passwords. There's no doubt that passwords play a key role in any application. We'll learn how to protect passwords so you're not the next big data breach headline. Next, we'll learn how to protect data at rest. As a first to the data held within your database, sensitive data must be kept secret, and encrypting your database is the best way to keep your secrets safe. Data is always moving throughout your application. When data is being transferred from one node to another, such as between a client device on the web server, it must be protected from prying eyes. Finally, we'll cover two-factor authentication. Sometimes just a password is not enough. Adding a second factor to your application can greatly increase the security. We will look at time-based one-time passwords and how to add them to a Node.js application using a library called Speakeasy. Now you're just brimming with excitement about what's to come. But before we get to the meat of the course, let's take a quick whirlwind tour of the crypto library in Node.js.

Taking a Tour of Node.js Crypto Library
We've seen applications of cryptography we'll cover in this course, but this is a Node.js course, so we need to figure out what specific tools Node gives us to perform cryptographic functions in our applications. We'll certainly dive into more details as we move along in the course, but we can start with a whirlwind tour of some of the classes and libraries provided by Node.js. Node has a built-in module called crypto. The crypto module gives Node developers the basic building blocks of a great crypto system. First, we have the cipher and decipher classes. These classes are used to do the dirty work of encrypting and decrypting your data. We'll see a lot more of these classes when we discuss how to protect data at rest. Next, we have the DiffieHellman and ECDH classes. DiffieHellman is a method of exchanging keys when using asymmetric cryptography. Asymmetric cryptography is what makes HTTPS possible. ECDH stands for Elliptic-curve Diffie- Hellman, which uses elliptic curves to create the keys. We'll discuss how all this works in much more detail when we discuss how to protect data in transit. The hash class, as the name implies, generates hash digestive data. Hashes transform plain text data into a fixed-length random output. What makes hashes great is that given the output, you cannot compute the input. This makes hashes great for storing passwords. We'll discuss the different methods of protecting passwords in the next module. The HMAC class is used to generate hash- based message authentication codes. These codes are sent along with a message to verify the identity of the sender and the integrity of the message. HMACs are very powerful when used to protect data in transit. So we'll dive into HMACs in that module. The sign and verify classes are used for cryptographic signing. Signing a document verifies the integrity of the document and the identity of the sender. This is another topic we'll discuss in the module on protecting data in transit. Finally, we'll look at the various methods in the crypto module that aren't tied to these specific classes. This includes generating random numbers, creating initialization vectors, and other utility functions. You'll also find that these crypto classes are not meant to be created directly using the new keyword. Rather, the crypto module has several constructor functions that are built to create these classes for you, so we'll be using crypto methods throughout the entire course. Now that we've had a taste of what the crypto library gives us, let's take a second to discuss our programming environment for this course.

Reviewing the Learning Environment
Let's talk about how we'll demonstrate the power of these crypto tools that Node provides. I've installed the latest version of Node.js onto my Windows 10 machine. I'm using PowerShell as a terminal to demonstrate the concepts using Node's built-in read-eval-print loop, or REPL. We can demonstrate that here by just typing node into the command prompt, and you can see that I can type in JavaScript code that Node will then execute. So I can save the string, string, into a variable called x, and when I type x, that string comes back out. I can also do console.log statements that do the same thing. The REPL will allow us to have simple, straightforward demonstrations of how we use cryptographic functions in Node.js. What do more complex examples require? I'll write up some code and create sample applications. If you need to see the code, I'll be using Visual Studio Code as my development environment. Let's take a look at that now. Here we have Visual Studio Code open showing the code from one of my open source projects. Visual Studio Code is an easy to use and powerful editor that's a joy to work with. It's available in Windows, Mac, and Linux operating systems. So no matter what you're using, you can use Visual Studio Code to follow along. Now since this is an intermediate level course, I won't be going into detail on how to install Node.js or set up your development environment. I expect you to know how to do that already, and if you don't, I have a step- by-step guide as part of the course downloads. Download the resources for this module, and you'll find a document there detailing how to install Node.js on Windows 10 as I have. You can find information on the Node.js website on how to install Node on Mac or Linux. So now that we've seen how the demos work, let's wrap up the module and begin our journey.

Summary
As software developers, we build complex applications. These applications have data moving all around and potentially sitting in places all over the internet. Thus, there are many places where data can be compromised, either stolen or perhaps manipulated in some way. Cryptography gives you the tools to protect data, whether it's in transit, at rest, whether it's a password or a Social Security number. For Node.js developers specifically, Node provides the crypto module for developers to use to protect their data. We looked at some of the classes provided by the crypto module such as cipher and decipher, hash, HMAC, and a few others. Get to know these classes well, and your next web application will be more secure. Now let's get started on our journey to encrypt data with Node.js. We'll now talk about protecting passwords.

Protecting Passwords
Introduction
Hi. I'm Justin Boyer. In this module, we'll begin the deep dive into using cryptography effectively in Node.js. Passwords are everywhere, and no matter what you may personally think about them, they aren't going away anytime soon. Let's look at why passwords need to be protected, how a naive implementation can put your users at risk, and how to properly secure passwords using Node.js.

The Problem with Passwords
Passwords are used all over the internet. They've been the de facto standard in authentication for many years. But passwords are not a great solution, and the industry is trying to find ways to reduce dependencies on passwords wherever possible. The first reason passwords cause trouble is because they are hard to remember. Since good passwords are hard to remember, users tend to pick easy to guess passwords. There's actually an attack called a dictionary attack. In a dictionary attack, an attacker has a dictionary full of words that they know people have used for passwords. If you use any of those words, your password will be cracked very easily. The second problem with passwords is the fact that many people use the same password on multiple websites. If an attacker gets your credentials for your bank account, they'll often try your email provider or social media account using the same credentials to see if you reuse them. This is called credential stuffing. Third, data breaches occur all the time. Large data breaches have leaked billions of accounts and passwords. These passwords are usually available for sale on the dark web. Now, someone can buy your credentials and try them on different websites. Let's take a look at a quick example. So let's prove the case that passwords are hard to protect. This site is Have I Been Pwned. It's a great site built by fellow Pluralsight author Troy Hunt. This site records and makes available the data released by major data breaches. The front page has a search bar that allows you to enter your email address to see if it appears in any of the compromised datasets. Notice the statistics shown below. Those are big numbers, and those numbers are only going to grow over time. There's also a password page. Here you can download passwords that have been compromised. When new users create an account on your site, you can use these passwords to check and see if they've used a password that's been compromised. As an example, I'm going to type password1 in here and click on this pwned button. And you see here this password has been seen over 2 million times, in fact, close to 2.4 million times that this password has been used. If your users enter this password, you should tell them that it's not safe. So all of this is just to illustrate why passwords are such a touchy subject. But if you can't get away from using them, you can at least protect them to the best of your ability. If your passwords are stored securely, even a data breach will not be enough to significantly hurt your users. Let's now look at the type of cryptographic technology used to protect passwords called hashing. Then we'll look at some examples.

What Is Hashing?
The best way to protect passwords is by using hashing algorithms. Hashes, or digests, are fixed-length outputs created by transforming an input of arbitrary length. Here we have a password. When the password is passed into the hashing algorithm, the output is randomized and gives no clues as to what the original password was. A good hash function makes it extremely difficult to figure out the input given the output. That's why they're sometimes called one- way functions. Someone could steal the output of the hash and have no better chance of knowing the actual password than just guessing random combinations of letters. To illustrate this idea, let's look at a math problem. So we have an algorithm here that simply multiplies a number by 250 to generate the output. Don't worry, real hash algorithms are much more complicated. This is just an example to illustrate the idea. If the input in this case is 10, 555, then the output, as you can see, is 2, 638, 750. But imagine that you are simply given that number, 2, 638, 750, and told guess which 2 numbers made that number. That would be very, very difficult. So hash algorithms work the same way, but on a larger scale. However, not all hash algorithms are created equal. There are some which have been proven to be insecure. Let's take a look at an example.

Protecting Passwords the Naive Way
So we're now going to demonstrate a simple hashing function within Node.js. We'll use MD5 as the hashing algorithm. I'm using MD5 on purpose because it shows how not all hash functions are created equal. MD5 stands for Message Digest 5 and was created to be a cryptographic hash function back in 1992. Since then, many weaknesses have been discovered in MD5 and no longer make it useful to protect passwords. Let's use MD5 to hash a simple password here in the REPL. First off, we type node to start up the REPL. First, we need to require, or import, the crypto module from Node. Now we can create the hash. Here's how we do that. So the crypto library has a function called createHash, and in it you pass the hash algorithm you want to use. So, in this example, we're going to pass in md5. The hash variable here now has an instance of the hash class within it. That class has a function called update. Now when you pass in update, you're passing in data that you want to be hashed. So in this case, we're passing in the password that our theoretical user would've entered. We're going to make it easy on purpose, password1. Finally, there is a method called digest that will actually do the hashing. We're going to call this within a console.log so we can see it in the REPL. So I'm going to come over here with this digest function. Once you call it, you cannot call it again. You also cannot call update on the same object; otherwise, an error will be thrown. Once we hit Enter, we now see the result. This is our hashed password, but it's not so safe. Just hashing is not enough, and MD5 itself is not enough either. We want to take this output, and we're going to switch to a website. So this website is called hashtoolkit.com. It allows people to come in and create or decrypt MD5 hashes and SHA-1 hashes. Let's put our hash in here and see if it knows what this means. And there it is, our hash and what it means, password1. So if somebody saw this hash in a database, they would easily be able to come here and know exactly what that user's password was and take over their account. Now just to be accurate, Hash Toolkit doesn't brute force to hash that quickly. It has a database full of known passwords and their hashes and simply looks up the value of the hash. This is an example of a rainbow table. A rainbow table is simply a table of all possible hash values for a given algorithm. Attackers can use this to break many hashes. We need another piece to protect our passwords called a salt, and we'll cover that shortly. MD5 is also weak because it doesn't produce a very large output, which reduces the number of possible outputs. It also has been shown that MD5 doesn't protect well against collisions. This is to say two different inputs could potentially produce the same output. That's a big no-no in cryptography land. Let's go back to our REPL, and this time we'll create a new variable and create a SHA-256 hash. So I created a hash object with sha256 as the algorithm this time, updated it. As you can see, there's a couple errors there because I accidentally updated the first object. But at the end here, you see the final hash output of a SHA-256. This is 256 bytes as opposed to 128 bytes of the MD5 hash. You can see how much bigger it is. So SHA-256 creates a much longer output, so brute force and reverse output is much more difficult than with an MD5 and has a low chance of collisions. However, the rainbow table problem still exists. When we come back here for password1, we see that it has a SHA-256 hash already for password1. So again, this is not enough. Just hashing with this algorithm is certainly not enough to protect passwords. And we'll solve this problem with the rainbow table in a little bit. But for now, let's look at some secure algorithms, and we'll demonstrate then how to protect passwords properly in your applications.

Comparing Password Protection Techniques
Let's talk about the good algorithms now. These can help protect your passwords and are considered the best to use in new applications. First up, we have Argon2. Argon2 won a password hashing competition in 2013 and is now the recommended algorithm for new applications. PBKDF2 stands for Password-Based Key Derivation Function 2. PBKDF2 works by applying a hash algorithm, specifically, a hash-based message authentication code, which we'll talk about more in a later module, repeatedly on a password and salt to generate the output. PBKDF2 can be tuned to increase the computation required to calculate the result. This feature makes it incredibly difficult to figure out the input using brute force tactics. An attacker must try each password one by one and wait for the long computation to finish. PBKDF2 is best for your application if you require wide enterprise support in compliance with federal standards such as the Federal Information Processing Standard. Next, we have scrypt. Scrypt is an algorithm like PBKDF2, but it's optimized to resist hardware-based attacks. It does this by greatly increasing the amount of memory required to generate the output, thus hurting the attacker's ability to brute force the input with its hardware- accelerated graphics cards or other sophisticated hardware. Finally, we have bcrypt. Bcrypt is a popular algorithm for hashing passwords based on the Blowfish algorithm. Bcrypt has grown in popularity due to its support across many languages. The OWASP password protection cheat sheet lists these algorithms in the order you see here from left to right as the preferred algorithms to choose when starting a new application. Argon2 is the best choice, followed by PBKDF2. We'll be using PBKDF2 in this course for two reasons. First, Argon2 is still new and isn't installed with Node.js, while PBKDF2 is. Second, PBKDF2 is a good choice for enterprises that require compliance in all their applications. While Argon2 is academically the best choice, for practical purposes, PBKDF2 is what developers will see most often in the corporate environment for now. If you're interested in how to install and use Argon2 within a Node application, I did write a blog post on the topic, which you can access with the link you see here. But hashing alone isn't enough. We need one more ingredient. To properly protect your passwords, you need to add a dash of salt. Let's discover how the salt fits into this picture.

How Does a Salt Work?
Let's look at how a salt works and why it's important. The salt is a random value added to the password entered. This value must be different for every login credential to be truly secure. This is an important distinction. It's possible for a person to have one account, but multiple logins, user different privileges within the system. Now even in this scenario, you must create a new salt with every login credential instead of using the same salt for the same user account. Earlier, we discussed rainbow tables and the ability for attackers to know ahead of time what certain passwords look like when they're hashed. Salts give randomness to every password, thus producing a different output no matter what the password is. For example, if two users choose the same password and use the same algorithm, the salt will make sure that a different output is given. Rainbow tables are no longer effective because an attacker would have to know the salt, and guessing the salt, if that salt is long enough, is not feasible. In today's world, a salt is a bare minimum requirement for secure storage of passwords. On this slide, we see what adding the salt may look like conceptually. The password, along with a randomly generated salt value, is put into the algorithm. Out comes a truly random output from which deriving a password is much more difficult. That's enough theory for now. Let's look at some code so you can practically use these tools in your Node application.

Protecting Passwords the Right Way
Okay, now it's time to put the processor to work and really write some code to protect your passwords. We'll work in the REPL to demonstrate how to save a password in a secure fashion. First up, we need to import our crypto module. Once we have our crypto module in place, we'll then need a password and a salt. Usually the user would give you the password. In this case though, we'll just define it ourselves. We're using a very descriptive variable name here of password. Now that we have the password, we need the salt. The crypto module has a function called randomBytes, and randomBytes function is what we'll use to create the salt. This is what that call looks like. The 256 passed into randomBytes is how many bytes we want, so our salt will be 256 bytes long. The toString call is required because the randomBytes function returns a buffer. If you want to see it in a more user- friendly way, we'll turn into a hex value for now. We now have a salt value. We can take a look at that salt value in the REPL. So there's our salt: nice, long, and random. So now we have a password, and we have a salt. Now it's time to actually create our hash that we'd store in the database. How do we do that? The crypto module has a PBKDF2 function. Let's see what that looks like. So there is a synchronous and an asynchronous version of the PBKDF2 function. We use the sync version here because we're in the REPL. In most applications, it's better to use the asynchronous version, in which you'll just pass in a callback function that will process the result. We're passing in here five different arguments. First is the password, second is the salt. Then there's a number here. This number is the number of iterations we want, so we have 100, 000 iterations. Now watch when I hit Enter, you'll notice that it takes a few seconds for the response to come back. That's because we're doing it synchronously, and we're doing 100, 000 iterations. And I want to do that to kind of show you why PBKDF2 is so strong. It's the fact that if you have 100, 000 or 150, 000, whatever you can tolerate in terms of usability, it will take longer and longer and longer for an attacker to brute force that password. The next number, 512, is how many bytes we want back from the function. Recall that the PBKDF2 stands for Key Derivation Function, so this actually can be used to create keys. So I'm essentially telling it that the derived key I want is going to be 512 bytes long. The next argument is the hash function that I want to use as the basis for this function. We've picked sha512. That'll return us our 512-byte hash. I'm going to hit Enter here, and you can see that it takes a few seconds to come back. There we go. Now we have our hash password. Let's take a look at what it looks like. This hash password is going to be a buffer, so we're going to call toString on it, pass in hex so it'll be a nice, readable, well, kind of readable, hex value. So this value you see in front of you is what will be stored in the database as the value of that user's password. Now you can see here, if you pull out a database full of passwords, and this is the data you see, it'll be incredibly difficult to figure out what that password was. In our example, we picked password1, which is not a good password to pick; however, if you pick a really good random password that's nice and long, it'll be pretty much impossible for anyone to figure out what that password was given this block of gibberish. And that's the true power of securing your passwords. Now let's take a look at how you might incorporate this into a real application. So here we are in an application that I created. It's up on GitHub. The link is here on the screen for you. And while the main purpose is not to necessarily talk about hashing, it does have hashing in it because you can create users. Here we have a signup function. The signup function is going to create the hash for us and create a new user object. We are using Mongoose along with MongoDB in this application. What you need to know is that Mongoose is an object-relational mapper for MongoDB. Mongoose allows us to build objects that can represent the different types of documents and tables that we might find in MongoDB. In our case, we have a user object, and we're creating a new user object with a username and a password. But did you notice here that the password of the new user is set to the response of the generateHash function? Now some may choose to have a separate cryptographic module that you then create and import into your application in order to generate hashes and do those types of utility functions. In this case, I actually added the function directly to the user object itself. In this particular example, if we look at the generateHash function itself, I'm actually using bcrypt here. I wrote this quite some time ago. I probably wouldn't use bcrypt this time, but it's still good enough, and it illustrates the point. Here we're using bcrypt to hash the password and also to generate a salt. This salt is actually too small. If you see the 8 there, it should at least be 16 bytes in order to be secure. Like I said, this is older code. But the idea is that you can seamlessly include hashing into your application. Be creative. Use that object-oriented programming experience and good coding skills that I know you have to place it where it makes sense. Here we're at the login function, and you see that I'm now checking to see if the password's valid. In order to check to see if the password is valid, you pass in the password provided by the user. The system will then hash that password, compare it to what's in the database, and if they match, you know you're good. So this is just a simple example of how you can incorporate hashing into your applications. Try to do it in a way that doesn't really get in the way of your development, but that is easy to remember to use. So we've now seen how to properly protect passwords. We know that you should use a strong hashing algorithm, preferably Argon2 or PBKDF2. You should always use a large random salt and store the hashes in your database, not the passwords themselves. Now let's wrap up the module.

Summary
You've taken a tour of the world of passwords. We know passwords are everywhere. They don't seem to be going anywhere anytime soon, so we must handle them properly. Hash algorithms are used to protect passwords. Never ever store your passwords in plain text. However, not all hashing algorithms are the same. We've looked at weak hashes that can be broken in no time. Remember the site we visited, hashtoolkit.com? We use that site to demonstrate the power of rainbow tables. You can defend against rainbow tables by adding random values called salts into your passwords. Remember to stick to the tried and true hashing algorithms. In order of effectiveness, we have Argon2, PBKDF2, scrypt, and bcrypt. These powerful algorithms use salts and several thousand iterations to make it nearly impossible to crack passwords. If the worst happens and your password database is stolen, you don't want your user's passwords out in the open. When you store them securely, attackers will get a database full of random noise that is worthless to them. You'll be able to handle the breach effectively, secure in the knowledge that your user's will have time to change their passwords before any of them are cracked. Thanks for watching this module. In the next module, we'll tackle how to protect data at rest in Node.js with encryption.

Protecting Data at Rest
Introduction
Hi. I'm Justin Boyer, and in this module, we'll discuss how to protect data at rest within a Node.js application. The way we'll protect this data is through symmetric encryption. We'll discuss what symmetric encryption is and how to do it in Node. We'll also discuss how to properly manage encryption keys. Let's get started.

Threats to Data at Rest
Let's start by discussing some of the threats to data at rest within your application. Data at rest refers to data stored on disk, so data held within databases and in files on a server both count as data at rest. Therefore, remember to protect files, as well as databases since attackers will try to get access to both. So what threats exist to data at rest? The first threat to data is loss of confidentiality. Confidentiality refers to showing the right data to the right people and no one else. Users and employees alike should only see the data they need to perform the task that they are completing. Loss of integrity is another challenge that may not get the attention it deserves. Maintaining integrity of data at rest means making sure that the data is not changed by an unauthorized party or without a record of the change. Every change to data must be made by an authorized party and a record made of the change. Finally, availability is another major threat to data at rest. Data must be available to the authorized users when they need it. A denial service attack is an attack against the availability of data. In this module, we'll focus on encryption to protect the confidentiality of data. If the database is compromised or a file is stolen, proper encryption will make sure that the data stays safe. Specifically, we'll use symmetric encryption to protect data at rest. So now let's define symmetric encryption and see how it works.

Using Symmetric Encryption to Protect Data
Symmetric encryption is the best way to protect data at rest. You encrypt the data and store it. When the data is required to be read again, it is decrypted and shown to an authorized user. The term symmetric refers to the fact that there's one key used to encrypt and to decrypt. A strong key is created and used to encrypt the data. Once you encrypt it, it's unreadable. And if you don't have the key, you can't read the data. It looks like random gibberish to anyone without the key. Of course, this means that the key itself has to be closely protected and managed, or the fact that you encrypted the data won't matter at all. We'll discuss later in this module how to protect your keys from attackers. Node.js features several tools for symmetric encryption within your application. For symmetric encryption, the cipher and decipher classes do the work of encrypting and decrypting data. The crypto module has a function called createCipheriv, and this function will create an instance of the cipher class using the algorithm you specify. The iv in the name refers to the initialization vector used to initialize the cipher when using Cipher Block Chaining mode. And we'll discuss that more when we demo the code used to encrypt. Once you have the cipher object created, use the update and final functions to encrypt your data. The update function is used to add data to the cipher to be encrypted. Once the data is added, the final function encrypts the data and returns the encrypted text. The use of the word final is deliberate. Once the final function is called, neither it nor the update function can be called again or an error is thrown. With this model, using the cipher class is like baking a cake. You mix all the ingredients, the algorithm, the initialization vector, the key, and the data to be encrypted. The final function bakes all the ingredients into the encrypted output and gives it to you. All this information is nice, but I know it doesn't stick until you do it, so let's write up the code that will encrypt our data at rest.

Encrypting Data with Node.js
Now it's time to whip out some code and start encrypting some data. So we're in the Node REPL now. I've imported the crypto module, so we're ready to go. Now it's time to gather those ingredients for our encryption cake and put it all together into the cipher. So here's what we need. I'm going to need to know what the algorithm is we want to use. We're going to need a key that we can use to encrypt the data, and then we're going to need an initialization vector. First up is the algorithm. For our purposes, let's use AES-256 with Cipher Block Chaining. I'm going to save that as a string because you pass that into the createCipheriv function as a string. So now we have that. So aes is the Advanced Encryption Standard. Two hundred and fifty-six refers to the output, so 256 bits. The cbc refers to Cipher Block Chaining. Cipher Block Chaining is when the data is chopped up into blocks and encrypted within each block. And then the output of one block is the input to the next block. Now the first block doesn't have an input, so that's what the initialization vector does. I wrote a blog post that explains this in detail, so if you want more information, check out the link that's on your screen right now, and you can learn more about Cipher Block Chaining and what it's all about. So we've chosen our algorithm, a good strong one. Now we need a key. So the PBKDF2 is a good way of hashing passwords; however, it's also a great way to generate a key. So you could have a password that is good, long, random, and that's used to then generate a key, and that key is then used to encrypt your data. So let's, for our purposes, create a string that's going to be our password. Once we have our password, we're ready to generate our key. We talked in our last module about doing a salt and using the crypto.randomBytes function to create a good salt, so let's do that now too. We're going to do a 32-byte salt. Now we can create the key. So the scrypt function, we're going to use scyptSync because we're in the REPL loop. So the password here is the first argument. The salt is the second one. The third one is how big you want your key to be. So in our case, 256 bits is equal to 32 bytes, so I'm going to put 32 in here so we know how big of a key we need. Next up is the initialization vector, and so we'll create an initialization vector of 16 bytes through the randomBytes function. Now it's time to create our cipher. We have all of our ingredients. We have a key, an iv, and algorithm. So you see that the first argument here is the algorithm, followed by the key, and followed by the iv. Now don't get tripped up here. For some reason, the iv here at the end of the function is not capitalized. So the first c is lowercase, the second C is uppercase, and the iv is lowercase. Now there is a createCipher function without the iv, but that has been deprecated, so do not use that function. Only use createCipheriv. So we have our cipher. We also need data. So let's just say that we have a Social Security number that we want to encrypt. So here's our fake Social Security number that we want to encrypt. In order to encrypt, we need to do the update function on the cipher object. So the cipher.update function takes the data that we want to encrypt, as well as the encoding. So we're telling it that it's UTF-8 encoding. We want the output to be hex. So we have this encrypted variable. The reason we have encrypted here is because when we encrypt the data, we're going to encrypt it and then store it in the same variable. So let's do that now. We're going to use the final function to encrypt the data. The cipher object already has all of the data it needs to encrypt, so the final function is only going to take what we want the output to be. We want the output to be a hex. And now we have encrypted = cipher.final, and now this encrypted variable will hold our encrypted data. There it is. So what you see here in this green is the encrypted data. That is the value of that encrypted value, which is the Social Security number encrypted using AES-256. And if we do console.log, you can see the same thing. Just having encrypted data in your database isn't very useful because you can't read it unless you decrypt it. So now let's walk through how to actually decrypt it, and it's actually pretty simple. We're going to use the same REPL loop so we have all the same variables. So we already have our key and our iv. So once we have those things, then we can decrypt pretty easily. First, we're going to need a decipher object. So decipher is the class used to decrypt data. So we already have our algorithm, our key, and our iv here, which makes this pretty simple. There's a createDecipheriv that we're going to use to create our decipher object. So the encrypted variable holds our encrypted data. This is actually what we pass into the decipher.update function. Decipher has an update and a final function just like cipher does. It's just kind of reversed. So decipher.update, you pass in the encrypted text that you will eventually want to decrypt. So now we see the update function we're passing it encrypted, hex, utf8. When we did the cipher.update, we passed in utf8 first and then hex. So this is telling the object what we want. In the cipher example, we're saying we're passing in utf8 and we want hex out. In the decipher.update, we're saying we're passing in hex, which is the encrypted data, and we're going to want the plain text utf8 back out. And now let's call decipher.final and get our data back. Even though I misspelled the variable here on decrypted, it should be decrypted, we can see here that the final worked. We now have our Social Security number back intact. So this is how you can use Node.js 's built- in systems to encrypt your data and then to later decrypt it. It follows a very similar pattern one to the other, which makes it a lot simpler to figure out how to do it. So now that we've seen how to encrypt data with Node.js, now is the time to take the next step. How do you protect the keys that are used to encrypt? Let's talk about that next.

Storing Keys Safely
So encrypting your data depends on the key for security. If you encrypt your data, but the attacker finds the key, then your encryption will be in vain. What you need is a robust key management system, sometimes referred to as a KMS, to manage your keys and protect them. So in order to help you identify a good robust key management system, here's some best practices. You should use a keystore to protect your keys. A keystore is a piece of software that securely stores your keys by encrypting them. The encryption key used to encrypt your data, which should be several different ones, not the same, they are encrypted by a master key. So it's like encryption inception. You encrypt data using a set of keys. Those keys are then encrypted by a master key and stored in the keystore. But it makes sense because keys are sensitive information, and any sensitive information, including your keys, need protection from attackers. When a client needs to read encrypted data, it first calls the keystore and asks for a key. Once the keystore authorizes the client and decrypts the key, it then passes the key back to the user and back to the client to decrypt the data that the client needs. And keys have lifecycles as well, so they should be created, but also retired, rotated for extra security. If the data is encrypted with different keys over time, it prevents a previous key from decrypting the data if for some reason it's discovered. So if an attacker finds a key that was used before, that key is no longer valid because you've been rotating your keys over time, and then that won't help them to decrypt your data. Some good examples of keystores for cloud applications that you may be familiar with are Amazon Web Services, Key Management Service, and Microsoft Azure's Key Vault. If you've used those in your applications, then you're using a keystore, and congratulations, you're using best practices. Let's look at another example of a keystore, which is an open-source system called Vault.

Using Vault to Store Keys and Encrypt
So Vault is an open source application created by HashiCorp. It's a keystore meant to keep your keys and other secrets safe. So to understand how it works, it's best to walk through the process of gaining access and retrieving a key using Vault. So Vault begins in an unsealed state. This means that the data is encrypted and cannot be read by Vault without the master key. And the master key is never stored anywhere. So if that's the case, then how do you decrypt the data in the first place? Well, Vault uses a technique called Shamir's Secret Sharing, and this breaks the master key up into multiple keys called shards, and then these shards are distributed to trusted administrators or computers. And a certain number of shards is required to create the master key. So for example, you could have five shards where three are required to unseal the vault. Here we have three keys, so maybe two are required to unseal the vault. So then Vault uses the keys to recreate the master key. And then once the master key is created, then that decrypts the database. And when this happens, Vault is said to be in an unsealed state, which means that applications can begin using it and asking for keys. So now an application requires access to encrypted data. How do you do this? Well, there's actually an API involved, and it allows developers to write code that accesses keys held within it. So here's how that works. So the application authenticates through the API with either username and password or preferably a certificate installed on the machine. Here I'm using a client as an example, but you could also have a server here, which would probably be pretty preferable. And on the server, you could have a certificate that's signed that tells Vault that this computer is allowed to talk to it and allowed to receive keys. Once it's authenticated, the application can then ask for a specific secret held within Vault. So let's say we have a key in there, and Vault uses what's called paths, which are similar looking to URLs to find values stored. So if this is an accounting application, the path may be accounting/data/key, as you can see here. The API returns this value to the application, and now the application can connect to the database and decrypt the data inside. So keystores like Vault are powerful tools and should be a part of every security architecture. So now that we've looked at how to encrypt and how to keep your keys safe, let's wrap up this module.

Summary
In this module, we discussed protecting data at rest. If you store sensitive data, you need to protect it from unauthorized access. Symmetric encryption is the mechanism used to protect data at rest. Node's crypto module has a function called createCipheriv, and this creates a cipher object for you with the algorithm you want to use. Another piece of sensitive data you may overlook is the key itself. We discussed the importance of keystores and to encrypt and protect your keys. If your keys are stored with the encrypted data, you might as well not even bother because once an attacker steals your data, they'll then have the means to decrypt it, so we need a keystore. We also looked at one example of a keystore called Vault, which encrypts keys with a master key, stores keys used for other applications, and features an API for easy integration with your application. Data at rest is a juicy target for attackers, so don't let them see any data they have no right to see. Symmetric encryption with the cipher and decipher classes in Node.js can keep your data safe. And for your reference, any of the URLs I've mentioned in this clip and in this module will be downloadable from the course downloads. In the next module, we'll tackle how to keep data in transit safe from attackers.

Protecting Data in Transit
Introduction
Hi. I'm Justin Boyer. We all need to send data somewhere from time to time. In fact, without the ability to send data to different places, the internet would not be nearly as useful as it is. Applications also need to send data within separate components. For example, your application could be made of small microservices that talk to each other to accomplish a task. If these communications contain sensitive information, how do you protect the data while it's traveling? Why do you need to protect data in transit in the first place? These are the questions we'll tackle in this module, so let's jump in.

Threats to Data in Transit
First, let's look at some threats to data in transit. The term, in transit, refers to data while it's on the wire traveling between two computers on a network. There are two main threats to data while it's traveling. First, you could lose confidentiality or integrity. An attacker is able to position himself between two computers, could read or even change the data before it reaches the computer on the other end. Sensitive information like passwords or credit card numbers could be stolen without either party's knowledge. Another threat, related to the first, is a threat of impersonation. When two computers are communicating with each other, how do you know the computer on the other end is the computer you think it is? How can you verify the identity of the machine or service on the other end? When an attacker can impersonate one of the parties, data could be stolen or changed. It might help to see an example of this type of attack. A common attack against data in transit is the man-in-the-middle attack. Let's say Bob wants to send information to Sally. Seems pretty straightforward. However, if Eve is able to position herself in the middle of the communication, she could steal data without either party knowing. Let's say Bob sends a sensitive document to Sally. The document will make a stop at Eve's computer first where she can steal it or change it before it gets to Sally. Then she sends the document to Sally. Bob thinks he's connecting directly to Sally. Sally thinks she's connecting directly to Bob. Neither is aware that an attacker is seeing all of their communications. Now this attack can be serious, but there are ways to protect data in transit, so we'll talk about that in the next video.

Combating Threats to Data in Transit
So how do we protect against attacks on data in transit? We need to be able to know that the data hasn't been changed or seen while traveling between computers. We also need to know who we're talking to on the other end. We can tackle confidentiality using encryption as we've seen before. Symmetric encryption is still very useful in this scenario to protect the data; however, remember that we need to protect the key in order to use it effectively. Enter asymmetric encryption. Asymmetric encryption uses two keys, one to encrypt a message and one to decrypt a message. These keys are referred to as public and private key pairs. The two parties at either end of the communication don't need to have the same key to read a message. We'll dive a little deeper on how that works in a second. We also need to know that data hasn't been changed while in transit. HMACs can help with this. HMAC stands for hash-based message authentication code. HMACs take the data in the message and create a keyed hash with the data. The hash is sent along with the data to the other party. When the computer on the other end receives the data, it hashes it on its own and checks if the two values match. If they do, then you have high confidence that the data hasn't been changed. Another means of protecting integrity while establishing identity is a digital signature. Digital signatures use asymmetric encryption and hashing in combination to ensure the identity of the person sending the document and to make sure it hasn't been changed. First, the document is hashed with a strong hashing algorithm. Next, the hash output is encrypted with one of the two keys. The party receiving the document has the other key. Upon receiving the document, the recipient would decrypt the hash using the second key and then recalculate the hash to make sure no changes have been made to the document. Signing is a major part of the public key infrastructure, or PKI, which is the backbone of the HTTPS protocol. So these three ways of protecting data are often used in conjunction within a strong cryptographic system designed to protect data from the moment it's created to when it's destroyed. Let's see these mechanisms in action with some Node.js code.

Asymmetric Encryption with Node.js
Okay, so let's take a look at how to actually write some code that uses asymmetric encryption. So first off is the Diffie-Hellman key exchange. This is a way for keys to be exchanged. If two parties need to share a private key between each other with somebody potentially listening, the key exchange is how you do it. So we have the REPL loop here going. We already have imported the crypto module. So now I want to create keys. So let's take our example from before. We have Bob, and we have Sally, and we don't Eve to know what we're doing. So let's create those objects. First we'll start with Sally. So there is a createDiffieHellman crypto function that gives us a Diffie-Hellman object. The 2048 that we see here is the number of bits of the key. What you'll find is with asymmetric encryption, the keys must be much larger in order to be properly encrypted as opposed to symmetric encryption. So symmetric encryption, we only needed 256 bits. With asymmetric, we see that's much higher. We need 2048 bits. And in fact, most asymmetric encryption algorithms you're going to see are even going to be higher than that. The bigger, the better usually with asymmetric encryption, but something you have to be careful of is it does slow down the algorithm. Even here, you can see that the REPL loop is clocking a little bit. The prompt hasn't come back. It takes a lot longer to generate these classes and these asymmetric keys than it does for the symmetric encryption. So now the object has been created. Now we're going to generate our keys. You see here a generateKeys function that will create our keys for Sally. Once those are created, we can now create our second Diffie-Hellman object, which is Bob. So we see this call is a little bit different. We're going to be actually calling Sally's object, getting the prime number used to generate the keys and the generator. This allows us to create that shared secret. Now we can generate Bob's keys. So now the next step is to create a shared secret. In this situation, we can exchange each other's keys. And the details are out of the scope of this course because there's a lot of complex mathematics going on. So we're going to call computeSecret on each of these objects, passing in the other party's keys. So now, by passing in Bob's keys to Sally's object and Sally's keys to Bob's object, we can now generate the shared secret. Let's take a look at what these secrets look like. We can see here that both secrets are exactly the same, so now we have a shared secret. Now somebody looking at this transaction over the wire will not get any useful information. What would naturally happen, which we'll discuss in more detail in the next clip, is that this shared secret will be encrypted using the asymmetric keys generated by the Diffie-Hellman protocol. So we have a public key and a private key one each side, and thus, the secret can remain secret as we're exchanging keys. Once each side has the key safely stored, then we can encrypt using symmetric encryption and have a protected secure connection. So before we move on, I did want to actually show one more way of generating key pairs in Node.js. We see here that there's a generateKeyPairSync and a generateKeyPair function that generate a public key and a private key for digital signatures, for example. The details of these arguments are not as important at this moment, but I just wanted you to be aware that there is an easy way to create these key pairs using whatever algorithm you wish. So now let's look at HMACs and how to do them. So back in our REPL loop, and we have our crypto module imported. Next, we can create a HMAC using the createHmac function in the crypto module. So the createHmac function returns an HMAC object, and we pass in two arguments. The first is the hash algorithm we want to use. In this case, it's sha256. The second argument is a secret, so it's the private key that you want to use in order to create the keyed hash. This is a secret that will be shared between two parties, so each side will need to have this secret. Once we have the HMAC object, it's trivial to use it. It has an update function where you can add data that needs to be hashed. For instance, if you have a file, you can read the file in. We're just going to add some data here as an example. So now we have the HMAC object coming back. And now it's time to use the digest function to create the signed hash. And there you have it. So the digest function simply takes in the outputting coding you need. So in our case, it's hex, and the output comes out as the hash using the key. So the way that you would use an HMAC is you would have a piece of data, for instance, maybe a document. You would send the document along. Along with the document, you would send this value here. This is the HMAC value. On the recipient's end, they have the same secret. They'd run through the same steps: creating the HMAC using the secret that's shared, adding the file to the update function, and then creating the digest. The two digests should match, and if they do, then the recipient knows that nothing's been changed while in transit. So we've seen key exchanges, we've seen some public keys and private keys, and we've now seen how to use a HMAC. The next question is how do all these things actually work? If you're looking for a good example of the application of these principles, look no further than Hypertext Transfer Protocol Secure, or HTTPS. Let's dive deep into the HTTPS handshake and see how these principles are used in our everyday life.

Exploring the HTTPS Handshake
While many web applications may not have direct uses of the mechanisms we've explored so far, they are necessary for a key part of web application security, HTTPS. HTTPS is the protocol used to securely connect computers with one another over the internet. So let's explore how HTTPS works with a diagram. Specifically, we'll discuss the handshake that establishes the secure connection between two computers. This will allow you to clearly grasp the concepts and see them applied in a real scenario. So let's say your computer wants to connect to a server owned by company. A connection is made. It's red here because it isn't secure yet. First, your computer will tell the server which ciphers or encryption algorithms it can use. It also communicates what version of HTTPS and TLS, or Transport Layer Security, it uses. Then the server sends back its public certificate. This certificate holds the public key of the server. Your computer will need to verify its digital signature before trusting it. Certificates have a standard format and are assigned by a third party that vouches for the company you're connecting to. These third parties are certificate authorities. And this is what you hear commonly referred to as the public key infrastructure. So once the certificate checks out, your computer then sends a pre-key that will be used to create a private key. This is the key exchange process you saw in our code demo. This private key will be used to encrypt all messages going forward using symmetric encryption. Asymmetric encryption is much slower than symmetric encryption. Therefore, asymmetric encryption is used to securely share the private key so no one can grab it in transit. All further messages are encrypted using symmetric encryption. The server will be able to then generate the same private key on their end and then will send another message back to your computer. This message will say here's the key I'm going to use. Let me know if you can read this. Your computer says yes, I can, and resends the key for confirmation. Now both parties have the private key and can communicate without the fear of eavesdropping. Now the connection is green, and this is when that little green padlock appears on your browser. HTTPS is quite complex, so much so that it has its own course. Take a look at the Web Application Security learning path at Pluralsight. Troy Hunt has a course entitled, What Every Developer Must Know About HTTPS. That course will dive much deeper into the inner workings of HTTPS if you're interested. So that's it for data in transit. Let's wrap up the module.

Summary
So in this module, we talked about how to protect data in transit, so let's review what we talked about. There are several different threats to data in transit. It can be stolen or changed by someone listening in on the conversation. Attackers may also try to impersonate someone. They're going to impersonate one of the two parties and thus trick them into revealing sensitive information. Some protections we have are asymmetric encryption, which is encryption using two separate keys, a public key and a private key. There's also HMACs, or hash-based message authentication codes, and HMACs can help us make sure that data hasn't been changed in transit. Finally, digital signatures allow you to validate the identity of the person who sent you a certain document, as well as making sure that the document hasn't been changed. An application of these technologies is HTTPS, which is the secure Hypertext Transfer Protocol. It's built on these technologies. It's used to make the web safer all over the place. More and more websites are using HTTPS as a default. We also saw how HTTPS works, how the handshake works using asymmetric encryption to create a key, share that key between two parties, and then use symmetric encryption to keep the messages safe. There's another interesting method of keeping your applications safe in Node.js using cryptography, and that is using two- factor authentication. But how does that work? Well, we'll talk about that in the next module. See you then.

Authenticating Using Two-factor Authentication
Introduction
Hi. I'm Justin Boyer. In this module, we'll discuss two-factor authentication and how to add it to a Node application. Unfortunately, nowadays, stealing a password is not very difficult. Data breaches have exposed literally billions of passwords over time. How can this risk be mitigated? How do you protect your users if their password is stolen? That's what we'll cover in this module. Two-factor authentication is growing in popularity, and developers should have a basic understanding of how it works so they can implement it in their applications. So let's dive in.

What Is a Factor?
To begin the journey into two factors, we need to understand what one factor is. In other words, what exactly is a factor? A factor, in authentication terms, is a method or mechanism used to identify someone. There are three main factors to choose from in an authentication scheme. First, we have something you know. This is a piece of information that the user knows, but no one else should. The password is the most common form of this factor. You should be the only one who knows your password. Therefore, if you type in the correct password, the system trusts that it knows who you are and allows you to access the system. The second factor is something you have. This factor requires the user to have a physical object in their possession to gain access to a system. A badge card, ID card, or token such as a YubiKey key are examples of this factor. You may be required to scan an employee badge to gain access to a building, for example. The third factor is something you are. This is commonly referred to as biometrics and uses the biological attributes of a person to uniquely identify them. A famous example of this is Apple's Touch ID. You use your fingerprint to uniquely identify you to your phone for easier use. Some advanced biometrics even watch how you walk or identify the unique features of your face in order to identify you. Biometrics have come a long way, but they aren't perfect and tend to have more false positives than other methods of identification and authentication. If you use biometrics, understand where they excel and where they might not be quite enough yet. We've seen three factors used to identify and authenticate a user, but why should you use two factors in your authentication for better security? Let's answer that question next.

Why a Second Factor Is Necessary
So let's demonstrate why using two factors is important. We have here a computer system that our friend Jim wants to log into. Unfortunately, a shady character is also on the loose. We'll call him Steve. His system only requires a password, one factor. So Jim logs in with his password, and all is good. He's let in. But what happens if Steve gets ahold of Jim's password somehow, perhaps through a data breach or a phishing attack? Well, that's bad news. Now Steve can log into the system because he knows Jim's password and impersonate Jim. So let's change things up. Now imagine that the computer system requires both a password and Jim's fingerprint. Now the attacker has no way to get in. He has the password, but he doesn't have Jim's finger, and I hope he never steals that. Without both factors being present and correct, the system will not allow the user access. So having two factors gives you defense in depth, which is a key security strategy. You hope no one steals Jim's password, but you'll still anticipate the possibility and counter that with a second factor, which is much harder to obtain than the first. So what factor will we demonstrate in this module? I've chosen to show you the time-based one- time password, or TOTP. This is a popular second factor to add to an application. It starts with a shared secret between the user and the server. The secret is stored on a physical device such as a hard token or a smart phone that the user holds and has in their possession. The shared secret is then used to generate a number based on the secret and the current time. This number will not repeat and changes rapidly, usually about every 30 seconds or so. When it's time to log into a site, the user types in the password and the current generated number into the login screen. So this proves that the user is in possession of the device which holds the secret generated just for him. The server uses the same secret on its side to generate what the current number should be. And if the numbers match, then the login is successful. If you've used Google Authenticator or Authy on your smart phone, then you've used a TOTP. So let's see how to add this functionality to a Node application.

Adding 2FA to a Node.js Application
So now let's take a look at how to add two- factor authentication to your Node application. We'll see how to add a time-based one-time token using the Speakeasy library. Before we look at the code though, I want to show you what the application looks like while it's actually running. You can see it in action, see it work, and then we'll talk about the code that makes it work. So I have the app running on port 3000 on my localhost. So I'll put in that address into the browser, and we'll see what pops up. So we see here a QR code. So this QR code is our secret. We've generated the secret, and now we need to scan that secret, so I'll be using Google Authenticator on my cell phone. You won't be able to see it. You'll just have to trust me on this one. I'm scanning it now, and then I'll put in the code that it gives me in order to verify. So the code that I'm seeing here now is 556023, but I'm going to wait because it's going to expire, and by the time I type it in, it's probably going to be too late. So we have a new one here, 627447. Let me submit that, and my token's been verified. What this means is the code running in the server has generated the token using the secret key that we shared, and they matched, so now I'm verified. So let's take a look at the code that made this app work. You can download this code as part of the course downloads. As we said before, we're using the Speakeasy library, but we're also using the QR code library to generate the QR code for us. We're using a user object, and this user object in a real application could be a user that's pulled from the database, for example. We're using an in-memory object here with three fields. One field is temporarily storing the secret until it's been verified. Then once the secret's been verified, it gets stored in a two_factor_secret property, that is the permanent secret, and then a two_factor_enabled will tell us whether or not this user has two-factor authentication enabled. To start the process, we have a 2fa path here. We generate a secret using Speakeasy. We save the Base32 encoding of that secret into the temporary secret property of the user. The next step is to generate that QR code that you saw on the screen. The QR code library has a toDataURL function, and we use that to create a URL. Once that URL is created, then we simply send it back to the user as an image. The user scans it, and after they scan it, they have to come back in and authenticate. So our authenticate path sends a form back to the user that allows them to enter the token and hit the submit button like you saw. The submit button then sends a POST request to the verify path, and you see that the code here simply takes the token that the user entered from the request body. We have the Base32 secret that was temporarily stored. We use all three of these things to verify using the Speakeasy's verify function. This takes the Base32 secret encoding that we're using and then the token that the user entered. This is the function that will generate the number for the server and make sure that the numbers match, that the user token matches the number that the server comes up with. Once it's been verified, we set two_factor_enabled to true, and we permanently set the secret in the user object. From now on, this user will have this secret stored in the database along with its record. And once the user logs in again, we'll just use this exact same process with the verify function to make sure that they are entering the correct token. So in just these few lines of code, you've now added two-factor authentication to your application and made it much more secure. I'm sure you can't wait to get your hands on this for yourself, but first, let's wrap up the module.

Summary
So in this module, we discussed how to add multiple factors to your application to make it harder for attackers to take over your user's accounts. We talked about three factors: what you know, what you have, and what you are. Using all three would make it very difficult for users to log in and get access to what they need and will probably frustrate them more than adding security, as opposed to two factors, which is a good balance between giving your users an extra step, but also greatly increasing the amount of security your application has available. We talked about, specifically, time-based one-time passwords in this module. It's a very popular form of two-factor authentication, and it was made popular by great tools like Google Authenticator that allows users to quickly scan a QR code and come up with their one-time password. The good news for Node developers is that you can add it to your own application, and we showed how to do that using the Speakeasy library. It's an open source third-party library that adds time-based one-time passwords to Node applications. With just a few lines of code, you have increased the security of your application by a good factor, and your users will thank you for that. So we've seen all these different types of encryption and security features in Node in isolation from each other, so in the next module, our final module, we'll take a look at what all these things look like, how all these pieces fit together in your application.

Implementing Cryptography
Introduction
Hi. I'm Justin Boyer. In this module, we're going to talk about implementing cryptography. So, so far, we've talked about protecting your passwords. We've talked about authentication schemes with two-factor authentication, and we've talked about symmetric and asymmetric cryptography to protect your data at rest and your data in transit. So now we're going to take a look at a sample application. It's going to be a simple diagram, but it's going to have all the different pieces that you need in order to actually apply what you've learned and kind of see where in your application all of these things fit. I did this to kind of give you a holistic view instead of looking at each individual thing in a very small scope. You can kind of expand that to see where it fits in the bigger picture of a large application that you may be building. So let's get started.

Implementing Cryptography in a Real Application
Let's now look at a sample application and see where encryption fits in. We have here an application that is simple, but holds many components you'll often find in business applications. First, we have an authentication server, then an application server with some code on it. This code reaches out to web services hosted in virtual machines on a cloud platform. Each of these web services has its own database. We also have a file server, which could hold sensitive information we need to protect. This type of hybrid application is what many enterprises will have as they transition to a cloud infrastructure, so I wanted to make sure I was realistic in my depiction of these systems. Many established companies won't be 100% on the cloud. As we walk through the application diagram, we begin with authentication. Our discussion on protecting passwords is definitely appropriate here, as passwords of your users will need to be protected. We also feature two-factor authentication in this application to demonstrate where that belongs. The user enters her credentials plus the one-time password on her device. Once her identity is confirmed, she receives a token, which is passed along with every request to the rest of the application. This token serves as the key to the rest of the application for the user. Next, we'll look at the application server. This server needs to connect to other services to perform its function. So how is that accomplished securely? With asymmetric encryption. Each server holds a certificate that is assigned by a third party called a certificate authority. This certificate holds the public key of the server, allowing for secure connections through the HTTPS protocol. Many cloud platforms default to HTTPS to keep their customers secure by default. Now our data in transit is safe. Finally, symmetric encryption comes into the picture when we need to secure our data at rest. The file server and the databases used by the web services each need to be encrypted to keep the data safe while it's stored. We can use a keystore to securely store our encryption keys and distribute them as needed to our applications. I hope now you can have a clearer picture at how these isolated encryption tools can work together within a larger ecosystem of a Node application. With this knowledge, you can know where to apply the different types of cryptography we've discussed throughout our course. Let's see this a little bit more concretely and see this in action. We're going to now take a look at a real Node.js application and fix some vulnerabilities in it dealing with encryption. We'll see how an existing application can be changed to make its data secure. Let's take a look.

Fixing Authentication in NodeGoat
Before we wrap things up, I wanted to show some examples of an actual application with some security vulnerabilities, and we'll be fixing those vulnerabilities here, live in front of you. That application we're using is called NodeGoat. And the purpose of this application is to highlight the OWASP top 10 vulnerabilities. And this application is great for Node developers to really learn security. There's major vulnerabilities in this application, and it gives a developer a chance to actually exploit those vulnerabilities and fix them. So we will be fixing the vulnerabilities in NodeGoat, and we're going to be fixing the ones that are related to encryption. First up, we're going to tackle the authentication pieces of the application. Right now, it's storing our passwords in clear text. So here we are in a tool called Robomongo. Robomongo allows us to view MongoDB data. We can see here in this record that the password field just shows the password in clear text, which means this application is not protecting its passwords in the way that it should. Let's now take a look at the offending code that's wrong and then how to fix it. We're now in Visual Studio Code, and we're looking at the UserDAO object. DAO stands for data access object. And this object is in charge of creating a user object that will then be saved to the database. Notice here that when we're creating the user object, we're simply grabbing the password from the request parameter and then adding it to the object. There's no hashing. We're storing passwords in plain text. So we saw in our previous module on protecting passwords the correct way to do this. So we're going to implement that now by creating a random salt value and then using PBKDF2 to create the hash. Let's see how that works. We imported the crypto module. We're using randomBytes to create a random salt. And notice that the salt is created every single time the addUser function is called. This is very important. We're not using the same salt for all of our users. We're using a different one for each user. So we're using the pbkdf2Sync function, 100000 iterations, and SHA-512 for the hashing algorithm used. So let's save this, run the application, and then check the database to see if the new user's password is hashed correctly. So we created a new user, and let's now check Robomongo and see what the password looks like. We see we have a new user named Justin Boyer, and look at the password field. Notice that the top password just has the plain text value. Now it says binary. If you want to see the actual value, you can right-click here and see View Document. And we see here there's the hash. So instead of storing the plain-text password, making it super easy for attackers to take over the account, you now have this password. And because of the PBKDF2 algorithm, an attacker would see this and never be able to figure out what the actual password was. So now we've fixed the passwords and the way that NodeGoat handles passwords, but how does it handle sensitive information? For example, if we wanted to store Social Security numbers, or dates of birth, or other personally identifiable information, how would we do that? We're going to take a look at that in our next clip.

Fixing Encryption in NodeGoat
So we discussed previously the importance of protecting data in two places, at rest and in transit. So for this application, we'll tackle data in transit. We see that this application is currently running over HTTP, and Chrome is nice enough to tell us that right here. This means an attacker could steal credentials and sensitive data while it's in transit. We won't walk through all of the steps required to set up HTTPS, such as creating keys or a signed certificate, but we can look at some sample code of how to use Node's HTTPS module to set up the site to accept HTTPS connections once you actually have these things, which are likely to be delivered to you by your security team. So in NodeGoat's server.js file, we see how to use HTTPS once we have a key and a certificate. These lines here, 22 through 28, will actually give us the code. If we uncomment these, it would actually try to use certificates and keys to set up HTTPS. So first up, you require the https module, and then we have to set up the httpsOptions object and give it a key and a certificate. Once we have everything set up, then we actually use the HTTPS module to accept connections. We do that here in this commented out code, https.createServer, and the createServer function will then create an HTTPS server that will be accepting connections over HTTPS. Another prudent step here would be to redirect HTTP requests to your HTTPS server. So once HTTPS is set up, you can send sensitive data between computers, but then comes the time to store it. And we hashed our passwords so far, and now it's time to use symmetric encryption to protect sensitive data while it rests within the database. Now back here in Robomongo, looking at our MongoDB database, I've updated one of the users to have a Social Security number and date of birth in their record. We can see here that the Social Security number and date of birth, as well as bank account information is all stored in plain text. This means if this database were ever compromised by an attacker, he would be able to steal this person's identity and do all sorts of bad stuff with his personally identifiable information. This is exactly the kind of sensitive information we have to protect. So let's now take a look at the code and see how to do that. We have a class here called ProfileDAO. This is the profile of the user. The user object is created here, and we see that the Social Security number and date of birth are simply stored without anything done to them. The request will pass in the sensitive information and simply store it in the database and the user object without any type of encryption. So how do we fix that? Well, we see here in commented code the fix. So what we're going to do here is we're going to delete this old code and we're going to uncomment this code. Now that it's uncommented, it's calling an encrypt function. Well, the encrypt function doesn't quite exist just yet. It's also commented out above. And let's take a look at what this encrypt function does. Here we are with the code we're going to use to protect this data. We've imported the crypto module and a configuration file. We have a createIV function here, and that's just using the randomBytes function to create an initialization vector for us. The encrypt function creates the IV and then creates an encryption key. And it's using crypto.randomBytes here for the encryption key, but in production you should get this from a keystore, such as Vault. Then you're creating a cipher, and we're using AES-256 for the algorithm, which is also held within our config object. Once we have the cipher, we're using the update and the final functions to encrypt the data and store it in the database. Our decrypt function does the opposite. It creates the decipher object so that we can decrypt the data when we need it later. Let's see this in action. We'll save this file, and then we will change a profile and see what the data looks like. We've now entered the system. We've logged in as a user, and now we're going to enter the Social Security number and the date of birth and see how the data is encrypted in the database when we're done. Okay, here we are in Robomongo, and you can see here that our user's data is now encrypted. This particular user had entered their Social Security number and their date of birth. Notice that it's not in clear text, but instead encrypted. So this is the encrypted value in the database. When it's time to show it to the UI, we'll pull this value out and decrypt it. Now that we have this encrypt function, we can actually use it for anything. So for example, if we wanted to encrypt the bank account information, we could do the same thing with that. So we've discussed where to put encryption in a real application, and we've seen how to implement these and fix these vulnerabilities in existing code. So now you're fully prepared. Whether it's a new application or an existing application, you're prepared to protect your data, so let's wrap up our final module.

Summary
In this module, we discussed where encryption fits into a web application when looked at holistically. We did this by studying an application diagram. We looked at individual components of the application and found where cryptography fits. Two-factor authentication was the first part of the application. This is the entry point where a user identifies themselves and gains access through a token provided by an authentication server. Once the user gains access, data must be transferred between computers in order for the application to do its job. So as we discussed, asymmetric encryption helps to keep data in transit safe. HTTPS is used to protect data transferred between web services, especially when traveling through the public internet to a cloud provider. Symmetric encryption came into play to keep data at rest safe in the databases and file servers used by the application, and the keystore keeps the encryption keys safe. In our NodeGoat demonstration, we saw all these pieces in action as we fixed insecure code to make sure our data isn't at risk. We fixed major flaws that left our passwords and sensitive data out in the open. Whether you're building something new or maintaining an existing application, look for ways to adopt these practices in your day-to-day development. Now we've seen each type of cryptography in Node.js in isolation, and now you've seen how each of these individual pieces fit together within a web application. Now you're ready. Go secure your app.
