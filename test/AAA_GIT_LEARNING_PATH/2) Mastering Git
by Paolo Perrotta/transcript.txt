Course Overview
Course Overview
Hi. I'm Paolo Perrotta. Welcome to my course, Mastering Git. If you have ever been impressed by someone using Git in a natural way, in a way that flows, working fluently with the index and the stash, changing a project's history, using sophisticated commands such as reset, for example, or reflog, well, if you were impressed by that, then prepare to be impressed by yourself soon. This short training contains all the information that you need to use Git fluently in your daily job, and also to move information around in Git like nobody's business, to investigate and change your history, to fix any mistakes that you make while working with Git, and even to organize a shared Git workflow for your team. This is the training you need to up your game and become a power user. It's also a follow up to a previous course, How Git Works, but you don't necessarily need to have followed How Git Works to enjoy this training. As long as you have some experience with Git, you can follow along. So if you've been looking for a course that tackles the more advanced Git topics, focuses on how to actually get stuff done with Git, and teaches you the Git way of thinking so that you can work comfortably with Git day in and day out, here is that course.

The Four Areas: Introduction
About This Training
Welcome to the first module of Mastering Git. The style of this training might surprise you a little maybe. This is an advanced training, so maybe you expect a lot of technical details like detailed descriptions of all those Git commands, including a few obscure ones, and of their many, many arguments. Well, actually, that's not going to happen. I think that there is no point in memorizing all those details up front. You can easily find that information when you need it, maybe by using Git's own help system. Instead, I want to focus on, if you wish, the way that Git sees the world, the way that Git thinks about your data and your workflow. What really happens when you do common operations, like checking out a commit or resetting a branch? So instead of looking at obscure features, we're going to look first and foremost at the model of Git. And then, once you understand the model, learning the technical features will feel much easier. This idea of focusing on the model, that's also what I did in my previous training, How Git Works. If you followed that training, you probably remember that it talks mostly about the model of the Git repository, how Git stores your information and the like. We used the onion metaphor to talk about that stuff. We said Git is an onion, and then we described its layers. Well, compared to the previous training, this training is about cooking the onion, if you're okay with stretching the metaphor a little. We don't talk just about how Git stores your data. We talk about how to move that data around and do interesting things with it. By the way, while I'm talking about the previous training, How Git Works, you don't need to have followed that training in order to watch this one. However, you do need to know some of the things that I talked about in How Git Works. In particular, you should have some working knowledge of the basics of Git, how commits and branches work, how the HEAD reference works, that kind of stuff. If you're not sure that you have that knowledge already, well, don't worry too much about it for now. Soon enough, I will recap the information that you need from How Git Works. And then, if you find that information confusing, you can go and watch that other training first. This training is ideally divided into three parts. The first part is all about one key concept. In a Git project, there are four storage areas, and you move data across those areas. That's the foundation of our model. This first module, the one you're watching right now, introduces this concept, and its recaps a few basic ideas from the previous training. Then, in the next module, we'll see how the basic Git operations move data across the four areas. This is going to be a somewhat different look at the operations you already know and hopefully love, adding files, committing files, moving them, that kind of basic stuff. The following module will be all about git reset, one of the most powerful and also one of the most confusing commands in Git. This is the stuff that sends people straight to Stack Overflow. We will see how reset is actually easier than it looks. And finally, we will close our discussion of the four areas with a few odds and ends, all useful additions to your toolset. Then we have a second part of the training, two modules that are all about the project's history. The first is about browsing history, exploring the past, if you wish. This course talks a lot about operations that change a history, but you need to understand history before you can change it, and these are the tools that allow you to do that. And indeed, the following module is all about changing history and, in particular, how to fix the mistakes that you make while working with Git, stuff that's really important, especially if you make as many mistakes as I do. Finally, the last module stands on its own, and it's less about technology and more about teamwork. It's a little bit fluffier in a way than the rest of the training. Git gives you a lot of tools. This module is about using those tools to work together with other people on a project. It describes a few useful patterns and concrete suggestions to build a Git team workflow. That's a lot of material, but I will try to make it easy and digestible, and even fun, when I can.

A Note About the Command Line
One public service announcement before we begin. In this training, I will be using the command line a lot. And if you're following along, so should you. I'm recording on a Mac, so you will see Linux‑style commands, such as ls to list directories and forward slashes in path names rather than backslashes, as in Windows. But if you're running a Windows environment, it should be easy for you to translate those commands to a Windows terminal. Most of the commands that we'll use barely even change from Linux to Windows. Now, I know that many developers are bit uncomfortable around the command line. They find it intimidating sometimes or just unpleasant. Maybe you prefer to use a graphical user interface tool for Git instead of the command line, like the Git integration in Visual Studio, for example, or a standalone client, like Sourcetree from Atlassian. Well, good. I also like GUI tools for some operations, such as resolving merge conflicts or maybe comparing two versions of a file. I'm not saying that you should use the command line all the time. However, I still recommend that you use the command line most of the time, especially when you're learning Git, simply because, believe it or not, it's generally easier that way. A GUI tool will probably implement the most common operations and then fall short in those all‑important corner cases. And when that happens, you usually have to revert back to the command line anyway. I guess that what I'm trying to say is the command line is your friend. It makes it easier to learn Git because it gives you access to 100% of Git's features. And if you learn on the command line, then even if you decide to adopt a GUI tool later on, you know that you can still fall back to the command line when you have to send those more advanced, more specific commands. That's it. Public service announcement done. Let's dive into the first part of our Git training and talk about the four areas of Git.

Introducing the Four Areas
I was talking about a model earlier on. Here is the basic model I will use in this training. A Git project stores information in four separate storage areas. If you've been using Git for any amount of time, then you're probably familiar with at least three of these areas. The first of the Four Areas is the project director on your file system, your working area. It's the place where you keep your current files and your current folders. The second area is the all‑important repository. This is arguably the main reason that you use Git in the first place. The repository contains the entire history of the project. When you commit stuff, it goes here. In between these two areas, there is another intermediate area called the index. It's the place where you put your files before a commit. If you want to master Git, then it's essential that you understand how to use the index. Finally, the fourth area sits a bit to the side. It's a temporary storage area called the stash. It's not nearly as important as the other three, but it's useful. And those are the Four Areas. Now here is an important concept. If you want to really understand the Git commands, then for most commands, you should ask two important questions. The first question is, How does this command move data across the Four Areas? Does it copy data from the index to the repository, for example, from the repository to the working area? Does it delete any data from any of the areas? And so on. The second question you should ask is, What does this command do to the repository specifically? The repository is the most important of the Four Areas. So how does this command change the data in there? Does it create new commits? Does it move branches? Does it move the HEAD reference? And so on. It doesn't matter how confusing a command looks. If you can answer these two questions, then you will get it. At least broadly, you will get it. And you can worry about the subtleties later. Let's recap. We have the working area, the repository, the index, and the stash. Actually, let's forget about the stash for now. We'll meet it again later, and let's take a deeper look at the other three areas.

The Working Area
Let's talk about the working area and the repository first. These two areas are the subject of my previous training, How Git Works. So this clip and the next one are essentially a super quick review of that entire training. The whole thing will take just a few minutes. Actually, if you haven't watched How Git Works, then you can take the next few minutes of training as a self‑evaluation test. If at any point you're confused by what I'm saying here, especially when I talk about Git objects and branches, then maybe you need to understand a bit more about the internals of Git before you go on. No problem. Just go and watch How Git Works before you continue with this training. It won't take long. On the other end, if this stuff sounds obvious to you, then just move forward. Okay, let's get started. The first of the four areas is your working area, that is, the project's directory on your file system. This is where you work, you edit your files, you test your code, and so on. The project I'm using for this training, a simple cookbook, has just a handful of files and folders. If I want to change anything in this project, then I would probably start by editing a file or moving it or, I don't know, creating it. All of these changes happen in the working area. So the working area is all important to me. However, Git doesn't care as much about it. For Git, the working area is a very temporary place. Thankfully, Git will generally respect the working area. It won't go and destroy data in there. But in this training, we will see a few Git commands that do destroy data in the working area. So, in general, don't assume that your data is safe until you have committed it. Once you commit your data, Git stores it in what it considers the really important area, the repository.

The Repository
The repository is here in the .git folder. The most important data is in a directory that's called the objects database here. There are a few different kinds of objects in the database. Let's talk about them. Some objects represent the content of a file at some point in the project's history. These objects are called blobs. And then there are other objects called trees that represent folders in the project. And also there are commits. Whenever you do a Git commit, Git creates a commit. All of these objects are immutable. They can be created and deleted, but they can never be changed. These objects are linked together in a structure that represents your project's history. Each commit points to a graph of blobs and trees that represent your files and folders at the moment of that commit. For example, this commit is pointing at these blobs and trees, and this commit is pointing at these blobs and trees. So each commit is like a snapshot of your working area at a certain point in time. Also, two commits can share the same objects. This means that these objects in this case, for example, it's two files and a directory, these objects haven't changed between those two commits. And that's the way that Git stores changes to your files and directories. We will talk a lot about commits in this training, but we won't talk much about blobs and trees. So let's keep blob and trees off this picture and add a few more commits instead. In the history of a Git project, each commit is pointing to its parent commits. For example, this commit is pointing to this commit, which, in turn, is pointing to these commits, which are both pointing to this commit here. So if you refer to the first commit in this chain, then you're also indirectly referring to all of these commits. Now remember that each commit is a snapshot, right? A freeze frame of your product's history, so to say. So all of these commits taken together are a bunch of snapshots, that is, a slice of your project history. References to commits such as this orange arrow here are an important entity in Git. They're called branches. That's what a branch is, a reference to a commit. And because it references the commit and the commits are linked together to form a history, the branch is basically the entry point to a history of commits. And you can have multiple branches that are multiple slices of history. These are the commits in branch1, and these are the commits in branch2. A commit can belong to multiple branches. Finally, there is a special pointer called HEAD. There can only be one HEAD. It's usually pointing to a branch, and that's the current branch, and the branch is pointing to a commit. So HEAD is indirectly pointing to a commit, right? And that's the current commit. If I move HEAD, maybe because I check out another branch like I'm doing here, then I switch to a different current commit. But there is always one current commit. One last thing about commits. Sometimes you can do operations that result in commits that cannot be reached from any branch. For example, if I delete branch2, then these two commits become unreachable. There is no branch pointing at them either directly or indirectly. They are not part of any history anymore. So Git will eventually delete them, garbage‑collect them, if you wish. We will meet a few operations in this training that create unreachable commits. Well, okay, let me take a breath. That was it, our ludicrous‑speed recap of the working area and the repository. As I said before, if you could follow this recap easily, then you definitely know everything that you need to move on with this training. If you couldn't, then consider stopping now and watching the previous training, How Git Works. And in that case, see you back in a couple hours. Okay, so you're still here. Good. Let's move on.

The Index
Now let's talk about the third storage area in Git, the index. The index is a very peculiar thing. Pretty much every versioning system out there has a working area and a repository, but the index is unique to Git, or at least Git is the only versioning system that allows you to modify the index directly as far as I know. You can visualize the index as something that stands between the working area and the repository. You generally don't move the data from the working area to the repository directly. You go through the index. That's why the index is also called the staging area. You stage the changes by adding them from the working area to the index, and then you commit the changes from the index to the repository. Let's look at this process in more detail. Okay, so we have these three areas. I will use the same cookbook project that I used in a previous training here, so the project already has a history of commits. But if you ask Git for the current status, right now there is nothing to commit and nothing new in the working area. Let's call this situation the clean status just to give it an easy name. In the clean status, the working area and the repository are aligned. They contain the same stuff. For example, let's go back to our project. There is a menu.txt file here in the recipes folder, and the folder contains more files, but let's ignore those. Let's make it simple. I will add this file and folder to the working area in the picture. The file and the folder have been committed sometime in the past, so they are in the repository as well. They are two different kinds of objects. One is a blob, and the other is a tree. But that doesn't matter for us. Let's just say that they are two objects in the database. I will put them in the picture as well. Now I have to clarify one thing about the terminology I'm using. When I say that a file is in the repository, I usually mean something more specific. I mean that the file is in the current commit of the repository. Of course, the repository contains more stuff. It contains other commits and other files, the entire history of the project in fact. So I'm playing a bit fast and loose with my language here. When I say the working area and the repository contain the same data, that's not exactly true. There is more data in the repository. I should say the working area and the current commit in the repository contain the same data. But to avoid repeating that every time, I will just say the repository instead of the current commit in the repository. It's fine as long as we understand each other. So I will just visualize these two files, not the entire content of the repository. Okay, now, what about the index? If you look at the content of the .git folder, you will see the index. It's this file here. It's a binary file, so we cannot just open it in a text editor for example. What kind of data is in this binary file? Okay, this is where it gets a bit tricky. Right now, you probably think of the index as a transition area, a launch pad of sorts. In this mental model, the index is normally empty. Then you add files from the working area to the index, you launch the files into the repository by committing them, and then the index is empty again. And, in fact, that's pretty much how the index is implemented in Git. However, for the purpose of this training, I suggest that you ignore the implementation for once, and you think of the index in a subtly different way. Think of it as just another area that holds everything, just like the working area and the repository. All of your files and folders. So when we say git status, and we see this message, that doesn't mean that the index is empty. It means that the index contains the same files and folders as the repository. It's a small mental shift, but in many cases, it makes it easier to understand and visualize how data moves around in Git. So in this model, when we are in the clean status, the three areas are all aligned. They contain the same data. We can double‑check that with the git diff command. Git diff gives you the differences between two areas. One thing that is a bit counterintuitive about diff is if I use diff without any argument, then it's going to compare the working area with the index. Right now, they contain exactly the same data. So the diff is empty. But usually I don't use this diff style, not too often. The git status command is usually all I need to see the difference between what I have, that is my working area, and what I'm going to commit, the index. Instead, most of the time, I want to compare the stuff I want to commit with stuff I already committed. That is, I want to compare the index with the repository. For that you can use git diff with the ‑‑cached option. Right now, the index and the latest commit in the repository are aligned. So this diff is also empty. Okay, we're all clean. And this closes our introduction to this training. Now that we laid the groundwork, we're ready to start playing with the data. See you in the next module.

The Four Areas: Basic Workflow
Revisiting the Basics
Welcome to the second module of Mastering Git. Good to see you again. In the previous module, I said that to understand the Git command, we must ask ourselves a couple of questions. How does this command move information across the Four Areas? And how does it impact the repository in particular? In this second module, we will look at the basic Git workflow commands, the ones you already know: add, commit, check out, moving and renaming files, the works. Only, we will look at these commands through the filter of those two questions. So even if you know those commands already, this might be a different way to look at them. Let's start straight away.

Moving Data to the Right
You already know the basic workflow of Git: edit a file, stage the file, and commit the file. Let's look at those commands again, keeping the two questions in mind. To begin, I will edit data in my working area in the menu.txt file. I love Indian cuisine. I think it's amazing! So let's add something Indian or at least international Indian. There, we have Chicken Tikka Masala in the menu now. So I changed the menu file, and I will change its color in the diagram as well. I will make it darker. And the status tells us that the file has been changed but not staged yet. It's red. Now I want to copy the updated file from the working area to the index. You know the command that does that. It's git add. There you are. The file has been copied from working area to the index, overriding the previous version of the same file. Now git status tells me that the file is modified and staged, and git diff sees no differences. The working area and the index are aligned. But if I compare the index and the repository, then I can see the changes. They're ready to get into the next commit. So let's do this, git commit. And as soon as we commit, the updated file is copied from the index to the repository. And now everything is aligned again. So in the course of these few operations, we moved data from left to right, so to say, from the working area to the index to the repository. And now as a result, the three areas contain the same data, no difference whatsoever. We're in the clean status again. Notice that the last command, commit, did more to the repository than just copying this file. It also created a new commit and other objects, it updated the current branch, all stuff that I'm not showing in this picture here. So commit moves data and also changes the repository. It's actually one of the most important commands that change the repository. By contrast, add just moves data and doesn't touch the repository.

Moving Data to the Left
So we've seen two commands that move data from left to right, from the working area to the index. That was add. And from the index to the repository. That was commit. A quick question for you. Can you think of a command that moves data in the other direction? From the repository to the working area and the index? There is one that's really common. Got it? Yeah, it's checkout. Checkout does two things essentially. In the repository, it moves the HEAD reference, generally to another branch. So it changes the current commit. And the second thing it does is it takes data from the new current commit, and it copies that data from the repository to the working area and the index. So it changes the repository first and moves data second. Okay, that was probably hard to follow. Let me show you how it happens, and everything should be clear. We have a few branches here. Let's look at the lisa branch. I can see the differences between that branch and our current master branch by diffing them. In lisa, the menu file is different, and other files in the recipes directory are also different. So what happens if we check out the lisa branch? A couple of things just happened. The first thing, you probably already know about it. Look at those files in the repository. There is a commit pointing at them, and it's the current commit. It's the current commit because there is a branch pointing at it, which is master, and HEAD is pointing at that branch. Well, the first thing that happened when we checked out is that HEAD moved to the lisa branch like this. So the current commit changed. Where we are now, the files are different. I showed these in the diagram by using different colors for the files. As usual, I took a few shortcuts to make the diagram simpler. I ignored many objects in the repository, like the files in the recipes directory, a few merge commits, and the like. I simplified the diagram to make it less busy. But, otherwise, this is a good enough approximation to make my point. That is, it's not that data in the repository actually changed. It's just that HEAD changed. So the current commit changed, so we're seeing different data. So when we say the data in the repository changed, this is a shortcut to actually mean the current commit changed. So we're looking at different data in the repository. From now on, I will take these shortcuts for granted both in my language and in my diagrams. And, okay, that was the first thing that checkout did. It moved HEAD. The second and last thing it did is it copied the current data from the repository to both the working area and the index, like this. So now all the three areas have the same content, and we are in the clean status again. So checkout changes the repository because it moves the HEAD pointer in there, and it copies data from the repository to the working area and the index. Okay, enough talking about checkout. Let's go back to the master branch. So let's see, we have seen add, commit, and checkout. You already knew these commands, but now we've been answering the two fundamental questions about each of them. First, how does this command move data across the areas? And, second, what does this command do to the repository? So far, so good.

Removing Files
Now let's talk about something less intuitive maybe, removing files in Git. We're starting from the clean status with a clean diagram. Let's ignore the existing files and directories. I will create a new file, a copyright note for my cookbook project. Let's fill it in. I don't want anybody to steal my precious cookbook. There. Now we have a new file in the working area. If I ask for status, I see this file marked as untracked. That means that the file is in the working area, but not in the index or the repository. Git doesn't know what to do with it yet. I'm planning to commit this file, so I will use git add to copy it to the index. And now the status says that the file is new, which means that the file is in the working area and the index, but it's not in the repository yet. It's not an official part of the project yet. If I committed now, then the file would be copied to the repository, the three areas would be aligned, and I would be in the clean status again. But what if I change my mind instead? What if I want to remove the file from the index? Say I want to keep this file in the working area, but I don't want it in the index anymore. Maybe I want to commit something else first and get back to this file later. In other words, I want to go back to the situation I was in before the last add. I want the file in the working area but not in the index. Now I used the add command to copy the file to the index, so you might think that I can use Git's remove command, rm, to un‑copy the file from the index. Remove sounds like the opposite of add, right? Well, unfortunately, that's not what remove does. Or better, that's not the only thing that remove does. If I used it without any option, then remove would try to delete the file from both the working area and the index. This could be pretty destructive. So remove has kind of a security feature built in which you can see if I send this command. What happened is that Git noticed that the file I'm removing is not in the repository. So Git is essentially telling me, Look, I don't see this file in the project history. If I remove it from both the working area and the index, then it would be gone forever. Are you sure you want to do that? And it gives me a couple of options. I can force the removal, which is like saying, Yeah, I know what I'm doing. Just delete this file and forget about it. And I also have the option to remove the file from the index but not the working area with ‑‑cached. That's what we want to do, so let's do it. There. The file is still in my working area, but I removed it from the index. That is, I unstaged the file. So to recap: in Git, remove without arguments is not the opposite of add. Add only changes your index while a plain remove changes both your index and your working area. You have to use the ‑‑cached option to make remove work as the opposite of add. That's worth mentioning because it's a bit counterintuitive. Remove was pretty perplexing for me the first time I used it or the first few times actually. Now that I told you about remove, let me delete the copyright file for good. I thought about it, and I don't think that anybody would want to steal my cookbook anyway. There. I removed the file from the working area, and we are in the clean status again. Okay, that's it about removing files. Now, let's take another baby step up to a slightly more complex topic.

Renaming Files
We have seen what happens when you remove files. Now let's talk about moving and renaming files. Moving and renaming is actually the same thing, right? Renaming a file is just like moving it in place, if you wish, moving it to another name in the same directory. So I will show you what happens when you rename files here, and moving is exactly the same mechanism. Let's start from a clean status as usual with the three areas containing the same data. I'll only visualize one of our files, menu.txt. I want to rename this file and change its extension from txt to md. Md stands for markdown. It's a simple formatting language, and let's say that I'm planning to make this a markdown‑formatted file in the future. I will do the renaming in my working area first. There. So now the file in my working area has changed. I made it blue in the picture to show it changed. It's like a different file altogether. What happens if I ask for git status? The status is a bit confusing here. Git can see that there is a file in the working area that is not in the index, this blue file here, so it says, This file is new. I don't know about it. It's untracked. And also Git can see another file that is in the index but not in the working area. This purple file here. So it says, This file is in the index; it's not in the working area. You deleted it, right? Well, no, not quite. How can I tell Git, Look, this is actually the same file, only with a different name? Well, the good news is I don't need to do that. I can just copy all the changes from the working area to the index. First, let me add the new file. There. It's been added. And now let's take care of the purple file by adding that one as well. I will admit that this looks strange. I'm adding something from the working area to the index, but that something is not in the working area in the first place. Well, remember what add actually means. It means copy this data from the working area to the index. So if that data is nothing, as in this case, then Git will just overwrite the data in the index with nothing, which means it will remove that piece of data from the index. So now we have the same data in the working area and the index. All of our changes are staged. And if we ask for this status, Surprise! Look at this. Git already understood what's happening. It compared the content of the files in the working area and the index with the content of the files in the repository, and it noticed that the purple file and the blue file have the same content, so they must be the same file with a different name. That's pretty smart. And it works both for renaming and for moving. It gets even better. Actually, Git is smarter than that. In most cases, it understands that you are renaming or moving a file, even if you change the content of the file at the same time. It just says, These two files here look quite similar. It must be the same file. Now, of course, you can confuse Git if you try really hard. For example, if you move a file and you also change most of its content at the same time. But I would argue that if you get to that point, then maybe you're doing too much stuff at once. Maybe consider moving and changing the file in two separate commits. For simple changes together with moves, it just works. Oh, by the way, I didn't commit my changes yet. Let's do that. Now the file has been renamed in the repository, and we are in the clean status again. I just told you that Git tracks your moving and renaming automatically. So, technically, you don't need the move operation, right? Still, there is such an operation, but it's just a convenience command. It basically does the same things that we did earlier. It moves the file in the working area and updates the index. Only it does it in a single shot. See, I didn't need to rename the file first and add both the old and the renamed file to the index later. I did it all with a single git mv. Frankly, I personally don't even use git mv that much. I prefer to go through the steps manually and let Git figure out what happened. Just before leaving the module, let me commit what we have to revert the effect of the previous commit and leave everything in the clean status again. There.

A Quick Summary
Let's summarize what we've seen in this module quickly. Here is how the basic commands impact the three main areas in Git. Add copies data from the working area to the index. It doesn't impact the repository. Commit copies data from the index to the repository, and it also creates additional objects in the repository. In particular, a new commit. And it moves references in the repository. Checkout copies data from the repository to the working area and the index, and it moves the HEAD reference in the repository. Remove deletes files from both the working area and the index. It doesn't touch the repository at all. And mv, the move operation, moves a file in the working area and also updates the index. It doesn't touch the repository. And you can actually ignore it and do the same things that it does with the other basic commands. There. We covered all the basics. Now let's move forward and deeper into advanced territory.

The Four Areas: Git Reset
Understanding Reset
Welcome to the third module in Mastering Git. We're still going to talk about the four areas of Git, but now we're starting to talk about the stuff that tells apart an occasional user of Git from a power user, so be ready. We'll talk about one of Git's most useful commands, which also seems to be one of the hardest to understand, git reset. I have to admit that for the longest time, I was nervous around reset. I did use it for a couple of common use cases, but I never felt like I really understood what it was doing. I also knew that reset was a potentially destructive operation, which only made me more nervous around it. But like so many other things in Git, once you understand how this command works, you will wonder how it ever felt so hard in the first place. Why is reset such a confusing command really? One reason is that before understanding reset, you have to understand a few other things about Git. You have to be familiar with the way branches work and the way the working area, the index, and the repository work. And if you're not familiar with those concepts, then you will have a hard time understanding reset. The good news is that you are familiar with that stuff now, so you're all set. The other reason that reset feels confusing is that it has many use cases. That is, you can use it in different ways for very different reasons. So if you look up for ways to do things with Git, you see reset coming up again and again with slight variations, and the results look very different depending on how exactly you apply it. So you end up thinking it must be a very complex command. Well, it's not. Let's see how it works. I will tell you what reset does first, and then we will see how those operations can become useful in practice. I would start our discussion of reset with a little quiz. How many Git commands do you know that move a branch? Think about it for a moment. You certainly know a few, four of them at the very least. Can you list them? Okay, your time's up. One operation that you know that moves a branch is commit. It creates a new commit, and then it moves the current branch to point at the new commit. Merge also creates a new commit in most cases, and it also moves the current branch to point at the new commit. So it's another command that moves the current branch. And rebase also does something similar. It creates new commits by copying existing commits in this case, and it moves the current branch to point at one of the new commits. And also git pull. It gets new commits from a remote and updates the local and the remote branches. And maybe you know a few more. All of these commands move the current branch. They're all branch‑moving operations. However, none of them is a specialized command that only moves a branch. They move branches implicitly as a side effect of creating new commits or pulling them from a remote. You might wonder whether there is an operation that is more specialized, an operation that is all about moving a branch. Well, that's reset. The most important thing that reset does, the first step in reset so to say is just that. It moves a branch, generally the current branch, the branch that HEAD is pointing to. You pick a commit, say this commit here, and reset moves the current branch to that commit. So that commit is now the current commit. Notice that reset doesn't move HEAD. HEAD is still pointing to the same branch it was pointing at before, but the branch itself is moving. So HEAD is following along for the ride. If you only look at the repository, then that's all that reset does. It moves a branch to point at a specific commit. The part that you might find confusing, however, is not what reset does to the repository. It's the second step, what reset does to the other two main areas, the working area and the index. And reset does different things there depending on its options. If you give it the ‑‑hard option, then reset copies data from the new current commit to both the working area and the index. With the ‑‑mixed option, reset copies data from the new current commit to the index, but leaves the working area alone. This is the default option. So if you don't give any option to reset, then it will be a mixed reset. And finally, the ‑‑soft option means don't touch any of these areas. Just move the branch and skip step 2 entirely. So this is what reset does. First, it moves the current branch, so it also changes the current commit. And second, optionally, it copies the files and directories from the new current commit to the working area and the index. That's all it does really. Okay, you might say so how is that useful? How do you actually use reset in practice? And that's where it gets interesting because there is no one single answer to that question. Remember when I told you that reset has many use cases? Indeed, depending on your use case, you might want to use reset with different options. Let's look at a couple of practical examples.

A Reset Example
I will need to make a few changes to the repository before I show you how reset works. This time I will draw the repository a bit bigger than the other two areas because we will focus on what's happening there first and foremost, so we need space in the picture. Okay, we're on the master branch in the clean status. So the three areas contain the same data. I will draw the menu.txt file and the recipes directory in each area. When it comes to the repository, however, let me draw a few more details as well. Here is the current commit. It contains the data and also has the previous commit as a parent, and I will also draw the current branch, master, which is pointing at the current commit. And finally, here is the HEAD reference pointing at the current branch. There, now we have a pretty complete view of the repository. It's not really complete. As usual, I'm simplifying here. There are additional files in the recipes directory, which I didn't draw. I didn't draw the root project directory and so on. If I tried to squeeze everything into this diagram, it would get pretty cluttered. But this is the essential stuff that we need to follow this explanation of reset. Okay, so this is our starting situation. Now imagine that I heard about this fashionable chef in Denmark who's having a lot of success with his new signature dish, squids with strawberry jam. I want to add this dish to the menu, so I will edit the menu. There, Strawberry Squids, nice. So look at the diagram. I just changed the menu file in the working area. I made it darker. I colored it purple to show it changed. Now let's stage it. And I just copied the updated file to the index. And now let's commit it. Look at what happens in the repository when I commit. Git creates a new commit, it moves the master branch to point that this new commit, and the new commit contains the new version of the menu file and the same old version of the recipes directory. Let's go through this entire process once more. In my cookbook project, whenever I add a new recipe, I'm also supposed to have a file in the recipes folder that contains the ingredients and other details about the recipe. So let me add the file with a couple of ingredients. Now this file is here in the working area. I'm not drawing all the files, so I simplified and just showed the change to the recipes folder. I also made it purple, and I add it to the index, and I commit it. And again, Git creates a new commit, updates the master branch, and the new commit references the latest versions of both menu.txt and the recipes directory. Now imagine that I get a phone call from a friend I trust who actually tried to cook squids with strawberry jam, and she guarantees that they are pretty terrible. She definitely does not recommend that. Apparently great chefs sometimes can go overboard with their experimentation a bit and, well, long story short, I changed my mind. I don't want Strawberry Squids in my cookbook anymore. Unfortunately, by now I have not one, but two commits that reference Strawberry Squids. I regret those commits. I would like them to go away now. How can I do that? Well, one way I can do that is by using reset. I have a commit here, two commits ago, this one. It still contains the blue versions of my files before I started doing the squid thing. I would like this to be the latest commit in master as if the last two commits never happened. That's where reset comes useful. I can take note of this commit's hash and ask Git to reset the current branch to it. This will move the branch back in time, so to speak. And what about the options to reset? Should this be a hard reset, a soft reset, or a mixed reset? Well after the reset, I want to have the blue versions of the files, not just in the repository, but also in the index and the working area. I want to be aligned. I want to be clean again. So this must be a hard reset. Remember ‑‑hard copies the files from the repository to the other two areas. Let's do this and see what happens. First, Git moves the current branch to the previous commit, which now becomes the new current commit, and HEAD follows along. Second, because this is a hard reset, Git copies the content of the new current commit, the blue versions of the files, to both the working area and the index. And third, because the two squid‑related commits are unreachable now, they have no branch pointing at them, they will eventually be garbage collected. So we are back to where we were before this whole strawberry squid fiasco, all with a quick reset.

More Reset Examples
So we've just seen one way to use reset to move a branch, one specific use case. The use case was I want to reverse the whole project to the state it was in a previous commit. We did that with a hard reset. But that is not by any means the only reason to use reset. If I had to give you examples for all the reasons I can think of, then I'd have to talk about reset for an entire training, and I'm also certain that there are a few more reasons that I cannot think of, so I'll keep it short. I will just give you a few very quick examples. Here is one. Let's start from a clean status and focus on the menu file. Suppose that I've been experimenting with this file. For example, I edit it and add a new line for a barbecue recipe. I will stage this change. There we are, a changed file in the working area, and it's also staged in the index. Now what if I change my mind right now and I want to clean the staged file? Maybe I want to commit something else first and get back to these changes later. In other words, I want to keep the changes in my working area, but I want to remove all changes from the index. In the index, I want the same version of the files that is in the repository. How do I do that? Earlier on, we've seen one way to do that, using the rm ‑‑cached command. That works, but it's not the only way to do it. In fact, if you read Git's messages carefully, when I asked for the status, Git itself suggested a different command to unstage a file. It suggested using reset. Actually, the very latest versions of Git suggest yet another command to unstage files. I'll tell you about that in the next module. In this slightly older version of Git that I'm using here, it suggests using reset. How exactly can you unstage files with reset? Well, the idea is to have what I call a HEAD reset. This means that we are moving the current branch to the commit pointed at by HEAD, but the current branch is already pointing at that commit by definition. So in this case, the reset doesn't move the branch at all. If you wish, it moves it to the same place where it already is, so it doesn't move it. This is like skipping the first step in a reset altogether, the step where it moves the branch. What happens after that? Remember the second step of reset. Git moves data from the repository to the working area and the index. In this case, we didn't specify the kind of reset we want, so Git will go with the default, and the default is a mixed reset. Remember what a mixed reset does. It moves data from the current commit to the index, but not the working area. And the result is it unstages all the changes. Now what if I decide to throw it all away? I don't want to commit this change at all anymore. After all, a barbecue is not really a recipe. I should have separate recipes for all the different stuff in a barbecue. So for now, I just want to wipe out my edits to the files in the working area and go back to the clean status. I can do that with a hard HEAD reset. A hard HEAD reset doesn't move the branch because it's still a HEAD reset. But it copies data from the repository to both the index and the working area. It overrides everything there. This is a popular command, but I use it with some care because it's a destructive command. In fact, it's one of the easiest ways to lose data in Git. You are saying explicitly I don't care about all the stuff in my working area. Please just override it with the content of HEAD. And if I send it, everything in the working area and the index gets overwritten. I could go on and on with examples of using reset, soft and hard resets, HEAD resets, but you've got the message by now. There are many different flavors of reset that you can use in many different circumstances. What you need to remember is the two steps. First, move a branch, possibly moving it in place, but in general moving it to a specific commit. And second, copy data from the current commit to the index, the working area, both, or neither, depending on which kind of reset you're doing. And since I don't want to rename this course Mastering Git Reset, I guess I'd better stop here frankly.

The Four Areas: Advanced Tools
Stashing Data
Hello again from Paolo. In this last module about the four areas, we are going to take a look at a few tools that didn't find space in the previous modules. We're going to make a few comments about merge conflicts, working with individual files, or even only parts of a file. We're going to talk about a couple of experimental Git commands and the general philosophy of Git. But first, we're finally going to talk about the fourth area, the stash. At the beginning of this training, I told you that there are four areas where Git stores your data, but I only focused on three of them. I ignored the stash altogether. That's because the commands we've seen so far have some kind of effect on the working area, the index, and the repository, but none of them has any effect on the stash. Indeed, there is only one command that affects the stash, and it's, you named it, Git stash. So, if you want something to happen in the stash, you have to be very explicit about it, and this is actually the selling point of the stash. It's all yours, even more than the working area is. The data in the stash doesn't change unless you really want to. Let's see how you can use the stash. I will start from the clean status as usual, and for now, I will only draw the menu.txt file here. Now, let's create a new recipe in the recipes directory: guacamole. This file is supposed to contain a recipe, or at least a list of ingredients, but I'll think about that later. For now I'm leaving it empty, and stage it. In this project, whenever I add the recipe, I must also add it to the menu file. Let me do that. There. So now we have an updated menu in the working area, and a new file in the working area and the index. Now imagine that while I'm working on this new recipe, I get interrupted for whatever reason. I need to do some work on another branch, for example. I want to focus on that other work, but I don't want my half‑baked guacamole recipe to get in the way, so this is a good time to use the stash. I can store all my changes in the stash, and they will stay there, safely, until I decide to get back to the guacamole recipe. I store the current status with git stash_save, or just git stash. I usually use the abbreviated form. And I also use this option, include‑untracked. It means also stash files that are still untracked, that have never been added, files that are entirely new in the working area. It doesn't make a difference in this case, as we don't have any untracked files, but by default, git stash just ignores untracked files. I personally don't like the default much, so I use this option without even thinking about it, usually. And here is what happens. Git takes all the data from the working area and the index that is not in the current commit in the repository, and copies all of that data to the stash. And then it also checks out the current commit. So, now we are aligned with the current commit. We're in the clean status again. Our files are gone from both the working area and the index. They're not really gone, of course; they are still in the stash. And I can read the content of the stash with stash list. And there it is, all my half‑done work neatly packaged in a single stash element. Now we can see the point of the stash. The stash is like a clipboard for your project. It's the place where you store stuff that you need to set aside for some time, and it's a multiple clipboard. You can have as many elements as you want. Each element gets labeled with information about the latest commit to make it easier to identify, and it also gets a serial ID. Right now we only have one element, so it's called stash@0. The next one would be stash@1. Now that my stuff is stashed, I could switch to the other branch, do stuff in it, create new commits, whatever, anything. My half‑done work on guacamole stays in the stash, and after doing all that other work, I can retrieve the stuff I stashed. You use stash apply to move data from the stash to the working area and the index, and you can give it the name of a stash element. I will not give it a name, so it applies to the most recent element by default, which is stash@0. And there we are, all our data in the working area and the index is back where it was when I stashed it. I can finish the job, I can stage the menu file, add a few ingredients to the guacamole recipe. Here, good vegetarian stuff. Mm, I'm getting hungry. And let's stage this update as well and commit the whole thing. There, now that our data is safe in the repository, I don't need that data in the stash anymore. Let's clear the entire stash. And there you are, that was the basic stash‑related workflow. There is more to know about the stash if you want to dig deeper, but what you've just seen is the gist of it, a clipboard for your project.

Solving Conflicts
One thing that I must mention in this training are merge conflicts. I always talk about merges as if nothing could possibly go wrong during a merge, but in real life you can have conflicts. And even if I call them merge conflicts, they can happen during other operations as well, like rebases. Now, I won't tell you much about merge conflicts, because there are other trainings on Pluralsight that focus specifically on working with Git branches and solving conflicts when they happen. If you already followed those trainings, you can skip this short clip if you wish. But for completeness, I want to have a very quick example of a conflict here because this topic also has a few connections to the four areas. So let's edit the guacamole recipe from two separate branches and then try to merge them. First, I will create a new branch called tomato, and check it out. And in this branch, I will add some tomato to the recipe. I think that guacamole is better with tomato, as long as you don't overdo it. And let's commit it. There, now let me switch back to the master branch, and I will modify the recipe in there as well. In this branch, I will add onion. That's another important ingredient. And I commit. Okay, now let's try and merge the tomato branch into our current master branch, and as soon as we do that, we get a conflict. And in fact, if I ask for the status, it tells me that there is an unmerged path, a file that has been modified in both branches that I'm merging. Git is pretty good at solving these kinds of problems, but in this case, both sides added a line right at the end of the file, so we have two changes in the exact same position. Git cannot possibly decide which of these changes comes first, or whether one of these changes must overwrite the other, so it changed the file in the working area to give us enough information to solve the conflict ourselves. This is the first way in which a merge conflict impacts the four areas. It results in a modified file in the working area. Before looking at this file in more detail, just one question. How does the git status command know that we're in the middle of a merge and that there is a conflict on this file? Well, it knows because the merge command created a few files in the .git directory, here, that signaled that there is a merge operation ongoing, and they also contain information about what is being merged, among other things. For example, the MERGE_HEAD file is a reference, just like HEAD, only MERGE_HEAD is a temporary reference. It only lasts as long as it's needed to complete the merge, and it's pointing at the tip of the branch that we're merging, the tomato commit. Normally we don't even see this stuff because Git completes the merge on its own, but now we are right in the middle of a merge, and we can either abort the entire merge or fix the conflicts and move forward. Some conflicts can get pretty complicated, but this is not one of those. We have an easy situation here. If we edit this file, we can see that Git is showing both sides of the merge. It marked them clearly for us so that we can identify them. The side marked as HEAD is the current commit, and the side marked as Tomato is the tomato branch. Now we can manually edit this file and decide what the merged file must look like. Here, I will keep both the tomato and the onion and put the tomato on top. Now that we have solved the conflict, we need to tell Git because it cannot know that we solved the conflict yet, and, in fact, the status still sees a conflict here. And that's another connection to the four areas. I must use the index to tell Git that I solved a conflict. We know that the index tells Git which information goes into the next commit, and that's still true here, but in this case, the meaning of the add command is a bit more specific. It means this file is ready to be committed because I edited it and I solved the conflicts it contained. So now we can finally go forward and complete the merge. All we have to do is tell Git to commit. And there we are, the merge is done, and it's in the log. And that's how you solve merge conflicts manually. Again, you probably knew all of this already, right, but it's interesting in the context of the four areas because it shows that the same Git commands like add or commit mean subtly different things, depending on the context. Keep this point in mind because we are going to mention it again soon. But first, there are a few more Git features that I want to mention here.

Working with Paths
I spend a lot of time in this training talking about commits. And indeed, we usually work with files only up to the point where we put those files in a commit, and from then on, we tend to work with commits all the time. When you reset, you reset to a commit. When you checkout, you checkout a commit, and so on. But commits a pretty coarse in a way. You remember, a commit is like a snapshot of your entire project at some point in time. Sometimes you want to work with something smaller than your entire project, something like a single file or a single directory. Let's look at an example involving the menu file and the README file. I will edit the menu, and I will make everything in it all uppercase with a bit of vim magic. And I will also make a similar change to the README file. And now let me stage all these changes. Now let's say that I'm not sure about these changes anymore. Let's say that I like the change to the README, but I'm not sure about the change to the menu just yet, So I want to unstage the menu file, but not the README file. In the previous module, we've seen one way to unstage a file. You can do a HEAD reset. But last time we did it, we did it on the entire content of the index. However, it turns out that you can also do that on a single file. So let's do it. We didn't specify that this should be a hard HEAD reset, so by default, it's a mixed HEAD reset. And remember what a mixed HEAD reset does, it doesn't move the current branch because it's a HEAD reset, but it copies data from the current commit to the index. It doesn't change the working area. Normally, such a reset copies all the data from the current commit to the index, but in this case, we're saying that we only want to reset the menu file, so only the menu file gets copied. And the effect is that the menu file and only the menu file has been unstaged. The README is still staged. Brilliant. Exactly what we wanted, right? Now, let's go one step farther, and remove the menu changes from the working area as well. You might think that to do that we could use the same instruction, only this time make it a hard HEAD reset. But no, that doesn't work. Git refuses to do a hard HEAD reset with the path. That feels a bit inconsistent, but it's the way it is. Instead, the most common way to revert a single file or directory in the working area without touching other files is to use checkout. Look at this weird checkout here. Normally, checkout moves the HEAD reference in the repository, usually to a branch, and then it copies all the files from the repository to the working area and the index. In this case, however, checkout is not going to move HEAD. Checkout is just going to copy stuff from the current commit in the repository to the working area and the index, and it's only going to do that for the one file we specified. So we just lost all the changes to that file. The menu is back to where it was in the latest commit; exactly what we wanted. Note that checkout with a file or a path in general is not nearly as harmless as a regular checkout. It's actually one of the most destructive operations you can do in Git. We didn't even get a warning. We just swiftly and irrecoverably destroyed all of our changes to the menu file. So, handle this command with some care. So now the only file that I have left, modified and staged is the README. And I can finally commit it. So, we've seen that you can do operations in Git that are very granular, down to a single file. But you don't have to stop there, as we'll see in the next clip.

Committing Parts of a File
In the previous clip, you've seen how to do some operations that are smaller than a commit, operations on a single file. But Git goes farther than that. It can operate on something that's even smaller than a file. I've got to tell you, this is going to feel a bit weird because so far we acted as if the file and the directory are the fundamental units of the Git model, the atoms of Git. And in part, that's true. That's a good model to describe Git. It operates on files and directories. On the other hand, you can split that atom in Git if you wish. Let me show you on a terminal. There, with large fonts so it's easy to read. I created a new branch called hunks to show you this feature. You'll see in a moment why I used this name. And on this branch, I'll make a few changes to a project file, the menu file here. I will add a popular Italian dish right at the top, Spaghetti Bolognese, and I'll also make a small change to the Apple Pie and turn it into an Apple Piece because it's lighter on calories that way. And finally, I'll add another Indian recipe right at the end. Let's add Aloo Gobi. So I made a few changes. Let's save this file, and with git diff, we can see the changes I just made. Now here is a new scenario. Let's say that some of these changes I want to commit immediately, and some I'd rather commit later in a separate commit. Or maybe I won't ever commit them. I'll decide later. But for now, I only want to commit some of the changes, but how can I do that? Because all the changes belong to the same file. There are a few different ways to do that in Git. The quickest is to use git add only with this option, ‑‑patch or just ‑p. And here is what happens. Git looked at the changes I made and divided them into sections called hunks. That's where I got that term from. And for each hunk, it gives me a number of options. They are somewhat hard to make sense of at first, but one of them, the question mark, gives us documentation for the other options. So I press the question mark, and we get more details about the options available. You see, we can add the hunk to the index, skip the hunk without adding it to the index and move onto the next hunk, quit without adding anything else to the index, and so on. However, in this specific case, I have a problem with my changes in that they're all very close together. This is a short file. So Git decided that all my changes are part of a single hunk. So if I want to decide which changes to commit on a line‑by‑line basis, I have to ask Git to split this hunk a bit more into smaller hunks. There is an option for that, s for split. So I press s, and now we have three hunks it says here. That's what we wanted. The first hunk is the one that adds Spaghetti Bolognese. Now plot twist, if you've ever spoke with an Italian about spaghetti bolognese, you might have heard that spaghetti bolognese is a fake dish. It doesn't actually exist in Italy. We just don't think that bolognese sauce and spaghetti fit well together. Look, if we ever meet in person, I can entertain you for half an hour on this topic, but you probably don't want me to do that now. So just know that I want to skip this hunk. I don't want to add it to the index. I must press n to skip this hunk, and skip it I will. And I'll probably just remove this change later on. Then, there is a second hunk, the one about Apple Piece, which I would also like to skip. It's not that I don't like to have a piece of apple, but honestly, I'd rather have a full blown apple pie. So I press n again and skip to the third hunk that adds Aloo Gobi to the menu, a lovely dish. And this is the one change I'd like to add to the next commit. So I'll press y for yes, please do add this hunk to the index and the next commit. Let's recap what we just did. We used git add ‑‑patch to add some changes from the working area to the index. Not on a file‑by‑file basis, but on a more granular hunk‑by‑hunk basis. We only added one change from one file, and we left the other changes unstaged in the working area. And in fact, if I do a git status now, I get this weird result that the menu file is both in the list of changes to be committed in the index and in the list of changes not staged for commit because part of it is staged and part is not. We can still see exactly what changes belong where by using git diff. Do you remember this? It means show me the changes between the working area and the index. That is, give me the unstaged changes. And to see these staged changes, that is the changes from the index to the repository, I can do that with git diff ‑‑cached. And here is the change that will go into the next commit. This example involved a single file, but I can also use this hunking functionality over multiple changes across many files. And as it turns out, git add isn't the only command that has this patch option. Other commands have it, like git checkout, git stash, and even git reset. In all of those cases, you can say ‑‑patch, and it means let me do this operation not on a file‑by‑file basis, but on a hunk‑by‑hunk basis. So you can decide which changes inside each file are involved in a checkout or a stash or a reset. To be clear, that's not how most people usually work with Git. I told you to think of the Git model as a model based on files and directories. Just know that you can access this smaller granularity when it's useful.

Introducing Switch and Restore
We talked about many Git commands that impacted the four areas so far. But there are two commands that I didn't know whether to mention in this training honestly because they're still experimental as I produce this training. They're called git switch and git restore. As I speak, they are available in the latest versions of Git, and they're probably going to grow more important in the future. But being experimental, they might change or even go away maybe, even if that's unlikely. So I decided to mention them here, but not really focus on them in this training. Where do switch and restore come from? They both replace some functionality of the git checkout command. In this module, I give you a few examples of Git commands that do multiple things, and checkout is one of those commands, right? It can be used in different ways. In particular, you can use it to move to a different branch, or you can use it to get the files from a previous commit in your working area. And by now you know how Git works internally, so you know that, under the hood, those two things are essentially the same. They're both about moving the HEAD reference, so it does make sense that Git has a single command for both operations. But from the outside, these two operations look like two different features, especially to a beginner, to someone coming to Git from other version control systems maybe. So many beginners are left wondering why does the same command do two very different things like that? So to address this confusion, the maintainers of Git are experimenting with a split of checkout into two different commands, switch to deal with branches, like move to a different branch or even create the branch in the process if it doesn't exist, and restore to deal with files specifically. I sincerely don't know how much value these two commands add to Git at this stage, but we'll see. They might turn out to be a useful distinction, especially for beginners. And also, I've got to say restore in particular is already proving useful because it doesn't just replace part of the functionality of checkout. It adds some new functionality of its own. For example, in this training, we've seen a few ways to unstage files, to remove them from the index after you put them in the index. But the latest versions of Git suggest using restore for unstaging instead of reset as they did earlier because when you use restore, you can specify this ‑‑staged option. That means copy the files from the repository to the index only, not the working area, which is arguably the most intuitive way to unstage files now. So these new commands might turn out to be useful and deserve their place among Git's most important commands, maybe even replace checkout for good in the long term. But we don't know yet, so just be aware of that for now. For now, they are yet another example of Git giving us multiple ways to do the same thing. And talking about that, let's close the module by looking at this point in a more general way.

Git Is a Toolbox
Consider a toolbox, just a regular toolbox, screwdrivers, hammers, that kind of stuff. The tools are specialized in a way, right? Each tool has specific features. But at the same time, you can do many different jobs with each tool. You can use a hammer to plant a nail or to remove a nail or to straighten a piece of metal, for example. And you can also use different tools to do similar jobs if you are creative. If you need to remove a nail, you can do that with a hammer, or you can use a plier, for example. So you have a bunch of tools and a lot of flexibility in how you use them, and that's the metaphor I have for you here. Git is a toolbox. It's not a single program that does stuff. It's not even a collection of utilities that neatly match your use cases. It's a toolbox because you have generic tools like reset or checkout. And like in a toolbox, you can use the same tool for different jobs. Think about git reset, for example. You can use it to unstage a file, you can use it to clean up your working directory, you can use it to remove the latest commits from your history, and so on. Or git add. You can use add to tell. Git about a new file, to put a modified file in the next commit, or to signal that you solved the conflicts in your file during a merge. And you can also use different tools for similar jobs. If you want to unstage a file, Git doesn't give you a command named, I don't know, unstage. There is no such command. To unstage a file, you need to understand how the index works. And once you do, you can unstage the file with a reset, or you can use a remove ‑‑cached, remember that one, or you can use the new restore command, and we mentioned all of these commands in this training. Git doesn't tell you here is this command, it's the command that you've got to use if you want to unstage a file. Git gives you the basic toolset, and then it's up to you to pick the right tool. And it also gives you a few precision tools, like staging only some hunks, some parts of a file. This is a very Unix‑like approach, which is not surprising because Git was conceived by Linus Torvalds who also made Linux. And this approach makes Git a bit more challenging than other versioning systems to get into, that's true, but it also makes it really, really powerful. And with that, we can close the first and longest part of this training. In these first four modules, we explored the Git toolbox, and in particular, we focused on tools that move data across the four areas of Git. Some of those tools also have other effects, especially in the repository. Think of commands such as commit or reset. We described those effects as well, but our focus was on moving data across the areas. Now that you know about those data shuffling tools, we can shift to another set of tools, one that focuses almost exclusively on the repository.

History: Exploring the Past
Becoming a History Surgeon
Welcome back. Welcome to the second part of this training that includes two modules about working with your project's history. This module, Exploring the Past, is all about digging in to that history and making sense of it. And in the next module, we are going to talk about how to change history. I remember this training that I watched once about Vim, the text editor, and the teacher said using Vim feels like being a text surgeon. I think that's a nice metaphor, whether or not you like Vim in particular. Some technologies are like that. They are very precise and accurate. And when you use them, it feels a bit like doing surgery. I mean, I don't know how doing surgery feels actually, but that's how I imagine it. You do precisely what you want on the data you want, and you use tools that are a bit scary maybe, they cut easily, but they are also very powerful. Git also feels like that, especially when you're working with history. So this module and the next are about becoming a history surgeon, if you wish. And because your history is part of your repository, we'll stop talking about the other storage areas and focus on the repository alone. One note about this part of the training, I promised that I wouldn't linger on technical details in this training, that I would focus on the model and the way of thinking of Git, not on the commands, the options, and the like. Well, in these two modules, I'm going to relax that approach a bit. Working with history is mostly a technical thing. So I'm going to focus a little bit more on the commands here. Let's dive in.

Referencing Commits
When I talk about exploring your project history, I'm mostly talking about commits. So we will be referring to commit a lot in these two modules. And there are many ways to refer to a commit in Git. Let's take just a few minutes to talk about that. Here is our cookbook repository again. I will check out one of the existing branches, this branch called nogood. It's one of the branches from the previous training. It doesn't matter what it contains exactly. I'm just looking for any old bunch of commits here. I can use git log to look at the history, but the default of git log is not very useful when you're trying to make sense of a complex history because it squashes everything in a single list. So it's hard to make sense of branches and merges and understand what's really happened. So we'll use git log with a few options. The graph option gives me a nice graph‑like structure where I can see how the commits branch and merge. And the decorate option shows the positional references, like branches and HEAD. And finally, I will format the log so that each commit takes only one line. There, beautiful. We can see the structure of the repository now, all the references, including HEAD, branches, remote branches, the works. This command alone can almost replace a GUI tool for many of my needs. Now let me copy this information to a diagram here so that it stays visible as I keep working in the command line. Okay, let's say that I want to see information about the current commit. I want to know which changes were introduced by this commit, date of the commit, and so on. I can use the git show command to do that. Of course, I need to tell it which commit I want to look at. How can I refer to this commit? The obvious way is to use its hash like we did in the past. Or better, the first few characters of the hash like this. There it is, detailed information about this commit. However, using hashes is not always the easiest or the most practical way to refer to a commit. Another way to do that is to give Git the name of a reference that is pointing at the commit. The nogood branch, for example, is pointing at this commit, so I can use the branch to refer to the commit. Also, HEAD is pointing at the branch that is pointing at the commit. This is the current commit at the moment. So I can also refer to it through HEAD. So far, so good, and nothing new, right? We've been doing all these things already in this training. But now what if we want to reference this other commit, the second to last one? There is no reference pointing at it, so it seems that our only option is to use its hash. However, there are other ways. I can start at HEAD and add a caret like this. The caret means the parent commit. So now I'm asking for the parent commit of HEAD. Bingo. And if I want to refer to this commit here, then I can use two carets. That means go to the parent of the parent of HEAD. And I can also say the exact same thing by using a tilde sign followed by a number. You can read this as go to HEAD, and then go back two commits. This is useful, especially if you want to look at, say, the tenth commit before HEAD and you don't want to type 10 carets. You can just say tilde 10. This syntax is fine if each commit has exactly one parent, but it breaks down as soon as you have commits with multiple parents, like this merge commit here. What if I want to refer to this commit, for example? It's the second parent of the second commit before HEAD. In this case, I can address it with this syntax. Let's see. Start from HEAD, then go back to commits, and then pick the second parent. Voila. There are other even more sophisticated ways to refer to commits, some of them surprisingly sophisticated, in fact. Just for a quick example, yeah, I just asked Git to show me where HEAD was 1 months ago. That's cool, huh? However, I won't go into any more detail, so we don't need them. When it comes to referencing commits, I think that we have enough information to get by. Let's move on.

Tracking Changes in History
Now that you know how to refer to a commit, let's finally talk about how you can explore how those commits are connected, your history. There are a few useful commands for that. One is git blame that shows you where the lines in a file are coming from. Let's see who changed the apple pie file and when. Here are all the lines in the file. For each line, you can see the latest commit where that line was changed. The caret here means, in this case, that this line is there in the file since the very first time the file was added to the project. And all the other lines were changed or added in subsequent commits. And here, I can see the dates and the authors of these changes. The author was always me, even if I apparently changed my name in my Git configuration after creating the file. Another useful command is git diff. We already used git diff a few times in this training to compare the content of two areas, like the repository and the index. But you can also use it to compare other things, for example two commits. Let's see the differences between the current commit and two commits earlier. Okay, so this is the only file that changed between the two commits. One line was added and another line was modified. And, as usual, you can use branches to reference commits. So one common technique is using git diff to compare two branches. This shows all the changes between the two branches. Comparing branches is really useful, especially before merging stuff. We've seen git blame and git diff. However, the most important command by far when you are exploring history is a command that you already know. We just used it just a few minutes ago, git log.

Browsing the Log
Git log is the most useful command for exploring a project's history. We've already seen a few options for it, graph, decorate, and oneline, but there are many more, a huge amount of options in fact. Git log looks pretty harmless, but it's arguably the most complicated Git command. It's super powerful. I will give you a few examples. You certainly don't need to memorize these examples. See these as a quick demo of some things that git log can do. To begin with, you can get a detailed diff for each commit in the log, like this. So you can see exactly which changes were introduced in the commit. It's also very colorful. One more option. You can filter the commits. For example, I only want to see the commits that contain the string apples in their messages. And there is only one of them. You can even ask for all the commits that added or removed the word apples from any file with ‑G uppercase. I will also use the patch option here to show which lines exactly were impacted by these changes. There, there are one, two, three commits that either added or deleted this word. And I can also see the specific changes. And in all cases, they included the string apples. As an alternative, there is also a git grep command that is useful for these kinds of history‑wide text searches. Check it out if you wish. Git log can also visualize a specific range of commits. The easiest way to do this is to say, for example, git log ‑N, which means only show me the latest N commits in the log. You can also use two dots to express a range like this. This means show me the commits from five commits before HEAD to the parent of HEAD. I used to find this range syntax mildly confusing because you specify the oldest commit first here, but in the default git log output, the commits are reversed. So you see the oldest commit at the bottom instead. But I did get used to it eventually, kind of. This commit range feature is particularly useful if you need to compare two branches. This is a common scenario. It's not like diff. It's a different kind of comparison. A diff can compare the files in two branches. Here, we want to compare the histories of two branches. That's easier to understand with an example. For example, the current branch is the nogood branch. Let's say that I want to list the commits that are in the master branch, but not in the nogood branch. So you can read this as go from nogood to master and show me all the new commits that you see. And here they are. If we merged master in nogood right now, these are the commits that we would get. This branch comparison is really useful. I do it all the time. Okay, I guess you've got the idea by now. Git log has a huge amount of options to show your history in a number of different ways, to filter commits, to format them, and so on. Again, I definitely do not expect that you will remember these features just because I spent a few seconds introducing them. But still, I don't want to spend more time going through all those options. By the end of it, you'd probably hate me. The point of this module is if you know that those features exist, then whenever you need them, they're just a quick Google search away. So let's recap. In this module, we've seen a few ways to refer to commits with special syntaxes, such as the caret and the tilde, and we've seen a few examples of commands that you can use to explore history, git diff, git blame, and git log. Here in this list, I'm showing examples of some of the arguments we've been using. Oh, and let's not forget git show. And that was it. This module was quick, essentially a warmup for the next module, which delivers the really cool stuff, how to change your history.

History: Fixing Mistakes
Reviewing the Golden Rule
So this is the second module in this training that focuses on history surgery. In the previous module, we've seen a few commands to explore your project history. In this one, we'll see how to edit your project history. Now, of course, you are already editing your project history in a way. Every time you commit, for example, you are adding something to the history, and every time you use rebase, you're changing your history. However, in this module, we're going to take it a few steps farther than that and look at some advanced surgical tools. All these tools come really useful in emergency situations, such as when you want to fix a mistake. That's why I call this module Fixing Mistakes. However, these tools are also useful in less dramatic circumstances, such as when you're cleaning up your local commits before you push them to a remote server for example. One important note before we begin. Remember the git rebase command. If you watched my How Git Works training, and even if you didn't, you probably know one rule of thumb about git rebase. You should never rebase shared commits. That is, once you push the commit to a shared repository, from that moment on, you should avoid rebasing that commit. That's because rebase is a command that changes history. It copies all commits to new commits. The new commits might look the same as the old ones, but they're actually different objects in the database, and as a result, if you rebase commits that other people have in their repositories, then you can create a lot of confusion. You can introduce conflicts that cannot be fixed without a lot of manual tweaking. So, in general, you shouldn't do that. Well, here is an important point. This rule doesn't apply just to rebase. Most of the techniques that we're going to see in this module change history. So, just like rebase, these techniques shouldn't be used on history that has been shared. This rule is so important that I call it the Golden Rule of distributed work in Git. It's all fine when you change your own local history, but changing shared history is not going to win you any friends in your team. So in this module, we're going to see a few exciting and powerful tricks. But always remember the Golden Rule. Okay? And with that out of the way, let's open the bag of tricks.

Changing the Latest Commit
The first way to change history that I'm going to show you is also the easiest. It's about fixing the latest commit. We're in the cookbook project again on the master branch, and let's add a new recipe to the menu, Caesar Salad. Let me stage this change and commit it, and here is my commit message. There. It's in the log now. Now, after committing, I realize that I didn't quite finish the job. The rules of the cookbook say that whenever I have a recipe in the menu, I also need the matching file in the recipes folder. I don't have that file for Caesar's Salad. At the very least, I need a quick placeholder file for it. Let's create that file and populate it with a few ingredients. Just a placeholder for now, just the basic ingredients. There we are. Probably an incomplete salad, but, hey, you can't really go wrong with salad, right? And I stage it. So now I'm in the process of fixing the problem, but I don't want to fix it by just creating yet another commit. That wouldn't feel right. I would end up with two separate commits where the first commit would still have a menu item without a corresponding recipe. That's an inconsistent state for my cookbook. It's the equivalent of having code that doesn't compile in the repository. And the second commit would fix that. But instead I would like my history to be cleaner than that. I would like to go back and fix my latest commit and add this file to the latest commit so I would have only one commit, and that one would be good and clean. I can do that by amending the latest commit. All it takes is an additional amend argument. There. I'm not creating a new commit from scratch. Instead, I'm amending the latest commit. And now this commit will include both the modified menu and the new recipe file, and I can also take this chance to make any other changes that I wish to this commit. For example, the message here, it should be in the present tense. That's the recommended style for Git messages. So let me change it. Done. And I save and quit this message file. And let's see what is happening with the diagram. Look at the current commit. That's the commit we are amending. Git cannot really change this latest commit, right? Commits are immutable. What Git is really doing when I finish amending this commit is it copies the current commit to another commit that also includes all my amendments, the new file and the edited message. This is a brand‑new object with a new hash. Then Git moves the current branch to point to the new commit, and the old commit will eventually be garbage‑collected in the future while the new commit is staying there. So amending a commit is a history‑changing operation. It's like a very small rebase. In this case, I amended a commit that I hadn't shared yet. I'd never pushed it to a shared repository, so it was okay to change it. And there we are. If we look at the log, the commit has changed. This new commit has the new message that I fixed, and if we look at the details, we can see that it includes both the updated menu and the new recipe file. And that's commit ‑‑amend. It's quite useful because whenever you want to fix something, more often than not, it's something in the very latest commit. Actually, I'd be ashamed to admit how often I amend my commits. So, nice feature. But it's only useful for the current commit. You cannot fix an earlier commit like that. So what if you want to fix a problem that happened a few commits ago?

Navigating Interactive Rebases
I just mentioned this convention in my cookbook project that says for each line in the menu, like Apple Pie here, you want a matching file in the recipes directory, like apple_pie.text here. Well, as it turns out, I did this wrong in the past, twice. There are two items in the menu, Cheesecake and Chicken Tikka Masala, that have no matching files in the recipes folder. So what if I want to fix these past mistakes? If the mistakes had happened in the latest commit, then I could just amend them. But that's not the case unfortunately. Let's use git blame to see when these lines were added to the menu. And now let's look at the log. So here is the commit that added Chicken Tikka Masala to the menu. It was a few commits ago. And here is the commit that added the Cheesecake. This one happened way back in the past, one of the very first commits. Both of these commits broke the rules. They added items to the menu without adding matching recipes in the recipes directory. Now we have to be a bit careful. Look at the position of the remote branches here in the log. In particular, the remote master branch on origin. This repository is shared, right? I cloned it from my cookbook project on GitHub. Here is where the master branch on GitHub is, or at least where it was the last time we communicated to the project on GitHub. So these two commits are both wrong, but this commit happened after the last time I communicated with GitHub, while this other commit happened way before that. It's already being shared. So I don't want to change the Cheesecake commit because of the Golden Rule. I will just decide to live with it for now. Instead, I will fix the Tikka Masala commit, which is not shared yet. It's still a local commit in my own repository, so I can change it. So long story short, here is the plan. I will fix this commit so that it includes a new recipe file that matches this menu item, Tikka Masala. Let's do it in two stages. First, I will create this recipe file and commit it as a brand‑new commit. And, second, I will change my project history so that this commit and the old Tikka Masala commit get squashed together in one single commit. The first part is easy. Let's create a new recipe. I will confess my ignorance about the details here. I don't remember by heart how to make Chicken Tikka Masala, so I will just put a placeholder here. I actually did cook Tikka Masala in the past, and I think it was pretty good. My Indian friends would probably disagree on that, but hey. Good, this is done. Let's stage it and commit it. And that was the first part. Now let's finally get to the important point. I need to edit my history and do some serious surgery on it. How can I do that? Before I show you, let me make some space for a diagram. And also let me make this text a bit larger and more readable. Okay, this is where I show you one of the most powerful commands in Git. And strangely enough, it happens to be just a different flavor of a command that you already know, rebase. Forget what you know about the standard rebase though. If I do a rebase interactive or simply ‑i for short, then rebase ceases to be a normal rebase and becomes a super powerful history‑editing, Swiss Army knife on steroids. This is one of Git's weird vocabulary quicks. The word rebase doesn't just mean rebase. It evolved to mean change history. And in this case, the way we're changing history has almost nothing in common with a regular rebase. I need one more argument for this to work, and it's the reference to a commit. I can use the latest commit that was shared here, the one pointed at by the remote origin/master branch. This means let me edit history from this commit excluded, onwards. So I will edit this slice of history here. Are we ready? Let's do this. And here we are in the text editor doing an interactive rebase. We have a list of commits here, and don't get confused, the order of the commits is the opposite of the log order, from the least recent to the most recent. Here is what interactive rebase is about. What we are doing here is essentially we're writing a computer program. Here is the program. The program runs on the current commits in the history, and the output of the program is a brand‑new history. The first word in each line of the program is an instruction that applies to a commit, and it tells Git what to do with that commit. Right now, every line is a pick. It means just take this commit. So if we executed the program as it is now, Git would just compose the new history by picking all these commits one after the other, which means that the new history would be exactly like the history I have now. Nothing would change. But we do want to change this history, so let's change the program. For example, before even looking at the Tikka Masala commits, look at this commit here. It's a valid commit, but it has a weird message that doesn't really match Git's conventions. I don't know what I was thinking when I wrote this. I want to change this message. And if you read the comments down here, you will see that the instruction to change a commit's message is reword. So let me change this pick construction to reword. Notice that I'm not rewording the message just yet. That will happen later when the program runs. Right now, I'm just writing the program here. What else? Oh yes, the Tikka Masala thing, right? That was the reason why we did an interactive rebase in the first place. First, I want to change the order of these commits. I will cut this commit here, the latest one, the one where we added the recipe for Chicken Tikka Masala, and paste it right after the older commit that added Tikka Masala to the menu. And also I want to squash this commit and the previous commit together and make them one single commit. And while I'm here, let me do something even more radical. We have a few commits about guacamole here, and you might remember that these commits involve some branching and merging, and I think that's unnecessary. I would like to squash all this guacamole stuff into a single commit. So we have two squash instructions in a row. And that's it. The program is done. Let's exit and save. And at that point, Git starts executing this program. Now I will do something magic that can only be done when you are editing a screencast. I will slow down time. Right as the interactive rebase is starting, let me freeze the terminal in place for a moment. I'm going to copy the interactive rebase program here. Let's start at the first instruction. It's a pick. So Git is just picking this commit. But then the second instruction is a squash. So Git has to squash these two commits together, and that requires a decision from me. And, in fact, if you look back at the terminal, Git just stopped the interactive rebase and is asking me, I have two separate commits, and you want me to squash them into one commit, but what should be the commit message of this new commit? I can see both messages here from the original commits, plus comment lines and empty lines that are ignored. I will just pick one of these messages as the new message, and this other line goes away. And as soon as I save, Git squashes the two commits together creating a brand‑new commit. Okay, I froze time again. The third instruction is a pick, so Git can just pick this next commit and add it to history. Actually, it cannot literally add this commit to the history because a commit includes a link to its parent, and Git cannot change that link without changing the entire commit, and commits are immutable. So this is once again a brand‑new commit, a copy of the existing commit. By the way, this step doesn't require any intervention from me, so Git just does the pick and moves to the next instruction. Next, we have reword, and Git stops again. Now it's asking me to change the commit message. That's what rewording is all about. Okay, let's do that and save. Then we have the most complicated sequence of instructions so far, a pick followed by a squash and then yet another squash. This means that these three commits must be squashed all together. This doesn't seem hard. It seems to be the same as squashing two commits together, but this time we have a problem. Git stops and complains about a conflict. What conflict is this? Well, if you remember what happened a couple of modules ago, back then we had a merge in the guacamole recipe that resulted in a conflict. And we fixed the conflict by hand. Now what we are doing is we're getting rid of that merge, including the resolution of the conflict, and we're squashing everything into a single commit instead. So we have to go over that old conflict again and solve it again, this time for the sake of the interactive rebase instead of the merge. And, once again, I will open the guacamole recipe, put Tomato and Onion in a line, solve the conflict, and then I can continue the rebase as Git is suggesting here. Oh, sorry. I forgot to tell Git that I solved the conflict. Just like in a merge, I can do that by adding the file to the index. And now I continue again. There. Now we've solved the conflicts, and we are finally squashing these three commits together. We pick one commit message, and we continue. And after this, we have instruction eight, which is just a pick, and nine, which is also a pick. So Git can just copy these commits to the new history. And now that this last operation is done, Git can move the current branch to the new history and leave the old history behind for the garbage collector. And we're done. The interactive rebase is finished. If I look at the log, I can see my brand‑new history. We wielded a lot of power here. You can do a lot of stuff with interactive rebases. We've seen reordering commits, squashing commits, rewording them. But you can also remove commits by just deleting them from the program and even split a commit into multiple smaller commits. Interactive rebases are really powerful and still easy to do as you've just seen. Actually, they're so easy that I make them a standard part of my workflow. Here is what I do. When I'm working on a project, I commit early and often. I commit, commit, commit all the time, every few minutes, and most of my commits are half‑broken. They have temporary commit messages, maybe typos in the message. I don't care much about that. By committing all the time, I'm sure that if I make a mistake, I can immediately back trace to a previous state of my code. It's like having an undo operation always available as I write code. Then once I'm happy with the state of my code, and I feel ready to share it, typically, before pushing to origin, I stop and do an interactive rebase. I clean up my history. I refactor my history, so to say. It's like the refactoring that many of us do to our code after we make it run and before we commit it so that it's nice and clean and ready for production. Well, you can do the same to your Git history. You squash multiple commits together, reword their messages, maybe change their order. You make it nice, and then you push. I love using interactive rebase like that, and to fix mistakes of course. It's a very flexible, powerful tool. However, like all powerful tools, It can go wrong. Let's see what to do then.

Browsing the Reflog
We said that whenever you do anything that changes history, like an interactive rebase, for example, or even something as simple as amending a commit, Git has to copy information from old commits to the new commits. The new commits might look like the old commits, but they are not the same objects, and the old commits are left behind, and usually they are unreachable. There is no branch or tag pointing at them anymore, so they will stay in the object database for a while until Git eventually decides to garbage collect them. Now what if I change my mind and I want to recover one of those objects? This is not a common situation, but it can happen. And now it's a good time to talk about it because we just discussed interactive rebases, and, in my experience, interactive rebases sometimes go wrong. They are one of the most common cases where you might want to recover deleted objects. You might regret the interactive rebase and be looking for a way to recover those earlier commits. For example, what if I do an interactive rebase and delete a commit by mistake? Now that commit and its associated data, they are not in the history anymore. I know that they're still somewhere in the object database, but I don't know their hashes anymore, so I can't recover them. So what do I do now? Well, the good news is there is a very easy way to recover the hashes of abandoned objects. Every time a reference moves in the repository, Git logs that move. For example, when you check out a branch, you're moving the HEAD reference, so Git is logging that. Let's check out the spaghetti branch, and then let's check out master again. There, I just moved the HEAD reference twice. Git logged those movements into something that is called the reference log, or the reflog for short. And I can look at the reflog with git reflog, and then I can give it the name of a reference. Let's look at HEAD. There we are. Look at the first two lines of the reflog. It tells us that the last two changes to HEAD were from master to spaghetti and then from spaghetti to master again. And if you keep reading, you can see all the changes to HEAD that happened when I did the interactive rebase earlier on. And even earlier when I amended the latest commit, when I checked out branches, when I created the new commits, when I reset branches a few modules ago and so on. And this information comes with the hashes of the objects that HEAD was pointing to. So, for example, this commit here is not in the history anymore. It was amended and replaced by the following commit. But until it gets garbage collected, its hash is staying in the reflog, so we can still look at it, either by referencing the hash directly or by using this syntax here, which means the 15th previous position of HEAD. There it is, and if you can see it, then you can recover it. For example, you can put a branch on it and then it's not an abandoned commit anymore. It won't be garbage collected. Just to make it clear, the information in the reflog is strictly local information. This reflog belongs to this repository, and this repository alone. If I cloned this project again to another directory, then I'd get a different reflog. But when it comes to this repository, every time HEAD moves, Git is going to log it here. And the same goes for other references, such as the master branch. There, look at it moving around here, all the way back to the moment I cloned the repository from GitHub. That's when the local master branch was created. And that's it about the reflog command. Hopefully, it will make you feel a bit safer when you're using Git, because in the previous modules, we have seen a few operations that are truly irreversible and destroy data, but those operations usually destroy data in your working area and maybe the index. When it comes to the repository, you can usually recover all the objects you left behind thanks to the reflog. And talking about destructive operations, let's look at another history rewriting command that's as destructive as they get.

Rewriting Large Chunks of History
We talked about rewriting snippets of history, changing a commit here and another commit there, but sometimes that's not enough. Sometimes you want to go all in and rewrite large chunks of project history, or maybe even all of it. That doesn't happen too often. Maybe the most common reason that might happen is when you realize that you or someone else on your team committed a large file to the repository. It happened to me in the past. I committed a bunch of files, and I didn't notice that one of those was a big test file, hundreds of megabytes big. And it also got updated regularly, so I ended up with multiple versions of that useless big file across a few commits. And after a few weeks, I found out, and I deleted the file, but because of the way Git works, I still had multiple versions of that huge file in my project's history, taking up space on every developer's repository, and slowing down operations like git clone. So that's one case where you might want to revise your entire project history and wipe out that large file from every commit in your history, not just the latest ones. Another common case where you want to make sweeping changes across history happens when critical information gets into the repository and you don't want it there. The typical example is a password. Imagine a team that stores the password for the company's database in a configuration file in the project repository, and at some point they decide to make their project open source and put it on GitHub. Before doing that, they might want to step through their history and remove all traces of that password from every commit that ever happened. They don't want to make that password public. Those are two typical examples of why you might want to rewrite history on such a big scale. You may have more examples. My point here is sometimes it's not enough to change one commit or a few commits. Sometimes you need to go through all the commits in the project's history and rewrite many of them, or maybe all of them. For those extreme cases, Git used to have a command called filter‑branch. Scott Chacon, the author of Pro Git, my favorite Git book, calls filter‑branch the nuclear option of Git because it might change every single commit in your history with one command. But here is a plot twist. As I prepared this training, filter‑branch got deprecated, essentially, for a number of reasons. It turns out it's a very slow command, hard to use in many cases, and, to quote Git itself, filter‑branch has a glut of gotchas generating mangled history rewrites. That's pretty convincing, I've got to say. So this warning essentially tells me, don't use filter‑branch anymore. Instead, use this other command called filter‑repo. Right now, as I speak, filter‑repo is not yet officially a part of Git. It's distributed as its own separates thing, an optional extension. But I expect that soon enough filter‑repo will be incorporated into Git, and maybe the old filter‑branch command will be removed entirely. So I'm going to give you an example based on filter‑repo now. I installed this command through my operating system's package manager, and I'm going to use it to mess up with the history of this project in a pretty radical way. So I cloned the project to another directory for this experiment. This isn't the same repo that I use in the rest of this training. It's a fresh clone. And let's say that for whatever reason, I want to remove this file menu.txt from the project. I don't just want to remove it from the latest commits, I want to wipe out all traces of its existence now and in the past. Let's just say that menus have become illegal. And here's a quick way to do it with filter‑repo. I tell it, we're going to focus on this file, menu.txt. That's what ‑‑path stands for. But if I do it like this, that would mean this is the file that I want to keep in my project history, and everything else should be deleted. So I have to invert that selection with this other option, ‑‑invert‑paths. That means this file should be deselected and everything else is selected. So taken all together, this command means keep all files in every commit in the project history, except for this one. This one should be deleted. And after I do this, there we are, now the file has been removed from each and every commit. If I look at the log and earlier commits like this one, for example, I can check it out. And there is no trace of menu.txt here. It's gone. And of course, now the entire project history has been rewritten, so everybody on the project will have to set up the repo from scratch. This is the ultimate conflict. They probably have to delete their local repository altogether and clone this repository again to get the updated project history. But sometimes you have to resort to those extreme measures. This was just about the simplest possible example of what filter‑repo can do. It's a very sophisticated command with many options that you can read in the documentation when you need them. I think I gave you the gist of filter‑repo. It's the new nuclear option, as Scott Chacon said, and you should definitely handle it with care. And now, after this very destructive command, let's close this module with a very non‑destructive, gentle way to rewrite parts of your history.

Reverting Commits
I insisted a lot in this module about the fact that changing history is something that you should be careful about. Don't change shared history, and so on. Maybe I was even a bit schoolmarmish about it. But I want to close the module with a command that's more gentle. It's safer than the destructive commands we've seen earlier on. It doesn't destroy data. It doesn't go back and change the existing history. It's still about fixing history, but it does that without changing any commit. It just creates new commits. First, let's move to another branch, the lisa branch, and let's look at the log. You might remember this commit here, it's an old one, one of the very first commits in this project. And it's wrong, in the sense that it doesn't respect the rules of the project. If we look at it, we can see that it added a new item to the menu, cheesecake, but it doesn't add the matching recipe for the cheesecake in the Recipes folder. See? No cheesecake recipe here. We had the same problem for the tikka masala commit, and we fixed that one with an interactive rebase. But back then, we decided not to touch this other commit because it's been shared. It came before the latest update to the remote lisa branch here. I want to fix this situation for good. Let's recap. I want every menu item to have a matching recipe, but in this case, I have the item, but I don't have the recipe. So, I can either finally add a recipe for the cheesecake, or I can remove the cheesecake from the menu altogether. And after thinking about it, I decided that I would rather do the second. I want to delete the cheesecake from the menu. Delete this commit. How many ways do we have of deleting it? One way would be to use an interactive rebase. We could make a big interactive rebase starting from the very first commit in the history, and in that interactive rebase, remove this commit that adds the cheesecake. This is exactly what I don't want to do, however, because it would create an entire line of new commits, an entire new history, and it would change shared history. So, no, let's not do that. And because we don't want to change history, don't even think about using filter‑repo, either. Here is a safer way to do it. Just edit the menu, remove this line from the menu, and create a new commit. The old, broken commit stays in the history, but at least it gets fixed later on. I can do that, but instead of doing it by hand, so to say, by manually editing this file, I can ask Git to do it automatically with a command called git revert. All I have to do is to say, look, Git, I want to revert this commit here. What happens is that Git automatically creates a new commit that contains changes that are exactly the opposite of the changes in this original commit, which is very useful if the changes are not just one line, as in this trivial example, but, say, hundreds of lines of code. I can even revert multiple commits at once, but in this case, it's just one small one line commit. And indeed, I have a new commit here with a nice message that explains exactly what is happening. And the only thing it contains is the reverse of the cheesecake commit. It removes this line. By the way, the reason why I did this on the lisa branch and not on the master branch is that I tried doing this revert on master while I was preparing this training, but I got a conflict there because the menu file has been changing so much on master since this old commit that even removing a single line caused a conflict. So I didn't want to show you yet another conflict fix. In the interest of keeping this example as simple as I could, I just did it on another branch. And now I can once again check out master, where this revert never happened and just live with that cheesecake in the menu. It doesn't matter, really. I hope I made my point. One last thing about revert. I told you that revert reverts changes in a way that's completely safe. in the sense that it doesn't touch existing commits. It just adds new commits. But this behavior has a catch. All that a revert can do is revert your data by writing the opposite data. But it can't a revert your structural changes to history. For example, if you try to revert a merge, then revert can remove all the data that was added by the merge, but it cannot remove the merge commit itself. The merge is still there. And this can cause some confusing situations down the line, especially if you try to merge again after that. Now we're getting outside the scope of this training a little, so I won't go into more details. I will just mention this issues quickly as a general warning. Be careful when you revert merges. It's a special case, and you should be aware of how to deal with it specifically. In other words, don't think of a revert as if it were a generic undo operation in Git. In fact, the closer that Git has to an undo operation is probably reset when you use it to move a branch back to where it was in the past. Revert is much more narrow in scope. All that it does is write a new commit with new data that is the opposite of existing data. And that's it. In this module, we focused on how to change your history and fix mistakes. Congratulations, you are a Git history surgeon now. This module has been chock‑full of information, but if you look back, we introduced just a handful of commands, or sometimes new options to commands we already knew. Git commit ‑‑amend to modify the very latest commit, git rebase ‑i to do interactive rebases, git reflog to access the reflog and fix seemingly irrecoverable mistakes, git filter‑repo to rewrite entire swaths of history, and git revert to create new commits that revert changes in previous commits. And that is a small, but powerful tool set to edit history. With that, we can close the second part of this training. We focused on project history with two modules, one on exploring history and one on changing history. And we can move on to the last part and the last module of our training.

Finding Your Workflow
Git Workflows
And welcome to the last part and the last module of Mastering Git. So far in this training, we've made an implicit assumption. We assumed that you were working along on your own Git repository, and you were never sharing stuff with other repositories. We kind of paid lip service to the outside world sometimes, like when we said Golden Rule: don't change stuff that you've shared with other people. But mostly, we ignored other people and other repositories as if they didn't exist. But of course, the entire point of Git for most people is that you use it to share information with other developers, and you have a lot of options to share that information. In fact, the Git toolset is so powerful and flexible that you might feel like you have too many options sometimes, and that can cause a few headaches when multiple people come together to work on a shared project. To avoid those headaches, you and your team need to take a few decisions about how to work together and about three things in particular. First, you should decide which kind of distribution model to adopt. How many repositories do you have, and how do they interact? Do you maybe have one shared repository that is visible to all developers? Maybe many shared repositories? Can all developers push their commits to the shared repository, or do some developers have read‑only access? And so on. Also, you need take decisions on branches. Which branches do you have in your project, and what do you use them for? Which branch do you use to integrate your work with the work of other developers? Which branch do you use to package a release from and the like? And finally, you need to define more general constraints for everybody who contributes to the project. These are all those additional rules that don't really belong to either the distribution model or the branching model like, for example, when you get a bunch of new commits from a remote, should you merge those commits into your own repository? Or should you rebase them? Can you push your code into a remote if the tests are broken, or should you make sure that the code is stable and working before pushing? And so many other possible decisions. So distribution model, branching model, and constraints, these three things together define what you can call a distributed workflow. And that's what this last module is about, distributed workflows, how to use Git in practice on a real‑world project. This module is a bit different from the rest of the training. Workflows are a social topic more than a technical topic, so you won't get much in the way of technical information here. What you will get is a vocabulary to discuss workflows with other people, like a set of patterns. In a way, you can think of this module as Git workflow patterns. To understand this module, you have to know a few things about distributed Git. Not much, just the basics. In particular, I expect that you know what a remote is, and you should be familiar with the concepts of pushing to a remote and pulling from a remote. If you've ever worked on a distributed Git project, even your own project on GitHub, then you already have that knowledge. If you're not sure about these topics, then you can refresh them by watching the last module of the How Git Works training. Let's start talking about workflows.

Selecting a Distribution Model
The first thing that you should decide when you set up a Git workflow, the decision that influences most other decisions down the line, is your distribution model. The simplest distribution model is probably the peer‑to‑peer model. Imagine that you are a developer in a team of three. All of these repos contain the same project of course. They were originally cloned from each other, but they do diverge as the developers commit to their own copies of the repo. The trick here is that each developer can see the other developers' repos as remotes. So if you are Nick in this diagram, and you know that Ralph here has some new commits that you want, then you can just go out and pull those changes into your repo. And if you know that there is new stuff in Jane's repo, then you can pull in those changes as well, and the other developers can do the same. So changes spread around like that. Now it's true that the peer‑to‑peer model is simple, but it's not necessarily easy, specifically because no repo is any more important than the others. That's the definition of peer‑to‑peer, right? And it can become a challenge when you want to do something as simple as releasing the project, for example. Then you need to decide which repo to release from, and each repo might contain slightly different things, so it might be hard to decide which one is right, so to say. And if that can be hard with three developers, it can be much harder with four or five. For this reason, unless your project is literally two people in a room, you probably want to take a few additional decisions up front. In particular, you might decide that one of the repos is special. It's blessed as they say. This blessed repo is accessible to everybody in the project, both for pulling and pushing. So you can commit data to your own local repo, but you also have a remote that is pointing at the blessed repo, and you can push data to that remote. Most developers call this remote origin by convention because that is the default name that Git gives to the remote that you clone the project from. The blessed repo is often a bare repo, which in Git terms means that it's just a repository without a working area or an index. Nobody's working on that machine directly. It's just used to share data and maybe to host the build machine, the system that runs the unit tests, packages releases, and so on. So let me put a robot in there to mean that this is the shared build machine repo, not a repo that a human is working on day in and day out. Now in this model, you don't access your teammates' repos and see their data, like in the peer‑to‑peer model. Instead, you only care about the data on the blessed repo. That's the official state of the project, so to say. So everybody will pull his or her data from the blessed repo, and a developer who has new commits, like Ralph in this case, must push those commits to the blessed repo so that the rest of the team can pull them. Everything is centralized. Indeed, you could just call the blessed repo the server. And the model itself is often called the centralized model. Essentially, the centralized model is the same model that people use with non‑distributed versioning systems, like Subversion or Team Foundation Server. Most companies these days replaced those versioning systems. They switched to Git for a number of reasons, but they do not necessarily change the distribution model. Many of them are still happy to use a pure centralized model. Then there is yet another model that is a twist on the centralized model in that you still have developer repos, and you still have a central blessed repo, but most developers cannot write to the blessed repo directly. They cannot push to it. They can only pull from it. Only one person or a few people in the project have that power, to push things to the blessed repo. They're usually called the maintainers. In this example here, only Nick can push to the blessed repo, and the other developers, the ones who don't have push access to the blessed repo are sometimes called the contributors. I gave them dotted arrows to the repository to mean that those are read‑only or pull‑only connections. So the team still uses the blessed repo as a communication hub, and when a commit is on the blessed repo, then it's official, and everybody will pull it eventually. Now let's say that Jane has new commits to contribute, but she's not a maintainer. She doesn't have the power to push to the central repo. So how can she contribute those commits to the project? The trick here is that the maintainer can also see the contributor's repos. So Jane can say hey Nick, please pull my changes, see if you like them, and feel free to push them to the blessed repo. Maybe Jane can just walk to Nick's desk and tell him about the changes, or maybe Jane and Nick don't even share the same office, so she must let him know in some other way, for example by sending him a message that says look, I have new commits in my repo that you might want to pull. This message could be a mail, or it could be managed by some kind of service, such as GitHub, and it's usually called a pull request. Now Nick got the pull request, so he knows about Jane's changes. If he's okay with those changes, he can pull them into his own repo, solve any merge conflicts he might have, and then push them to the blessed repo. And now Jane's changes have been made an official part of the project, and other contributors like Ralph can also pull them. The pull request is the defining mechanic of this model, so you can call it the pull request model. Git has a few features that make it easier to prepare a pull request. There is actually a git request‑pull command. But actually sending the pull request, that's not a Git feature. You have to use old fashioned mail or some other means of doing that. And that is one of the reasons why services such as GitHub are so popular because they automate the sending of pull requests, so much so that the pull request has become the defining feature of GitHub. And the pull request model has become the most popular model for open source development. The most significant advantage of the pull request model is that it helps manage trust. You can get contributions from trusted sources, like Nick in this case, and also from less‑trusted sources, like Ralph and Jane. And this is necessary in open source projects, of course, because in open source, anybody on the internet could be a contributor, and you probably don't trust the entire internet to push directly to your project's repository. So you can have a few trusted maintainers and any number of contributors. But this trust management concept also comes useful for closed source projects whenever you have a project where you don't want to grant push access to the main repo for the entire development team. In that case, you can appoint an internal maintainer, maybe call her an integration manager. And the developers must ask to this person to pull their changes. One last thing about the pull request model before we move on. If you look at projects on GitHub, they use this model in a slightly more complex variation. The added complexity here is that on GitHub, and other services like GitHub, all these repos are actually in the cloud. So the developers are not working directly on these repos. Instead each developer has two repos, a private repo on their own computer and a public repo in the cloud. So the concept is pretty much the same as the basic pull request model, but the mechanics of pushing, pulling, and the like are slightly more involved. If you want a detailed explanation of this particular flavor of the pull request model, then you can find one in the last module of the How Git Works training, so I won't to repeat myself here. Instead, I will tell you about one last distribution model. This one is like the pull request model, but it takes things one step farther. In the pull request model, you have one blessed repo for the entire project with one or more maintainers who can access it. Here I'm showing the blessed repo, and Jane is the maintainer. In this other model however, the project is split into subprojects, and each subproject has its own blessed repo and its own maintainer or maintainers. And then there are the general contributors. I must admit that I'm reusing the graphics for the contributors a bit here, but that's okay. You know what they say about hipsters all looking the same. I also changed the style of this diagram a bit. I didn't draw any arrows to avoid making it too cluttered. Instead, just keep in mind that in this model, anyone can pull data from pretty much anywhere, but only the maintainers can push data to the blessed repos. So here we have three levels. You might have even more if you want to have multiple levels of subprojects, and there are pull requests, of course. Regular contributors generally send PRs to the subprojects, and the subproject maintainers send PRs to the main project maintainer. And everybody pulls data to their own repos. So data spreads upwards in response to pull requests, and it spreads downwards as people pull it from the upper levels. This model is used sometimes in very large projects that are too big for a single team of maintainers to handle. The classic example is the Linux kernel. In Linux, the subproject maintainers are called lieutenants, and the global maintainer is called the benevolent dictator. So you can call this model the dictator and lieutenants model. It's also popular in large enterprise companies who have huge projects or sometimes just really like hierarchies. So to recap, we've seen four distribution model, the peer‑to‑peer model, no blessed repo, no centralized control, it's purely distributed. The centralized model is like traditional, non‑distributed configuration management. You have a central blessed repo, a server, and everybody pushes to that server. The pull request model still has a centralized repo, but most people can only pull from it. Someone who has the rights to push to the central repo must pull changes from the other repos in response to some kind of pull request. And the most complicated model is dictator and lieutenants where you have multiple subprojects, each one of which is like a pull request model project and then a higher level or maybe even multiple higher levels of integration across the subprojects, also based on pull requests. One important point to close. Remember that these are patterns. They're not recipes for how to structure your own project. So you might want to have a mixed approach in your own projects. Many projects do that. Maybe most developers on a given project work in a centralized model except for that offshore development team who's following the pull request model and sending pull requests to the internal developers. Or maybe you work centralized except that sometimes two developers are working together on the feature, and then they choose to synchronize their repos as if they were working in a peer‑to‑peer model. That's fine. You don't need to stick to a model religiously. Use whatever works for you. These names I gave you are just labels. They are useful to conceptualize and discuss your options. So, for example, you can easily say we are using a centralized model in here, and your teammate can reply maybe we can try a pull request model. That's the point of patterns.

Designing Branches
Right after the distribution model, the second important element of a shared Git workflow is some kind of policy to manage branches. Every project has such a policy, whether or not it's an explicit one. So let's look at a few common patterns for branches. First, let me make a distinction between stable and unstable branches. A branch is stable when the tip of the branch always contains a working version of the project. That is, the tests are green, there are no known showstopper bugs, and so on. In theory, you could just package whatever is on a stable branch and release it. I will use this green checkmark to mean working version of the project. So even if someone adds new commits to the branch, for example by pushing them, the tip of the branch still contains a working system. In an unstable branch, you don't necessarily have that. When somebody pushes one or more new commits to the branch, the tip of the branch might be working or it might be broken. There is no guarantee. Now that we have a definition of stable branch and unstable branch, let's go back to the typical branches in a project. Almost every project has a main branch that you use to put everything together. This is usually the branch that people consider the most important branch in the system. People might work on other branches, but the other branches tend to branch out from this main branch. They tend to stay reasonably aligned with the main branch, and they ultimately tend to flow back into the main branch. I'm using different colors for the commits here to make the segments of branches stand out from each other. The colors don't have any specific meaning. This all‑important branch, the one that I drew in red in the picture, is usually called master. But whatever its name, you can call it the integration branch because it's the place where things come together and usually the place where you solve the conflicts that you might have when things come together. People also call it the main branch or the mainline sometimes or the development branch or just the master branch. But we have to pick one name, so I will call it the integration branch. Now is the integration branch stable or unstable? Well, this depends on the project. In most cases, the more stable the integration branch is, the better. This is the central branch in the project after all. Mostly everybody's working on it, and nobody likes to work on an unstable code base. On the other hand, it's hard to keep a branch stable when you're constantly integrating your stuff over it. So in practice, most projects aim for a mostly stable integration branch. Actually, that's what build machines are for. The primary job of a build machine with Jenkins or some other kind of automated build system is it checks whatever is on the integration branch, probably it runs the tests on it, and it tells you whether the current build is working or broken. Another important question on most projects is which branch do you release your software from? At some point, you have to deploy the software to a web server or maybe package it and distribute it on an app store or whatever your distribution method is. Some projects do that from the integration branch, maybe putting a tag on specific commits to mark the points where they release form. Other projects prefer to have a separate branch for releases, a release branch. What's the point of having a separate branch for releases? Well, there are a few advantages, but the most obvious one is that you can keep the code in the release branch more stable than in the integration branch. For example, you can merge the integration branch and the release branch only after checking that it's stable. Essentially, a separate release branch provides a buffer to keep releasable changes separate from not yet quite releasable changes. I talked about a release branch, but in some projects you have to maintain multiple releases at the same time. And in that case, you might have multiple release branches. Maybe they branch out from the integration branch at the moment when the release happens, and then they proceed onwards. If you have to add specific documentation to fix a bug on release 1.1, but not release 1.2, well, you have a specific release branch to work on that. There is another type of branch that is a staple of many, many projects. Let's say that you have two developers working on two different features. In some projects, they would both push directly to the integration branch by using two different colors for the two features here. With this of way working, you can have very frequent integration, which I personally like in general. But sometimes it can be hard to do right. And besides, your history becomes hard to make sense of because the commits belonging to different features can be all interleaved as in this case. And with this approach, you also have to live with half‑developed features on the integration branch most of the time. So, for example, right now, maybe the green feature is done, but the blue feature is still ongoing, so you have half a blue feature on the integration branch. One possible alternative is to create a new branch for each feature, so, for example, one branch for feature A and one for feature B. And as people start pushing to those branches, they diverge and progress in parallel until they eventually flow back into the integration branch. In this case, we are integrating by merging, but you can also rebase if you wish. And after this, you can either delete those branches or leave them there for future reference. These branches are called feature branches. Some people prefer the name topic branches, which is also good. I will use feature branches here just because it seems to be a tad more common. A lot of projects use feature branches. We've seen a few styles of branches already, and you might think that once you have an integration branch, maybe one or more release branches, and a bunch of feature branches, you have all you need. But there is an additional issue that can result in even more branches for some projects. Imagine that you have a situation like this with a couple of branches. Let me give them names so it's easier for us to reference them. It doesn't matter which branches they are exactly. What matters is that these branches have been diverging for a while. But branch 1 has one commit, this red commit here that you also want to have on branch 2. You don't want any of the other commits from branch 1 in branch 2, just this one commit. So how do you do that? How do you copy a single commit from one branch to the other? Well, Git has a special command that is just about that, and it's called a cherry‑pick. You can cherry‑pick a single commit or a few specific commits from a branch and copy them on top of another branch. Problem solved except for one detail. A cherry‑pick is just like a tiny rebase, it's the rebase of a specific commit, and some projects don't like rebases. They want to use merge everywhere instead. So cherry‑picks are not an option for merge‑based products. How can you still have the same commit in two separate branches without cherry‑picking? Well, there is another solution to the problem. When you want to have the same commit shared by two separate branches, just have a third branch, and you place that shared commit on the third branch, and then you merge the third branch into both the first and the second branch like this, and that's it. Now you have one place to put shared commits, and you have just merges, no rebases. This is actually a common situation, especially when you have a bug fix. Let me change the names of these branches. You have a release branch and an integration branch, and they've been diverging. You just found a nasty bug in your latest release. You want to fix it immediately and prepare another release. But you also want the same bug fix to be on the integration branch so that you'll have the bug fixed in the next releases as well. What you can do in this case is to put the bug fix on another branch called, say, hotfix and then merge hotfix into both the release and the integration branch. Now this fix is in the history of both branches. Best of both worlds. You kept the branches separate, and you still shared data between them. There are also other use cases for a decoupling branch like this, but bug fixes are a common one. So don't be surprised if you see projects that have so‑called hotfix branches for this kind of stuff. So let's see. We've talked about the difference between stable and unstable branches and then about different branching patterns, integration, release, feature, and hotfix branches. There can be more. You will probably come up with a few specialized branches of your own, but these ones are common enough that they deserve to be called patterns. You'll see them coming up again and again in a number of different projects. And that's it about branching models. Let's look at the third and last component of a distributed workflow.

Setting Constraints
The third and last element of a distributed workflow after the distribution model and branching model is a set of constraints. I'm using constraints as a catchall name for all the stuff that doesn't clearly belong to either the distribution model or the branch model, rules if you wish. Every project I ever worked on had its own rules, sometimes very specific and even surprising sometimes. So I cannot show you any specific patterns here because there are so many possible constraints. But I can come up with a few examples of constraints that I've seen in real‑life projects. I've already mentioned one of the most common examples, the choice between merges and rebases. In some projects, people prefer to always merge. So if you just finished working on a feature branch, for example, you merge it into the integration branch. On the other hand, some projects would rebase the entire feature branch on top of the integration branch. And the two policies have different tradeoffs, which are often subtle, and, well, they're off‑topic here really. I talked about those trade offs in the How Git Works training. Once again, I don't want to repeat myself. My point here is it's up to you whether to use merge or rebase. But whichever you choose, you might want to be consistent about that. You probably don't want half the team using merge and the other half using rebase. That would be confusing. So this tends to be a project‑wide decision. You might want it to be an official constraint. Another question that is important to some projects is who can do what to which branches? Maybe some developers are expected to only commit to some branches and not others. Or maybe your project is using tags on the release branch to mark a new release, so only the person in charge of releases can tag the release branch. Other developers should avoid doing that even though, technically, they could do that. Here is another example. This one is not necessarily common, but it's interesting. I was working on a project with a lot of developers doing continuous integration and the build machine running the unit tests on the integration branch. Every now and then, the tests could be broken, they could be red. So we had a rule in place that said if you see that the build is red, then stop pushing to the server. Wait until the person who broke the build realizes that there is a problem so that she can fix the build and make it green again. Otherwise, if you keep pushing, you will make this person's job really hard. You will change the code under her feet and trigger more builds. So that was the constraint. Don't push when the build is red. Wait for it to be green again instead. The interesting part was that sometimes people forgot to check the build machine before pushing, so they violated this constraint even though they didn't really mean to. So the team did something smart. They used a feature of Git that is called hooks. It's basically a way of running a script whenever a specific event happens. So they had this hook on the server that started a script whenever somebody initiated a push to the server. And the script checked the build machine. And if the build was red, the script gave you a warning and the opportunity to abort the push. I think that's a good example of how to help you respect a constraint with some simple automation. Here is another decision which some teams choose to regulate. What kind of history refactoring should you do on feature branches before you merge a new feature into the integration branch? Some projects like to squash the entire feature into one single commit, for example, while other projects prefer to keep small, highly granular commits in the mainline history and so on and so forth. I don't want to keep blathering here because that might suggest that these are all the areas where you are supposed to take decisions. Actually, in your project, you might not care about these matters at all, and instead you might care about other things that I wouldn't even think about. I just wanted to come up with a bunch of examples. The point I'm making is most distributed workflows do have a few constraints, and there are so many diverse constraints. So it's good if you make your projects' constraints explicit when you describe your workflow. So now we have discussed the elements that constitute a Git workflow, a distribution model, a branching model, and a set of constraints. How do we combine these elements together into a workflow? To answer that, let's first look at one popular real‑life example of a distributed workflow.

“We Need to Talk About GitFlow”
If you look for git workflows on Google, it's likely that you will find this blog post among the first results. It's a post by Vincent Driessen, a Dutch developer. He posted it in 2010. Back then, Git was starting to spread everywhere in the software community, and many people were overwhelmed by all the possibilities that Git offers. So they were looking for advice on how to work with Git. And many of them found that advice in this blog post. It describes the workflow that Vincent and his team used. It's a very specific way of working that became known as GitFlow. We don't need to describe it in detail here, but it's worth taking a quick glance at it. In a nutshell, GitFlow is based on the centralized distribution model. Every developer can push to a central blessed repository. But GitFlow also encourages developers to exchange data directly when appropriate. So this is a mixed distribution model, centralized with peer‑to‑peer elements. The core of GitFlow is its branching model, which is very detailed. It defines a number of branches. To understand GitFlow branches, you can broadly partition them into two groups, the unstable branches used for development work, and the stable branches, used mostly for releases. Amongst the unstable branches, you have an integration branch called develop and the feature branches, one per feature. In the second category, the stable branches, you have another integration branch called master. This is different from develop because develop is not stable in general, while master must be stable. So you only merge develop into master when you know that you have a working system. And then you have the release branches, a separate one for each release. And you also have a hotfix branch. And then there are the constraints, quite a few of them. They mostly define which branches can branch off from which other branches and which branches can merge into which other branches. By the way, I say merge because it's always merging, never rebasing. GitFlow believes in maintaining a truthful and trackable history. You are not supposed to change that history by rebasing. And then there are more rules about what to tag and when and so on. GitFlow also gives you the naming conventions that you should use for some of your branches. All these constraints mean that GitFlow is pretty tightly defined, and this procedure has some definite advantages. For example, you can find Git extensions on the internet that provide specific commands for GitFlow. Operations like creating a feature branch or merging a hotfix are very tightly defined so they can be automated. At the very least, the precision makes for very good documentation. These are additional reasons why GitFlow became popular. In any case, it is very popular. It became the go‑to Git workflow for many people, and many teams just adopt it as is. Now I have a pretty strong opinion about this. In a sentence, I suggest that you don't just take GitFlow and start to use it. Now please don't think that I'm a GitFlow‑hater. I don't think that there is anything wrong with GitFlow. It's as good a workflow as you can have, and it also includes a lot of sound versioning practices. What I am recommending against is just picking up and using any precanned workflow. And many teams do just that was GitFlow, especially large companies. They go to the internet, they find GitFlow, and they make it mandatory for everybody. But there are many projects for which GitFlow is not the optimal solution. For example, projects that can avoid all those complex branching rules. Imagine that your product is a web app rather than a packaged application. So you only maintain one production release that time. Then maybe you don't need the multiple release branches. You can get away with one. Or maybe some of the rules in GitFlow might be counterproductive for you. Maybe you are on a cutting‑edge project that does continuous deployment. It deploys to production every time someone integrates a stable feature, and all those branches actually slow you down. They introduce too much indirection from integration to deployment. Some of the constraints in GitFlow can even encourage damaging behavior in projects that don't fit those constraints. For example, GitFlow mandates features branches, and you are supposed to merge a feature branch into develop once the feature is done. But some big legacy projects can have dozens of features in development at any given time, and each feature can take months to be implemented, and it tends to contain a lot of code. So when this process is done and you finally merge a feature in the develop branch all at once in a single big merge, that can cause huge conflicts for other people in the team. In such projects, I would encourage people to integrate more often. I'm not a big fan of feature branches to tell you the truth. I generally prefer to do more frequent integration when I can. But some teams respect this GitFlow constraint to the letter and end up having very long‑lived feature branches. Well, you catch my drift. GitFlow is great. It's a very well‑designed workflow. But this doesn't make it the perfect workflow for any project. Even the author of the original GitFlow post put up a note at some point that said basically don't use this as a solution to every problem. It was never meant to be. When we are talking about workflows, we are talking about people, the way they work. And when it comes to that, one size definitely does not fit all. Context is everything. So once again, don't just use GitFlow. So what should you do instead?

Growing a Workflow
How do you come up with your own workflow? Doing that is more art than science, so there are no hard and fast rules, no recipes. But I can give you one important guideline here, and that is avoid the temptation to just sit down and design a workflow. That approach tends to generate an over‑designed, over‑complicated workflow that still doesn't address the specific problems that your project might have in the future. Even if you are very smart, it's still hard to forecast every possible situation that your project will get into. And even if you're quite experienced, that does help, but it might still not be enough because every project is different, often in subtle ways, so your past experiences might actually mislead you. So instead of designing a workflow, you should strive to grow your workflow. Start small. I'm thinking really small here, something like this. The details don't really matter here. This is just an example of what I mean by small, a distribution model, the centralized model in this case, but pick whatever fits the size of your project, a simple branching model, no complexities, unless you know for a fact that those complexities are needed, and a handful of constraints. Three constraints like in this example could actually be enough. You can always add more constraints later. Maybe you might need more than this if you have a big project or if you work in a very structured traditional organization. But in any case, try to stay on the small side. You might find that your very simple workflow is almost all you need actually. And when it proves insufficient, and you find out that you need something more complex, well, just add that complexity as you go. You can add constraints, you can add new branches, incorporate ideas from other distribution models. That's what I mean when I say grow your workflow. Make it evolve to fit your project. Only add rules in response to real problems that become visible, and always be ready to remove rules that are not having a positive impact on the project. A gentleman named Dee Hock said something that kind of relates to what I'm suggesting here. Here is that quote. If you want complex, intelligent behavior, then come up with simple principles because simple principles give people the space they need to be flexible and smart to solve the unexpected problems that arise in a complex environment. By contrast, complex rules and complex regulations create bureaucracy. They create an environment that is unfit to problem solving. Dee Hock was the founder and CEO of the Visa credit card company, so he proved firsthand how powerful this idea can be. Most of us will never solve the kind of complex problems he solved. But I still try to keep this quote in my mind when I'm tempted to be clever and add, you know, rules and procedures to my teams' way of working and my own way of working. Keep it simple. You will rarely regret it.

Thinking in Git
We have reached the end of this training, so here is a quick wrap up of all that we talked about. In Git's worldview, the world is divided into four areas. The most important area is the repository where your data stays safe and versioned. The working area is your own private area where you interact with your data. The index decouples the working area from the repository, giving you a lot of flexibility in deciding when and how to move data to the repository. And the stash is like a clipboard that you can use to stock data temporarily as you juggle the other areas. Most commands in Git can be understood in terms of two elements, how they move data across the areas and what they do to the repository in particular. If you understand those two elements, then you probably understand the command. We looked at the basic commands under this light, the ones that you use for a basic local workflow, such as add, commit, and checkout, and we paid special attention to less common commands, such as reset, which are more specialized, but can be useful in a number of situations. These topics were the subject of the first part of this training that spanned four modules. The second part of the training was about a thing that a master Git user does a lot of, that is interact with history, which means browsing history to make sense of it with commands like git log, git diff, and git blame. And it also means actually editing history, refactoring it, with techniques like interactive rebases, amending commits, and the git revert command. And it even means using tools like the ref log to audit history and recover from the odd destructive mistake. We had two entire modules dedicated to history surgery. Finally, this module stood alone as the third part of this training about workflows. What are the elements and common patterns of a distributed Git workflow, the distribution model, the branching model, and the additional constraints. And we said that you should not just design a workflow. Instead, you should grow a workflow to fit your own specific situation. And that was it. We have reached the end of Mastering Git. Of course, there is a lot that you can still learn. There are so many commands and features and options that I didn't mention because they did not fit the flow of this training. But now you have what counts. You have the model. You understand how Git sees the world and the basic toolset that Git gives you to manipulate that world. So you are thinking in Git now. You know how to cook this onion, to use the metaphor I used in the beginning, and that's enough knowledge to move on on your own or move on to the next training in the Git path here, on Pluralsight. Congratulations. I had a lot of fun preparing this training. I hope you had just as much fun going through it. So thank you from Paolo Perrotta, and see you in the next training.
