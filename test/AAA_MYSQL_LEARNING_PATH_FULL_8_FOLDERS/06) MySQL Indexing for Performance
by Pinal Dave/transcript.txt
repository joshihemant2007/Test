Performance is one of the most essential aspects of any application. Everyone wants their server to perform optimally and at the best efficiency. Indexes are the silver bullets for Performance. In this course we will gain an understanding of the basics of Indexes and further explore practical tips and tricks for performance tuning.

MySQL Indexing for Performance
Introduction
Welcome to MySQL Indexing for Performance course. This is Pinal Dave for Pluralsight. We'll be walking together on the journey to learn MySQL Indexing. Indexing is considered to be a complex subject. I promise that I will make it as simple as possible for everybody to learn indexing. Here is a scenario from a typical workday of any developer. When any application gets slower, a manager runs to a developer expressing the queries are running slow on a server. A typical expression from the developer is create an index on the slow running queries. Honestly, this is a very tricky answer. If you ask me, indexes are double-edged swords. If you use it properly, you are guaranteed to get optimal performance. However, if you implement it incorrectly, you are once again guaranteed to get a worse performance. More than a technique, I like to call indexing an art. Just like any other art, you need to practice a lot with indexes to master it. In this course, first we'll be covering various different types of indexes. Right after that, we will learn with the help of lots of demonstrations how to get high performance from any query with the help of indexes. A beautiful piece of art has to be maintained if you want to preserve the masterpiece for a long time. Just like that, we have to maintain the indexes to get optimal performance forever for any application. Before we end this course, in the last module we will go through the checklist for getting optimal performance from any query with the help of indexes.

Types of Indexes
Introduction
Hi, this is Pinal Dave for Pluralsight, and in this module we will discuss various different types of indexes. There are different types of indexes in relational theory. Each index is designed to achieve a different goal. Old indexes, which we are implemented at the database storage level instead of database server level, hence, each index is different from each other and there is no single way to implement indexes in MySQL. In simple words, the inner workings for each index are quite different from each other. In this module, we will take a look at all the different types of indexes which MySQL supports and their advantages, as well as disadvantages. Before we start the module, we'll discuss about InnoDB and MyISAM storage engines. Later, we'll understand how B-tree indexes are implemented and their advantages. Right after that, we'll discuss clustered indexes, their advantages, disadvantages, and building blocks of clustered indexes. We will also understand how secondary index B-tree works. In some engines, it is also known as non-clustered indexes. Hash index with MySQL is also a very interesting concept. We will also understand various limitations of hash indexes, how adaptive hash indexes work, and what are the inner workings of hash indexes. We will end this module with the discussion of other index types.

InnoDB vs MyISAM
There are many different types of storage engines available for MySQL. Index structure, performance, and features are dependent on the storage engine used under the hood of MySQL installation. Well, when there are many different storage engines it is practically impossible to discuss all of them. However, in the industry you will mainly hear about two major storage engines, InnoDB and MyISAM. Before we continue learning about indexes, let us compare both of them over here. InnoDB is the default storage engine as of MySQL 5. 5. That means when we install MySQL 5. 5 or a later version, the default storage engine is InnoDB. However, before MySQL version 5. 5, the default storage engine was MyISAM. If you go to the real world, you will see lots of installations are using InnoDB as a storage engine and lots of installations are still using MyISAM. I personally see lots of projects where people are migrating from MyISAM to InnoDB as a default storage engine. You may ask why the industry is moving from MyISAM to InnoDB. Well, both of the storage engines have their own advantages and disadvantages. It totally depends on the business to decide which storage engine they want to use for their application. InnoDB is ACID complaint. ACID stands for Atomicity, Consistency, Isolation, and Durability. This is very crucial for data integrity. MyISAM is not ACID compliant. InnoDB also supports transactions like rollback and commit. This gives the user better control of the data and its flow in the replication. On the other hand, MyISAM is a non-transactional storage engine. MyISAM supports table level locking whereas InnoDB supports row level locking. InnoDB has more granular control of your data locking. In the case of InnoDB, row data stored in pages is as per primary key order. That means whatever is your primary key, based on that your data will be stored in the data pages, whereas in MyISAM, there is no particular order for data storage. As InnoDB is ACID compliant, it also supports foreign keys and other relationships whereas MyISAM does not support any relationship constraints. MyISAM supports full text search. InnoDB does not support full text search. Hence, there are no full text indexes in InnoDB. Well, you can clearly see from this table why MySQL has changed their default storage engine to InnoDB from MyISAM. All the applications in the industry made for ACID compliant are now switching to InnoDB. However, if your application is independent of relationship transactions or does not require atomicity, consistency, isolation, and durability, MyISAM is a great feed. As this is as an indexing course related to performance tuning, we will be using InnoDB as our default database for all the examples, as well as theory. We will discuss MyISAM where and when required, however, our default assumption is that our storage engine is InnoDB.

B-Tree Index
When you hear in the industry the word index, they often mean a B-tree index. Most of the MySQL storage engine supports B-tree indexes. In B-tree index, each leaf node contains a link to the next node for the fast range traversal. All the values are stored in order and each leaf page is at the same distance from root level. As I mentioned earlier, every storage engine has a different implementation of B-tree indexes. For example, InnoDB storage engine uses B+Tree indexes. In a B-tree, you can store both keys and data in the internal leaf nodes. However, in B+Tree, you can only store the data in a leaf node whereas internal node whereas internal node will contain the pointers. The key advantage here in B+Tree is that intermediate node does not contain data, hence, more keys can be fit into the pages in intermediate node. Hence, the size of the entire B+Tree is much smaller than B-tree and more data can be stored into memory. Therefore, in the case of B+Tree, more numbers of indexes can be stored in the memory. Additionally, the leaf node of B+Trees are also linked, which increases the performance of the full scan or grand scan. Now let's understand a few of the key advantages of B-tree index.

Advantages of B-Tree Index
Advantages of B-tree index. The major advantage of B-tree index is that it speeds up data access. The storage engine in B-tree traverses from root node to leaf node with the help of pointers. In simpler words, to access any data engine does not help to traverse in that table. It can just traverse a few nodes in the B-tree index structure and can get you necessary data much faster. B-tree index increases the performance of a query when it uses any of the following patterns. Full value. For example, when you are searching for an entire word like Pluralsight or Pinal Dave. Leftmost value, or column prefix. For example, if you're searching for a word Plural from string Pluralsight or word Pinal from string Pinal Dave. Range of value. For example, if you're searching for every record, which is between 1-99 or every record, which is between Aaron and Fritz or Aaron and Kei and percentage. What it means, percentage is just a wildcard and represents that ending string can help first three letters as Kei. There is one more advantage of B-tree. The B-tree structure has an ORDER BY clause to increase the performance. When the B-tree structure keys are ordered the same way as _____ ORDER BY clause. We just looked at all the advantages of B-tree indexes. However, it's very difficult to feel the importance of all these advantages until we understand how B-tree indexes are built. However, before I go explaining how B-tree indexes work, we need to cover a few of the important concepts. Let's cover how cluster indexes work first and right after that I will explain how B-tree indexes play a roll in cluster indexes. At that time, when we understand how B-tree indexes are built, we will also come to the realization of all the advantages, which we have just discussed.

Clustered Index
Clustered index. Clustered index is just a different approach of data storage. It's not really a different type of index. InnoDB supports clustered indexes, but not all storage engines support it. In clustered indexes, rows with adjacent key values are stored close to each other. That's the secret for its better performance when we are doing grand scan. Its rows with adjacent keys are physically sorted in clustered index, it's only possible to have one clustered index per table, but you can use different keys and build a secondary index. Now let's see the advantages of clustered indexes.

Advantages of Clustered Index
Advantages of clustered index. In clustered indexes, related data is stored close to each other leading less disk I/O while retrieving sequential or range data. If the table is huge, the clustered index architecture often saves a lot of disk I/O operation when compared to scanning the entire table. And hence, while query engine is looking for specific data in the table, it can point to the exact location of data storage with the help of clustered index. This leads to much less I/O operation and ultimately it increases overall performance of the query. This faster data access is possible as data and index are stored together at the leaf node and leaf nodes are pointing to each other with the help of pointers. If you're returning the data in the same order as the clustered index keys are stored, the performance of that query is also improved massively. In summary, the main advantage of clustered indexes is performance. Now let's look at a few of the disadvantages of clustered indexes.

Disadvantages of Clustered Index
Disadvantages of clustered index. Data insertion speed is dependent on the order of the primary key when there's a clustered index on a table. Hence, the table and the insert statement need to optimize if inserted data is not ordered by a primary key. Also, if you have in memory data, clustered indexes have a minimal impact over it. Updating the clustered index column is expensive as data is moved based on its size to different locations. Because of the different size of the data in row and the presence of clustered indexes, page split occurs when new data is inserted leading to a fragmentation into the table. A lot of fragmentation in a table will lead to bad performance of the entire server. In a later module in this course, we will also understand how we can overcome fragmentation problems in clustered indexes. Secondary index is nothing but an index or a table, which is not a clustered index. In some IDBMs, they call it a non-clustered index.

Secondary Index
Secondary index. An index, which is not a clustered index, is called a secondary index. Secondary indexes in InnoDB do not store actual data, but only contains the pointer to the data. What it essentially means is that if there is a clustered index on the table, secondary index will contain the pointer to the clustered index. If there is no clustered index on the table, secondary index will contain the row pointer to the actual data. Now, let's understand everything what we have understood so far with the help of visual diagrams.

Building Clustered B-Tree
So far we have understood B-tree, clustered index, and secondary index. All three of these are very important concepts when we are talking about indexes. It's very difficult to understand all these concepts with the help of regular slides. Now let's understand all three concepts with the help of visual representation. As all three are interrelated to each other, I will attempt to explain them in one single flow. Now with the help of the diagram, we will understand how a clustered index B-tree is built. Here is a simple example where we have root node, intermediate node, and leaf node. In clustered indexes of InnoDB, we only have data in leaf node. A root node and intermediate node will have a pointer to the next level node. Here is a data page and for simplicity, we will assume that a single data page can contain 10 rows or 10 entries. If there are only 10 rows in our table, we only need a single page. Let's assume that we have 10 more rows from 11-20. In that case, we will need now another page. The first page at leaf level node, 0, will have row 1-10 and the second page will have rows from 11-20. At this point in time, we note that page 1 contains 1-20 rows and page 2 contains 11-20 rows. However, the tables need one more page to make those entries. Let's introduce one more level over here. Now, this new page is root page in this scenario. It's a level 1 and is a single page. It has two entries over here. The first entry indicates that row 1-10 is now in page 0:1 and row 11-20 are in page 0:2. 10 more pages over here, in this case, this entire 1:1 page will be filled. In that scenario, we will need another page over here and one more page on the top of it to maintain all the entries, and that will bring us to this kind of structure. In this example, we have leaf node, which will contain data and pointer to the next page and we will help intermediate node, which will have a pointer to the leaf node. The root node will also have a pointer to the intermediate nodes. Now to better understand what we have just discussed, let's try to traverse into our clustered B-tree index. For example, if we want to retrieve row #22, from visual inspection we'll note that row #22 will be in this page. However, when MySQL engine wants to get row #22, it will have traversed from root node to intermediate node and end up on leaf node. Let's see how it works. First, it will go to root node and it will ask where actually row #22 belongs. Root node will send it to intermediate node on the left side. Intermediate node, which contains the location to rows 1-30. Now, MySQL engine will read this intermediate node and try to figure out where exactly row 22 belongs to. The intermediate node will point it to this particular leaf node for row #22. Similarly, it will traverse from root node to intermediate node and leaf node for any other value, which we're trying to retrieve. If you pay attention, you'll notice that no matter what number of the row it is trying to retrieve, it always helps to jump through root node, intermediate node, and leaf node. The amount of the jump or hoops it has to do always remains the same. Hence, it is called B-tree. Let's understand one more time how traversing clusters of B-tree index happens. Let's assume that we are still looking for row #22. From root node, MySQL engine will go to intermediate node and from this intermediate node it will go to the leaf node which contains row #22. However, if our query says retrieve, go from 22-32, in this case it will read this entire node and instead of going back to the root node, it will now use the link between two leaf nodes and will directly continue reading next rows from the next page. Then you are retrieving range data from your clustered index. In that case, MySQL engine always locates the first record in the lymph node and after that it will use either forward pointer or a backward pointer and continue reading the entire range. It will save lots of disk I/O and extra lookup in B-tree index. Now, this was a pretty straightforward explanation of how clustered B-tree indexes work, as well as how locating accurate data happens in the index. Remember, in the case of the clustered index, all the data is located in a leaf node. This particular information is not true if we are talking about secondary index for InnoDB. Let's understand how a secondary index works next.

Building Secondary Index B-Tree
Now here's a diagram of secondary index B-tree. On a very first look, it looks exactly the same as clustered index B-tree. However, there is one big difference between both of them. A clustered index has a data and a leaf node, but a secondary index does not have a data at the leaf node. If you remember our earlier slide on secondary indexes, it says if there's a clustered index on a table, secondary index will contain the pointer to the clustered index and if there is no clustered index on a table, secondary index will contain the row pointer. Following the same logic, a lymph node will contain either a pointer to the clustered index or a row pointer. Because secondary index does not contain any data, it's quite possible to have more than one secondary index if any database supports more than one clustered index and had more data at the leaf node, that is essentially copying the same table multiple times, and that leads to many different problems, as per architecture perspective. Now, let's quickly understand how InnoDB clustered table works.

InnoDB Clustered Table
InnoDB clustered table. Here on the left side, we have clustered primary key index and on the right side we have secondary key index. On a very first look, both of them look exactly similar. However, when you pay attention to the leaf level, you can see in a clustered primary key index, we have rows at leaf level, whereas in secondary key index, we have keys and primary key columns. As there's a clustered index on this table, secondary key index also contains pointer to primary keys. Here is how it works if you are looking for a column, which is key of secondary key index. First, your query will use secondary key index and figure out an appropriate location, and once it's figured out the key for the rest of the data, it will once again go back to clustered index and will continue to look for additional data and retrieve the entire row. The question, which I often get asked, is why do I need a secondary key index? The answer is, it's not possible always to order our clustered index as per all of our queries. Our first query may be on a first name and second query is on last name. In that case, we clearly need two different indexes. We can have one clustered index in a table and we can order that according to first name or last name if we have our clustered index key ordered by first name. We will have to use secondary key index with last name. Here, the last name will be part of the key and there will be a pointer to clustered index. If our query is looking for only first name, it will not require to come to secondary key index, it will directly use clustered primary key index. If you're looking for last name and the address, at that point in time, we cannot directly use clustered primary key index. We will go to this particular index and figure it out appropriate last name and later will jump back to our clustered index and get additional data from leaf node as leaf node contains all the rows. Well, this slide just talks about theory, when we go to the next module, we'll see various demos where we'll be using clustered primary key index and secondary key index. At that particular point in time, you'll clearly see how different indexes play a role in query performance.

Hash Index
Hash index. Just like B-tree index, we also have a concept of a hash index. A hash index is built on a hash table. It increases performance for exact lookups. The logic behind hash index is very simple. For each row, a hash code is generated. Generally, different keys generate different hash codes. It stores hash code in index with pointers to each row in a hash table. If there are multiple values with the same hash code, it will also contain the row pointers in a linked list. It looks like hash index has very similar logic as hash algorithm, and that's true. If from this bullet point it's not clear to you how hash indexes work, we will see that with the help of visualization in this module only. Here is one more thing to remember, memory storage engines in MySQL supports explicit hash tables. Hash indexes are very fast and effective as it resides in memory. Let's quickly look at limitations of hash indexes before we jump to visualization.

Limitation of Hash Index
Hash indexes are lightning fast, however, there are few limitations associated with it. The reason for limitation is it only contains hash code and row pointers and not real data in the index. As hash codes do not contain original data, it is not effective in sorting and partial matching. The example of partial matching queries would be find all the first names starting with the letter A. Hash index only supports equal to operator. If you have any other operator in your query, hash indexes will not be effective or useful. Generally, a different case generates different hash codes, but due to any reason, if your table is very huge, it's quite possible to have multiple rows with the same hash code. Multiple values with the same hash code will result in slower performance. This is because the storage engine will follow each row pointer in the linked list and compare the value to the lookup values to get necessary data. Well, from this limitation, it's very clear that hash code is not the answer to all the questions. In InnoDB, we have a concept called adaptive hash index, which closely works with B-tree index. Let's understand what adaptive hash index is in the next clip.

Adaptive Hash Index
Adaptive hash index. InnoDB storage engine supports adaptive hash index. This is an automatic process. It does not give us any control to configure it. Definitely we can disable adaptive hash index, but we cannot do any modification in this algorithm. Hash indexes are built in memory on the top of frequently used B-tree indexes. MySQL engine automatically figures out which are the most frequently used B-tree indexes. It will take those B-tree indexes and values and put them into memory. In the memory, it will build hash index on the top of it. Now, your storage engine has definitely B-tree indexes and on the top of it there are hash indexes in memory. When MySQL engine receives any query, it will evaluate it for hash index, as well as B-tree indexes. If there are scan or any other situation where we have used different operators than equal to, it will directly use B-tree indexes. However, there is a direct lookup of any particular value, MySQL engine will use in memory hash index to get data immediately. In other words, adaptive hash index gives B-tree indexes very fast hash lookups for improved performance. This is one of the reasons why InnoDB storage engine is getting more popular into various installations of MySQL and more and more people are migrating from MyISAM to InnoDB for performance. If your storage engine does not support hash indexes, you can also simulate them yourself manually. However, this process is very complicated and maintenance of those hash indexes can be a nightmare sometimes. In the next clip, you will understand how hash indexes are built visually.

Building Hash Index
Let's understand how hash index works visually. Let's assume that we have a single table, it has six rows, Aaron, Fritz, Keith, Mike, Jeff, and Megan. Let's assume that our query is on FirstName. For example, our query is select FirstName, LastName from TableName where FirstName is equal to Jeff. That means we're going to look up for FirstName is equal to Jeff in the FirstName column. Let us build our hash index on our FirstName column. We applied a random hash function on our FirstName column and here is our result. The hash function generates a different value for each row in our table. The first two columns, FirstName and LastName are the original table. Function name and Value are columns from our hash index. Column value will contain a pointer to the row on which hash function is applied. In our case, we are looking for Jeff Ross as an answer to our query. Now, let's understand how a query works internally. On the left side, we have a hash index and on the right side we have the original table. Here is our query. Select FirstName, LastName from TableName where FirstName is equal to Jeff. First, function is applied on value Jeff. It will return as value 4786. Now, the same query is internally rewritten as SELECT Value from TableName where hash function is equal to 4786. That will return us this result. 4786 value is located in our hash index. It will also point us to row #5. MySQL engine will look up internally row #5 and will give us value Jeff Ross as our final result. When you understand how a hash index works, you can see that hash index logic is very simple. It is very efficient and it improves the performance of the query massively. However, please note that I have just created this example for our understanding. The hash function value, which I've generated, is a representation of what MySQL engine might have originally generated. As I mentioned earlier, in InnoDB storage engine, hash index is an automatic process and there is no control or configuration possible. Hash indexes are automatically built in memory on the top of frequently used B-tree indexes. If you're using InnoDB as your storage engine for performance you need to focus only on building right B-tree indexes.

Other Indexes
Other indexes. MySQL is open source and you can use different kinds of storage engines with MySQL. Different kinds of storage engines support different kinds of indexes. Let's look at some of the other types of indexes. Spatial indexes. MyISAM supports special indexes. However, MySQL GIS support is not exhaustive, hence, there is not much of the interruption of spatial indexes in MySQL. I suggest if you ever deal with spatial indexes, you explore other IDBMs products with extensive spatial support. Full text indexes. They are just like search engines. They find keywords in your text. They use different kinds of operators to search any data. Full text index is supported by MyISAM. Understanding full text indexes can be an entirely different course. Additionally, there are other types of indexes also existing in MySQL, which are based on different kinds of storage engines. For example, TokuDB, ScaleDB or InfiniDB. Well, with this slide we end understanding the theory of various different kinds of indexes. In the next module, we will see a lot of particular examples of how to build indexes, which improves performance of various queries. Next, let's summarize this entire module in 60 seconds.

Summary in Sixty Seconds
Summary in 60 seconds. Indexes improve query performance greatly in most of the cases. Indexes reduce the random I/O of the storage system by converting it to sequential I/O whenever possible. Indexes improve performance by avoiding sorting using temporary tables and reducing additional network traffic.

Indexing Strategies for High Performance
Introduction
Hi, this is Pinal Dave for Pluralsight, and in this module we'll discuss Indexing Strategies for High Performance. Here is our outline. We will cover the effectiveness of indexes, basis of indexes, order of columns in indexes, optimizing for OR and AND condition, how to implement cover indexes, and finally we will cover clustered indexes and non-clustered indexes. This is a demo-oriented module. Before we jump to demonstrations, let's quickly see the effectiveness of indexes.

Effectiveness of Index
Indexes are called keys in MySQL. They are data structures that storage engines use to find rows quickly, leading to a better performance for your queries. They are very important for higher performance when your data is quite large. Indexes are often misunderstood. So, poor indexing can cause lots of performance problems. Indexes can improve performance by many orders of magnitude. Let us look at some of the cases where indexes can be helpful. Indexes help to find rows matching a WHERE clause, eliminate rows by opting for the MOST selective index, retrieving rows from other tables while joining multiple tables, finding MIN or MAX values from table columns, sorting or grouping tables. A covering index is very helpful to reduce an I/O bottleneck. Well, this is a list of a few of the things where indexes are very effective to improved performance. Let's understand most of this with the help of demonstrations next.

Demo: List Indexes
Here we are in the MySQL Workbench and in this very first example, we will understand the basics of indexes. If you want to know if any table has an index or not, you can use the command SHOW INDEX. For example, if you want to see all the indexes of film table from sakila database, you can run this SHOW INDEX command. SHOW INDEX FROM film FROM sakila. First FROM film indicates the name of the table, and the second FROM film indicates the name of the database. You can select the statement and click on Execute. In the result output, there are four rows. The first row is for PRIMARY key and the rest of the three rows are for non-PRIMARY keys. The first column indicates the name of the table, which is Film over here. The Column_name on which PRIMARY key is created is film_id. Cardinality of that is 1000. That means there are a 1000 different values in this column. When we scroll further, we can see a column called Index_type. On the table film of sakila database, all the indexes are of type BTREE. In simpler words, film table has four indexes. First, on film_id, second on language_id, third on original_ language_id, and fourth on title. If the context of your query is sakila database already, you can just write SHOW INDEX FROM film to list all the indexes on this table as well. Here is one more method how you can list all the indexes on the table film. We'll be retrieving data from INFORMATION_SCHEMA. STATISTICS table. INFORMATION_SCHEMA is the information database, the place that stores information about all the other databases that the MySQL server maintains. Inside INFORMATION_SCHEMA, there are several read-only tables. They are actually views, not base tables, so there are no files associated with them and you cannot set any events or triggers on them. We can read the contents of INFORMATION_SCHEMA table, but cannot perform INSERT, UPDATE or DELETE operations over it. INFORMATION_SCHEMA. STATISTICS table provides us information about table indexes. Let's select this entire statement and click on Execute. Well, on a quick look, we can see that the result is very similar to what we have seen earlier. However, the column placements are a little different than earlier results. Here is TABLE_SCHEMA, which is sakila, TABLE_NAME is film, and here is NON_UNIQUE column. The name of the index is listed in this column and columns which are used in indexes are listed over here. CARDINALITY is also listed in this column. On further scrolling right, we can also see type of index. Personally, I have no preference. Both of them always retrieve accurate information. Use the one which you find easy to remember.

Demo: Basics of Indexes
Now, we will further continue with this demonstration and create indexes on the table film. Here is the syntax to create the index. CREATE INDEX, name of the index, ON, table name, and column on which index has to be created. Now, let's execute a query, SELECT film_id, length, FROM film, WHERE length is equal to 100. Select this entire statement and click on Execute. The query returned us 12 different rows. Now, pay attention to the WHERE clause. In the WHERE clause, we have length is equal to 100. A few moments ago, we have just created an index on this length column. It would be a good idea to see if this query has used our index or not. To validate what index our query is using, we can use the EXPLAIN command. In that, we just have to write EXPLAIN right before the SELECT statement. When we have a SELECT statement, it gives us the entire result set, but if your EXPLAIN keyword right before SELECT statement, we can see totally different information in our result set. Now, let's quickly understand our result set. The first column is id. It is just a select identifier. The second column is select_type. There can be various different select types. For example, SIMPLE, a simple query of select, which we have just seen. UNION over here indicates there is a UNION used in the select query. If there is a sub-query used in our SELECT statement, the select_type would sub-query. Well, in this case it's select. The column table indicates the table for output row and type indicates the type of join. In this case, the type of join is ref. That means all rows with a matching index value are read from this table for each combination of rows from the previous table. That means all the rows with matching index values are returned in this query. Here is the possible_keys column. The possible column indicates which indexes MySQL can choose from to find the rows in the table. Note that this column is totally independent of the order of the tables as displayed in the output from EXPLAIN. That means that some of the keys in possible_keys might not be useable in practice with generated table order. If this column is null, there are no relevant indexes. The next column is key. This is a very important column. The key that MySQL actually decided to use, the possible_keys, was just an indication. However, the key column is the actual key used to retrieve the results. In other words, if MySQL decides to use one of the possible keys indexes to look up rows, that index is listed as the key value. In some of the cases, it's quite possible key will name an index that is not present in the possible key values. This can happen if none of the possible keys indexes are suitable for lookup rows, but all the columns selected by query are columns of the other index. The column key_len indicates the length of the key that MySQL decided to use. In our case, the key length is 3. The reference column shows which columns or constants are compared to the index named in the key column to select rows from the table. We will understand this later in this module. The rows column indicates the number of rows MySQL believes it must examine to execute the query. Remember, in InnoDB, this number is an estimate and may not be the exact number of the rows written by the query. The final column Extra contains additional information about how MySQL resolves the query. In our case, it suggests using index. That means the column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. That is because key idx_film_length already contains column length and film id. You may wonder when we created the index we only used column length as a part of the index definition, we did not use film_id column in this index. Well, you are correct. However, remember the lesson which we learned in our previous module. If there is a clustered index on the table, secondary index will contain the pointer to the clustered index. Well, this is exactly that scenario. In our case, we already have a primary key on column film_id. Let's filter that by listing all the indexes by executing this query. Here is our primary key that is on film_id. In InnoDB storage systems, when we create a primary key on any column, InnoDB storage system will automatically create clustered indexes on that column. Hence, there is a clustered index on column film_id. What that means is that a column film_id will be included as a pointer in all the other secondary indexes. In our index, idx_film_length now we have two columns. The first is length and the second one is film_id. This is the reason our query can retrieve all the data from our index. It does not help to go anywhere else to retrieve the data for this query. A WHERE clause is the key where lookup happens and film_id is an additional column along with length retrieving of our SELECT statement. Both of them are part of this index. Additionally, we have a WHERE condition on the length column. The length column is the column on which idx_film_length index is built. I hope this explains why this query is using idx_film_length query. You can execute this query to drop any index. DROP Index, name of the index, ON table name. Click Execute and it displays Query Completed. The index which we have just created is now dropped. In this clip, we learned the basics of indexes. Now let's see a little bit more advanced example next.

Demo: Order of Columns in Index
Let us see one more example of how indexing works with MySQL. We can use either SHOW INDEX or INFORMATION_SCHEMA. STATISTICS to list indexes on table film. Table film has four indexes on it. Now we will create two more indexes on it. First, we'll CREATE INDEX ON column length. We are not specifying the sort order over here. That means order of the column which we are specifying in index is ascending. Select the statement and click on Execute. Query completed successfully. Hence, the index is created. Let's check that with the help of INFORMATION_SCHEMA, select the statement, and click on Execute. Here it is, the fifth line indicates our recently created index, which is idx_film_length, in its own column, length. The cardinality of the column is 333. Now, we will create another index on the table film. This time, we will use column length once again. However, the sort order of the index is descending. If you pay attention to the sort direction, definitely both of these indexes are different. Now, let's select the statement and click on Execute. As soon as we executed, in our Output window we can see there is a warning. Let's copy the warning and paste it in Notepad. The warning is idx_film_length_desc is defined on table sakila. film is duplicate. This is duplicated and will be disallowed in a future release. This is indeed a little bit strange that technically both of these indexes are different. However, MySQL has indicated that they are duplicate indexes to each of them. As a matter of fact, when we retrieve data from INFORMATION_SCHEMA. STATISTICS table, we can see that row #5 and row #6 are identical to each other except the name of the index. What essentially is happening over here is that MySQL is ignoring DESC keyword. MySQL only supports ascending index. If you specify the DESC keyword in your index, syntax does not throw any error, it will go ahead and create an index. However, internally it will be ascending index only. The future plan of MySQL suggests that eventually they may consider the direction of the index. For the moment, they do not consider the direction of indexes, however, when we specify sort order descending in our syntax, it is ignored and an index is just created with sort order ascending. As descending is not considered in this index, technically both of these indexes are now absolutely identical to each other. Hence we are seeing the duplicate index warning. Now let's execute this query. This query returns us a few rows. Let's use command EXPLAIN to understand what's happening behind the scenes of this query. Select the statement and click on Execute. Well, when we observe possible keys in the result, it lists both of the indexes, which we have just created, the ascending order index and the descending order index. When we see the column keys, it indicates it has used the index which is ascending order. Technically for MySQL, both of these indexes are identical to each other. It might help very well use other indexes as well as both indexes are the same. It really does not matter which index it has used to retrieve our data. The learning from this demonstration is that MySQL ignores descending sort order if we specify it in an index. MySQL also allows users to create duplicate indexes. Duplicate indexes is just an overhead to the system as both the indexes are present in the system, MySQL will help to maintain both of the indexes with the rest of the storage space, as well as other important resources. In the next module of maintenance of indexes, we will discuss a little bit more about duplicate indexes, as well as unused indexes. Before we move to the next demonstration, let's do our cleanup and drop both of these indexes.

Demo: Optimize OR Conditions
In this example, we will see how we can optimize OR condition with the help of indexes. With the help of this script, we can see what different indexes exist on our table film. There are four different indexes. Now we will execute this SELECT statement and we can see it returns us around 220 rows. With the help of keyword EXPLAIN, we will understand what is going on under the hood. This query has not used any indexes. You can see the key column is empty, as well as possible_keys column is also empty. In this scenario, MySQL engine has to scan the entire table to return us only 220 rows. This is a classic scenario of table scanning. Table scanning is alright if your table is very small. If your table is very big, it is the time when you are going to face performance issues. Table scanning on a big table is absolutely not advisable. It's quite possible you're only retrieving a single digit row from the big table, which might help millions of the rows. This will waste lots of your I/O, CPU, and memory resources. You'll want to optimize this query with the help of indexes. Well, let's try to create some indexes and see which indexes are optimal for this query. When we observe our WHERE clause, it has two conditions. The first is rental_duration and the second is length. Let's create an index on the rental_duration column. Select the statement and click on Execute. The query has completed successfully. Now, we will execute the same query and see if our index is used to retrieve the results. When we execute this statement with the help of EXPLAIN, we get our result set where we can see what other different indexes are used in this query. The possible_keys column indicates our recently created index. However, when we pay attention to our actual key used in this query, it says null. That means MySQL engine definitely has considered this index, but it has not found that as optimal index and hence it does not use that for final query execution. That means our index was not optimal. Now let's create an index on another column, which is length. Select the statement and click on Execute. Query successful, that means we have successful created an index on column length. Now once again, let's select the statement and click on Execute. Here the fun begins. In the possible_keys column, there are two indexes listed. The index which was earlier created on rental_duration and the index which we recently created on column length. In the very next column where it indicates actual key used in this query, we can also see both of the indexes once again. That means to execute this query, MySQL has used both of our indexes, which we have created so far. Isn't this strange to you that when we have created rental_duration index, MySQL has decided not to use it. However, when we created another index which is on column length, MySQL decided to use both of the indexes, which we have created so far. The reason is that MySQL has converted this OR to UNION. When we scroll on the right, we can see that MySQL is using union over here. It has union in both of these indexes, and found the most optimized way to retrieve the data from storage engine. And looking at the index type used, it also indicates that MySQL is now using index_merge technique. Index_merge technique has been introduced recently in the latest versions of MySQL. In earlier versions, queries with OR condition in MySQL were very, very slow. In this scenario, we are to take this OR condition and convert it to UNION. However, in the latest version of MySQL, query optimizer automatically uses all the indexes created on the column used in a WHERE clause with OR operator and returns us a result with the help of index_merge. By looking at this example, you may also ask what happens if I create an index which contains both of these columns. That's definitely a good idea. However, MySQL is to find that index optimal to use that index onwards. We will not know if that index is optimal or not until and unless we try it out. Hence, we are creating another index with rental_duration and length column together. Select the statement and click on Execute. Now, once again we will execute the same query to check which index it uses, though in a possible_keys column we see the entry of our recently created index. However, MySQL still uses index_merge and keeps on using two separate indexes to retrieve the results of our query. If you are thinking this is because of the column order used in the CREATE INDEX statement, let's try another example. In this example, now we will stream order of these two columns. First, we will use length column and after that we will use rental_duration. Let's create this index and now once again, we execute our same SELECT statement. When you pay attention to our possible_keys column, it is now four different indexes listed over here. That means any of these four indexes can be used for a final query. When we carefully observe our actual index use column, we can see it still uses two independent indexes. MySQL still finds index_merge as an optimal solution. Now, here is the question back to you. In all of our examples, we have used rental_duration as a first condition in the WHERE clause. What happens if instead of rental_duration we use length condition as first condition. Well, let's select the statement and click on Execute. A careful observation of result indicates that MySQL still uses index_merge and the same two indexes. As we are not using parentheses over here, the order of the execution does not change. Internally, MySQL optimizer will use the same indexes. Now, here is another question for you. In our WHERE clause, now we have only one condition instead of two conditions. What do you think, which index will these queries use? Let's check them out. When we execute the statement where our WHERE condition has rental_duration is equal to 6 only, it uses the index, which has rental_duration as a key. Now, let's execute our second statement. Over here in the WHERE condition, we have length is equal to 100. Select this entire statement and click on Execute. Our result set indicates it uses the index where length column is part of the index. It is very clear from this example that where MySQL engine uses the index based on a WHERE clause of the statement, what it means is that it will first look at what other different conditions are there is a WHERE clause and based on that, it will pick the optimal index which contains the column similar to one used in WHERE clause. Let's cleanup our system by dropping all the indexes which we have just created.

Demo: Optimize OR Conditions - Advanced
Now, let's see one more example where we are using the OR operator and we will explore how indexes improve performance of it. We will be using film table from sakila database once again for this demonstration. There are four different indexes on sakila table. Now, let's go and select this query, click on Execute, and you can notice in the result set that it does not use any index at all. The column key is empty. Now, we will create four different indexes on it. The first index is on the rental_duration column, second on length, third on rental_duration along with length column, and fourth on length column along with rental_duration column. Let's select this first statement and click on Execute. Query Completed. Hence, all these four indexes are created successfully. Now, we will execute our query one more time. In our query, we have used the EXPLAIN keyword. Hence, it is returning its result where we can see what other different indexes are used in execution of this query. Possible_keys columns indicates that it can use any of the four indexes which we have created. However, key column, which indicates actual indexes used to execute this query indicates that it is using index on rental_duration column and index on length column and successfully executing this query. The type of this kind of index is called index_merge. Here is a question for you. If I swap the order of columns used in the WHERE condition with each other, do you think this query will use a different index? Well, let's go and check that out. Here is another query where we have swapped the position of conditions length and rental_duration. When we select the statement and execute it, we can see that it still uses index_merge with indexes on length and rental_duration column, though the order of the columns over here used in the same order as the order of condition in WHERE clause, they are still using the same two indexes, which it used in an earlier query. In a nutshell, when we are not using parentheses, swapping the condition in the WHERE clause with the OR operator does not make any impact on indexes used to execute the query. Now let's scroll all the way to the right. Over here in our Extra column, we can see it's using UNION of these two indexes. Let's drop both indexes, which we see used in this extra column. Select the statement and click on Execute. As the queries completed successfully, both of our indexes, which were used in the query are now dropped. Now let's execute the same query one more time. Upon execution of this EXPLAIN statement, we can see the possible_keys column still lists two other indexes. However, both the indexes, which we have dropped, are no more in this list. Index on column length and index on column rental_duration, both were essential in the earlier query. In their absence, the actual key column now does not list any other index and this is the example where even though there are two different indexes that exist, MySQL has decided to go for simple table scan and retrieve necessary rows, which satisfies the WHERE condition. Now, a few minutes ago we have seen that it was using UNION of these two indexes. Let's try to convert this query with the OR operator to a new query, which uses UNION. Here is the query. There are two different statements, UNION with each other. The first statement has a WHERE condition as length is equal to 100 and the second statement has a WHERE condition where rental_duration is equal to 6. Now let's select this entire statement, which is joined with the help of UNION and executed. Now, here is a very, very interesting scenario. Instead of one single row, we are able to see two different rows over here. The first row is using index length_rental_duration and the second query is now using index rental_duration_length. This clearly demonstrates that both the indexes, which were created earlier on the combination of two columns are both now used over here. The patter is very simple. The index where we have the length column as a first column in the query with a WHERE clause including length. In the index where rental_duration is the first column, it is used with the query using rental_duration in the WHERE clause. Both of the queries independently returns results and they are joined with the UNION operator. MySQL engine internally uses a temporary table to join both of these queries and returns us a single result. This is very, very interesting. In the first query, we have the OR operator and in the second query we have the UNION operator. Even though both of the queries will return exactly the same result, execution plan of both of these queries is very different. This is because MySQL interprets OR and UNION a little bit differently and uses a different kind of index internally to get best execution plan to users. In an earlier version of MySQL, these kinds of queries were never optimized. To optimize any query with an OR clause, we had to rewrite them with the help of UNION. However, in the latest versions of MySQL, we have the concept of index_merge, which we have seen a few seconds ago. With the help of that, now a query with the OR operator is also optimized. Let's do one more interesting thing. Let's recreate two indexes, which we have dropped earlier. Here is cleared index script and now click on Execute. As the query completed successfully, both the indexes on rental_duration and length column are recreated. Now let's see what our EXPLAIN keyword displays in our result set when we execute the same query. When we execute this query, our result set is still using those two indexes, which it was using earlier, which is index on length and rental_duration and index on rental_duration and length. Our newly created index has technically no effect on this query. Well, let's try to take this example a little more in-depth. This time, we will drop the two indexes, which this query is using, select the statement, and click on Execute. Now, we have dropped those two indexes, which this query was using. Let's select this query again and click on Execute. Our result set is very interesting. As we have dropped two indexes which this query was using, MySQL has fallen back on index of length and rental_duration. At this point in time, MySQL thinks these two indexes are the best option for it. Well, the reason for this is very simple. MySQL engine is very intelligent. It will always use the index which it finds is the most optimal for any query. Earlier, the other indexes were most optimal for MySQL engine to execute this query. Hence, it was using those indexes. Now, the option, which was optimcal for MySQL, is not there. Hence, it is using the next best indexes. Now, let's summarize this demonstration. Even though OR and UNION, both conditions gives us the same result, internally both of them are different queries. One query finds one set of indexes useful and another query finds a second set of indexes as useful. When we are dealing with indexes, there is no one solution or one index which can fit all the queries, even though it is retrieving identical results. While writing query and working with indexes, try out different options and find out which one works for your result set. Let's drop these two indexes to cleanup this example. So far we have seen how to optimize the OR operator. Additionally, we learn how we can rewrite the OR operator with the help of UNION. In the next demonstration, we will learn how to optimize the AND operator.

Demo: Optimize AND Conditions
Now in this example, we will see how we can optimize the AND operator. We will be using film table from sakila database. We can see that it has four indexes on it. First, we'll execute our SELECT statement, which retrieves approximately four rows. Now, let's execute the same statement with the help of EXPLAIN keyword. Select the statement and click on Execute. From the result set, it is very clear that it is not using any keys or any indexes. Now we will CREATE INDEX ON column rental_duration. The reason we are creating index on rental_duration column is that rental_duration is one of the conditions in WHERE clause in our query. Select the CREATE INDEX statement and click on Execute. Now we will go back and check our SELECT statement once again to see if it is using the index which we have just created. Absolutely. This query is using the index which we have just created on the rental_duration column. When we carefully observe our WHERE clause, we can notice that it also has another condition on the length column. Let's try out one more thing. We will create an index on column length this time. Select the statement and click on Execute. Now, we will go make and check what are the different indexes our SELECT statement is using. Well, let's execute our statement one more time and see our result set. It is interesting to note that our query is using both of the indexes, which we have just created. It is using index on length column and it is using index on rental_duration column. This particular scenario happens when two indexes intersect. You can see in the Extra column that it mentions that index on the length column and duration column are intersected. The type of operation is index_merge where both of these indexes are intersected and merged together to get this result. If you are following this module from the beginning with me, I'm very sure you must be thinking that now I will be creating an index on both the columns length and rental_duration. Well, you are very correct. Let's create an index on both of those columns. Select the statement and click on Execute. As now we have just created an index, we will once again test this query. Upon selecting, now we can see that the query is using our newly created index. It's no more doing index_merge, but rather it's just plainly using our newly created index, which is on rental_duration and on the length. What we have seen so far is that as we are creating new indexes, MySQL is finding the newly created index much more efficiently to retrieve the data. The lesson here is very simple. If you see MySQL query using one index, do not hesitate to create another index and test your query out. If the newly created index is efficient for your query, MySQL engine will automatically use that. However, if your newly created index is not useful, MySQL engine will not use that index, hence, you should now drop the newly created index, which is not being used. Let's continue this demonstration further and now we will create another index. First we created an index on rental_duration and length column. This time we still swap this column order and we will use the length column first and rental_duration as a second column. Let's select the statement and click on Execute. Now, we will execute our same SELECT statement one more time. In possible_keys we can see the newly created index is now added there. However, when we closely pay attention to the index, which is used for this query, we can clearly see that it is using rental_duration and length index. That means it is not using the index which we have just created, it is still using the index which we had created earlier in this demonstration. What this indicates to us is that this newly created index is not as efficient as the index which we had created earlier. In a real world scenario, I will drop this index because I know I have already created a more efficient index earlier. Now, let's further continue with our demonstration. Here is another query. The difference between this query and this query is that here I have changed the order of the column used in my SELECT clause. In this case, we were using rental_duration column before the length column. In this example, we have length column before our rental_duration column. The question is that as we observe the order of the column over here, is there a chance to use our newly created index where the length column is the first column and rental_duration is second column? Let's check that out by executing this query. Well, our answer indicates that MySQL engine still thinks the index which you have earlier created is more efficient than the latest created index. Even though we swapped the order in our SELECT statement, it has made no impact on index selection by MySQL engine. Technically, the order of column you mention in a SELECT statement has no impact on index selection by MySQL engine, though which column you use in your SELECT statement definitely matters and that we will learn when we talk about cover indexes later in this module. Now let's do one more test. Here, we will swap the order of the condition in the WHERE clause. Earlier, we had rental_duration first, now we will have length column first. Let's execute this query and we will notice that it is still using the same index, which it has been using. As there is no use of parentheses, it does not matter what order we list our condition in the WHERE clause. MySQL engine will always use the index which it finds most optimal for any query. Now, let's cleanup by dropping the index which we have created in this demonstration. In the next clip, we will see advanced concept with the AND operator.

Demo: Optimize AND Conditions - Advanced
We will see one more example where we will use the AND operator in a query and see how various orders of the column in the SELECT statement, as well as WHERE clause impacts the index selection of MySQL engine. We will be using film table from sakila database. It has four different indexes on it. Now, let's execute this simple query. We will be using the EXPLAIN keyword to see what is going on under the hood for this query. The result set over here indicates this query does not use any index. Now, let's create four different indexes. The first index is on column rental_duration, the second index is on column length, the third index is on two columns, length and rental_duration. The fourth index has once again two columns in reverse order of what we used in index three. Let's select all these four indexes and click on Execute. As the query has completed successfully, all of these four indexes are created. Now, we will execute the same query once again. In the result set, we can see it is using index idx_film_length_rental_duration. That means it is using the index third, which we have created over here. Now, let's change the order of the column which we have used in SELECT statement. Here, we have rental_duration first and right after that we have length column. In this new query, we have swapped the position of these two columns. Let's select this entire statement and click on Execute. Carefully observing the result set, we can see it is still using the same column, which it has used earlier. Now, we will change the order of the condition in WHERE clause. Earlier, we had rental_duration right before length. Over here, we have condition with length first before rental_duration. Now let's select this entire statement and click on Execute. Our result set indicates it still uses the same index which it has been using all the time. It is very clear from this example, if you have not used parentheses in the WHERE clause, the order of the condition with the AND operator does not matter. Similarly, in a SELECT statement, we can list columns in any order. It does not impact what index MySQL engine is going to select for optimal performance of the query. Now, let's cleanup by dropping all the four indexes, which we have created.

Demo: Cover Index
Now in this example, we will understand how covering index work. Just like every other example, we will use film table from sakila database. It has four different indexes on it. First, let's execute this query. This query does not use any indexes. Let us create three different indexes on this query. Now once again, we will execute the same query with the help of the EXPLAIN keyword. In the result set, we can observe MySQL indicates it can use any of the three indexes, which we have created in possible_keys column. However, in reality it uses only one index created on length and rental_duration columns. Now, let's closely watch the SELECT clause. In SELECT clause we have three columns, title, rental_duration, and length. However, the index which is used with query has only two columns, length and rental_duration. The column title is not there in our index. Let's try to create an index which contains all the three columns from the SELECT clause. Remember, our query has used this index because length and rental_duration are also part of the WHERE clause. SELECT clause has an additional column of title, which we will now include as a part of index. Let's select the statement and click on Execute. A new index is successfully created. Now once again, we will execute the same query and see what is our output. In our output, we can see that MySQL engine is now using a newly created index, which contains all the three columns, length, rental_duration, and title. When you create an index which contains all the columns that exist in a WHERE clause, as well as all the columns from the SELECT clause, that index is usually called a covering index. The reason it is called a covering index is that it includes all the columns which the SELECT statement includes or covers. When any of the MySQL queries do not have to go back to the base table to retrieve the data, but can get all the necessary data from any index, that index is called a covering index. Covering indexes improve the performance of the query, as well as reduce I/O. Now let's try to be a little bit creative and see how UNION works in this scenario. Remember, the result of this query and this query will be very different because this is not our OR operator, which we are converting into UNION. This is as a matter of fact an entire different statement, which will return us a very different result. Let's select this entire statement and click on Execute. As we have used UNION, our result also includes UNION. Both the SELECT statements, which we have used in UNION now uses different indexes. Together, it returns us our final result set. It is very common that a single query uses multiple indexes to return as a result. Now, let's see one more example. The WHERE condition is very similar to what we have used in our very first query, however, instead of specifying column names over here, we are using star. Now, let's select this entire statement and click on Execute. When we execute this query, MySQL uses index length_rental_duration. Please note, it does not use the index which we have created with title because at this point in time, we are pretty much retrieving all the columns from table film. MySQL figured out using index with length and rental makes more sense over here because after retrieving the key from secondary index of idx_film_length_rental_duration, it will go to the clustered index to retrieve all the columns from the table. This is a great example where we can see MySQL uses secondary index to locate the key to clustered index and retrieves all the columns from base table. If you want to create a covering index over here, we will have to select all the columns from table film, which will not be a practical idea. MySQL best practices suggests one should not use star in a SELECT clause. It is always a good idea to list only the column which you are going to use in your application. Now, let's drop all the indexes which we have created in this demo.

Demo: Clustered Index
Now here we are. We will create a new table in this example and we will see how clustered indexes impacts ORDER BY clause, as well as query performance. First, we will create a simple table which has four columns, ID, FirstName, LastName, and FullName. Primary key index of this column is ID and secondary key index of this table is FirstName and LastName together. Let's create the table. Now, with the help of the EXPLAIN keyword, we can see the structure of this table. With the help of the actor table of sakila database, we will populate our TestTable. Let's select the statement and click on Execute. Now, we will run these four sets of query on our table and see which index these queries use. Our very first query has two columns, FirstName, LastName, and its ORDERBY ID. Click on Execute. You can notice that it is using primary key. Now, let's select the second statement where we have column FirstName in our ORDER BY clause. If you notice, it's now using our secondary index to order this table. This is because FirstName column, which is in ORDER BY is also in our SELECT clause, as well as we are ordering by this entire table by FirstName. Index ix_TestTable_FN_LN is now a covering index for this query. Now let's see what happens when we order by the same query with LastName column. Select the statement and click on Execute. You can notice that MySQL still uses the same index to order this query. This is because MySQL finds this index still an efficient index to order this entire table. Now let's see which index this query used when we have ORDER BY FullName column. Click on Execute and the query does not use any index. This is because FullName is not part of any of the indexes which we have created. When we say ORDER BY FullName, MySQL pretty much has to scan this entire table to retrieve our data. Now you can easily relate all these four queries. You can clearly notice that if we are ordering by the entire query by primary key, MySQL finds primary index as a most efficient candidate for that query. It does not matter what you have in a SELECT statement as long as your primary key is that in ORDER BY. If you use the column, which is there in secondary key index, MySQL may use that secondary index to order the entire table. However, it varies case by case. If you use any column in ORDER BY, which is not part of any index, MySQL will have to scan the entire table. Now let's make this query a little bit more interesting. This time, we have introduced a WHERE condition along with same ORDER BYs. Our very first query uses primary key as the primary key column is used in WHERE condition. When we have this entire set of queries, ORDER BY primary key with WHERE condition containing primary key, it will definitely use primary key to retrieve data for this query. It becomes a little tricky when we have primary key in WHERE clause, but we are ordering by a column, which is part of secondary index. When we select and execute, MySQL still uses primary key because primary key column is used in WHERE condition. Right after this query locates necessary data with the help of primary key index, it will order this entire result set by the column used in ORDER BY. In this case, also we can notice that primary key is the most optimal column for this query. This is because we have primary key column in our WHERE clause. Now let's go to the next level and see the next set of SQL statements. Here, we have a WHERE condition, but instead of primary key column, this time we have a column from secondary index. We are retrieving all the rows where FirstName is equal to ALBERT. When we execute the first query, MySQL uses secondary index, which we have created. This is because FirstName column is part of the secondary index. It becomes a little more interesting when we have FirstName in WHERE clause, but we are ordering this entire result set by PRIMARY key column. Upon execution, we can still see that if a SQL statement has two clauses, WHERE and ORDER BY, and both of these clauses may use a different index, MySQL usually tends to use the index for the column which is in the WHERE clause. In most of the cases, the column used in WHERE clause gets priority when index is selected for the query. Of course, let's look at the next query and in this query we can notice we have FirstName in WHERE clause, as well as FirstName in ORDER BY. It is a no brainer that it will use secondary index for this query. Now, it's your turn to guess which index this query will use, primary index or secondary key index. Right it down on a notepad. Now, let's click on Execute. MySQL once again uses secondary key index and if you guessed secondary key index, you definitely have learned how to do proper indexing for your query. Here is the last set of queries. Instead of FirstName, this time we have LastName in our WHERE clause. This is going to be very, very tricky, so I would like you to pay special attention to this set of queries. It's quite possible you may get an answer, which you have not expected. Now, let's execute the first query. The first query definitely uses secondary index as LastName is part of our secondary index. However, here is the tricky part. This time we have LastName in WHERE clause, but we are ordering by this entire result set by ID. What do you think, which index will this use? In the earlier case, when we have FirstName in our WHERE clause, it does definitely use our secondary index. And in this case, when we execute it, we can see MySQL uses primary key index of secondary index. This is because LastName is not the first column in our secondary index. Let's go back for a second and see what I mean by that. When we see our index, it's very clear that FirstName is the first column of the index and LastName is second column of the index. When we are to find data, MySQL definitely uses this index because it finds it's two of the most important columns, FirstName and LastName in this query. However, it has to pinpoint any single record. It can only pinpoint by first column, which is used in any index. When we have LastName is equal to any value, at that point in time this index can just help as a cover index, but will not help them to identify or pinpoint exact data. As in this query, we have LastName is equal to GRANT, but we are ordering this by ID. MySQL decided it totally makes sense in this particular case to execute this query with the help of primary key. Now, let's see the next example. In this example, we have LastName in WHERE clause, but FirstName in our ORDER BY. When we execute this query, at that time MySQL uses our secondary index. The reason is very simple. The WHERE clause contains LastName column and ORDER BY clause contains FirstName column. Both of these columns are part of our secondary index. The tricky part is when we have FullName as our ORDER BY, but LastName is there in our WHERE clause. This is your final chance to guess which index this query will use. Make a note of it in a notepad. Now, click on Execute. Well, if you guessed no index used for this query, you are right. But if you guessed that it will use secondary index or primary key index, well, think again. Here is the answer. This query will not efficiently use any of the indexes. Column LastName is second column of our secondary index and because of that, secondary key index is not helpful to locate data with LastName is equal to GRANT. We have FullName. FullName is also not part of any indexes. When you face this kind of scenario, at that time MySQL decides to scan this entire table as both the indexes are on the column, which are not used in either ORDER BY or in a WHERE clause. This means this query has to scan the entire table. Hence, it does not use any queries. Now let's clean up this example by dropping this table. Before you move to the next demonstration, I strongly suggest you recreate this scenario on your MySQL server and play with a different combination of columns, as well as indexes. There is no better teacher than the errors which you encounter when you are playing with indexes on your test server.

Demo: Index Hints
Now, in this final demonstration, we will understand three important keywords. They are FORCE, USE, and IGNORE. Let's understand how they work. We will be using table film from sakila database. It has four indexes. Now, here is a simple query which we will use. It has three columns in SELECT statement and two columns in WHERE clause. Let's select the statement and click on Execute. From the result set, we can notice that it is not using any index to retrieve this data. It is simply doing a table scan. Now we will create two indexes on this table. First is on rental_duration column and second on column length. Now, we will create another two indexes. This time, we will have a combination of columns in our index. The first index is on rental_duration and length and the second index is on length and rental_duration. Now let's create these indexes. Query completed, so indexes are created successfully. Now, let's execute the same statement. In our example, we can see all the four indexes which we have created are listed in possible_keys. However, MySQL uses this particular index to retrieve all the data. Now, let's understand what FORCE keyword can do. Right after FROM table name, we will use this syntax, FORCE INDEX and name of the index. Please note the name of the index over here is quite different from the name of the index MySQL is using right now. Now, let's select this query and click on Execute. You can notice that MySQL now has eliminated all the indexes from possible_keys and only kept the index which we have specified over here. As MySQL engine only had one index, it is forced to use the same index to retrieve data for this query. As the keyword FORCE is used, MySQL engine indeed forces the query to use the index. However, the USE keyword works a little bit differently from FORCE keyword. Let's see how it works. In the parentheses, we have listed three different indexes. Now, we will select this entire statement and click on Execute. Using the keyword will give us additions to MySQL engine that MySQL can use any of the indexes from these three options. They are listed over here in the possible_keys column. A query with the USE keyword only suggests MySQL that it can possibly use any of the indexes specified in parentheses. Unlike the FORCE keyword, it does not push MySQL engine to use the index which is specified in parentheses, it just gives a polite suggestion. Now let's understand how IGNORE keyword works. As the name suggests, IGNORE keyword instructs MySQL query not to use the index, which is specified in parentheses over here. That means if this index exists in possible_keys column, MySQL engine will remove that from possibility. Let's see that into action by selecting this entire query and clicking on Execute. You can notice that this particular query is now no more listed in possible_keys, hence MySQL does not have an option to use that key to execute this query. In this scenario, MySQL picks the next best index and uses it. Let's be a little creative. Let's take this index, which MySQL used and also pass that into our IGNORE list. Now, once again we will execute this query. In this scenario, now MySQL removes this index as well from possible_keys list. This leaves MySQL engine with the other two indexes. MySQL still finds these two indexes useful and intersects them internally to get a result set. If we specify both of these indexes also over here, now MySQL does not have any option at all with regards to index. In this scenario, MySQL will just scan the entire table to get us necessary data. In summary, FORCE keyword forces query engine to use the index, which is specified in parentheses whereas USE keyword just gives a suggestion to query engine to use indexes specified in parentheses. When we use IGNORE index and list the name of the index in parentheses, MySQL does not consider those indexes while building query execution plan. Here is the disclaimer and a little warning. Do not use keywords FORCE, USE or IGNORE frequently in your queries. As we have seen earlier, in most of the cases MySQL engine knows what is the right path to take when it is about performance of queries. If you use any of these hints, MySQL engine will now use intelligency which you have provided from outside. Use them rarely and sparingly. Now, let's clean up this demonstration by dropping the index, which we have just created.

Summary in Sixty Seconds
Summary in 60 seconds. In most of the cases, MySQL engine knows the best indexes for optimal query performance. Duplicate indexes are allowed, but they negatively impact performance in MySQL. Use keyword EXPLAIN with queries to get data related to query execution. Use query hints rarely and sparingly.

Index Maintenance
Introduction
Hi, this is Pinal Dave for Pluralsight, and in this module we will discuss about Index Maintenance. So far we have learned how to create the most optimal index for any query. It is as essential to maintain that index at optimal performance as much as it is to create the best index for a query. In this module, we will see various tips and tricks, how we make sure that indexes always perform at its best all the time. First, we will quickly understand MySQL Query Optimizer, and right after that we will understand how to maintain index statistics. Fragmentation is one of the main causes for slower performance. We will understand how we can remove data and index fragmentation in this module. We will also cover other maintenance tips and tricks. Let's start this module by understanding MySQL Query Optimizer.

MySQL Query Optimizer
MySQL Query Optimizer is responsible to build the most efficient execution plan for any query. Selecting the most optimal index is one of the tasks of building the most efficient execution plans. MySQL Query Optimizer follows a cost-based algorithm. That means it has several sets of metrics it follows to find the most economical execution plan. The main cost metric is data accessed by the query. MySQL Query Optimizer uses two different API calls to decide the selection of index for any query. The first API call is records in range. This call returns the number of records in range and points, and the second API call is info. It returns various types of data and statistics. Well, MySQL Query Optimizer is a very complex subject. Now, we have learned about these two API calls, we will relate these two API calls with index statistics in the next clip.

Statistics
Statistics. Statistics are used when the storage engine does not provide accurate information to the query optimizer about range endpoints which we have just learned in the previous clip. If statistics are very old or do not exist, query optimizer can make suboptimal decision for an execution plan. That means statistics are a very key element of MySQL performance tuning exercise. If due to any reason, statistics does not exist or are not updated for a long time, we can execute ANALYZE TABLE command and regenerate statistics for any table. Based on a different storage engine, statistics also behave differently in MySQL. Let's explore the behavior of statistics in InnoDB store engine in the next clip.

InnoDB Statistics
InnoDB statistics. InnoDB stores statistics in memory rather than disk since MySQL version 5. 5. Statistics are generated by sampling a few random pages in the index and assuming that the sample represents the entire index. The default sample pages are 8, however, we can configure InnoDB statistics by using an environmental variable of innodb_stats_sample_pages. The higher the sample pages, the more accurate are InnoDB statistics. If your system does not have a restriction on resources, it's a good idea to keep the sample pages to a higher number. However, if you keep the sample pages to a higher number, the resources used to build statistics are also much higher. Try out different values for innodb_stats_sample_pages variable and see which value works best for your server. Generally, InnoDB statistics are updated when table is first opened, as well as accessed. Table size statistics are also updated when table size changes significantly. What I mean by significantly is that if your table size is changed one-sixteenth of the original size, it will automatically trigger to update statics. Or, if you insert around 2 billion rows in any table, InnoDB statistics will be also updated. Additionally, if you run ANALYZE TABLE command, it will automatically update statistics for any table. It is very essential to understand statistics are a key element for MySQL Query Optimizer to select the most optimal index for the query. Make sure your statistics are always up to date. You can create updates at regular intervals to update your statistics.

Data and Index Fragmentation
Data and index fragmentation. Fragmentation in B-tree indexes can lead to heavy I/O operation and nonsequential reads on the disk. This leads to very poor performance of a query. For optimal performance, it is essential for data to be organized in ordered sequence and closely placed near each other in the leaf page. To reduce data fragmentation, run the OPTIMIZE TABLE command on the fragmented table. However, certain database storage engines do not support the OPTIMIZE TABLE command. In that case, you can just execute ALTER TABLE TableName and name of the engine right after that to optimize that table. To reduce the fragmentation in index, drop and recreate the indexes. As fragmentation can lead to poor performance for your query, it's a good idea to run defragmentation operations at frequent intervals based on your transactional operations. Now let's see a demonstration how we can maintain statistics and fragmentation in a MySQL database.

Index Maintenance
In this demonstration, we will use film table from Sakila database. We can see the various properties of index with the help of the SHOW INDEX command or INFORMATION_SCHEMA. STATISTICS view. We can execute this statement and it will list us all the details related to indexes on film table. Film table has four indexes, and this is the cardinality of the column. When we scroll all the way to the right, we can also see that these are B-tree indexes. Very similar information we can get when we execute this statement. Now let's assume that due to any reason, your queries on film table are giving you very poor performance. At that point in time, you may want to run a maintenance job on the film table. As we have learned in this module earlier, we can do update the statistics and reduce the fragmentation. To update the statistics, you can just run ANALYZE TABLE and name of the table. When you execute this statement, it will display a message that it is done analyzing table successfully. To reduce the fragmentation of the table as we have learned, we can execute OPTIMIZE TABLE and name of the table query. Let's select the statement and click on Execute. Well, in this particular scenario, this table does not support optimizing this table with the help of this command. It also suggests that we should recreate and analyze instead. As we have already analyzed the table, we will just recreate this table. ALTER TABLE and name of the table is a very cool trick to recreate this table. You can select the statement and click on Execute. Our query is completed successfully. That means our table is recreated. These two tasks will definitely help improve the performance of your query on film table. You can create a regular event to execute at certain intervals and include these two statements to update statistics and reduce the data fragmentation. Now, here are two more commands, CREATE INDEX and DROP INDEX. If your index is fragmented, you can drop the index first and right after that you can recreate the index with this script. Remember, dropping and recreating will use lots of I/O, as well as it may create a temporary lock in your database. However, once this operation is done, it will definitely give you a much higher performance with the help of these indexes. I strongly suggest that you execute this task in a scheduled event and make sure your scheduled event is executed at the time when there is a maintenance window on your server. If there is no maintenance window provision for your server, I suggest you run this maintenance task when there is very low activity on your server. In the industry, I have seen quite a lot of people analyzing and optimizing tables along with recreating indexes at the time of night when there is very low traffic.

Other Index Maintenance Tips
Other index maintenance tips. Here is something I strongly suggest you do frequently on your server. Review your indexes with the help of INFORMATION_SCHEMA, SHOW TABLE STATUS, as well as SHOW INDEX. When you review your index, here is what you are going to look for. You'll make sure there are no duplicate indexes that exist on your table. When I say duplicate indexes, that means your keys are not overlapping on each other. If there are more than one identical indexes on any column, that is absolutely a waste of I/O, as well as other resources. MySQL will only use one of those identical indexes. It does not make sense for MySQL to maintain all other indexes, which are absolutely identical to other indexes. In that scenario, you should identify those duplicate indexes and drop them. Additionally, you should frequently analyze your workload, as well as various queries which you are running on MySQL. You should check that if the queries are using all of the indexes that are created on your table. If you find any index that is not used by any of the queries on a server, I strongly suggest you make a note of this index and drop this thing in subsequent maintenance tasks. Before you drop any of the indexes, make sure you have saved the create index script somewhere in a safe place. It is quite possible as you are manually analyzing this table, you may make incorrect judgments. In that scenario, you can always use the script which you have saved to recreate the indexes. Again, index maintenance is a very tricky task. Anything and everything you do, you should always try it out on your development server. Once you are satisfied with the performance on your development server, then only you should move those changes to production server.

Summary in Sixty Seconds
Summary in 60 seconds. With the help of statistics, MySQL Optimizer selects an optimal index for any query. Statistics can be updated manually with the help of the ANALYZE TABLE command. Data and index fragmentation can lead to poor performance of the query. Command OPTIMIZE TABLE will reduce fragmentation in data tables. Recreate indexes to remove index fragmentation.

Checklists
Checklists
Hi, this Pinal Dave, and this is the final module of MySQL Indexing for High Performance course. In this module, we will review the checklist related to query performance and indexing. Here are a few things you can do when your query is running slow. Check for excessive indexing on the table, create a new appropriate index, which can help your query to run faster, check index maintenance jobs, and validate that they are running at frequent intervals. Additionally, you can also apply a few query tuning tricks like deleting your query, removing unused columns from your SELECT statement, and rewriting your joins to get optimal performance from your query. If your index which is not used by any query, it becomes dead weight and you should drop the indexes which are not used by your query as one unused index wastes lots of resources. And finally, drop least used indexes from your table. If your query, which you run once in a while and have created an index just to improve the performance of that query, it can easily qualify for this list. Before you drop any indexes, make sure you thoroughly test that they are really not used by any query. Creating indexes is one of the most essential tasks related to indexes. If you create a lot of irrelevant indexes, it can also damage the performance of the entire server. Here are a few things you need to consider when you are going to create an index. Create clustered indexes on a table if necessary. Do not create indexes on every column of table. Create indexes for most critical queries for optimal performance. Narrow width indexes are preferred over wider width indexes. Narrow width indexes use much less resources in terms of storage and CPU, as well as memory. If you have an option to select an integer column for an index and a long string for an index, it's a good idea to always go for integer data type for index. Careful with column order in indexes. It really matters which column you use first when you create an index. A general practice is to create indexes on the conditions used in the WHERE clause. Here are a few tips related to index maintenance. Rebuild indexes at well-defined intervals. You should create events in your MySQL server which run at specific intervals to rebuild all your indexes. This will reduce index fragmentation. Update statistics. You can use ANALYZE TABLE command to update statistics manually. Reduce fragmentation by optimizing tables. You can use the OPTIMIZE TABLE command to reduce fragmentation from your table manually. Finally, thank you very much for watching this course. Remember, indexing is an art and to master the art of indexing, practice, practice, and practice.
