MySQL is a popular choice of database for use in web applications, and is a central component of the widely used LAMP open source web application software stack. This course covers the fundamentals of MySQL, including how to install MySQL as well as write basic data retrieval and data modification queries.

Introduction
Introduction
Introduction to MySQL Part 1. Hi, this is Pinal Dave for Pluralsight. This is introduction to MySQL Part 1 course. We will be working together on this journey to learn MySQL. Let us do first thing first and answer the most important question. Why should you learn MySQL? Well, answer is very simple. MySQL is the most used open source relational database management system as of year 2008. The opportunities associated with MySQL are truly amazing, and some of the leading IT industries uses MySQL, for example, WordPress, NASA, US Navy, Bank of Finland, and many more. Well, there are two important terms we need to understand. First, a relational database. A relational database is a collection of data items organized as a set. There are tables and keys. The model was proposed in June 1970 by Edgar Codd. And second is open source. MySQL is licensed under GNU General Public License. The GNU General Public License is the most widely used free software license, which guarantees end users the freedom to use, study, share, and modify the software. In this introduction to MySQL Part 1 course, we'll quickly get started with MySQL and understand various GUI tools. Later, we will cover fundamentals of RDBMS and database designs. We will totally understand how to use efficiency tool, MySQL Workbench. Later, we will cover data retrieval and data modification techniques. We will end this module with important list of resources. Now we will see what we will cover in next course. In next course, we'll talk about joins, functions, views, transactions, stored procedures, stored functions, triggers, and events. Well, before we start the course, here is a quick question for you. What does the My mean in MySQL? MySQL is named after co‑founder Michael's daughter, My. Now, let's start our journey to learn MySQL.

Installations and GUI Tools
Introduction
This is Pinal Dave for Pluralsight. In this module, we'll get started with MySQL and GUI tool. This is fundamentals of MySQL course, so we are assuming that we are all beginners. The biggest issue with any beginners is to start and get going. Similarly, the biggest issue with any developer is to install the product, configure it, and get started with it. MySQL installation is very simple, and if any developer is not starting learning MySQL because he or she thinks that installation is very complicated or difficult, I personally do not agree with it. In this course, we will install MySQL and all related tools live. We will see how easy and fast the entire process is. Additionally, we will also install and get started using MySQL Workbench. It is the most popular GUI tool to work with MySQL.

Downloads
There are a few essential downloads for MySQL installation. You can download MySQL from the link displayed over here. Make sure to minimum download MySQL Community Server and MySQL Workbench. If you're using Windows platform, I suggest that you download MySQL Installer. It contains almost everything you will ever need related to MySQL. For example, MySQL Server, all of the supported connectors, Workbench and simple models, MySQL Notifier, MySQL for Excel, MySQL for Visual Studio, sample databases, and documentation. Now, let us quickly download and install MySQL Server.

Demo: Installation
In this demonstration, we will download MySQL and install it live. In your browser, go to mysql.com/downloads. Over here, you'll be able to see various MySQL downloads, MySQL Community Sever, MySQL Enterprise Edition. MySQL Cluster, MySQL Cluster CGE, MySQL Workbench (GUI Tool), and various other MySQL connectors, ODBC, .NET, Java platform, Python, C++, C, and PHP. You can download each of these things and install as they're needed. If you're on a Windows platform, I suggest you download MySQL Installer. MySQL Installer for Windows contains all of the MySQL products in single package. Let's click on Download, and it will bring us to the page where we can download MySQL Installer. MySQL Installer will contain all the MySQL‑related products. MySQL Installer provides an easy‑to‑use wizard‑based installation experience for all of the MySQL software needs. You can click over here and download MySQL Installer. In the interest of time, I already downloaded MySQL Installer on my local drive. Next, we will install MySQL using MySQL Installer.

Demo: Installation Part 2
Here you can see I have already downloaded MySQL Installer. Let's double‑click it, and it brings up Welcome screen. Now we'll follow a standard MySQL installation. Click on Install MySQL Products, read and agreed to license terms, click on Next, and it will ask you if you want to check for latest updates. As I've just downloaded my package, there won't be any update, even though it does not harm to check it one more time. Let's click on Execute. It will connect to the Internet and fetch product update information. Over here, it gives us various options for setup types. Developer options. It installs all products needed for MySQL development purpose. This is the one which we'll be selecting. However, it's worth noting there are other options like server only, client only, a full installation, and custom installation. Two more things to note before we click on Next. First is Installation Path, and second is Data Path. Installation Path is where MySQL will install MySQL, and Data Path is where MySQL will store data files. Click on Next. On the prerequisite screen, it will give us list of all the prerequisites. In my case, all the prerequisites are met; hence, we are seeing all green checkmarks. Let's click on Next. Now we'll be installing MySQL and all the related product. I would like you to pay close attention to the time it takes to install MySQL Server. The reason is that after I click on Execute, you'll notice that installing MySQL Server and all related product is very fast and efficient process. Let's click on Execute. (Music) And we are done. You can see in very few seconds we installed MySQL Server and all related products. Isn't it easy and efficient? Let's click on Next. Here it will ask us to do configuration. After installation, configuration is very important task. However, MySQL configuration is very simple to do. Click on Next. Here, you're to select your server configuration type. We have development machine, so we'll leave the Development Machine as a default option. Alternatively, you can also select Server Machine or Dedicated Machine as well. In a server machine, you'll have other applications also running with MySQL installation. However, in case of the dedicated machine, only MySQL product will be running on this machine. My machine is development machine; hence, click Development Machine, and click on Next. Here you can enable or disable TCP/IP Networking. Let's not change any setting over here and click on Next. MySQL Server configuration will ask us to enter root password. And you can see Password Strength is Medium. Let me create another admin user over here. I'll give name pinaldave. I'll let the role be DB Admin. I'll provide complex password. Click OK, and now we are ready to go to next screen. Click on Next. On this screen, MySQL will allow us to configure Windows service details. Here we'll change the Windows Service Name so we can easily identify our MySQL installation. We'll give it the name as SQLAuthority. Now click on Next. Here you can see now server configuration is complete. We can click Next one more time, and Samples and Examples will be configured. Click on Next. And now, along with MySQL Server, Samples and Examples are ready to go. Click on Next. On the very last screen, it will ask us if you want to start MySQL Workbench after setup, yes or no. I'll leave this one on because that's the next thing which we are going to discuss. Click Finish, and immediately you can see MySQL Workbench is open.

MySQL Workbench
MySQL Workbench is very powerful graphical user interface for MySQL. In this course, we'll be using MySQL Workbench for all of our tasks. There are three major workspaces in MySQL Workbench, SQL Development, Data Modeling, and Server Administration. Each of them performs very essential task for MySQL. Let us see a couple of functionalities of MySQL Workbench in action right now.

Demo: MySQL Workbench
Now let's see a quick example How MySQL Workbench works. MySQL Workbench has three major workspaces, SQL Development, Data Modeling, and Server Administration. In a SQL development, we can run queries and modify data. In SQL Modeling, we can create and manage models. And in Server Administration area, we can do various server‑related operations, like starting a server or taking backup. Now let's see a quick example how we can use SQL Development area. Double‑click on our server name, which we have just created, and it will open SQL Editor. SQL Editor is the area where we'll write query to retrieve data, as well as modify data. In this very first initial example, we'll just retrieve few data. On the left side, there is the Object Explorer, and right below it there is an Information area. We can see there are three schemas over here. Let's expand world schema. When we expand world schema, we can see Tables, Views, and Routines. Let's further expand Tables. Upon expanding Tables, we can see the of the name of the tables, city, country, and countrylanguage. Let's click on city. Upon clicking on the city, in the Information area, we can see the definition of the table city. City has five columns, and ID column integer and primary key. Let's expand city table as well. Upon expanding city table, we can see four object groups, Columns, Indexes, Foreign Keys, and Triggers. Let's expand Columns. Here we can see the same five columns once again. Click on ID, and in Information area, you can see the definition off ID. Now let's select data from city. Right‑click over city and select very first option about selecting rows. This option automatically wrote a simple query for SELECT * FROM world.city, and result is displayed in result tab. This result tab is also very powerful. You can select any row and click Edit from the menu over here or Insert new row, as well as Delete any row. Let's try to delete fifth row. Select fifth row. Click on Delete selected rows. You can see between four and six there is no row. The row number fifth is deleted. Well, that's enough for SQL Editor. We will learn about SQL Editor in depth in later module. Now, very quickly, we'll see a simple example how we can use Server Administration area. Double‑click on our collection, and it will open Server Administration area. Server Administration area will display as Server Status. Here is the information about our server. Our server is currently running. You can also see system information, CPU, and memory. Additionally, there are various vital server information, like connection usage, traffic, query cache, and key efficiency are also displayed over here. You can use the same area to start up and sit down MySQL Server as well. There are various connection parameters, system information, server logs, and a lot of other administrative tasks available in this area. We will explore each of them in dedicated module. Let's close this one, and now we are back into MySQL Workbench main screen.

MySQL Command Line Editor
MySQL Workbench is a great tool to work with MySQL, and you'll be using that throughout this course. However, if you ever face a situation where you come across a workstation without MySQL Workbench, you will have to find alternative to it. In place of MySQL Workbench, you can use MySQL Command Line Editor through the same task which you want to do using MySQL Workbench. You can start MySQL Command Line Editor from Start, All Programs, MySQL, MySQL Server, MySQL Command Line Editor. Now let's see MySQL Command Line Editor in action.

Demo: MySQL Command Line Editor
Now let's see a simple example how we'll use MySQL Command Line Client when we don't have access to MySQL Workbench. When you open MySQL Command Line Client, the very first thing it will ask is password. Enter your password, hit Enter, and it will bring you to command prompt. If you want further help over here, you can type help and semicolon, and it will give you pretty much every single help available for this command prompt. Now let's try to see what are the different databases installed on this server. For that, we'll be using command called show. Type show databases and click on Enter. It will list all the databases which we have. Let's use the world database. Type use world and hit Enter. You can see the message displayed, Database changed. Now let's try to see what are the different tables world database has. We'll use, once again, show command, show tables and semicolon. Let's hit Enter, and it will list every single table belongs to this database. If you remember in MySQL Workbench, we retrieved few data from city table. Let's try to do the same over here. Let's retrieve 10 rows from city table. So type SELECT * FROM City LIMIT 10 and hit Enter. And it will display you top 10 rows from city table. When you don't have access to the MySQL Workbench, you can quickly use this as a replacement.

Summary in Sixty Seconds
Summary in 60 seconds. MySQL installation is very easy and efficient on Windows platform while using MySQL Installer. MySQL Workbench is a key tool for SQL development, data modeling, and server administration. You can use MySQL Command Line Editor when MySQL Workbench is not available.

Fundamentals of RDBMS and Database Designs
Introduction
Hi, this is Pinal Dave for Pluralsight. In this module, we will cover fundamentals of RDBMS and database designs. In last module, we learned how to install MySQL and GUI tool MySQL Workbench. Before we start with MySQL database architecture design and object creation, it is good idea to understand fundamentals of RDBMS and database design. In this module, we will understand what is client server system architecture, how web application server and database work together. Additionally, quickly we will see history of relational database model, and right after that, we will understand key concept of RDBMS. You will understand what is table, column, rows, cells, and a few other key concepts.

Client/Server System
We will be using SQL to access MySQL database. At that time, the system is often called client/server system. Let's understand client/server system. There are three important components for any client/server system. Clients. Clients are like PCs, Macs, laptops, tablets, smartphones, etc. Server. Server usually stores files. When server stores database along with files, it is called database server. MySQL is database server application. Networks. Networks are communication links between client and server. Besides including lines and cables, network also includes hubs, router, and other interface components. In many enterprises, large database files are also stored on a network storage. Networking components connect server with network storage. In simple topology, clients and servers are both on the same network. They're often known as LAN or local area network. If there are more than two LANs located in separate geography location, that's called WAN, which is wide area network. If we assume there is a database on this client/server system, we can say that client sends the request in terms of the SQL query to the server. Server in turn passes the same SQL query to the database, and the database query returns the results back to the client, and then the client, which can be PC, Mac, or your handheld devices will display the result.

Web Application Server
Now we will try to understand how a web application server works with a database with a real‑life example. Let's assume you want to check your email. You take your computer, open it, start it, and run your web browser. In a web browser, you'll type your URL address. As soon as you type your URL address, the web browser will now send the request. The request will go to the internet via your ISP. ISP stands for internet service provider. Once your request goes to the internet, your domain server will now forward that request to the application server. This application server is where your email application is hosted. An application server will process all the HTML and dynamic pages. The front end of any application is pretty much the same across every single user who is using this application. For example, if you're using Gmail, Yahoo, or Hotmail, the look and feel will be pretty much the same across every single user of Gmail, Yahoo, or Hotmail. However, their emails will be different. The data will be different. You will have data from your friends, and other users will have data from their friends and relatives. Data will differ, but the page will look the same. That's exactly what will happen in an application server. It will pass the static HTMLs and will pass back the dynamic pages to the application server. However, every request for data will now go to a database server. A database server will have DBMS, or database management system. A management system will query the user's data and will give it back to the database server. The database server later will pass back the data to the application server, along with HTML and the dynamic page will be returned to the internet, and at the end, will go to the web browser of the user. It's hard to imagine that there will be any application without any kind of database on a back end. As of 2008, MySQL is the most popular database management system on the planet Earth.

History of Relational Database Model
We notice that database management system plays a very important role in any application. There are two kinds of database models, relational database model and non‑relational database model. MySQL is relational database model. Let's quickly see couple of history bites before we moved to understanding Relational Database Management System concept in depth. In 1970, Dr E.F. Codd has developed the concept of relational database. Any relational database will have following three most important properties: There will be less redundancy between the data, retrieval of the data will be very efficient, and the data modification should be intuitive. Through a relational database can get complex, the basic three properties of less redundancy, efficient data retrieval, and intuitive data modification usually stays the same because relational database concepts enforces them. Let's see what are the relational database concepts in depth.

Relational Database Model Concepts
For any relational database model, there are four very important concepts. A model for relational database states that data is stored in one or more tables. It also states that each table is two dimensional. It's dimensions are columns and rows. Intersection of the columns and rows are cells. Let's see them a little bit more in detail. A table. Any relational database consists of one or more tables. Tables are usually modeled after real‑world entities. For example, an address table would have address 1, address 2, city, state, country, and zip code or postal code. It's quite possible on a single address one or many different persons are staying. It's quite possible that there is nobody staying at the address as well. Addresses can have different types like work, home, factory, or open ground. Well, all of them can be tables. A column. A column represents some attribute or entity of the table. For example, in case of the address, as we discussed, it can be street number, apartment number, address 1, city, zip code, or any other detail. Columns are also known as fields. A row usually contains a set of value for single instance of entity. For example, in address table, it will have a single address. A single address may contain multiple columns. An address can be apartment number, followed by street number, followed by city, state, and zip code. If the table has multiple country's data, then there may be an additional column for country, and the row will contain name of the country. Well, this discussion leads to our last discussion about cells. Cells are nothing but intersection of row and column. One cell may contain apartment number, and another cell may contain street number. They can belong to different columns, and they can belong to different rows. It is just an intersection, and each of the cells will have a single value. Well, think about it this way. Apartment number may be a number, but street name may not be a number, but may be a string. Now we are leading to another concept that cell can have different kind of value. It can be a number, or it can be a string, or it's quite possible it's a mix of both of them. In relational database, everything into the table has relation to each other, as well as there is relation among the tables. Well, let's see that in the next clip.

Relational Database Model Keys
The most important part of any relational database model is relations. In a relational database, there are always relations between various tables, as well as columns of different tables. They're associated with each other with a primary key, as well as a foreign key. Primary key. A primary key uniquely identifies each row of the table. There can't be more than one primary key per table. The most important property for a primary key is that it cannot allow any null. It's not necessarily that a primary key has only one column. There can be more than one column for a primary key as well. When there is more than one column with a primary key, they are called composite columns. Let's try to understand what can be a good candidate for a primary key. Let's assume that your table is called Student. In the table Student, Student ID will be a good candidate for a primary key. If you have a table called Supplier, in that case, you can also go with Supplier Name as a primary key as well. In your system, you don't want two suppliers with the same name, However, due to any reason, if you have two suppliers with the same name, and your system requirement is to allow that, you might have to add another column, which we'll call Supplier ID. Instead of identifying each row with Supplier Name, now you have to identify each row with Supplier ID. Now think of it. What could be the reason that you have the same name for two different suppliers? It's quite possible both of them are supplying different things. One is supplying pencils and another one is supplying erasers. In that case, you have two options. Either you add Supplier ID, which I would prefer, or you can create composite columns as a primary key. You can use Supplier Name and Supply Item as a composite primary key. Personally, I would add Supplier ID. The same primary key will be also another column in another table where we will have a foreign key relationship. A narrow primary key translates to less random data and eventually leads to higher performance. Well, we'll talk about this thing with an example in our advanced course. But for the moment, let's assume that you've created Supplier ID as a primary key. However, you still want every supplier's name unique in the system. What should be the workaround for that? Well, the workaround is to create a unique key for Supplier Name. A unique key is not a primary key. However, it still ensures the data is not duplicated. You can have multiple unique keys in one table. A unique key also allows one null, whereas a primary key does not allow any null. We talked about foreign keys a little bit earlier. Foreign key. Foreign keys are the columns in a table that refer to the primary key of another table. Let's assume that we have a table called Purchase Order. In the Purchase Order table, we will have Supplier ID. Supplier ID will have a foreign key relationship with the primary key of Supplier table. The prime responsibility of a foreign key is to enforce referential integrity throughout the database. There can be different kinds of relationships between a primary key and a foreign key. They can be a one‑to‑one, one‑to‑many, or many‑to‑many relationship. Let's understand a one‑to‑one relationship. Here we have person and address. One person has one address, and one address has one person. This is a one‑to‑one relationship. However, it can go complex. One person might have multiple addresses. He might have a billing address and a mailing address, as well as his office address. Now a person has multiple addresses. That is a one‑to‑many relationship. Let's look at the same example a little differently, one‑to‑many again. This time there is one address, and there are multiple people staying at that one address. Isn't that the case in our homes too? We have multiple people staying at one single address. Let's go a little bit more real, many‑to‑many. Some might have a one‑to‑one relationship with one address, and it's quite possible that in certain places, one address might have multiple people staying there. And it's also possible that all three of them are working at the same place. This is a great example of a many‑to‑many relationship. Here the office address has three relationships, whereas one home address has one relationship, and another home has two relationships. The primary task of a relational database is to retrieve data efficiently from these various relationships and help reduce redundant data stored in the database.

Column Definition
Column definition is very important. We create primary key, unique key, foreign key, and indexes on column. Column definition is very critical when we talk about performance. In column definition, data type determines the type of information which is stored in column. For example, we have various kinds of data types, string, integer, float, date and time. We can store any character string in CHAR or VARCHAR data type and can store any numeric value in integer data type. If we have a similar value, we can put them in a float, and if we have date data type, for example, birthday or anniversary date or joining date, we can use date and time DATE data type. Along with data type, there are a few important properties of column definition as well. Let's look at them. Default value. We can specify a default value for any column. Let's see a scenario where you have a requirement to log current datetime of data inserted into a table. You can create a column with a name, insert a date, and by default, give it a value of current datetime. What it means is that every single time any data which is inserted into that table, the column inside the date will be automatically populated with default value. But not every column qualifies for default value. There are cases when you may not know what to put in a column. At that time, you can leave the column as null. This is called nullable column. Now you can have a default value in a column, or you can just leave the column null, and there won't be any data there. You can later go and update either this default value or null value. Auto increment column. Auto increment column is a column which is continuously increasing by the interval which we specified in a column definition. Auto increment column is very important because in many cases it's difficult to identify column qualifying for primary key. In that case, we can add an auto increment column. Now, auto increment column will not have null value. Additionally, it will be always incriminating distinct value. This is a good candidate for primary key. Personally, I believe defining column data types and column properties is one of the most essential tasks for any database designer. With this, we complete understanding our last concept in fundamentals of database design.

Summary in Sixty Seconds
Summary in 60 seconds. A relational database consists of tables. A table consist of rows and columns. The intersection of rows and columns is called cell. Primary keys uniquely identifies each row of the table. Foreign keys enforces referential integrity. Defining data type of column is one of the most crucial tasks of database modeling. Check out other database designing courses on Pluralsight.

Introduction MYSQL Workbench
Introduction
Hi. This is Pinal Dave for Pluralsight. In this module, we will understand how MySQL Workbench works and various features of it. In earlier module, we had a little bit introduction to MySQL Workbench. In this module, we will understand MySQL Workbench a little bit more in depth. Now the next logical step is to learn about coding and building the database. However, before we move to that one, we need to learn about how we can use MySQL Workbench efficiently to build our database. MySQL Workbench is a visual database design tool. It has three main workspaces, one is development, second is design, and third is administration. In this module, we will understand each of them a little bit; however, we will spend more time on development‑related features of MySQL Workbench.

MySQL Workbench Features
MySQL Workbench feature list is very long. It will be impossible to cover every single feature in this module. We will be covering the features, which we are going to use in this course, as well as the essential feature, which is important to do any task in your daily job. MySQL Workbench features can be divided in the following areas, Database Development, Database Designing, Database Administration, Database Migration, and Miscellaneous. You can see that MySQL Workbench is very feature rich and pretty much you can do every single task, which you need to do with MySQL database. In Database Development area, you can do schema browsing, syntax highlighting, addition or update to the result set, as well as it contains efficiency tool of snippets. Database Designing, which is very critical task for any database developer, MySQL Workbench offers visual drag‑and‑drop modeling. It also helps to reverse engineer from SQL scripts, as well as from live database. Schema synchronization and printing of models are also very popular database designing feature of MySQL Workbench. In Database Administration area, one can configure any instance, as well as do account management. You can turn on or turn off any database instance, as well as do log file browsing. Additionally, you can use MySQL Workbench for database migration where you can use any ODBC database complaint database to migrate from one database to another database. Well, this was just a list of MySQL Workbench features. Let's see MySQL Workbench into action next.

Starting MySQL Workbench
Now, for the rest of the module, we will see demonstration of MySQL Workbench features, which will be useful to us in performing our daily task with MySQL. You can start MySQL Workbench on Windows platform by going to Start, All Programs, MySQL, and clicking on MySQL Workbench application. Upon launching MySQL Workbench, you will see following screen. This is the home screen of MySQL Workbench. On the home screen of MySQL Workbench, we have three major workspaces, or sections. First is SQL Development, second, Data Modeling, and third is Server Administration. SQL Development is the section where we'll be spending most of our time as this is a SQL development course. In the SQL development area, we can create databases and run SQL queries. In the Data Modeling, we'll create and manage models. Additionally, we can also reverse engineer database. In the Server Administration area, we can set up various user accounts, browse status variables and sever logs. We can also do import and export of the data over here. We will also see how we can start and sit down server in this section. On the top part, you can see Workbench Central. Click on the arrow, and it will expand. We have few of the very important links in Workbench Central area, like MySQL Document Library, MySQL Utilities, Database Migration. MySQL Bug Reporter, as well as Workbench Blogs. Let's start first with SQL Development workspace.

Demo: Opening a New Connection
In the SQL Development area, first, we will learn about how to open new connection and start creating database. Go to the Open Connection string. Click over here. On this Connect to Database screen, we'll be providing few of the information so we can connect to the database. First, we'll give a hostname. I have provided 127.0.0.1 because this is my localhost, and MySQL Server is installed here on a localhost with default port of 3306. The username is root. Now click here for password. On the password page, enter the password which you provided when we installed MySQL. Click OK. Now click on OK again. You can see that it has opened SQL Editor for us. Let's go back to home screen before we continue with SQL Editor. Now you have seen here how we can open a connection and start querying. But we are all developers, and we know that there are few connections which we like to save and keep on using it again and again. We can also save connections in a SQL Development area. Let's see that how we can do that. Click on New Connection, and it will bring up this screen. Provide over here connection name, and provide information for hostname, port, username, and password. Click OK. And now on this screen, you can also test connection. Click on Test Connection, and it will show us the status of our connection. And click on OK one more time. Now, over here, you can see the SQLAuthority is new connection, which is saved. You can double‑click over here, and it will also open SQL Query Editor. Now here are two types in our SQL Editor. First type, which we opened a few minutes ago, and second type, which we just opened. On the second type, you can clearly see it is marked with SQLAuthority label. These labels are very important. I've seen an industry that developer has executed incorrect SQL on a wrong server with the wrong connection. Well, before you execute anything, always make sure that label of the connection is correct.

Demo: Manage Connections
Well, we just noticed that we have created a new connection, which is SQLAuthority. As you keep on using MySQL in your production environment and development environment, you'll notice that number of the connections you work with keep on increasing. At one point, you may want to delete, create, or modify your existing connection. You can easily manage all of your connections from your MySQL Workbench. Under SQL Development area, go to Manage Connections, and click over here. It will bring up this screen. You can see on the left side there is a SQLAuthority connection. This is the only connection we have created so far. Let's click over here. Once we clicked, you can see all the information from this connection is filled up on the right side. You can also configure a few of the advanced connections over here by clicking over Advanced tab. As this is a fundamental course, we'll be not spending much of the time on this tab. Let's go back on Parameters. Also, on the bottom of the screen, you can see there are a few options. New creates new connection. Delete deletes existing connection. Let's create one more connection. I'll click on New, and New connection is also added on the left side, as well is it has populated a few of the default values on the right side of the screen. Let's give Connection Name as Pluralsight. We'll keep Connection Method as a Standard (TCP/IP). In Hostname, either we can leave this one as it is, or we can provide localhost as a hostname. We'll keep Username root, enter password, click OK, and in this case, we will also give a default schema. We will use Default Schema as sakila. Now, let's click on Test Connection, and our test is successful. Click OK, and now you can close this one. On the main screen, you can see that now we have two databases. One is SQLAuthority, and second one is Pluralsight. Let's change the order of SQLAuthority and Pluralsight in Manage Connections. Click on Manage Connections, and now let's click on Pluralsight on the left side in Stored Connections area and click on Move Up. You can see that Pluralsight is now on the top, and SQLAuthority is on bottom. Click Close, and on the main screen the order is also changed. Now double‑click on newly created Pluralsight collection, and you can notice that sakila is highlighted. What it means is that sakila database is now, by default, selected. Now let's go back to home screen.

Demo: Selecting Data
Now we have seen how we can manage connection, let's see how quickly we can retrieve data using MySQL Workbench from MySQL. Double‑click on SQLAuthority. It will open SQL Editor. On the left side, we have Object Browser. Right below it, we have Information pane. Let's explore schemas. Click on an arrow beside sakila, and you can see it lists down Tables, Views, and Routines. Click on Tables, and we have various tables listed over here. Right‑click on actor, and select first option which says, Select Rows, and it will spell out SELECT * FROM sakila.actor in query editor, and on a result pane, we can see the select data. You can see how easy it is to retrieve data from MySQL database using MySQL Workbench.

Demo: Updating Data
Now we will see how we can use MySQL Workbench to edit table data. On the home screen of MySQL. Workbench, go to Edit Table Data. I'll select SQLAuthority is my stored connection and will click on Next. Over here, it will give us a few drop‑downs where we can select our default schema and tables. I'll select default schema as sakila and table as actor. You can select other table if you prefer. Now click on Finish. Immediately, it has opened up table actor. You can also see name of the table over here, actor. Now let's go to the very first row, and you can see the first row is Edit table. You can change the value if you prefer. I'll leave this actor_id as 1. However, instead of PENELOPE, I will put over here PENELOPE1. I'll click on tab. Instead of GUINESS. I will also put over here GUINESS1. I'll move to the line number 3, and over here I'll put ED2, and behind CHASE I'll put 2 again. You can see that now I have edited two rows. Now you can see on the screen that I have changed PENELOPE to PENELOPE1 and GUINESS to GUINESS1. Do you think this information is committed? What I mean by that is that if I go back and select this data again, do you think I will see PENELOPE and GUINESS or I will see PENELOPE1 and GUINESS? Well, let's go back and check it in query editor. Now, to write a new query, go to SQL Editor, and click on Create a new SQL tab for executing queries. It will open core editor tab. Now let's type in a simple query. After selecting the query, click on lightning bolt icon over here. It will execute the selected portion of the script or everything if there is no selection. Click here, and you can see the result is now displayed in result tab. On the result tab, let's look at the first row. First row says PENELOPE and GUINESS. Remember, we have changed them to PENELOPE1 and GUINESS. We expect to see the changes over here, but they are not over here. The reason is very simple. Let's go back to our actor tab, and over here you can still see them, PENELOPE1 and GUINESS1. Though we have changed the record over here, we have not committed it. What it means is that the data which you are seeing is changed is only in a query editor. They are still not propagated to actual database. To apply them to the actual database, you have the select on Apply. You can see on the right bottom screen there is an Apply tab, which is highlighted. Now let's click on Apply. Apply asks us to review two update. You can see over here it has automatically generated to UPDATE script. One is UPDATE to sakila actor SET where first_name is PENELOPE1 and last_name is GUINESS. When you scroll on the right, you can see it also has a WHERE condition where actor_id is equal to 1. Similar thing is also there for actor_id 3. Let's click on Apply. If you do not understand the SELECT statement, don't worry about it. We are going to cover this thing in depth in later modules. Click on Apply, and the screen displays success. Click on Finish. Now you can see the Apply button is disabled. Once again, go to our ad hoc query, which we have written a few minutes ago, and execute it one more time. When you execute it over here, you can see that line number 1 is now changed from PENELOPE GUINESS to PENELOPE1 and GUINESS1. Similar thing for line number 3. It's also ED2 and CHASE2. We have learned that how successfully we can edit the row in any table using SQL Editor. On this whole table, you can go to any of the cells and double‑click over here. It will make that cell as writable. You can edit the cell and make ED2 to ED and CHASE2 to CHASE. Now you can see once again there is an Apply button and Cancel button. Apply is highlighted, and if we click on Apply, the ED and CHASE will be committed, and it will be communicated to the database. If you don't like the changes which we have done, we can easily click on Cancel, and you can see they will revert to their original value. SQL Editor is very powerful. We can also edit it one more way. Click on any line, and now go to Edit in the result tab. Click over here, and now that particular cell and complete row is editable. The logic of Apply and Cancel remain the same in all the cases. In this clip, we have learned three different ways to edit any row in SQL Editor.

Demo: Open and Execute SQL File
Now we will see how we can edit SQL script in SQL Editor. Go to MySQL Workbench home screen. Click on any SQL script. Let's select SQLAuthority as your stored connection, and click on Next. Over here, it will ask us, please select SQL file we want to open. I already have created SQL file, which I'll select from this Browse menu. I selected the file Test1.sql. There is an option if I want to execute this file upon opening. I'll select this one as I know that this one is safe to execute. I strongly recommend that do not select this check box if you are not sure about the content of the file which you are opening. Now click on Finish. It has executed the SQL which was part of Test1.sql. In the Test1.sql, I had very simple SELECT statement. It was SELECT * FROM sakila.actor. It will list us all the actors. Let's write another SELECT over here, and now we will save this file. Let's close Test1, and now we will open the same file once again. Go to Open a SQL script file in a new query tab, which is second option in menu over here, and open Test file once again. You can see that Test1.sql now has two SELECT statements. Let's execute them together. Select these two statements, and click on Execute. Now let's look at our result pane. On result pane, you can see there are two types also over here. One is actor 1 and second one is city 2 . One and two is just indicating the order of the query, how they're executed. They are just an indication. You can reorder them as well. Actor is now listing all the actors, and city is now listing all the cities. Working with SQL Editor is indeed very easy.

Demo: Inserting Data
Now we will learn how we can insert new row using SQL Editor. Go to Schema or database sakila, click on Tables, right‑click on actors and select Select Rows. It has returned us rows from table actor. Now on the Result tab, you can see on the top bar there is a menu. The first menu says Edit current row, which we have seen it earlier, and now go to the next one. There is a small plus sign on table grid there. The pop up says Insert new row, click over here. At the end of the table, it has given us a new row. Here I'll insert a new ID 1000, name is Pinal, last name is Dave, and last updated date, let's put any date. Now the logic of apply and cancel is still there. Click on Apply if you want to insert this row. I'll click on Apply and it has automatically generated insert script for us. Now you can see the insert script has been generated. You can see the values when when you scroll on right side. Now click on Apply and click on Finish. Now you can see apply and cancels are disabled. If you go at the end of it, you can see the new row has been inserted. In the next clip, we will see how we can delete the newly inserted row.

Demo: Deleting Data
In this clip, we will see how we can delete any row using SQL Editor. We'll be deleting the row which we have just inserted in a previous clip. Click on the row which you want to delete, and, once again, you go to the menu of the result pane. Beside the Insert new row, there's a minus sign over the grid. Click on this menu icon, and you can see the row has disappeared. Click on Apply. You can see the SQL for DELETE is generated. Click on Apply again, and it has applied the SQL script to the database. Click on Finish, and let's scroll down. And this time, Apply and Cancel are disabled. Now you can see how easy it is to select INSERT, UPDATE, and DELETE rows in MySQL Workbench.

Demo: View and Edit Column Definition
Now we will see how we can view and edit column definition in SQL Editor. Go to Sequel Development area. Click on your server, and it will open SQL Editor. We'll be using sakila sample database for this example. Let's expand it and further expand table section. On the very first table, which is actor, right‑click over it, and now click on Altar Table. Altar Table will open up this screen where we can complete table definition. We can see there are four columns over here, the actor_id, first_name, last_name, and last_update. Additionally, we can see each column name's data type as well. Actor_id is SMALLINT, first_name is VARCHAR, last_name is VARCHAR, and last_update is a TIMESTAMP. If you remember, we talked about there are various properties of column. Now we can also set them over here. First column PK stands for primary key. Actor_id in this table is a primary key. The second column is Not Null column. You can see that actor_id, first_name and last_name, and last_update are Not Null column. The next column, UQ, stands for unique index. There is no unique index in this table. BIN stands for binary. If any of the column was binary, the check box in front of that column would have been selected. UN stand for unsigned data type. In this case, SMALLINT is unsigned data type. Also, there are two additional properties which we have talked earlier. One of them was default value. You can also selected default value over here. ZF. ZF stands for fill up value for that column with 0 if it is numeric. If any of this column is numeric, we can just select this particular column, and it will automatically default it to 0. AI stands for auto increment. In this case, the first column, actor_id, which is also a primary key, and it is also auto incremented. If you remember in a previous module, we talked about how most of the time the column which is auto incrementing is a good candidate for primary key. If there is any other default value, we can also specify them over here. For example, in the fourth column, which is last_update, we have a TIMESTAMP data type, and it is not null, and the default value is CURRENT_TIMESTAMP. What it means is that when we insert any row in this table, if we do not specify what data goes to last_update, it will automatically assume current timestamp value, which is current datetime. You can further see the translation of each of these columns in this area. If you carefully look over here, you can see there are other types as well. The Indexes tab talks about what kind of index exists on this particular table. We can also create new indexes, as well as delete indexes over here. We can use this Foreign Keys tab to define foreign key between this table and another table. If there are any triggers, they will be listed over here, and we can further modify them. If table is partitioned, you can see the logic over here. We will talk about partitioning in administration course. And on the last tab, we can set up various different values for table. For example, here you can specify the auto inclement value. This is the new initial auto increment value for the table. If you have 1000 records in this table, the next record will be 1001. Remember to click on Apply if you want to commit any changes you do with table definition.

Demo: Creating Snippet
Now we will see how we can use Snippet in MySQL Workbench. Snippets are nothing but a library of SQL syntax. No matter how expert you are writing SQL queries, they're always moment when we don't remember what was the exact syntax of particular feature. To enable Snippet area, go onto MySQL Workbench, on a further right most icon over here, click here, and it will open up Snippet area. Let's see few of the snippet. Double‑click on SELECT Syntax, and you can see the select syntax is given over here. You can either edit this one and write new syntax over here and click on Done. Similar way, we have a JOIN, INSERT, UPDATE, DELETE, and REPLACE Syntax. Let's try to create snippet for selecting data from a table. I'll write down syntax over here, which is SELECT * and FROM. Now I will select this one and click on Add Snippet. When I click on this one, you can see there is a new entry over here. Now double‑click on it and you can see the selected text is visible here, which is SELECT * FROM. Now, click on Done again. Now type any schema name followed by a table name, for example, sakila.actor. Now, right‑click over the snippet and select Insert snippet text at the cursor and you can see it automatically populated SELECT * FROM and table name, which we had already written. You can just click on Select, and now it will display the data. This is how you can use snippet to expedite writing your SQL queries.

Demo: Output Window
Now we will see one more feature of MySQL Workbench, which is Output tab. In the SQL Editor, go on the top, and select on second most, which you see over here. You can see it has brought up Output tab without any data over here. Let's go to sakila database and right‑click over actor table and select a few rows. Output tab displays us any query which we have executed, along with any message. If we have done any syntax error, we can also see that in our Output window. For example, here instead of FROM I'll write FROMS. Now, let's execute the whole query again. You can see that the query is not correct anymore and error is now displayed over here. Error code: 1064. You have an editor in your SQL. Now let's go back to Home tab.

Demo: Data Modeling
So far we have been seeing features from SQL Development section. Let us see how Data Modeling section works. We'll create a EER model from existing database. Let's click over here and select our preferred connection. I'll select SQLAuthority. Click on Next, and it has successfully connected to DBMS. Additionally, it has also Retrieve Schema List from Database. Click on Next, and you can see all the schema, which exists in MySQL database. Let's select sakila, and click on Next. You can see on the screen that it has successfully retrieved all the object from selected schema. Click on Next. On this page, it is asking us what are the objects which we want to use for reverse engineering. We can select tables, views, routines, and triggers. Just for this example, I will leave all of them checked and click on Execute. We can see that it has successfully executed reverse engineering task. Click on Next, and we can see the success message. Now, for last time, click on Finish. Here is our EER diagram. Well, currently, all the objects are over each other. Let's select all of them by typing Ctrl+A. Now go to Arrange, and click on Autolayout. It will automatically lay out each of these tables along with their relationships. Let's go to city table and click on Indexes. Click on Indexes, and you can see there is the only Primary key over here. EER diagram are very interesting to read. Let's go back to the main screen of MySQL Workbench.

Demo: Server Administration
Now let's understand a couple of important features of MySQL Server administration. Double‑click on the connection, which we already created, and it will open the server administration area. On the top of the screen, it displays Server Status. You can see in this info section that the name of our server is SQLAuthority and it is running on a local host. Additionally, the version of the server is also 5.6.10. The status of our server is running. On the very right side, we can see the system health of the CPU and memory. MySQL Server health is also displayed right beside it. Connections, traffic, query cache hitrate, and key efficiency are displayed here. We can quickly see them and get an idea of how the server health is. Also, you can see there are four different connections, and each connection has a different state. One connection has a query, and the other three connections are right now in a sleeping state. If there is a query which is taking a lot of resources, you can either kill the query or can kill the complete connection as well. Right below the server status, there are startup and shutdown options. You can stop your MySQL Server from here, as well as start it. Let's stop our server and start again. Currently the server status is running. Click on Stop Server. And now you can see the server instance is stopped. If you want to start the server instance back, you can just click on Start Server and it will turn on MySQL Server instance. You can use this administration screen to do a lot of other tasks as well. For example, you can collect status and system variables, or you can see server logs. If there are any errors, you can find them over here. Additionally, you can configure MySQL administration's lot of variables over here. There are many important settings in this configuration area. In MySQL Administration course, we'll go over each of these options and their significance. We'll discuss about logging, InnoDB, networking, advanced settings, other settings, security‑related settings, replication, MyISAM, and performance‑related settings. I open _____ developer, working hard to tune their SQL queries; however, they absolutely ignore this performance step in MySQL administration. There are many options available in this configuration area which can immediately impact performance very positively. This server administration area also gives you fine control on your users and their privilege. You can take a backup and export your database or import your database and restore your MySQL databases from this Data Export/Restore section Let's click on the Home tab and go to the main screen of MySQL Workbench. Well, with this, we finish our introduction to MySQL Workbench.

Demo: Workbench Central
Now we understand three major sections of MySQL Workbench, SQL Development, Data Modeling, and Server Administration. Now we will understand Workbench Central. Click over here, and you can see there are various links for Workbench Central. The first one is MySQL Doc Library. Click over here, and it will open MySQL documentation. You can pretty much search anything over here, and this is a great reference. For example, let's search for alter index. And when we searched for alter index, it gave us 24 matches, and all of them showed up instantaneously. Let's do another search. Let's search for create database. There are more than 50 results for create database. If you are doing MySQL code and if you are stuck, I strongly encourage you to refer to MySQL Workbench Reference Manual. There's a good chance that it will solve all of your problems. Let's close this and go to Home tab. The second link over here is MySQL Utilities. When we click over here, it displays a list of MySQL utilities. They are very important. For example, there are utilities for identifying difference, auditing administration, or doing import or export. Let's close it, and here is the link for database migration. When you click over here, it opens MySQL Workbench Migration Wizard. This result assists us in migrating table and data from supported database systems to MySQL. You can also use this one to copy the database from one MySQL instance to another MySQL instance. Let's close this one. Similarly, we can submit MySQL Bug from MySQL Workbench itself, as well as for additional tips and tricks, we can read Workbench blogs. Now we are back on the main screen of MySQL Workbench. With this, we conclude this module and move to summary.

Summary in Sixty Seconds
Summary in 60 seconds. MySQL workbench is divided into three major sections, SQL Development, Data Modeling, and Server Administration. We can retrieve, view, edit, or delete data from SQL Editor of SQL Development section. We can create database model, as well as reverse engineer database from Data Modeling section. We can start, stop, manage MySQL instance from Server Administration section. Remember, we can use MySQL Command Line Editor if we have no access to MySQL Workbench. You can download MySQL Workbench from the URL displayed on the screen.

Data Retrieval Techniques
Introduction
Hi, this is Pinal Dave for Pluralsight. In this module, we will discuss about various data retrieval techniques. For any IDBMS, data retrieval is the most essential task. In an earlier module, we learned we can use MySQL Workbench to retrieve and modify data. MySQL Workbench is a great tool for developers who have deal with the data. For any application, we have to write scripts in SQL to retry or modify data. SQL stands for Structured Query Language. In this module, we will learn how to code SELECT statement and retrieve data. It is very important to have proper understanding of how SELECT statement works and its building blocks. All the concepts which we learn about SELECT statement applies to UPDATE and DELETE statement, which we will explore in the next module of data modification. Let's start to understand the basic of SELECT statement, and its most essential building blocks, WHERE, ORDER BY, and LIMIT.

Basics of SELECT statement
Developers use SELECT statements for various purposes. Here is a list of a few of the examples where we use SELECT statements, retrieve static value, retrieve all the data from a table, retrieve all the data ordered by a single column, retrieve selected columns from a table, retrieve data with filter conditions, retrieve data with a filter condition and ordered by multiple columns, retrieve empty result set. In this module, we will see examples of this, as well as few real‑world scenarios. Let's start with understanding the basic syntax of the SELECT statement. A basic SELECT statement has five clauses. SELECT clause. It displays the column in the result set. FROM clause. Names the base table from which the query retrieves data. We can also use views here, but that's an advanced concept. WHERE clause. It specifies the condition that must be met for any row to be retrieved in the result set. ORDER BY clause. It specifies how to sort the rows in the result set. We can have one column or multiple columns by which we can order a result set. LIMIT clause. It specifies the number of the rows to return. Sometimes tables are very huge, and it's important that we retrieve only a limited number of the rows for various reasons. In the basic syntax of a SELECT statement, we have not included all the clauses in this basic syntax of a SELECT statement. For example, the HAVING clause. The HAVING clause filters data based on aggregate functions. In our advanced course, we will be talking about aggregate function. At the same time, we will explore the HAVING clause and also understand the difference between a WHERE clause and a HAVING clause. Now let's see SELECT statement in action.

Setup for demo
Before we start with our demonstration, let's understand the setup required. We will need MySQL Server, MySQL Workbench, and sample database sakila. In my case, I've used MySQL Installer for Windows, and it has by default installed MySQL Server, Workbench, and all the necessary sample database. You can use either of the methods, but make sure you do practice all the demos which you see in this course. Now open MySQL Workbench, click on your server name, and it will open SQL Editor. This is the screen where we will be starting most of the demos. On the left side on Object Browser, you can see we have sakila sample database installed. Most of the demos of this course will begin with this screen.

Beginning SELECT statement
We'll open MySQL Workbench, and let's start with simple examples. As discussed in an earlier setup clip, you just need the Sakila sample database, MySQL Workbench, and MySQL Server. Let's start coding together. Let's try SELECT MyFirstValue. MyFirstValue is a string, and let's select that and see what result comes up. Click on Execute, and you can see MyFirstValue is now displayed over here. The name of the column is the same as the value, as we have not specified any alias. Let's type alias AS SomeValue. Now let's execute the same thing again, and you can see the name of the column is now SomeValue, and the value is MyFirstValue. A similar thing you can do with arithmetic operations over here, select 1+1 and let's see the fun. You can see that value is now 2, because 1+1 is 2; however, the name of the column is 1+1. Let's give it an alias over here, AS TWO. Now let's execute it one more time, and you can see now the name of the column is 2, and the value is also 2. In MySQL, you can also get the current date time by using the function NOW. Let's run SELECT NOW. The result displays with the current date and time. If you just want only the date part and not the time part, you can just write SELECT CURDATE. Let's execute this, and you can see only the date part is displayed and the time part is not displayed anymore. If you want only time, a similar way you can write SELECT CURTIME, and it will display as the current time, and the date part is not displayed. You can also display the value of pi by using SELECT PI via its in‑built function. Let's execute it, and you can see the value of pi is displayed here, 3.141593. Well, you can do other mathematical functions as well, like finding a remainder. When you divide 45 by 7, what will be the remainder? Well, let's run SELECT MOD 45, 7, and it gives us a remainder as 3. Another interesting function would be to just find the square root of any value. Here we have specified 25, and the square root of 25 is 5. Let's execute this, and you can see it has found the square root of 25, which is 5. You do not need FROM, WHERE, ORDER BY clauses if you are just doing some simple operations.

Demo: Select without FROM clause
We'll open MySQL Workbench, and let's start with simple examples. As discussed in an earlier setup clip, you just need sakila simple database, MySQL Workbench, and MySQL Server. Let's start coding together. Let's try SELECT MyFirstValue. MyFirstValue is a string, and let's select that and see what result comes up. Click on Execute, and you can see MyFirstValue is now displayed over here. The name of the column is same as the value as we have not specified any alias. Let's try alias as SomeValue. Now let's execute the same thing again, and you can see name of the column is now SomeValue, and value is MyFirstValue. Similar thing you can do with arithmetic operations over here, SELECT 1 + 1, and let's see the fun. You can see that value is now 2 because 1 + 1 is 2. However, name of the column is 1 + 1. Let's give it a yes over here AS TWO. Now let's execute it one more time. And you can see now, name of the column is TWO, and the value is also 2. In MySQL, you can also get current datetime by using function NOW. Let's run SELECT NOW. The result displays with current date and time. If you just want only date part and not the time part, you can just write SELECT CURDATE. Let's execute this, and you can see only date part is displayed, and time part is not displayed any more. If you want only time, similar way you can write SELECT CURTIME, and it will display us current time, and date part is not displayed. You can also display the value of pi by using SELECT PI via its in‑built function. Let's execute it, and you can see the value of pi is displayed here, 3.141593. Well, you can do other mathematical functions as well, like finding remainder. When we divide 45 by 7, what will be the remainder? Well, let's run SELECT MORE 45,7, and it gives us remainder as 3. Another interesting function would be to just find square root of any value. Here we have specified 25, and square root of 25 is 5. Let's execute this, and you can see it has found square root of 25. It is 5. You do not need FROM, WHERE, ORDER BY clauses if you are just doing some simple operations.

Demo: Retrieve all the data from table
Now we will see how we can use star and retrieve all the data from the table. Here is an example, SELECT * from sakila.actor. When we use a star and do not provide any filter condition using where, this statement will retrieve every single column and every single row from sakila.actor table. Select the statement and click on execute. You can see it is retrieving all the four columns and all the 200 rows from sakila.actor table. Let's take another example. We can also retrieve all the rows and all the columns from sakila.city table. Select the statement and click on execute. Well, if you noticed, we are using sakila.city name. This naming convention is database.tablename. If you don't want to keep on using sakila in the name of this table, you can use another technique. For example, here I'm using USE sakila. When we execute this statement, it will, by default, sakila database has a database for every subsequent execution of statement. Let's see that into action, but first, pay attention on the left side in the Object Browser. You can see sakila, test, and world; all three have similar forms. Now let's execute USE sakila. When you execute this one, at that time, now sakila is highlighted or bold. What it means is that now sakila is the full context for every single execution after the statement. When we execute this one, it will retrieve the same data, which we got from SELECT * from sakila.city. USE the data's name is a good idea to execute if you know every subsequent execution you are going to do from same database. Let's close this. And now in the next clip, we will retrieve all the data ordered by single column.

Demo: Order data based on a column
Now we will see how we can retrieve all the data ordered by single column. For example, here is SELECT * from sakila.actor, which we have just seen. It has four columns actor_id, first_name, last_name, and last_update. Quickly glancing at results set, we can see that first_name column is not ordered alphabetically, so is last_name. We can quickly order first name in alphabetical chronological order if we write ORDER BY first_name right after select statement. Let's select this statement and execute it. Now we can see that first name is chronologically ordered. Adam is first, Zero is at last. Interesting enough, the name of actor is Zero. Similar way, we can order the same table with last name. Let's execute this statement. Now you can see that the complete table is ordered by last_name column. A is on the top and Z is at the bottom. Well, currently we are just seeing them in alphabetical order. However, the order is ascending. We can also change the sequence order by just adding descending clause. Let's execute this first statement where we have first name as descending in ORDER BY clause. When we execute that, we can see now Zero is on the top and Adam is on bottom. What happens here is that by adding ORDER BY, column name, and DESC clause, now entire table is ordered descending by first_name column. We can do similar thing with last_name as well. Let's execute this statement. And now entire table is ordered by last name descending. ORDER BY clause is very handy and very easy to use. Now, in the next clip, we will see how we can retrieve selected columns from table.

Demo: Retrieve selected columns from table
So far we have been retrieving all the columns and all the rows from the table. Now we'll see how we can retrieve only selected columns instead of retrieving all the columns. For example, let's see SELECT * FROM sakila.actor. There are four columns, first is actor_id, second is first_name, last_name, and last one is last_update. Now it's quite possible not everybody needs last_update data. Some people may only want to see first_name and last_name. Well, we can do that very easily. Instead of writing *, we can just write first_name and last_name and select data from this table. We'll write SELECT first_name, last_name FROM table name, which is sakila.actor. Let's select this and execute. Now you can see we are getting data from only two columns, which is first_name and last_name. There are many reasons to spell column names instead of writing *; however, the primary reason for that is performance. Additionally, note the data which we retrieve for first_name and last_name is not in order. If you want to order them, we can just specify ORDER BY clause over here. In this case, I'm specifying ORDER BY first_name DESC. Let's select this statement and execute it. Now we have first_name and last_name column ORDER BY first_name DESC. In this example, we have seen how we can filter columns and retrieve only the columns which we need. In the next demonstration, we will see how we can further filter rows as well.

Demo: Retrieve selected columns and rows
In the earlier example, we filtered columns. In this example, we will filter rows. SELECT * FROM table name retrieves every single row and column from table. You can see that in this example where I'm retrieving all the data from sakila.actor table. Here let me introduce a new clause, which is WHERE clause. WHERE clause is nothing but condition. In later part of this module only, we will understand WHERE clause in detail, however, this is a simple example. Let's read the statement from the start, SELECT * FROM sakila.actor. What it means is that now we are going to get every single row and every single column from sakila.actor table. Now let's read the next line, WHERE actor_id > 100. What it means is that now we will only retrieve from sakila.actor table those rows where actor_id is greater than 100. Currently our sakila.actor table has 200 rows. Now we are talking about retrieving rows only where actor_id is greater than 100. Let's select this statement and execute it. You can see that in our result our data starts from actor_id 101. Let's quickly scroll down and see if there are any date which is less than 100. A quick inspection demonstrates that there are no rows which has actor_id greater than 100. What it means is that this WHERE condition has filtered out rows where actor_id is 100 or less. Now let's change this greater than to less than and see what result it brings to us. After executing, we can see that we have actor_id 1, however, let's see what is our maximum actor_id. The maximum is 99 because here we have WHERE condition where we have specified that WHERE action_id is less than 100. You can notice that writing WHERE condition is very simple and it's very intuitive. Let's see next example. In this example, now we are filtering out the fourth column, which is last_update. We are only selecting actor_id, first_name, and last_name. We have changed here the WHERE condition. Now I'm mentioning WHERE first_name is equal to Nick. What it means is that now we will retrieve only those rows where first_name is equal to Nick from the table sakila.actor Let's select this statement and execute it. We can see there are three records over here. All three record has first_name as Nick, however, last_name is different. Additionally, the fourth column of last_update is also not visible over here. It was very easy to see how we can filter rows and columns.

Demo: Bringing it together
Now we will further continue our same example and see how we can filter columns, filter rows, as well as order record set with multiple columns. Let's start with a very simple example. Here we have SELECT* from sakila.actor where first_name is equal to Nick. As we have seen, we are going to get four columns because there is star, and three rows because we have first_name is equal to Nick. Let's execute it, and, as expected, we can see now four columns and three rows. Let's assume that we don't need last_update column. We'll remove that. Now we will not use star. Instead of that, we'll specify actor_id, first_name, and last_name. While we do that, we will also add one more twist. Currently, we are getting our data which is as per actor_id ascending. Let's change the sequence, and we want now data, which is ORDER BY actor_id descending. What it means is that we want our very first record to be 166 and the very last record to be 2. We can easily do that if we specify only three columns in a SELECT statement, and additionally, we provide ORDER BY actor_id sequences descending. Let's select this and execute. You can see now we are getting 166 as the top record and 2 as the bottom record. Currently our result is ORDER BY by only one column, which is a actor_id. Let's make it more complicated. I'll change the WHERE condition and I'm retrieving, once again, actor_id, which is greater than 100. Here we have ORDER BY first_name, which is ascending, and last_name, which is descending. Additionally, we have three columns, which is actor_id, first_name, and last_name. What it means is that we have all the elements which we'll learn together in this single query. We are filtering by columns. Additionally, we are filtering by rows. Also, we are ordering this complete result set by multiple columns, which is first_name and last_name. Let's execute this, and now we have the result set. We can clearly see that every single record in the first column actor_id is over 100. Additionally, let's pay attention to the first name. You can see that the first name Adam is on the top and William is on the bottom. What it means is that first_name is ordered ascending alphabetically. However, there is also last_name which is ordered descending. What it means is that after the first_name column is ordered alphabetically ascending, MySQL will pay attention to the last_name column. Let's see an example. Look at these two lines. We have the first name Warren, and last name is Nolte and Jackman. You can see the last name is now ordered descending because N comes first and J is now coming later on. Here is the example where we have Russell. If you think of alphabets, you can see the B should come first; however, we have ordered last name descending. What it means is that now T is coming first, and later, C and B. So, MySQL has first ordered complete data, as per first name ascending and later order complete result set by last name descending. Let's see a tricky concept next where we retrieve an empty result set.

Demo: Retrieve empty resultset
Let's see a tricky example. I've seen a lot of developers writing SELECT* from table name, where they just want to see what kind of column table has. When we run SELECT* from table, it will pretty much retrieve every single row and every single data from complete table. This is not a good idea if you just want to know what are the names of the column. The very quick trick would be over here is to just write where 1 = 2. When you write where 1 = 2, at that time, MySQL will not return you any data because 1 = 2 is always a false condition. It's good to understand that you can write this kind of query and get empty result set. With this step, we complete our learning of fundamentals of SELECT statement. In next clip, we will understand advance concepts relative to SELECT statement.

Working with Arithmetic Expressions
Now we will see a demonstration how we use arithmetic expressions, as well as column aliases. By default, MySQL gives column in the result set the same name as the column in a base table. However, for business needs, we can specify a different name known as column alias. If a column is based on calculated values, by default, the name of the column is the complete expression. This automatically assigned expression is usually very difficult to read, as well as write. It's always a good idea to assign a column alias to a column, which either has a calculated value or very complicated name. We will see that in a demonstration later this clip, MySQL values any arithmetic expression from left to right. The order of precedence is as follows, multiplication, division, integer division, modulo, addition, and subtraction. If your multiplication and addition are in the same expression, MySQL will first perform multiplication and later addition. When we are reading from left to right, we forget the importance of order of precedents. If you want to avoid confusion, it's always a good idea to use parentheses. Parentheses avoids confusion, as well as gives you expected results. Arithmetic expression involving multiplication, division, addition, and subtraction are very common. Modulo or remainder or integer division are not commonly used arithmetic expressions. We will see in the next demo how we can use these various arithmetic expression in MySQL queries.

Demo: Arithmetic Expressions
Now let's understand the concept of alias with example. Let's first retrieve few column from sakila.rental table. Select the statement and click on Execute. You can see we have retrieved three columns, rental_date, inventory_id, and return_date. Due to any reason, if you do not like these column names, we can just change them. For changing column name, we just have to alias them. For example, in this SELECT statement, rental_date is original column name. We can just say rental_date AS RentalDate in a camel case, and now this is our alias. Similarly, for inventory_id, we are also aliasing it as FilmListID. For return_date, the alias is ReturnDate in camel case. Let's select the statement and execute it. You can see in the result set that original column names are now replaced with column aliases. However, the data which is being displayed right after the header title, it's same, and there is no difference at all. So in other word, aliases is just another name for any of the column. Well, there is not much of the importance of alias at this point of time; however, alias becomes very, very important when we are dealing with arithmetic expressions. For example, from sakila.film table we are retrieving three different columns, and two of them have arithmetic operation. Let's select the statement and execute it. You can see the column names are very wide. The most is easy way to fix this problem is to just alias a column. Let's see that now. You can see in this example I have aliased replacement_cost‑rental_rate AS CostDiff. Length/60 is now aliased AS TimeinHour. Let's execute this statement, and you can see that column width is much lesser and it's very easy to read. You can see in this SELECT statement we have used various different arithmetic operators. For example, we have plus, multiplication, and subtraction. However, to make this more interesting, I have used parentheses at a different place. Select this entire statement and now click on Execute. You can see that arithmetic operation on original column changes the complete meaning of the column. Now let's see one more example. Let's select this particular statement and click on Execute. Here you can see each column has a different value. You can see the original column replacement_cost is now aliased with ReplacementCost in camel case. Right after that, it is divided by 5. Our result will be decimal. However, if we don't want decimal results, we can just use the word DIV. It will give us integer results. We can also find very quickly modulo or remainder of any value. For example, here we have value 20.99. When it is divided by 5, we are getting the value as 4198. When we use the DIV function, it will only give us integer part of this decimal value. In this case, it's 4. In this case, it's 2. In this case it's 3. Here there is a 12.99. When we divide that with 5, our remainder is 2.99. Now you can see how various arithmetic operation come together with a regular SELECT statement and start building intelligent data.

Select statement and other functions
So far, we have seen SELECT with aggregate functions, as well as doing some static operations. Now we will see how we can use SELECT clause with various other functions. For example, we will see functions related to numbers, strings, and dates. One of the interesting challenges we developers have is to eliminate duplicate rows from our result set. We will see that how easy it is to eliminate duplicate rows by ending simple keyword distinct. Now let's go to MySQL Workbench, and we will see each of these into action.

Demo: Select statement and other functions
Here we are back in MySQL Workbench, and we will see a demonstration related to integer, string, and date functions. If you see the list of all the functions in MySQL, the list is extremely large. It's just impossible to cover each and every function and explain them in a single course. However, we'll see a few of the important functions in this demonstration. Once you know how to use one function in SELECT statement, you can go and use any other function in SELECT statement as easily. We'll very first see how integer works. Here is the statement where I am retrieving data from payments table. Let's first select the data, and later we will understand what each of this function do. Select the statement and click on Execute. Now you can see we have five different columns displayed in the result set. The very first column is amount. You can see amount is directly retrieved as it is from payment table. We have not modified or applied any function over it. The second column over here is using ROUND function. ROUND function rounds up or rounds down any of the decimal value to nearest integer. You can see 2.99 is converted to 3, and 0.99 is converted to 1. If you scroll down, you will see the similar examples over here. In the third column, once again we are using ROUND function. However, this time we are specifying second parameter over here. Second parameter we have passed is 1. What it means is that when you round up or round down, at that time, display information until first decimal. For example, over here, you can see now 1 is 1.0. To see them further into action, let's take one more example where we will not use any FROM clause, but write over tag any integer value and try to apply ROUND over it. Let's write SELECT ROUND and function. Now let's pass here the value 4.5, and let's execute it. You can see it's now rounded up to value 5. If we pass 4.99, it would still round up to 5. However, if we pass 4.49, it will round it down to the 4. Let's go back to our statement and execute it again. Now we have two more functions to look at. FLOOR rounds down any of the value to the nearest lowest integer; whereas, CEILING rounds up any value nearest higher integer. Let's see an example over here. We have value 2.99. When we apply function FLOOR over here, it has rounded it down to 2. And when we apply CEILING function over here, it is rounded up to the 3. Though they look very simple, these are very important functions and comes very handy when we are dealing with numbers.

Demo: Select statement and string functions
In this demo we will see how we can do some of the very common string operations with string functions, for example joining two strings and making it a single string. One of the most common tasks every developer faces is to concat two strings. For example, if you have first name and last name, if you want to display a full name you just have to concat two strings. MySQL has an inbuilt function, which we can use to just concat string. For example, here we have CONCAT function. We can pass multiple parameters over here. I will pass three parameters. First is first_name, space, and last_name. Now let's execute this one. Select the statement and click on Execute. I'll alias the column AS FullName. Under the FullName column you can see now first name and last name are displayed together with a space between them. You can see how easy MySQL makes it to join two or more strings. If your need is to just display initial of the person you can do that using MySQL as well. Here is the second example where I'll use function call LEFT. LEFT take two parameters, first is a string and second one is how many characters you want to select from the left side. Here I'm applying LEFT function on a first name, as well as on a last name. And both the times I'm just selecting one character. When we run this complete SELECT statement you can see that along with the full name now we are able to see the initials. Currently initials has a space between them because I have left space over here. If you remove this space and comma and execute it again you can see that now initial does not have a space between them. Similarly, there is a function called RIGHT, which will just select the right‑most rows. Currently, we are selecting only one character. Let's make it two for first name and last name. Now let's execute it one more time. You can see this time that we are getting first two characters, first name and last name. For example, we are selecting PE from PENELOPE and GU for GUINESS. Similar thing is for NICK we are selecting NI, and for WAHLBERG we are taking WA. As we know that we are selecting only two rows from first initial and last initial, the string which is built for initial has a fixed length. However, in case of the original first name and last name, we really do not know what is the length of this string. We can use function LENGTH and can figure it out length of our first name and last name together. For example, here I'm concatenating first_name and last_name and applying LENGTH function over it. Let's execute this complete statement. And here it is. For example, NICK WAHLBERG has 13 characters and JENNIFER DAVIS has now 14 characters. One of the functions is REVERSE. What it will do is that it will take the complete string and display it in the reverse order. We can use this function to figure out palindromes. Let's execute this one. Now in the result set the first column is FullName, which is the original full name. You can see NICK WAHLBERG is all here. But when we see the reverse full name it is now spelled backwards. For example, last character G is the first character over here, and second last character which is R is now second character over here. Let's examine the REPLACE function. For example, in JENNIFER DAVIS we have S as the last character. When we see the replaced example we can find DAVI$ because our S is now replaced with $. A similar thing is also there with GRACE MOSTEL. In this case, S is once again replaced with $. You can use this REVERSE and REPLACE function and can do a lot of different things. Next, we will see functions related to date and time.

Demo: Select statement and date functions
Now we will see some of the functions related to date. One of the most used function is DATE_FUNCTION. Every country and every geographic region has their own format. When we are dealing with an application which is using a multiple country, we are to carefully pay attention to the date and time. In our daily routine and in our application, we need a different part of the date. Sometime we need to know date part, and sometime we just need time part. Let's see some of the date and time functions right now. Let's see this very first script. Select the statement and click on Execute, and here, you can see the date is first and the month is in middle. Also, one of the other difference between these two column is how well we spell. If you look at the last column, it's also very differently formatted. Even the date and time are the same, the way it is displayed are different. In my circle, we have a different mask for date and time. For example, when we have m, d, and y in the smaller letters, they each map to month, day, and two‑digit year. If we just capitalize Y, it means now four‑digit year. Similar way, if you want your month to represent with three corrector string, you can just use small b. Capital T stands for the time, and F stands for precision of the time. If you search for function_date‑format in MySQL documentation, you can find detail of each and every mask available for date format. For example, a stands for abbreviated weekday name, whereas, small h stands for hour. Capital H stands for now hour as well, but in 24‑hour system. If you want day of the week, you can just use small w, and if you want weekday name, you can just use capital W. And if you go further up in the MySQL documentation, the 12 section is dedicated to functions and operator, and over here, you can find out various numeric function and operator, as well string functions. Here is the entire list of string functions and operator, which you can practice out each one at a time. Similar way, here is the list of string functions. Let's go to next script. Now you can see that we can change this mask and build the date and time format as we want. Let's go to next script. Here is the date format. It's quite possible that we are not familiar with each country or its zones. At that time, we can use a very interesting function which is GET_FORMAT. What GET_FORMAT does is that instead of specifying mask, it will automatically get the format based on your date and time from the zone which you specify. For example, let's execute this, select the statement, click on Execute. Now we have four columns and you can see on a very first column, if you carefully pay attention to each of these columns, you can notice that they have the same value. The reason is very simple that GET_FORMAT when we use with the DATETIME for Europe, ISO, or USA, it gives us the same time format. Now I replace DATETIME with time and let's execute the script again. When you execute the script again, now you can clearly see that all the column has different information. You can see over here that column number one and last has pretty much same information, however, date and month are swapped. In Euro, the date is always first, in USA, month is always first, and in ISO format, year in a four‑digit month and date. Let's first, we execute this script, and later, we will understand the output. In our result pane, we have five column. First is rental_date, which is the original date_time and other four columns. The date is May 24, 2005. It was the third week of the day and it was in a second quarter as month is May. This particular month was twenty first week of the year. Well, MySQL has a default function where it will give you day of the week, quarter of the year, week of the year, and name of the month. You can just use any of this function and pass your datetime as one of the parameter. It will give it output which you are expecting. With this, we end our clip, but you can notice that how easy it is to use various function in a select statement and can get desired output.

Demo: Select statement and distinct rows
Now in this demonstration, we will understand how distinct keyword impacts query as a set. Before we execute query, let's enable Output window. Go over here in MySQL Workbench, and click in here to display output Window. We'll first execute SELECT first_name from sakila.actor. Select this statement and click on execute. You can see the results set over here, as well as can notice there are 200 rows returned from this query. Now we will execute second query. Only difference between first query and second query is distinct keyword. We have additionally added distinct keyword because now we want unique first name from sakila.actor. Let's execute this one, and this time, you can notice that we only received 130 rows. What it means is that there are 70 records which were duplicated. Now duplicate records are eliminated and we can only see distinct result sets. Let's run it again for last name. Select last name from sakila.actor and click on execute. From result set, you can clearly see that Allen last name is there multiple times, as well as Barry. Now we'll learn another select statement where we have distinct keyword right before the last name. Select the query and click on Execute. Now Allen is only displayed once, so is Barry. If you look at Output window, we can see that when we select the last name from sakila.actor, at the time MySQL returned 200 rows. However, as soon as we added distinct keyword, it has returned us only 123 rows. We can use distinct with multiple column, as well as with star. The purpose of the distinct is to return unique rows based on a column using a select statement.

Introducing WHERE clause
Performance is a very crucial dimension for any application. So far, you have seen in most of the cases we are retrieving pretty much the entire table for our purpose. For that, we use SELECT* FROM Table syntax. We also learned that we should not retrieve columns which we are not using in our application and use column names in the SELECT statement instead of using SELECT*. There should not be a need of all the rows of the table. Most of the application, in most of the cases, needs only a subset of the rows from the table. We can limit the number of rows retrieved by query by using the WHERE condition. It is important that we understand how to use the WHERE condition very carefully, as it will help us tremendously when we are dealing with the very last table and we want to retrieve only rows which are required. Let's understand a few of the conditions which we can use in a WHERE clause.

Select statement and Comparision Operators
Now we will see how we can use various comparison operators in the WHERE clause. We can use comparison operators to compare any two expressions. MySQL is good at converting data for comparison; however, it's always a good idea to have both the sides of comparison operator to have the same data type. If the result of the comparison is true, the row being tested is included in a query result set. If the results of comparison is not true, the rows are not included as a part of result set. If you are comparing numeric value, we will not need single quote. If you're using string, date, or similar kind of data type, we may have to wrap our value with single quote. We will see that and understand that in the demonstration. Let's see the list of various comparison operators, =, <, >, <=, >=,<>, and !=. Let's see all of them in action.

Demo: Comparision Operators
Here we are in MySQL Workbench in SQL query editor. Let's see some of the examples of how the WHERE clause works with comparison operators. First, we will see how the equal operator works with integer and string. We'll be using the sakila.actor table for this demonstration. Let's now select the WHERE clause and select SELECT column name FROM sakila.actor. Click on Execute. We can see that it has returned us an entire table. Let's also enable the output window. In the output window, we can see it has returned us 200 rows. Now let's execute this entire query with the WHERE condition, where actor_id is equal to 100. Select this row and click on Execute. You can see an output window. It has retrieved only 1 row, and the row actor_id is equal to 100. Instead of selecting the entire table, we should be passing the WHERE condition and select the row which is needed. Here we are comparing the column name with the string operator. As mentioned earlier, for integer you do not need a single quote around it; however, for string, you need a single quote around your parameter. Now let's select this query and execute it. You can see in the result then it is retrieved as three rows and similarly it's also reflected in our output window. This query is returned as every single actor whose first name is equal to Nick. The implementation of the comparison operator equal to is pretty straightforward. Now we will see how the operator less than works. Instead of using equal in a WHERE clause, I've used less than. What it means is that now we will get all the actors who have actor_id less than 100. Let's select this query and execute. Now we have 99 rows, and when we check the actor_id in the result set, you can clearly see that it is less than 99. None of the actor_id is over 100. This is how we can use in our WHERE condition the less than operator. Let's execute this query and understand the result. Please pay special attention to the first name when I scroll over here. Very quickly, you will see the pattern that there is not a single name which is starting with any letter which comes after N in the alphabet. Now let's understand the greater than operator and we will understand the same example a little bit more in depth. In our SELECT statement in a WHERE condition, we have actor_id is greater than 100. Let's execute this and see the result set. The query has written 100 rows. When we see the result set, we can see actor_id starts from 100, and it goes all the way till 200. Any record with actor_id less than 100 is no more included in this result set. In the case of the second query, where we have first_name greater than Nick, select the statement, click on Execute. Now let's call the result set. In this result set, you can notice that every single name in the column first_name will be after Nick if their ordered alphabetically. However, in both the cases of greater than and less than, we have noticed that the actor_id 100 and first_name Nick was never included in the result set. There can be a scenario where we need actor_id 100, as well as first_name Nick, also included as part of the result set. We can do that if we use the less than or equal to operator. Let's see that in this case. In result plan, let's scroll down all the way, and you can notice the very last line is actor_id is equal to 100. What it means that this query has included 100 and every value which is less than 100 for actor_id. Similar logic also applies to first_name less than or equal to Nick. Let's select the statement and click on Execute. Now you can see that actor_id is equal to Nick is also included in our result set right away. Same logic also applies if you're going to use the greater than or equal to operator. Now let's execute this query. We can see that we have now actor_id 100, as well as every actor_id over 100. When I execute this query, any name alphabetically after Nick, as well as it includes first_name Nick. Well, now you know how most of the comparison operators work. However, there is one more comparison operator which is very important to learn, not equal to. Not equal to negates the condition which we have provided into the WHERE clause. Let's understand that with an example. In this case, we have a condition where actor_id does not equal to 100. What it means is that we will get every single result where actor_id is not equal to 100. Let's execute this query, and we can see that now we have 199 rows in the result set. If you scroll down and try to see between 99 and 101, there is no row 100 because actor_id equal to 100 should not be included in our result set. Similar case with first_name not equal to Nick as well. Let's execute this query, and you can see Nick was actor_id, too. It's not included in this query. If you scroll down all the way, you will not find name is equal to Nick. You'll find a result set containing every other name besides Nick. Well, with this, we complete our understanding of comparison operators. Let's go to our next concept of logical operators.

Select statement and Logical Operators
So far we have seen in a WHERE condition that we are using simple search condition. What it means is that we take one column name and try to compare it with string or indeed, a literal. However, the real‑world scenario is much more complex than this. We sometimes have more than one condition to compare and validate. At that time, we need logical operators. Logical operators help WHERE condition to become compound condition. We can use multiple logical operators and can build complex WHERE condition. For example, here is the list of popular, logical operators, AND, OR, and NOT. AND operator is true if all the conditions in WHERE clause are true or an operator is true if any one of the conditions in WHERE clause is true, whereas NOT is negate logic. What it means is that it will reverse the logic which we have used previously. Sometimes NOT operators tend to confuse developers because of readability issue. I suggest you write a logic in such a way that you don't have to use NOT condition. Well, to understand this, we have to see a demo. Let's open MySQL Workbench and see them in action.

Demo: Logical Operators
Here we are in my SQL Workbench in SQL Dditor. Let's first see how AND operator works. Here is a simple example from sakila.actor table. We are going to retrieve all the records WHERE first_name = KENNETH. Select the statement, click on Execute, and you can see there are four rows retrieved over here. Let's make it a little bit more complicated. In WHERE clause, we add one more condition, and the condition is that actor_id should be less than 100. Now if you carefully observe our result set, you can see there are three records which have actor_id less than 100, and 1 record which have actor_id greater than 100. Now because of this new addition in our WHERE clause, our result set will not have four rows, but it should have three rows. Let's execute this and check the result set. Now it's very clear that in our result set, we don't have actor_id which is greater than 100, even though the first_name is Kenneth. Besides having first_name Kenneth and actor_id less than 100, we have added one more condition where last_name = TORN. Let's execute this and check the result set. In our entire table, this is the only row which satisfies all three conditions which are specified in WHERE clause. Now we will see how OR logic works. First we'll see a simple example, and we'll retrieve all the records first_name = KENNETH. Now you can see we have retrieved four rows. Let's make it a little bit more complicated, and we add one more OR into our WHERE clause. Right now OR suggests actor_id is less than 100. What it means is that now our query should return everybody who has a first_name = KENNETH, as well any actor_id which is less than 100. For example, looking at this condition, we know that following four rows will be part of the result set. When we look at this condition independently, we also understand that there will be additionally 99 rows, also part of our result set, and there is always chance of overlap. What it means is that we'll definitely get all the records where actor_id is less than 100, as well as one additional row where actor_id is greater than 100 and is 169, because it qualifies for condition where first_name = KENNETH. Let's validate our assumption by exhibiting this query. And let's scroll down. At the bottom of our result set we can see that we have retrieved every row which has actor_id less than 99, as well retrieved row 169 because it has first_name is equal to KENNETH, and that is also one of our conditions. Now you can see in our WHERE clause we have added last_name = TEMPLE. What it means is that any row which has first_name as Kenneth OR last_name as Temple OR actor_id is less than 100 will be qualified for our result set. Let's execute that and scroll all the way to bottom. Now you can see that we have additional rows where last_name is equal to TEMPLE, and all of this row has actor_id greater than 100. Well, now let's move to our next logical operator, which is NOT. Well, NOT conditions are very simple conditions. They just negate the logic which we have used in a WHERE clause Let's see this example. Here we specify actor_id = 5. If we do not have a NOT, what it means is that this query will return us results where actor_id is equal to 5. However, because we have used NOT just right before our condition, what it means is that this query will return us every single result WHERE we don't have actor_id = 5. Let's execute this query and validate our assumption. Well, in result set, pay attention to actor_id column. There is no row between actor_id 4 and actor_id 6. What it means is that this query does not return us any result where actor_id is equal to 5. Remember what I mentioned earlier? NOT sometimes confuses the user or developer if there is very complicated logic. You can rewrite this query without using NOT as well. Look at this example. Here instead of using NOT, I have just changed the condition from equal to to not equal to, and this query will also return us absolutely same result. Now we have understood all three of our logical operators. Now let's put all of them together and understand with much more complex examples. Here is our first example. We have used AND and OR together. Let's execute this query, and we have retrieved seven rows. You can see this query has retrieved us everybody who has a first_name as KENNETH and actor_id is less than 100. Additionally, it has also retrieved all the records where last_name is equal to TEMPLE. Remember one more thing which we just discussed a few minutes ago, which is logical operator precedence. Logical operator precedence is is NOT, AND, and OR. What it means is that AND is evaluated first, and OR is evaluated right after it. In this case, these two conditions were evaluated first, and later they were OR'd with this condition. Let's send this order of condition and we will see that we will get absolutely different result than what we have just got over here. Now here is the second query. What we have done here is that we just took this OR and moved it a little bit before AND, and AND actor_id is now right after OR condition. As for the precedence of operator, AND will be evaluated first. What it means is that these two conditions will be evaluated first. These two conditions will be evaluated first, and later they will be OR'd with first_name = KENNETH. Even though both the queries have almost similar conditions, they have very different meanings. I select the query and click on Execute. Now this query has returned us every record where last_name is equal to name and actor_id is less than 100. What it means is that anybody who has a last_name is equal to Temple, but actor_id is greater than 100 is not part of this result set. Kenneth is an OR condition, so anybody who has a first_name is equal to Kenneth will be always part of this result set. And hence, we are able to see actor_id, which is 169, with first_name as KENNETH, also, part of this result set. The concept which we have just discussed is very, very important concept, and I strongly encourage all of you to execute this query on a Sakila sample database. Now let's make it a little bit more complicated and take this example to the next level. We'll start using parentheses to our logic which we have just seen. Here are two examples. Let's execute this first query first, and you can notice this query is very similar to our initial query. If you do not use parentheses is in this logic, it will still give us same result. However, it's not true in this case. You can notice over here we have parentheses around actor_id, which is less than 100, and last_name, which is Temple. When you select everything together and execute, you can see that we'll not only get the result where first_name is equal to Kenneth. Funny enough, we went the way of condition where last_name is equal to Temple, none of the row qualifies because now we have additional condition to our original result set, which says first_name is equal to KENNETH. There is not a single actor who has last_name Temple and first_name Kenneth. Now you can see the power of parentheses and order of precedence, how they play together and keep on changing our result. Well, with this, we end our logical operator section, and let's move to the various other operators related to WHERE condition.

Select statement and WHERE clause
WHERE clause is one of the most powerful clauses in the entire SELECT statement. There are lots of interesting elements which we can use in a WHERE clause to make it interesting to learn. For example, the IN phrase. We can use the IN phrase to test whether the expression is equal to the value in the list. The order of element in the list does not influence the final result set. Additionally, we can use subquery in the IN clause as well. During the demonstration, we will quickly see an example of the same. In an advanced course, we will cover this concept in detail. We can use the NOT operator to negate the logic of the IN phrase. The BETWEEN phrase qualifies the row of a result set when an expression falls within a range. The lower and the upper limit range expressions are also part of the range. Just like any other operator or phrase, we can use NOT to negate the result set. We can use the LIKE operator to retrieve rows that match a string pattern. A string pattern is called a mask. We will also understand how Wildcard percentage and underscore helps to build this string pattern using demonstration. Additionally, we can use the NOT keyword before LIKE and negate the entire logic. NULL is one of the most interesting concepts within the database. I've seen developers often getting confused with NULL. Incorrect implementation of NULL brings unexpected results. The NULL value stands for a value that is unknown or unavailable. It is not a zero or not an infinite. In SQL, we can't compare NULL by using the equal to operator. We have to use the special clause of IS NULL and IS NOT NULL. When we use this clause, our result set contains value based on this logic. Let's quickly jump to a demonstration and understand these concepts.

Demo: Using Between in WHERE clause
Let's open MySQL Workbench SQL Editor, and let's start with our very first example. First, we'll understand how IN works. Once again, we will be using sakila.actor table. SELECT * FROM sakila.actor WHERE first_name IN ('NICK', 'JOHNNY', 'JOE', 'VIVIEN'). What it means is that this query will return a result where first_name is any of these names. Let's verify that. Select the statement and click on Execute. The datatype of our literals is a WHERE string. That's why we have single quotes around them, and they're all separated by commas. If the datatype of our literal is an integer, there is no need of single quotes around them. Let's see an example of that as well. Here it is. In this case, we have literals as integers. We do not need single quotes around them. Our WHERE condition is WHERE actor_id IN (1, 2, 3, 4, 5, 6, 7). Let's select the statement and click on Execute. You can see the result set. We have all the results where actor_id is 1, 2, 3, 4, 5, 6, and 7. Well, the implementation of IN is very simple as you can see that. Now we will quickly see the example of the subquery. On our very first glance, we can see there are two different queries over here. The first query is that where we SELECT * FROM sakila.actor WHERE first_name is IN ('NICK', 'JOHNNY', 'JOE', 'VIVIEN'), and there is an OR condition over here, which is looking for actor_id IN, and then there is a second query. Let's read now the second query, which is SELECT actor_id FROM sakila.actor WHERE last_name = 'DEGENERES'. Let's execute this query and see what is its result set. When we run this result set, we can see it returns to us three distinct values, which are 41, 107, and 166. What it means is that there are three actors whose last name is Degeneres, and their actor_ids are 41, 107, and 166. That simplifies this query a lot. What it means is that SELECT * FROM sakila.actor WHERE first_name is IN ('NICK', 'JOHNNY', 'JOE', 'VIVIEN') OR actor_id IN (41, 107, 166). What it means is that we will get every record where the first name is either Nick, Johnny, Joe, or Vivien. Additionally, there will be rows where actor_id will be 41, 107, and 166. To validate our assumption, let's select entire query and click on Execute. Carefully observe the first_name column of the result set. You can see the name belongs to NICK, JOHNNY, JOE, or VIVIEN. Additionally, there should be three records where actor_ids go to 41, 107, and 166. In case of actor_id of 41, we can clearly see it's over here. Actor_ids 2, 5, 9, 14, and 40, the logic was first_name belongs to our four names. In case of actor_id 41, the last_name was Degeneres, and that's the reason it qualified for this result set. Same logic is for 107 as well. This record qualifies for both of the conditions. What it means is that if we had a condition instead of OR in here, actor_id 166 will be still a valid result set. Instead of OR right here, AND. Now we will execute this, and you can see only one record is now in our result set. This record is here because the first name is Nick and the last name is Degeneres. Now let's understand how the BETWEEN clause works. But before that, let's execute a simple query. SELECT * FROM sakila.actor WHERE actor_id > 10 AND actor_id < 20. What it means is that it will get us every single actor_id which is over 10 and less than 20. Let's select this and execute it. In our result set, we have 9 rows where actor_id is from 11 to 19. Here is an example. SELECT * FROM sakila.actor WHERE actor_id is between 10 and 20. Now let's like this one and execute. When we execute this record, we can see that there are no more 9 rows. The total number of the rows is 11. The difference between this query and the query which we ran before is a row with actor_id 10 and a row with actor_id 20. The reason is that the way the BETWEEN works is that it also includes both of the ranges. What it means is that the 10 is also part of the range, and 20 is also part of the range. The way the range logic works in case of the BETWEEN is lower inch, upper range, and anything between them. If you want to simulate this query with using BETWEEN, you'll have to change here something. Instead of 10, you're to replace that by 11, and instead of 20, you're to replace that by 19. Now this query will be exactly similar to the query which we executed in the beginning, just like this. Let's scroll further down. You can just put NOT before BETWEEN, and it will just negate the complete logic over here. With the use of the NOT keyword here, we'll get every single row where actor_id is lower than 11, and actor_id is greater than 19. Let's validate that. Select the statement and click on Execute. Now let's scroll further down, and you can see after 10, right after there is a value 20. There is no other value in between. It means rows with actor_id 11 and more and rows with actor_id 19 and less are all omitted. You can see that BETWEEN can be very powerful when we have to deal with range.

Demo: Using Like in WHERE clause
Now we will see how LIKE operator works. LIKE is very powerful and interesting because it works with patterns. Using pattern logic and wildcard, you can pretty much build infinite combinations of the logic to use in a WHERE condition. Well, let's start few of them over here. Here are some of the examples. First one is SELECT* FROM sakila.actor, where first_name is LIKE A% wildcard. This one pretty much will list every single actor whose first name starts with A. Percentage match is one or more characters. Let's execute this one, and you can see in our result set we have every single actor whose first name starts with A. However, if we want to make it a little bit more interesting, we can select only actor whose first name starts with A and L, which means we should get Alec, Albert. Albert is here two times, which means actor_id 125 and actor_id 146 should be also part of our result. Let's execute this one, and we will see. Here we have WHERE condition with first_name LIKE AL%. In result set, we have all the actors whose first name now starts with all Al. Well, we can make it more creative as well. Here is an example. We have used two underscores. Underscore stands for a single character. The pattern which we have returned here is the first character is A. Second and third can be any other character. However, the fourth character has to be E. Let's execute this one and see how many records qualify for this pattern. When we execute this, we can only find one actor who qualifies for this kind of pattern. That is Anne because the first character is A. We do not care about second and third characters; however, the fourth character has to be E. Additionally, when we write this kind of pattern, it means we are looking for four‑character string only. However, if we just put percentage right after it, now what it means is that we can have first character A. Second and third we don't care. However, the fourth character must be E. When we put percentage right after E, it means now we do not care how long this particular string is. Well, let's execute this one and see if we find any actor with such name. You can find there are many, Angela, Angelina, Albert, Angela, and Albert again, along with our original record of Anne. You can see in all of this, there's a single pattern. First character is A, fourth character is E. However, if we do not care the length of them, as well as we do not care what the second and third character is. Let's further continue modify the same pattern. Here instead of putting two underscores, now we have replaced two underscores with single percentage. Now what it means is that the first character is A, and there is a percentage between A and E. What it means is that E doesn't have to be anymore the fourth character. E can be any character after A, and there can be any number of the characters between A and E, and we do not care about them. Additionally, E does not have to be fourth character or last character. There can be more characters right after percentage as well. What it means is that, find a name which starts with A and has E anywhere in the name except first place. Let's execute this one, and you can find many of the records. Now you can see the position of E is not fixed. In this case it's third, and in this case it's the second last. Again case of Anne, it's fourth, and in case of Angela, it is also fourth. Well, now there is no real logic where the E is going to be. However, you can notice that A is always the first character. Now let's go to our next concept, which is about null. As we say, null is very interesting, and it's very important to understand how nulls behave. We cannot use any arithmetic or logical operator over null. To compare null, we just have to use special keyword, which is IS NULL or IS NOT NULL. Let's go to our address table and select every single record from it. You can see in column address2 there are four records which are null, and other records have empty string. Let's go to our second query and run it. Please pay special attention here. The WHERE condition is address2 IS NULL. What it means is that every record where address2 is null should be part of result set. Select the query and execute it, and you can see, there are four records over here, WHERE address2 IS NULL.. If you want to negate this condition, select the query and execute, and now you'll get every single row where address2 is not null. Well, logic of the null is very interesting and null starts playing a very crucial role when we start using OUTER JOINS. With this, we finish our demonstration regarding WHERE clause. Now we will go to our next concept of ORDER BY clause.

Select statement and ORDER BY clause
The ORDER BY clause specifies sort order of the result set. The sort order can be ascending or descending. Additionally, we can sort the result set by one column or multiple columns. We can also use various expressions in ORDER BY clause as well. ORDER BY clause is the only clause where we can use an alias to sort columns as well. Additionally, we can use column number to specify sort order as well. ORDER BY clause has a very special behavior with null values. Null values always appear first in a sort sequence. It does not matter if you specify sort sequence ascending or descending. Additionally, remember that you can sort any column in a base table, regardless if you use that one in a SELECT statement or not. Let's see some of the interesting examples of how ORDER BY clause works in the next demonstration.

Demo: Select statement and
Now we open MySQL Workbench and SQL Editor. We will be seeing example how ORDER BY works. Let's start with very simple example. Here it is. SELECT * from sakila.address ORDER BY district. Select the statement and click on Execute. In result set, pay attention to the district column. You can notice that district column is now ordered alphabetically in ascending order. Abu Dhabi is on the top and Zulia at the end. Now, if you want to reverse the order of this column, what it means is that you want Zulia on the top and Abu Dhabi on the bottom. You can easily do it if you just specify descending keyword in ORDER BY clause. Here is the example. Let's select the statement and click on execute. You can see that now Zulia is on the top, and if you scroll all the way to bottom, and Abu Dhabi is at the end. Now let's see another example where we have more than one column in ORDER BY clause. Let's select this one and execute. Let's select example of Abu Dhabi itself. You can see that the Abu Dhabi is on the top. It is ordered in ascending sequence by column distinct. If you pay attention to the postal code, you can see that higher number is on the top and lower number is on the bottom. What it means is that in this window of Abu Dhabi, MySQL has once again sorted postal codes. However, the order of the postal code is descending. Hence, you can see the value which is higher on the top and the value which is lower on the bottom. Similar example is also here in Adana. You can see that higher number is on the top, where lower number in the postal code column is on the bottom. Now let's see a different example. Here it is where we have our expression in a select statement. You can see that here we have actor_id from sakila.actor table and we are concatenating first name and last name, and we are releasing first_name and last_name as FullName. We can order this complete table by expression using a select statement. For example, we can use this CONCAT in our ORDER BY clause as well. Let's select this complete statement and execute. You can see that now complete table is now ORDER BY expression which you specify in ORDER BY clause. To make things simple, we can also use alias in ORDER BY clause as well. You can see here that instead of using expression, we are using the alias which we are given in select statement in ORDER BY clause. Let's select this one and click on Execute. The result set is very similar to the one before, however, it's very easy to read and easy to write as instead of writing complete expression, we can just replace it with alias. Well, there is one more trick I want to show you. Here in ORDER BY, we have views, digit 2. Digit 2 stands for column number 2, which is in a select statement. What it means is that actor_id is column one and CONCAT expression is column two. Let's execute this one. You can see that the result set is ORDER BY second column, which is concatenating of first_name and last_name. If we remove these two and put over here one, it will be ORDER BY actor_id. Let's see that. Select the statement, click on Execute, and you can see that now complete result set it is ORDER by actor_id column. Well personally, I do not like this method because this method can create ambiguity when we are using the star, or when we have schema change, or some developer adds column in a SELECT clause. I personally prefer to use complete expression or alias of the column in ORDER BY clause. Well, with this, we finish our understanding of ORDER BY clause.

Retrieving limited rows
Now we have reached to very last concept which we want to learn in this module, which is LIMIT clause. We can use LIMIT clause to limit the number of the rows written by SELECT statement. This clause usually has one or two arguments. Each of them has different meaning, and we will understand them while we do demonstration. It's always recommended that we use ORDER BY along with LIMIT because there is no guarantee when we use LIMIT that we are going to get the data in the same order in every subsequent execution of the same SELECT statement. The very frequent use of this LIMIT clause is when we're doing paging. Think about it this way. If there are 1000 rows in one table and now you want to retrieve only row which is between 500 and 510, how would you go about retrieving them? Well, this is the time where you use the LIMIT clause because LIMIT clause has two arguments. One is number of the rows and second one is offset. Let's quickly understand both of them in demonstration.

Demo: Retrieving limited rows
Here we are in MySQL Workbench in SQL Editor, and we are going to see how the LIMIT keyword works. As mentioned earlier, the LIMIT keyword is a pretty straightforward keyword. Let's first retrieve data FROM sakila.actor that we have ORDER BY clause on actor_id. Let's go and apply LIMIT 10. What it does is that when we execute the statement, it will only retrieve 10 rows. However, what happens if you want to retrieve data which is somewhere in between the table? What it means is that you want to retrieve row numbers 32 to 35, or row numbers 50 to 65. At that time, you can additionally specify offset to the LIMIT close. This is how it works. Look at this example where we have limit 15 and 10. We'll just have two parameters. Let's execute them and understand what each of these parameters do. When you execute this query, you can see that the first record is no more actor_id 1; it is now actor_id 16. The first parameter which we provided to the LIMIT keyword is offset. What it means is that if you specify here 15, MySQL will skip the first 15 lines and will start reading the lines after that. Here if I specify 10, what it means is that it's only going to retrieve 10 rows. Let's change this number and see one more example. For that, I'm going to put here 25 and the number of the rows. I'm going to put 5. What it will do is that it will start retrieving rows from row number 26 and will retrieve until row number 30 because we are going to retrieve only 5 rows. Now let's select this one and click on Execute. As we expected, it is retrieving us 5 rows from the actor_id 26 and onwards. As the LIMIT clause limits the number of the rows it retrieves from the offset, it also helps with performance of all rows that were held. Well, with this we end our understanding of data retrieval and its various clauses, phrases, and operators. In the next module, we will see data modification techniques. And now we end this module with a summary in 60 seconds.

Summary in Sixty Seconds
Summary in 60 seconds. SELECT clause describes the column list in the result set. FROM clause describes the table names from which the query retrieves the data. WHERE clause describes the condition to match for rows to qualify for result set. ORDER BY clause describes the sort order and sequence for result set. LIMIT clause describes the number of the rows result set returns and offset of it. Use column names in SELECT statement instead of * to reduce ambiguity and impact performance. Using aliases improves readability. Use various comparisons and logical operator in WHERE clause to retrieve rows relevant to application. Always use ORDER BY clause if you want your result set ordered.

Data Modification Techniques
Introduction
Hi. This is Pinal Dave for Pluralsight, and in this module, we will discuss about data modification techniques. Our major focus in this module will be on insert, update, and delete statements. With update and delete, we'll be also using where clause. All the operators and phrases which we have learned in an earlier module will apply over here, as it is. Each of the statements has two clear distinct areas. First area is how to modify a single row, and second area is how to modify multiple rows. Also, it's not a good idea to modify your live data. For the same reason, I'll be creating a sample table, and we'll be doing all the operation on top of sample table. Let's start with insert statement.

Insert Statement
We use INSERT statement when want to add one or more rows to a table. To insert a single row, we can specify INSERT command with table name and column list followed by the data which we want to insert. Also, we can use SELECT statement to populate another table as well. When we want to insert multiple rows at the same time, same logic applies. We can use one INSERT and multiple VALUES clauses or SELECT statement, which returns us multiple rows. There are two important things to keep in focus while learning about INSERT statement. One is default values, and second is null values. We will understand all of this thing in demonstration next.

Demo: Insert Statement
Let's open MySQL Workbench and SQL Editor, and now we will see a few of the examples of how insert works. We'll start with creating a sample table, and we'll be inserting all the data into this sample table. This is how we make sure that we do not upset live data. We will be using database, Sakila. We will create a table, which is ActorSample; it has actor_id, first_name, last_name, and last_update. Actor_id is a small integer, and it's unsigned; however, it's not null and it's auto‑incrementing. As we are not specifying any other properties of AUTO_INCREMENT, it will start with 1, and will increment the value of the column by 1 as well. First_name is varchar, and it's not null. Last_name is null, and last_update is timestamp datatype, and it's also not null. However, there is an important property defined here, which is default. The default value of this column is CURRENT_TIMESTAMP. What it means is that if we do not specify any value to be inserted for last_update column, it will be automatically populated by CURRENT_TIMESTAMP. Let's start with our very first example of INSERT. Let's execute this one and you can see in output, it has already created table for us. Now we'll start with a very simple example where we will insert a single row into the table. The script is INSERT INTO table name, sakila.actorsample. We have specified here three of four columns. Those are first_name, last_name, and last_update. Please note that we are not specifying here column, actor_id. The reason of that is very simple. It's going to be auto‑implemented. What it means is that we do not have to explicitly enter data into this column, as and when we insert data, this will be auto‑populated by AUTO_INCREMENT property of a column. Let's see an example of that as well. We are going to use VALUES clause right after the insert statement. In the VALUES clause, we are going to specify the property, first_name, I'm specifying Pinal, last_name is Dave, and last_update as any date. Let's select this one and click on execute. You can see an output clause, the message is one row affected. Now let's check the data into this table. Select SELECT * from table and click on execute. You can see this inserted one row, which is actor_id 1, because it's the first value, first_name Pinal, last_name Dave, and last_update date, which we have just specified. As in our insert, we did not specify any of the time component. It is by default assumed time component of 0000. And let's go to second script. Here is the second script. Let's compare this one with the first one. You can see there are two major differences. First, there is no column list in the second script, and the second is default specified over here. Let's first execute this one, and we'll talk about that afterwards. Click on execute, and now check the data. We have successfully inserted the second row and it says Nupur Dave and a date. If you notice, it's the same data, which we have just inserted, However, in the earlier one, we did not specify actor_id, because actor_id was auto‑populated. However, when we are inserting data into table and not specifying the list of the column, at that time, we will have to specify every single column's value in a value list, as well as it has to be in the same order as the original table. What it means is that this default stands for actor_id, Nupur for first_name, and Dave for last_name, as well as the data, which we specify is for the fourth column. Column order has to match to the original order. If I change the order of Dave and a date, it's not going to insert the data properly, and it may give us an error. If we do not specify default, MySQL will also give an error. When we specify the default, it will go and take the default value for this column. In this case, the default value will be auto‑implemented. An auto‑implement will be adding 1 to the additional value, as we have not specified any other auto‑incremented data. That means we will have value 2 over here. Well, let's continue with our next example. In this example, you can see that now we have only two columns where we are inserting data. One is first_name, and the second one is last_name, and the data which we are inserting is Pinal Dave. Let's think for a moment, what would happen in this case. In case of the first_name, the value Pinal will go, in case of the last_name value, Dave will go. What will be the value of last_update? Let's go and check the value in our table definition. In table definition we have specified the last value is of data type timestamp and will have default value of CURRENT_TIMESTAMP. What it means is that if we do not specify the last_update, it will automatically take the current date/time of the server where MySQL is installed. Let's execute this and validate our assumption. Select the statement, click on execute. and now select the data from table. You can see over here that the third record is inserted with first_name Pinal, last_name Dave, and the date is current date/time from my system. Now let's go to the next script and understand that. In our next script, we have only one column specified in our insert statement, and the value is Pinal. There is no value for last_name, as well as last_update and actor_id. Let's try to guess what will be the value in each of these columns. Well, in case of the actor_id, once again, we will have auto‑increment value, and we will see 4. In case of the last update. as we have noticed, we will have a current date/time of server, but what will be the value of the last name? Let's go to our column definition one more time and see what it will be. You can see last_name column is defined as null. What it means is that if we pass any value to this column, it will take that value, but if we do not pass any value to this column, it will just take that as null. Well, let's execute this and validate that. Select the statement and click on execute. As we have expected, actor_id is 4, first_name is Pinal, last_update is current date/time of the server, but the value of the last_name column is null. Isn't this interesting that sometimes we feel that we have to specify every single column, but as we start narrowing down, we learn that there are so many things which are dependent on the definition of table, which we have defined earlier. That is why data modeling is considered as one of the most challenging tasks. Now, let's try to do the same thing with last_name, Dave. Here we are not specifying the first_name, but we are only specifying the last_name. What do you think will happen? Let's go all the way up and see here. The first_name only says it's not null. There is no different value specified. What it means is that this column has to have a value. If we do not specify what is to be inserted into this column, MySQL will not let the entire row to be inserted into this table. Let's see that into action. Now we select the statement and click on execute, and on the bottom over here, you can see that there is an error. Error says, first field does not have a default value. What it means is that if you do not have a default value, you will have to insert some data in it. You cannot just walk away without specifying any value for the column, which is marked as not null and does not have a default. Well, let's see one more example. Insert into table name columns first_name, last_name, and last_update. The value Pinal will go into first_name, and null will go into last_name, and default value will go into last_update. What will happen over here is that we will see in a first_name column, value Pinal, in the last _name null, and last_update current date/time of the system. Let's select this statement and execute it. Now we'll go and check the data into the table. You can see actor_id 5 is over here, and first_name is Pinal, last_name is null, our server's default date/time is in last_update column. Now let's go a little bit more advanced and see how we can insert multiple rows. So here is the example where we will see how we can insert multiple values into tables. First method is very simple and very easy to implement. We have INSERT INTO table name, and column name listed over here. In VALUES clause, we have first column and comma, and second column and a comma, and we have a third column. We can have more than three columns over here as well. With this kind of syntax, we do not have to specify insert statement again and again. Let's execute this one, and now select the data. Scroll down, and you can see now we have three records inserted, which is Pinal Dave with date 17, Nupur Dave with date 18, Shaivi Dave with date 19. There is one more method where we can use select statement to insert data. For example, If you want to insert all the data where actor's first name is Nick into this table, we can use this kind of syntax. Let's see the select statement first, where you can see, we have three names with actor's first name is Nick. Now we will just write insert statement just on the top of this select statement. In the insert, we have three columns: first_name, last_name, and last_updated. In case of the select statement, let's select everything and click on execute. When we execute, we can see there are three rows, which are returned. Let's go and check the data. SELECT * FROM ActorSample, and click on Select. Let's scroll down all the way to the bottom. You can see that there are three new records which are inserted, which is Nick Wahlberg, Nick Stallone, and Nick Degeneres. Well, you can see how easy it is to insert data into a table by using select statement. Let's clean up and drop this table. Now, in the next clip, we will learn about update statement.

Update Statement
We can use an UPDATE statement to update one or more rows in a table. The SET clause in an UPDATE statement will contain the name of the column and its new value, whereas a WHERE clause will have a condition which qualifies rows to be updated to a new value. Just like INSERT, we have a concept of default and null here as well, and the words are almost exactly the same. Let's see UPDATE in action. UPDATE has many variations. For example, update single row and single column, update single row and multiple columns. We can also update multiple rows and single column or update multiple rows and multiple columns. We can use SELECT subquery in an UPDATE statement as well. Let's see all of this in action now.

Demo: Update Statement
Now let's see UPDATE statement in action. We'll be using Sakila database, and we'll be creating our custom table. We want to make sure the table which we use does not modify any of the _____ system. The table, which we are going to create, is almost the same table which we have created in our insert script. Click on CREATE TABLE script, and click on Execute. This script is very similar to the script, which we are using in our INSERT statement demonstrations. Click on Execute, and now the new table, which is sakila.ActorSample, is populated with the same data of sakila.actor. First, we will learn about Update Single Row using Single Column. Here is the UPDATE statement where we are updating sakila.ActorSample. SET keyword has first_name. Every single row in the first column will be now be populated with Pinal. What we want to do is that we only one to update the value of the first record where actor_id = 1. Now we are limiting our update to only one column and one row. And now, before we check our data, we'll do the same operation with the last_name as well. What it means is that we'll now update the last_name column to value Dave WHERE actor_id is also 1. Let's select this one and click on Execute. Now let's go back and check our data. The value of the first_name is Pinal, and the value of the last_name is Dave. Now, let's move further. In earlier example, we have updated first_name and last_name separately. We do not have to do that. We can update first_name and last_name of single row altogether. For example, over here, I'm going to update the row WHERE actor_id = 2 with first_name Pinal and last_name Dave. Please note the current values are Nick and Wahlberg. Now let's execute this script and do SELECT on the table. You can see the old value is now replaced with Pinal and Dave. This time we did not have to write two separate UPDATE statements to update a single row. We can update a single row with multiple columns by specifying all the column into SET clause. Let's take this one into next level. We can fully observe the WHERE clause. WHERE clause has actor_id and list of the actor_id. What it means is that every actor_id with the value 3, 4, or 5 will be now updated with the value Pinal. Let's execute this and check our data. Upon checking our data, we can see this change also happened over here. Well, what we did is that we specified a list and multiple rows were updated for a single column. We can take it to the further next level where we update multiple columns and multiple rows. Here is the example. Here we have a WHERE condition where actor_id is 6, 7, or 8, which means these are the three rows, which we are discussing over here. We are updating first_name with Pinal, last_name with Dave, and last_update with DEFAULT value. DEFAULT value will populate current date/time of the server in the column. Let's select this one, and click on Execute, and now, check the data. In the result set, we can clearly see that 6, 7, and 8 row has now Pinal Dave value everywhere, and last_update date is updated to current date/time. Let's see one more concept. Here is the concept of using subqueries. The UPDATE statement where we are updating sakila.ActorSample and setting value first_name to Nupur, and WHERE condition has actor_id; however, let's pay additional attention to the WHERE clause. Here we have subquery in the WHERE clause. Let's execute the subquery independently, and you can see the subquery is returning its value of 1, 10, 20, 40, 50, and so onwards. These are the lists of actor_id who all work in film_id 1. What it means is that all these actors work in a single film, which has film_id = 1. Now we will change the first_name of every single actor who has acted in film 1 to Nupur. Let's execute this one. Well, execute did not happen successfully, and we can see that in error, Error Code: 1175 You are using safe update mode and you tried to update the table without WHERE clause. Now we are definitely using a WHERE clause; however, by default, MySQL Workbench works in safe mode, and let's change that. Let's go to Edit, and go to Preferences, go to SQL Queries, and here, uncheck Safe Updates. Additionally, it also requires us to do reconnection. I uncheck this option and click on OK. Now click on this icon which suggests reconnect to DBMS. Now, once again, try to run this query. This time, query is then successfully in these updated 10 rows. Let's go to our table and check the data in it. We can see the very first row is now updated to Nupur because actor_id = 1 was also actor in a film_id 1. Scrolling down, we can see another value where actor_id is 10. Now you can see how easy it is to update single and multiple rows in MySQL. We can use complex logic in a WHERE clause, as well as subquery to a bit of data. Let's do clean up and drop our table. Next, we will see another important concept of delete.

Delete Statement
DELETE statement is one of the most powerful statements. It can delete every single row in your table pretty much with one line of syntax. However, we should make sure that we're using a WHERE clause with DELETE statement so we delete one or more row from table instead of deleting every single row. We can also use subquery and SELECT statement to qualify a row to delete in DELETE statement. If you forget the WHERE clause it will pretty much delete every single row from the table. Let's see all of this concept into action next.

Demo: Delete Statement
Here we are in MySQL Workbench in a SQL editor, and we will see example of DELETE statement. We'll be using Sakila database. And now we'll create very similar table which we have created in earlier examples. Table is ActorSample, and has four columns, actor_id, first_name, last_name, and last_update. Click on Execute, and table is successfully created. Now we'll populate the table with sakila.actor table. We'll be using INSERT statement, INSERT INTO sakila.ActorSample, column names, and we'll be retrieving the same column from sakila.actor table. Let's execute this one. And now we have our sample table ready, which we'll use to exercise our DELETE statement. Let's see our very first example. Here we are going to delete a single row. First, let's select our data. Here we'll see in our data the our first row is actor_id 1, and first_name is Pinal and last_name is Dave. Let's execute this statement where we have DELETE, FROM, table name, where actor_id = 1. If you look at this statement, the structure from FROM is very similar to SELECT as well as UPDATE. Click on Execute, and now, once again, check your data. We can see that in data the actor_id 1 row is now deleted. Well, let's go further down, and this time, try to delete multiple rows together. We are going to use list in WHERE clause, where actor_id IN 3, 4, or 5. Let's select this entire statement and click on Execute. Upon selecting the data, we can see that we no more have row 3, 4, and 5. This is how you can use WHERE clause in a SELECT statement to delete one or multiple rows. However, just like UPDATE statement, you can be creative with subquery in DELETE statement as well. Here we have a subquery where we are selecting all the actor_id who work in film_id 1. Select the statement and click on Execute. You can see various actor_id over here. Actor_id 10, 20, and 30, let's remember them for a moment. And our DELETE statement says DELETE, FROM, table name, where actor_id into these all actor_ids. Let's select the entire statement and click on Execute. Upon checking the data into table, we can see that now we do not have record id 10, 20, or 30 over here. They all got deleted because we executed this DELETE statement. You can observe the DELETE statement is extremely easy to do. Just missing a WHERE condition is capable to delete entire table as well. Let's see that in our next example. Here we do not have any WHERE clause. What it means is that now entire table sakila.ActorSample will be deleted. Select the statement and click on Execute. If you are paying attention to our output window, you can see that it displays 187 rows affected. Actually, they're all deleted. Now, let's go to SELECT* from ActorSample. Click on Execute, and we're getting no rows over here. The reason was that we did not use the WHERE clause, and that's why every single record from this table has been deleted. Well, with this we complete our demonstration for data modification. Let's clean up by executing this statement. And now we will see summary in 60 seconds.

Summary in Sixty Seconds
Summary in 60 seconds. Use SELECT statement in subquery when inserting, updating, or deleting multiple rows at the same time. Do not forget to specify WHERE clause in DELETE or UPDATE statement, or it will modify your entire table. By default MySQL Workbench runs in a safe update mode preventing users from making accidental updates. Disable safe mode only when required.

Summary and Resources
Final Words
Hi, this is Pinal Dave for Pluralsight. In this module, we will talk about summary and resources. So far, we have learned installation of MySQL Server, MySQL Workbench, and MySQL Sample Databases. All of these components and all other components are installed by default. Later, we learned MySQL Workbench and three of its major sections, SQL Development, where we connected to existing database and then SQL queries; Data Modeling, where we created and managed EER models; Server Administration, where we configured database server and set up user accounts. Later, we spent time on Relational Database Management System and database design concepts. We also learned in depth various techniques for data retrieval. In data retrieval techniques, we focused on SELECT, WHERE, ORDER BY, and LIMIT clauses. Finally, we spent a lot of time on data modification techniques. We learned how we can modify our data using INSERT, UPDATE, and DELETE. Well, here are a few of the important resources. Well, I thank you very, very much for spending time learning with me MySQL Fundamentals Part 1. In part 2 of MySQL introduction, we will learn joins, functions, views, transactions, stored procedures, store functions, triggers, and events. Thank you, and we will meet in MySQL Introduction Part 2.

