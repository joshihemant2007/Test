This course shows developers how to use next generation JavaScript language features today. Developers will learn to use ES2015 (previously know as ES6/JS.Next/Harmony) without waiting for browser support by introducing Babel, a JavaScript compiler, into their build process. This course will demonstrate how to install and configure Babel. Developers will learn to use Babel with their preferred front-end build tool (Gulp, Grunt, Webpack, npm Scripts), with Node.js on the server, and while writing unit tests. The course also details how to configure Babel for legacy browser support.



Course Overview
Course Overview
Hi everyone. My name is Craig McKeachie. Welcome to my course, Babel: Get Started. I am the author of the Javascript Framework Guide, and have been a developer for over 15 years. This course shows developers how to use next generation Javascript language features today. Developers will learn to use ECMAScript 2015, previously known as ECMAScript 6, JS Next, and Harmony without waiting for browser support by introducing Babel, a Javascript compiler, into your build process. This course is a quick introduction to using Babel to write modern Javascript applications, and no prior experience with Babel is required. Some of the major topics that we will cover include installing and configuring Babel, integrating Babel into your build using your front end build tool of choice, including Gulp and PM scripts, Webpack and Grunt, how to configure Babel to support legacy browsers as far back as Internet Explorer 8 using Babel with React and JSX, Node. js, and in your unit tests with Jasmine and Mocha. By the end of this course you'll have a solid foundation, and be ready to use Babel when developing your Javascript applications. From here you can continue your learning by diving into the specifics of the new Javascript language features in these courses, JavaScript Fundamentals for ES6, JS. Next: ES6. I hope you'll join me on this journey to learn Babel with the Babel: Get Started course at Pluralsight.

Basics of Using Babel
Overview
Welcome to the first introductory module of the Babel: Get Started course. I'm Craig McKeachie. In this module we'll be working to understand how Babel can help us generate Next Generation Javascript today. We'll start with a demo of Babel in a REPL, so you can see it in action. We'll compare Babel to Tracer and TypeScript, so you can better understand where it fits in with everything else. We'll install Babel from scratch, and learn how to configure and run it, then we'll take a deep dive into how we can better organize our code by using ES modules today.

Understanding Babel
In this section we take a detailed look at how Babel was able to make next generation Javascript language features available without waiting for browsers to implement them. When looking at the often referenced kangax compatibility table for ECMAScript, that's the official name for Javascript if you're not familiar with it. We're set to version 6 right now, as you can see, and we're pretty far zoomed out, but don't worry if you can't see a lot of details. You could go to this URL here if you want to take a closer look, but for now it's enough to have a big picture view of this table. If you haven't looked at this table before it can be kind of overwhelming with the amount of information, but in general you just need to understand that down the left hand side are the language features that are available for that language version, in this case, ECMAScript 6, and across the top are the various browsers, desktop, and mobile, and in the body of the table the cells that are red means that language feature is not supported, and the green cells means it is supported in that browser or runtime environment. The first thing to notice is how red the right hand mobile section of the chart is. Mobile devices are definitely behind in supporting these ECMAScript 6, which is now called ECMAScript 2015 language features, but even the desktop browsers here in the middle have an awful lot of red and a long way to go before we can rely on these new Javascript language features. What we will be focused on in this course is the compiler/polyfill section, more specifically the Babel column, which you can see has an awful lot of green there. Right now it supports 71% of the official language specification, so by introducing a build step into your code you can start using these new Javascript language features today. Let me show you how that works. If I jump over here to the Babel site, I'm at the Try it out link or the babeljs. io/repl link on the site, which allows you to put on the left hand side future Javascript, and see what it will be compiled to or transpiled to. Transpilation is just a fancy word for source code to source code instead of source code to byte code, which is how compilation is normally thought of, so again, the left hand side will be our future Javascript, and it will rewrite that code to ECMAScript 5, which runs in most browsers at E9+ basically on the right hand side, so we can deploy that, and trust that will run in our target environments. We'll talk more about supporting Legacy browsers even further back than IE9 in a later module, so just hold tight for that. You might have noticed I'm running the Safari web browser. I'm actually running it for a reason because there's a lot of ECMAScript 6 features that aren't supported yet in the newest version of Safari. If I go down to their developer tools, which is called the web inspector down on the console, and I paste some ECMAScript 2015 code, some next generation Javascript, and run it, I will get a syntax error. What it's not understanding is the new arrow function. That's like a lambda in other languages that's been introduced in ECMAScript 2015. If we take that same code and we paste it above here in the REPL. We'll see that that code that sorts an array has been rewritten to ECMAScript 5 on the right hand side. Let's take a closer look first at the code on the left. We've gotten an array, we're sorting the array, but instead of passing a function to sort on we're passing an arrow function, so we don't need to say return, and we don't need all the ceremony of the curly braces, etc., we just need the arrow, so it's a much more terse way to sort an array. On the right hand side this code has been rewritten to ECMAScript 5, so the arrow function has been translated to a full function, including the return statement. If we clear the console, and we take the ECMAScript code from the right hand side, make some room for it, so you can see it, and paste it in the browser's console, and run it we can see that the code runs fine even though arrow functions aren't supported in this browser because it's been rewritten to ECMAScript 5. This is how the Babel compiler works, and this is how you can start writing with the future language features today. If you're curious about who's using Babel you can see that major companies like Facebook, Netflix, and Yahoo are already using it, and as I scroll down you can see there are quite a few other companies adopting it as well.

Comparisons
In this section we'll compare Babel to both Google's Traceur compiler, and the TypeScript language with its compiler. You'll gain a better understanding how all of these projects fit in the overall Javascript landscape. There's another Javascript compiler Traceur with a similar purpose to Babel. Tracer was created by Google. This comparison slide gives you an idea of some of the differences between Traceur and Babel. Traceur's purpose has always been stated to be more of an experiment, helping inform the language committee about new features in the language by letting people use them before they become available. Another difference is the runtime dependency that Traceur has. We'll see a demo in a minute, which'll help you understand that better. Babel avoids this runtime dependency by using minimal inline helpers, and optional polyfills. Traceur removes comments and white space from your code, whereas Babel has always been known for trying to maintain the source code formatting, and keeping the code very readable. Traceur does cover a great deal of the ECMAScript 2015 spec, but is missing some features, whereas Babel is known for being more feature rich. Let's make each of these points more concrete by doing a quick demonstration. Traceur has a REPL as well where you can write code, and see it transpiled on the right hand side. The first thing to notice is the runtime that's required before you write a line of code with Traceur. If we switch over to Babel we see that all we're getting is a use strict statement before we write code. Let's flip back over to Traceur and write a simple console. log statement (Typing). Although we haven't added much code, you can see that the code has a little harder to read given the runtime surrounding it. If we take our console log statement and move it over to our Babel REPL we can see that the code is very readable and understandable. Switching back over to Traceur I'll quickly add a comment to the code (Typing). We can see that our comments are removed by the Traceur and compiler. We'll add some white space as well in another console log statement (Typing), and we can see that Traceur has removed the white space as well as the comments. Let's copy this code over to our Babel REPL, and we can see that Babel retained more of the source formatting. Lastly, let's look at the kangax compatibility table, so we can understand why Babel is considered more feature rich than Traceur. As we move down through the list we can see some gaps in Traceur, particularly with the weak map and weak set built-ins. If we scroll back up to the top, however, and change to ECMAScript 7, the next version of the language that's still being ratified you can see that Babel is definitely on the cutting edge with a lot more ECMAScript 7 features already implemented. TypeScript and Babel are often compared because both involve transpiling Javascript code, and outputting ES5 code, but they are really quite different. TypeScript is an open source language that is a type super set of Javascript. Babel is not a language. TypeScript happens to have a transpiler, but the language is the focus of the project. Babel's main focus is to be a Javascript transpiler. The Babel and TypeScript teams communicate a lot, and the creator of Babel, Sebastian McKenzie has said publicly that in the future there will be more collaboration between the projects, so although we cannot be sure, it's easy to imagine a future where Babel is either a transpiler or the transpiler for TypeScript.

Prerequisites
In this section we'll look at the prerequisite knowledge and development environment we'll use during the course. Some Javascript experience is needed for this course, but you will not need to be an expert. You will also need to install NodeJS. You can go to NodeJS. org and click the appropriate download link. NodeJS comes with a package ecosystem, npm, and we'll use that to install Babel. I'll be using WebStorm as my development environment during this course, but feel free to use another text editor that you prefer, including Sublime Text, Brackets, ATOM or even the new Visual Studio code. A fully integrated development environment like Visual Studio will work fine as well.

Installation
We'll learn how to install Babel in this section. Before you install Babel it's good to have a big picture of all the npm packages that make it up, and how they fit together. First there is babel-core, which is just what it sounds like, the core library that makes up Babel. In general, until you get into advanced scenarios like writing your own library that uses babel-core as a dependency you won't need to install this package. The babel-cli is the command line interface, which allows you to run Babel from the command line. This is what we'll install first and, as you might guess, includes babel-core as a dependency. When you start to transpile code you'll get output, but unless you have a plugin for a specific language feature your source code will not be changed or altered. For example, there is a plugin named babel-plugin-transform-es2015-error-functions, so when you install that package it adds that language feature, and begins to transform your code. This idea of opting into specific granular language features is new in Babel 6. Previously you got the features in an all-inclusive package named Babel, then you had to turn off specific transformers. With Babel 6 you install the babel-cli package, and turn on specific plugins by installing additional packages. Since specifying and maintaining dozens of plugins in a config file would be a lot of work Babel 6 introduced the concept of plugin presets, which group together similar plugins for easy consumption. For example, there is a babel-preset-es2015, which includes all the ES2015 plugins. There are two main ways to install Babel or any package you install using npm, globally, and locally. Let's look at how to do a global install first. As I mentioned before, to install Babel, as of version 6, you don't npm install Babel as shown here. You npm install babel-cli, the command line interface. To make Babel global you just add the -global or -g flag. Installing globally allows you to run the Babel command from any directory on the computer without giving a path to Babel, so where on your computer does npm install global packages? The short answer is in the user local or wherever Node is installed. To figure out where that is on your computer you can run this command, which lists global packages, but not other dependencies because of the depth parameter being set to 0. On a Mac it will be a path like this, and on a PC it will depend on your OS version. When should you install locally and not globally? Most of the time. If you're going to eventually share code with others, for example, team members working on the same project or in an open source project where people need to be able to pull down your code an easily run it. Another scenario is if you're going to have multiple projects running on your computer that might need different versions of Babel running, so locally is a best practice. Now how do we do that? First, npm has an init function, which creates a package. json file where you can record all the dependencies for your project, and allow the next developer to quickly install them all with one command. Next, you install the babel-cli making sure to pass the --save-dev flag, which will record it as a dependency in your package. json. If you don't have Babel globally installed when you try to run the Babel command it will fail because it can't find the package. When you install packages locally the code is placed in a node_modules folder in your project. If, however, you give a path to that folders bin directory it will be able to find and run Babel. Giving this path every time you need to run a command is not ideal, so in the next module on integrating Babel we'll look at several ways to avoid typing that path over and over again, including npm scripts or using a build tool like Gulp, Grunt or Webpack. Let's jump into a demo installing Babel both globally and locally.

Global Install
Let's look at how to globally install Babel first. I'm inside of WebStorm. WebStorm has an embedded terminal or command prompt, but these commands will work from your operating systems command prompt just the same. I'll start by invoking nodes package manager, I'll give it the install command, I'll tell it that I want to install this package globally, and then pass it babel-cli. I'll run this command, and the Babel command line interface is successfully installed. Let me clear the window, so we can see things better. Note that on that previous command I could have used just a -g instead of spelling out global, and it would have worked the same. With the babel-cli installed I'm now able to invoke Babel from anywhere. For example, I could ask for the version of Babel. You notice that it gives you two versions. A version for the command line interface, and then a version for the core library code. If you want to understand where on your operating system global packages are installed we run this command at a depth of 0, so we're telling npm to list all the global packages, but just list the first level. If I run that you can see that top line tells me my packages are in the user's directory under my username. npm-packages/lib. I'll run the command to uninstall Babel globally, so we can install it locally, and see the differences (Typing).

Local Install
Next we'll look at installing Babel locally. Remember this is a best practice because it enables you to work with other team members at work or on an open source project. It also allows you to have multiple versions of Babel running on the same computer. For example, if you had different projects that depended on different versions of Babel. I'll start by running npm init. This will create a package. json file after we answer all of the default prompts here. Don't worry about these prompts. If we're publishing to an open source project we might want to think about these a little more, but for this demo it won't really matter. I'll clear the command prompt, go over here and refresh my window, and we'll find that the project has a package. json file. If I open it it has all the default metadata I created. I'll install babel-cli again, but this time I'll pass a --save-dev flag, and install the babel-cli. If I refresh the package of that JSON file on the left we'll see that a devDependencies node has been added with the reference to the specific version of the babel-cli, which is installed. We'll also notice that a node_modules folder was created, and that the babel-cli code was copied inside there. There's also a. bin directory, which will allow us to run Babel with just the Babel command. If we dig inside the babel-cli code's dependencies, its node_modules, we can see that it has the dependency on babel-core, along with lots of other libraries. If we clear our command prompt and try to run the Babel command we'll see that it fails because it can't find the package. Remember, Babel is not installed globally, so it can't be found everywhere. We can remedy this by giving it the path to Babel (Typing). As we discussed, including the path like this every time is not ideal, but we'll look at several ways to not have to do that in the Integrating Babel module. To illustrate why this whole process of having a package JSON file is useful for sharing your code we can delete the node_modules folder, and pretend that we're a new developer just pulling this project off of GitHub. The directions for most projects generally say run npm install to get started. If we do this what happens is all the dependencies listed under dev dependencies or the dependencies node here in the package JSON file are automatically installed, so if I run this command, as a new developer, I'll automatically get babel installed for me without needing to know the specifics of installing it or any of the other packages required by the project. Now that we've got Babel installed let's move on to compiling some code with it from the command line interface.

Command-line Interface
In this section we'll start transpiling our ES5 code with Babel, and turning it into future Javascript, ECMAScript 2015. We'll be running all our commands from the command line. To make that easier I installed Babel globally, so if you're following along you'll want to do that as well. You can do that by issuing this command we just used in the last section. I've already done it, so I won't do it here. I'm going to start by creating a couple directories. I'll create a source directory to put our source code in, and then a build directory to output our transpiled Javascript to. I'll add a file called main. js to the source directory. I'll write a quick hello world example that uses the new let keyword and template strings, both ECMAScript 2015 features (Typing). If you're following along be sure to use the back tick character in these two spots, not the single quote, put the back tick character. Again, this is not an ECMAScript 2015 tutorial. There are several other good courses on Pluralsight that cover these new language features, so I'll make sure I save that, come over to our terminal and run Babel. The first argument I'll pass it is the directory that contains the source code. If I just pass that argument and no others the output will go straight to the console, so we can see that Babel ran, but it hasn't affected our code. This is because, as of version 6 of Babel, you'll need to turn on individual language features. You can do this by enabling individual ones via plugins or a group of them by using a preset. We'll install the ES 2015 preset using Babel now (Typing), making sure to pass --save-dev to it, so it's saved to our package. json file, so the next developer who works on the project will have an easier time. Now that that's complete let's verify it by looking in our package. json file. We can see that the preset has been added to our devDependencies. If we look in our node_modules folder and see that the preset has been added as a module. I'll clear the screen and run Babel again, and we'll still see the same output. That's because we haven't told Babel to use that preset yet. We do that by passing a presets command line flag (Typing), and then the name of the preset. Now we've successfully transpiled our code. We've got a use strict statement that was added, the let keyword was changed to var, and the template string was changed to string concatenation. In addition to outputting to the console, we can also output to a directory by passing an --out-dir flag, and the name of the directory. Instead of --out-dir you could also use -d. Now if we look in our build directory, see that we have our main. js file, and it's been transpiled. If we clear the console and run the same command, but change the --out-dir to -d we can see we get the same results. If I make a copy of main. js, call it another. js, and change the name from Craig to Dave inside of it, save it, then if I issue the same command to output to the directory build, we'll get two files in the directory, main, and another. If I wanted to combine those two files into one bundle I would change the -d to a --out-file. I could also use a -o and get the same result, send it to the build/bundle. js file. I run that, I'll get a bundle. js, which has the code from both source files transpiled into one.

Configuration
In this section we'll learn how to further configure Babel both from the command line, and by creating a babelrc configuration file. There are a couple other extremely useful flags that could be passed on the Babel command line. One is the -s flag, which is for source maps. If we run this command we'll not only get our bundle. js file in our build directory, but we'll also get a source map file, and our bundle. js will have a source mapping URL back to the map file. This will allow us to debug back into our individual source files like main. js and another. js in production environments. Another useful flag is the watch flag. If I add a -w to the end of our command line and hit Enter, then a watch has started on my source files. If I go into another JS, for example, change Dave to Dave S, and then save, you'll see that the change was detected, and the bundle was regenerated, the Dave S is in the bundle. Our command line's getting pretty long and onerous at this point, it might be a good time to create a new file, give it a. babelrc file name. This is just JSON. I can move the presets into here, it takes an array, so I'll pass es2015. If I stop our watch, rerun that same command, but drop out the presets, make a change to the source code, and save things should still be working, and the code is still transpiling. I'll cancel out of my watch. Pretty much anything you can do from the command line you can do in the babelrc file, it's just a way of establishing defaults. I'll move the source maps flag into the babelrc as well (Typing), and everything's still working fine. When the babelrc becomes particularly useful is when you're not able to use a preset like es2015, and you need to enable specific plugins for language features. The syntax can get quite long, and is easier to maintain in a configuration file. To demonstrate this I'll install the two plugins needed for our current hello world example, and reference those instead of the preset in the configuration file. We want to npm install those plugins for those specific license features we need. If we look at the source code again, collapse this down so we can see it better, we need the let keyword, and we need template strings here, so let's switch over to the Babel site, so we can look up what those npm packages are named, and what they're named as plugins. Here I am at babeljs. io. If we click on the Plugins link we'll see that there's a whole set of presets like es2015, that's what we were just using. You can see what's included in it. You can see it shows you how to install it as we just did. If I take a step back to the main page, then down below the presets are the es2015 individual language features. See here we have arrow-functions, and so forth. Block-scoping, that probably would have our let keyword, so if I click on that, yes, it looks like this is what we need, so I'll grab this string, jump back over, npm install statement, paste it here, run it. To include that in our babelrc we'll need this statement. I'll grab that, open our babelrc, take out our presets, add a plugins node for the block scoping. The other thing we need is template strings. Let's go back here, and look at the list. It looks like they're calling them template literals here. I'll grab the npm package, jump back over, install, and then grab the name of the plugin, paste it into our array of plugins, and save it. Now let's clear the screen, so we can see what's going on. Open up our project, delete everything out of our build directory, and rerun Babel. It looks like we're missing a comma here at the end between our two properties. I'll save that, clear, and rerun. Looks like things worked. Let's check our build directory. We've got a bundle there, and things are properly transpiling. In the next section we'll look at how we can use the ECMAScript 2015 module syntax today.

Understanding Module Formatters
Developers are always looking for a better way to organize their code. ECMAScript modules are a much anticipated language feature, which will facilitate better code organization. Babel has module formatter plugins, which transpiled ES modules to your desired target and module specification, CommonJS, AMD, etc., so that you can run that code in the browser or a Javascript runtime like NodeJS today. In this section we'll go into the details of how this is done. Let's start by defining a module. A module is a piece of reusable Javascript, commonly a file. It exports certain objects, which are thus made available to dependent code, so a module is a file with a js extension that has functions, objects, and constants that are related, and we can explicitly choose which of those functions, objects and constants we want to expose or make public. In ES2015 modules have been standardized in Javascript as a language feature. Here is an example. The basics are there's no module keyword, a Javascript file is a module, and everything is private or local unless explicitly exposed using the export keyword. Then you can import that module elsewhere in your code using the import keyword, and have the module code available to you. This is not a course on ECMAScript 2015, but this should give you enough background to follow the example. Prior to ECMAScript or ES module syntax developers desperately needed this language feature, so they created their own specifications for how modules should work. Two specifications emerged as the most popular. CommonJS is appreciated for its simplicity and readability. It is also familiar to many developers, as it is the specification generally followed when writing code for NodeJS. AMD or Asynchronous Module Definition is known for better supporting asynchronous loading of modules. UMD and SystemJS's register are attempts to unify these different specifications, and each take a unique approach to the problem. We'll look at the syntax of each of these in the demos, but the important thing to realize is these are just specifications, and require an implementation to be used in practice. Now let's define what a Babel module formatter is. A transformer that turns ES2015 module syntax into an equivalent target module specification format, so it takes code with import and export statements used in ES modules, and turns it into say, require and export statements for CommonJS. You can think of it like Google Translate for Javascript module specifications. Once you have your code in one of these module specifications you need an environment that provides an implementation of that specification. For the AMD specification this is most commonly RequireJS, which is an additional script in your HTML page, and some Javascript configuration, and then modules will be dynamically loaded asynchronously using ajax calls when they are needed. For CommonJS code that runs on the server you'll simply need to run the code with NodeJS because it supports this specification. For code written with the CommonJS specification to running a browser, developers commonly use browserify, which wraps their code in a function with certain arguments expected as conventions to allow imports and exports. We'll see examples of this later in the course, but for now I just wanted to help you understand the big picture of how this code eventually can be used in your application. Let's see how module formatters work, in practice, with a demo.

Module Formatters Demo
Alright, so before we dig into how module formatters work I'm going to clean up the project a little bit, I'm going to delete our bundle file there that we put in the build directory, and another. js I'll get rid of, so now when I add another file that's a Javascript module, remember a Javascript module is simply a Javascript file, I'll name this arithmetic. js there. Next, I'll create an object literal, we'll call it operations. It'll have two functions, an add, and a subtract function (Typing). Each of these will need to take an a and a b argument, and then I'll quickly implement them by saying return a + b, and down here I'll return a - b. Okay, now that we've got an object that exposes two functions, arithmetic operations add and subtract. To make this into an ECMAScript module we simply need to put the export keyword here in the operations object along with its functions become public. I'll save that, and move over to our main. js where we'll delete the existing code, so we need to import. What we're trying to import is that operations object, and we'll say from the arithmetic. js file there. Then we should be able to use it, so we could say, let a result = operations. add, and pass in 1 and 1, then we could log out that result. I can do the same thing with subtract. Operations. subtract. This time we'll do 3 minus 1, and we'll log out the result again. Okay, so we've got a module, our arithmetic. js here. It's just a file, and we've exported the operations object, then we import that object from the arithmetic. js module, and we can use it in our other code. Now the problem is most, if not all browsers currently don't support ECMAScript modules, so what can we do? We need to translate this code to a module format that can run inside a browser. Let's start by translating it to the AMD specification that we talked about earlier. If we go to the Babel site at babeljs. io, and we click on Plugins we'll see that if we scroll down there's a section for Modules right here, and it lists the specifications that are supported. We see we can support AMD here, and we get our npm install command, so I'll copy that. I want to add the -save-dev. Remember, that will cause it to be saved into the package. json file, so the next developer can easily pickup our dependencies. Once that's installed we need to go into our Babel configuration file, that's the. babelrc file right here. The plugin list we have is getting a little long, so I'm going to break this across a couple lines, add a comma, so we can add another one, go over to the Babel site, and it says, here is the name of the plugin, so we'll paste that in here, save it, and if we run Babel I'll just point it at the entire source directory, and have it output to the console, so we can easily see what it's doing, so it output our code in the AMD format, so you'll notice the AMD format basically wraps everything in the define function, the first argument is a list of dependencies, and the second one is a factory function. It's common with AMD to return the object you're exporting, but it also works with the exports object, as the code is doing here. It's setting exports. operations to our object, and sending out an add and a subtract, and then when we want to use that we can define and bring in arithmetic. js, and we'll have arithmetic. operations and. add and subtract available to us. Let's look at another module specification, CommonJS, which is probably the most commonly used. To do that I'm going to get rid of all the plugins right now, and go back to using our preset, so here's our es2015 preset. Remember a preset is a group of plugins that are already loaded. If we want to see what's in that es2015 preset we can dig into our node_modules folder, go into the folder that's called preset-es2015, and then look inside of its node_modules folder, and we can see everything it depends on, so you can kind of know what's making it up. Another way to do this is by going to the plugins page, clicking on es2015, and there's a list of them here at the top. The thing I wanted you to notice here is we could install the plugin for CommonJS, but if we use our preset you'll notice that it's already installed here. CommonJS is the default module formatter that's part of the es2015 preset package, so we already have it, so if we simply run our code, so if we scroll this back over, give ourselves some room, and run our code, clear our console window, run Babel again, with the preset of es2015. We'll get the code, but this time the code will be output using the CommonJS specification, so let's look at that a little more closely. Essentially, it comes down to an exports object that exports anything that you want to be publicly available, you just attach to that exports object. When you need to import something you use a require statement like we've done here to import the arithmetic module, and then the operations are available. Let's run Babel again, but this time give it an output directory of the build directory, so we can get a physical copy of the files. Okay, it looks like that ran. We'll pull this down, collapse down our node_modules, so we can see what's going on. In our build directory we have a main. js and the arithmetic file. Now we already have NodeJS installed because we're using the npm package manager, and as I mentioned before, the NodeJS runtime environment uses the CommonJS specification, so if we pass our transpiled main. js file in the build directory to node we get an error. If we look at the message it says, cannot find module 'arithmetic. js'. Taking a look back at our source code, we're asking for arithmetic. js, but we're not telling node enough information about where to find that file. We need to add a period for current directory, then slash, and then it should be able to find that arithmetic. js, so we'll need to first rerun Babel out to the build directory. We can verify that the main. js file now has that. / in the path, and if we run that transpiled main. js file using NodeJS we get 2 and 2 as our output, as we'd expect. To recap, as you can see, we wrote our source code using import and export statements, which are ECMAScript modules. Babel then transpiled this to CommonJS specification, and we were able to run that code in NodeJS. Later in the course we'll see how to get this same code running in the browser using browserify.

Summary
In this module we saw how Babel enables us to use next generation Javascript today by compiling it to ES5, so it can run in older browsers. We discussed how Google's Traceur compiler is more experimental in it's purpose, and demonstrated how it can have less readable output. We also talked about Babel being a compiler, and TypeScript just happening to have a compiler. We installed Babel from scratch using npm, and configured it by installing numerous additional plugins, and saw how to set those in the Babel configuration file. We also saw how Babel's module formatters can help you use your favorite module specification and loader like CommonJS or AMD while using ES module syntax.

Browser Support
Overview
You'll need to know which knobs to twist and levers to pull to be confident the code you write is going to run in all the different browser versions you need to support. We'll go over in detail how to do that in this module. We'll learn about shims and polyfills, and how they can help us support older browsers. We'll review a demo project that uses all ECMAScript 2015 features, and use it to work through getting these features to work in various browsers. We'll start with the latest version of Chrome, and then we'll move to more challenging browsers, including Internet Explorer 9, and eventually Internet Explorer 8.

Shims and Polyfills
In order to get support for all these features we need to start by understanding a few terms. A shim refers to any piece of code that performs interception of an API call, and provides a layer of abstraction. Now this isn't necessarily restricted to a web application or browser API, however, the term polyfill, which you've probably also heard, is a type of shim that retrofits legacy browsers with modern HTML, CSS, and Javascript features, usually using Javascript, so right now that's HTML 5, and CSS 3, and ECMAScript 6, which again is now being called ECMAScript 2015, but a polyfill could also cover ES7 or ES8 in the future. Here's an example of a polyfill. The code detects if a certain expected API is missing, and manually implements it. To get certain ECMAScript features working, even in more modern browsers like IE9+, you will need to install the Babel polyfill. It's a polyfill created just to work with Babel. Here's the npm command to install it, and we'll do that in the next demonstration. I'll also show you how to tell which features need the polyfill, but you'll probably just want to include it in most cases. It is important to understand what is in the Babel polyfill, and the easiest way to see that is to just look at the main index. js file for it. As you can see, it just imports two other open source libraries, core-js, and the regenerator runtime. Let's look at each of these to help us better understand the Babel polyfill. Core-js is an ECMAScript polyfill library. There are certain language features in ECMAScript that could be implemented as a polyfill without transpilation. In fact, in some cases the language features make more sense as a polyfill, but other features can't be done with a compilation step, so Babel's polyfill leaves to core-js the things that make sense to polyfill, and just includes it, so why does Babel use core-js in it's polyfill instead of the other ES shims out there. The scope of core-js is not just ES5 or ES6, it's both plus future features like ES7, so it has a broader scope than most of the other shim libraries. It's modular, so you can use individual polyfills not just by including scripts in code, but also by using a Javascript module loader like browserify. Lastly, it's possible to use it without global namespace pollution, so it's the most trusted modular and flexible collection of ECMAScript polyfills. Another alternative to use instead of core-js are the ES Shims. If you're familiar with one of these libraries or already have a dependency on it they can work with Babel as well, they're just not part of the official Babel polyfill, so how to these ES5 shims differ from core-js? Well, in general, in scope. They try to implement just the safe parts of the spec, so just ES5 or just ES6, but not ES5, 6, and 7, so these projects have a much more focused scope. They're not as modular, and you can bring in individual polyfills by including a script or the code, but they can't use the module specifications and module loaders that have become so popular. They also don't have the ability to use the shims without global namespace pollution, so in summary, they're a very reasonable alternative to the Babel polyfill if you understand what you want, and you understand these tradeoffs. There are two things that make up the Babel polyfill. We've already talked about core-js, but what about the regenerator runtime. What is it? Essentially it's a Facebook open source project that's a polyfill to support the ECMAScript 6 feature of generators. It has two parts to it, a transform, and a small 1 KB runtime. Babel implements the transform, but uses the runtime from the Facebook project, so the runtime is included in the Babel polyfill. Now that we understand the Babel polyfill how can we get the browser support we need? The first step is to know your ECMAScript version target. You can do this by defining which browsers you need to support, and then look at the kangax ES compatibility table we saw earlier to understand whether you can depend on all browsers having ES5 support or, as a generality, whether you need to support IE8, which only supports ECMAScript 3. This chart shows some rough heuristics I pulled from kangax ES compatibility table at the time of the recording of this course. In summary, if your targeting IE9+ you're targeting an ECMAScript 5 environment, but if you need to support back to IE8 you're targeting an ECMAScript 3 environment. Once you know the ECMAScript version that you're targeting, then you can follow this chart to decide what else you'll need. For example, if you know you only need to go back to IE9+, then you can just include the Babel polyfill script, but if you need to support IE8, then you'll need the polyfill, plus a couple ES3 plugins from the Babel Plugins page. I'll show you how to include these in the next demo, and depending on you JS coding style you may also need to pick up one of the plugins from the section titled Other on the Plugins page. For example, if you're using class syntax with static properties you will want to use the object-set-prototype-of-to-assign transform plugin as well. Now that you've got the big picture about browser support with Babel I'll demonstrate a sample application that uses all ECMAScript 2015 features, and show it failing in various browsers, and then we'll add the Babel polyfill, as well as individual polyfills to get some additional features working, and finally, we'll transpile the code with Babel to see all the new language features working.

Project Overview
Since this isn't a course on ECMAScript 6, which is now known as ECMAScript 2015 I've gone ahead and created a project. Let me start by going into the source directory and running the index page, so you can see what we've got going on here. If I run this page in our browser there's no output, but if I checked the developer tools, and we scroll back up to the top you can see that there's a ton of Javascript running here exercising the various features of ECMAScript 2015, and some of them are failing. Now to make this easier to read, and not have to go into the console every time, what I've done is included a script in the index page called logtodom. I'll uncomment that, and refresh the page, and we'll see that all of the information that was being logged is now logged out to the page, and the errors are highlighted in red. We've even got an aggregate number of errors up here at the top of the page. The logtodom script simply overrides console. log and console. error, and writes them out to an element on the page. I won't go into the details of that because it's not important. I want to focus on browser support with Babel here. Now, as you saw, if I close this up, and we focus on the JS files we have at the root of the site here I've got one file for each ECMAScript 2015 feature or group of features, for example, with string, well there's a couple features dealing with strings. There's multi-line strings, and there's string interpolation, so both these features are exercised in this script, so same thing for scope. We're just using let and const here, so that we can exercise the new language features related to function and variable scoping in Javascript.

Chrome Support
How do we get these features to work with Babel? Well there are two ways. We can polyfill them or we can transpile them, so let's start by adding the Babel polyfill, so if we look again at our errors a little more closely, and what is failing we're in the latest version of Chrome, Chrome 47 here, and you can see the iterators, destructuring, functions, which is default parameters, the spread operator, etc., modules, and the Reflect API are failing, so if we look at our package. json file for this currently we just have a dependency on the babel-cli, and the presets for ES2015. I'll add the Babel polyfill by saying npm install babel-polyfill --save, and if I refresh the package. json file we see that the babel-polyfill has become a dependency. Now notice that I did not save it as a dev dependency, I saved it as a dependency because we'll be including it in the production version of our code. Let me show you what I mean. What the babel-polyfill is is if you look in your node_modules in your babel-polyfill in the dist directory you simply get a polyfill. js script in a minified version of that same script, so we need to include that in our index page. Let's open that back up, and add the script (Typing), I'll go up a couple directories, node_modules, dist, and then load our polyfill. Okay, now that we have the polyfill included let's reload the browser, and you can see we're down to four errors. If I jump all the way down to the bottom you can see that the one that was fixed was the Reflect API. If we go over to the Babel site, and we click on the Learn ES2015 there's a list of each of the features like arrows, and classes, and so forth. If we use this navigation on the right hand side to jump to the reflect API we can see that underneath of it it says supported via the polyfill. If you need to remember how to install the polyfill you can click this link here or you can go up under Usage and Polyfill. It'll show you the npm command for installing Babel polyfill, so the key takeaway here is that each of these features, if they are implemented via transpiling or the polyfill, you can tell by scrolling down and looking for notes under each section, so for example, here the Iterators For.. Of feature is supported via the polyfill, so we've seen that we can polyfill that one feature. Now let's transpile the code, and see if we can get the rest of our features working. What we'll do is take, let me collapse this down so we can see a little better. What we'll do is we'll take the code in the source directory here, and we need to compile this code to ES5 using Babel, and put the output in the dist directory. I have an npm script to do just that. Let me run it from the console, so you can see what it does. Clear the console, then run npm run, which tells npm to run a particular script named whatever I say after run. I'm going to say run the build script, hit run here. Okay, let's scroll back up, and see what exactly happened. At a high level the script does several things. First, it cleans out the dist directory, deletes all of the existing files there, then it compiles using the Babel compiler, the source directory to the output directory dist. You can see all the Javascript source files here being moved to the dist folder after they're transpiled. Lastly, there's a couple simple copy commands that just copy the site. css file, and index file to the dist directory as well, so pretty simple script. I will go over the details of using npm scripts with Babel later in the course, but for now it's enough to just have an idea of what it does on our behalf, so I've already compiled the code, let's load the code this time from the dist directory, so I'll change the source directory to the dist, and load the index page, and we're down to only one error, so we've made some good progress there. Let's see what's still not working. Everything passes but ES modules. Let's look at that module code. If I go into the source directory and look at arithmetic. js this is the same example we used in the module formatter section, and we've got an operations object exported that has an add and subtract method. If we go down to the p15_modules class we can see that we import that arithmetic. js file, and call the methods add and subtract on it. Let's make sure that code's getting transpiled okay. If we go into the dist directory, let's just jump straight into the modules file, it looks like everything's being compiled to common. js specification, so it's a good time to show the babelrc file, so you can see what specific settings we're compiling Babel with. Right now we're just using the ECMAScript 2015 preset with no other plugins. If you remember, if we go back over to the site, and look at the ECMAScript 2015 Plugins section, we go to the ECMAScript 2015 one, and we look at the list of plugins that that includes we can see that it includes the CommonJS modules transform, which makes sense because we're getting CommonJS output. What we don't have right now is an environment in our browser that understands CommonJS, something like browserify or Webpack, and knows how to load modules. To see if the code is alright we could quickly run the compiled Javascript file under node, which understands CommonJS, and how to load modules. Let's do that. Then we pass to node the file name (Typing), and the code runs correctly. We'll show how to get modules running in a browser with a browser fire webpack later in the course. For now I'm going to comment out the module's script here, so we don't keep getting tripped up by that, but we will revisit it when we look at integrating Babel later in the course. Since I've commented that out let me rerun the build script, we'll check our output in the dist directory by reloading the page, and we now have all ECMAScript 2015 features working in Chrome.

IE9 Support
The latest version of Chrome was a pretty easy first browser to get Babel working with, so let's make this a bit more challenging, and move to IE9. Before we do this I want to quickly explain the service I'm using to do live browser testing. It's BrowserStack, and you can find it at browserstack. com. If I scroll down here to John Resig's quote, he said it best, it's instant access to a browser in a VM with dev tools. Let me show you how it works. I signed up for an account, just go to browserstack. com or I've got a BrowserStack extension installed. If I click View All it goes to browserstack. com, and shows me all of the options I have for browsers. I could do Windows 10 with Edge, Windows 8. 1, Windows 8, etc. We're going to go back to Windows 7, and load IE9 in this example. Let's first look at it in IE9 without the polyfill, so I'll comment out the polyfill, and we'll load up IE9 on Windows 7. Okay, we've got quite a few errors here. Basically all of the features are broken. If I switch back over and uncomment out the polyfill, save, and reload we're down to 14 errors, and you can see the features that were polyfilled like map, set, the Reflect API, and the APIs for like math, number, and string, and were polyfilled and are working now. Let's compile the code and see if we can get all of this working. We'll switch to the dist directory with the compiled source code, and now all the features of ECMAScript 2015 are working in Internet Explorer 9.

IE8 Support
Now let's see what it takes to get all these language features working in IE8. I'll come in out the polyfill to get started again, so we have a good baseline. We'll use BrowserStack again, this time to load IE 8 on Windows 7, and what you see is we're not even getting logging to the page. My logtodom script is broken in IE8 as well. If I double-click this icon down here it'll give me more details about the errors. Lots of ECMAScript 20156 features are broken, but if we look carefully we can see that even my logtodom script has an error because function. prototype. bind is not available. Let's switch over and add the polyfill back, come over here and reload, and we've still got quite a few errors, but my logtodom script is now working. Our next step will be to transpile the code, so I'll run our build, switch over to the compiled code or, more specifically, the transpiled code in the dist directory, and we can see that still crawling up there that we've got five errors. Let's scroll down and look at the specifics of some. Our first error is happening, let me drag this out of the way so we can see it better, on line 27 of the for script. If we go over here, and we look at line 27 of the script we can see that this line right here is the problem. Return is a reserved word in Javascript, and so it wants instead of you to say iterator. return like it's a property, it wants you to write this for it to be supported in ECMAScript 3. I'll undo that, and let's take a look at the Babel Plugins to see if we can find one that'll help us. Once again, if you go to the Babel homepage, and you click the Plugins menu item, you'll see a list of plugins. Now we're using the preset es2015, as we discussed before. If we scroll down we'll notice there's categories of them, and there's a category called es3, which seems like what we're looking for. If we pick the first one here we can see that it takes reserved words, and turns them into literals just like we need, so let's go ahead and install that es3 plugin, I'll copy the install command, jump over to the console and clear it, paste the command, and then add on save, and this is a dev dependency, so I'll do --save-dev. Install that. While I'm waiting for that to install I'll come over here and grab the name of the plugin to be put in the babelrc file, so that Babel knows that we want to use it as part of our transforms to our babelrc. We can see we currently don't have any plugins. I'll add that one, and just to make sure we've got good IE8 support I'll also add the es3-property-literals transform, which does, as you can see in this example, adds the quotes around the property keys to make them literals, so we'll grab the npm install command for that, come over and install it, again, it's a dev dependency, so by adding that --save-dev we know that it'll appear as a dev dependency here. We still need to include that plugin in our babelrc file, so that Babel uses it as part of its transforms, so we'll grab that string from that same page, copy it, and add it to our array of plugins that we support. I'll save that. We'll need to run our build again, so I'll say npm run build. Now if we switch back over to our virtual machine of Internet Explorer 8, and we refresh the page, scroll back up to the top, we can see now all the ECMAScript 2015 examples are running in Internet Explorer 8. In the next part of the course we'll look at the specifics of integrating Babel in with various build tools, npm scripts, Grunts, Gulp, browserify, etc., but first let's recap what we've learned.

Summary
In this module we learned about shims and polyfills, including the Babel polyfill, and how it is really just core-js plus the Facebook regenerator project's runtime that helps us support generators. We reviewed a demo project that uses all ECMAScript 2015 features, and used it to demonstrate how to include the Babel polyfill, and when to include additional ES3 plugins to support browsers all the way back to Internet Explorer 8. In the next module we'll look at integrating Babel into your build process using your favorite front end tools, including Grunt, Gulp, Webpack, and npm scripts.

Babel in Your Build
Overview
In this module we'll look at lots of different ways to integrate Babel in your build. We'll use build automation tools like npm scripts, Gulp, and Grunt. Then we'll go through the details of using Babel with module loaders like Webpack and Browserify. Lastly, we'll see how we can compile the HTML embedded in our React. js code known as jsx using Babel.

Babel with Npm Scripts
If you are not familiar with npm scripts they are a lightweight, easy to learn alternative to Grunt, Gulp, Webpack, etc. They are actually part of the package. json file recreated with the command npm init to keep track of our node module dependencies. They are like a batch file or a bash script, depending on your operating system. One of their key advantages is they will run the local version of an npm module you have installed for your project without providing a path. Npm scripts know to look in the node_modules folder. Because it's just like a batch file or a bash script it is very approachable and easy to learn, and in fact, you probably know most of what you need to use them. Inside the package. json there is a scripts key, which contains its own set of keys, which are script names, so if from the command line or terminal you run the command npm run-script followed by the name of a script it will execute that logic. In this example the script name is test. Typing run-script gets too long when typed repeatedly, so as a shortcut you can just type run, and then the script name. Certain script names can be called without the run command, but omitting the run command only works with the commands test, start, stop, and restart. Let me show you the basics of what we just covered, and then use what we've learned to call Babel. There's an entire course on using npm as a build tool on Pluralsight by Marcus Hammarberg if you are interested in learning more. For this demo I went back to just the couple simple files we had for the first module. I've got the sort. js that sorts an array using an arrow function. I've got a main. js here, which calls to the arithmetic module, and the arithmetic module, so just a few files here to compile, so we can learn about npm scripts. I'm going to open the package. json file, and we'll see that when we use the npm init command npm generated a script for us already called test, so if I type the command in my terminal npm run-script, and then pass it the name of the script, test, we'll get an error. The error is because the script itself exits with a code of 1. If we remove that exit code, and run the script again, I'll clear the console first, this time we'll run it with the shortcut run instead of saying run-script, we'll just say run the test script, and there are messages echoed out to the console. Also remember that npm has a few predefined script names that are built-in, and don't require you to type run right here, you can just type npm test or start or stop. If you do that the script will still run. Now if you try just to do npm and a script name that you create yourself it will not work. Let's create our own script, and start to use Babel. I'm going to add a comma after this first script. We'll call this script demo, we'll have it called babel, and just to keep it simple at first output the version of babel. Now before I run this if I were to run babel --version from the command line you'll see that the command is not found because Babel is not installed globally, it's only installed locally in this project directory right now in the node_modules folder, the babel-cli that is, but if I clear the screen and npm run the demo script we do get a Babel version back. This is because, as I mentioned a few minutes ago, npm scripts know about npm_modules and know to look in the npm_modules folder in this bin folder for commands that are available to it, so we can find the local version of Babel installed as the babel-cli here, so I'll add another script here called build:js. The implementation of the script will be to run Babel from the command line as we did before, and be sure not to forget your comma after each one of your scripts. If we go ahead and run that npm scripts by saying npm run and then build:js we'll see that our code was successfully transpiled by Babel. If we go up and refresh the directory structure we'll see a dist folder now, and we've got a transpiled set of files here in this directory. I just wanted to demonstrate how quickly you can get your Javascript compiling using npm scripts and the babel-cli.

Babel with Gulp
In this section we're going to see how to call Babel from Gulp, which is probably the most popular front end build tool at the time of this recording. I'm in the same simple project I was for the npm scripts demo, I just deleted the disk directory, and cleaned up the project a bit, but we've still got a main. js that calls arithmetic. js and a sort. js. I'll show you the basics of using Gulp that will allow us to call Babel, and don't worry if you're not that familiar with Gulp, we'll go step by step here. There's a great course by John Papa in the Pluralsight library that you should check out if you want to learn more, so to get started with Gulp we need to do an npm install, we want it to be global, and we'll install Gulp. Next, we'll need to install Gulp locally in our project, and add it to our development dependencies, so we'll do npm install, gulp again, but this time we'll save to the dev dependencies. If we open our package. json we can see that we now have Gulp as a dependency. Next we'll create a Gulp file at the root of our project. First we'll need to require Gulp, we'll do that with the require CommonJS syntax. Then we'll create a default gulp. task, we'll say task default, and then the second argument is a function that is the task. To start we'll just console. log, out hello gulp, and then run gulp from the command line. Okay, we've got Gulp working, hello gulp coming back because we didn't pass a specific task name like default it ran the default task for us. Now let's look at how we can use Babel from Gulp. There is a module that we'll install called gulp-babel, and we'll add that to our dev dependencies. This is just a wrapper around Babel to allow us to call it from inside of Gulp. If we look at our package. json we can see that it's now a development dependency. Let's update our gulp file to require gulp-babel. We'll name it babel as a variable, we'll get rid of our console. log, and create a gulp stream from the Javascript files in our source directory. We'll pipe those to Babel and invoke the gulp-babel process. Notice the parentheses there and then finally we'll output the transpiled stream of code to the dist directory. We'll need to create a Gulp destination for the dist folder to pipe it to (Typing). We'll want to make sure we return a stream from the Gulp task, and then run Gulp. It called Babel successfully. It looks like let's refresh the project, so we can see there's a dist folder here, and it has our transpiled code in it. Okay, the last thing worth talking about with Gulp in Babel is you may want to actually write your Gulp files using ECMAScript 2015 language features. For example, you might change this to const, this to const, and change the function to an arrow function. If you're using node version 4 or later, because the Gulp file runs in the node environment, this code will just work, but if you're running an older version of node, like I am for this demo, let's check my node version, my current node version is set to 0. 12. 2, then you'll need to do a couple things to get Babel to transpile your Gulp file. The first is to simply change your Gulp file, rename it to. babel. js. If we try to run Gulp now though, however, we get an error. If we scroll back up we can see that it's having trouble finding the Babel core module. Now we do have the babel-cli installed, and the babel-cli depends on babel-core, but we don't have babel-core installed as a dependency right now. If we add that by doing an npm install babel-core, and then adding it as a dev dependency we can see babel-core has been added as a dependency to package. json, and if we run Gulp again, we are successfully transpiling our gulpfile. js, which then transpiles our source code to the dist directory.

Babel with Grunt
In this module we'll see how to integrate Babel with the Javascript task runner, Grunt. Grunt was the first popular front end build automation tool, so we're going to look at how you could plug Babel into your Grunt build process. If you don't already have Grunt installed you'll need to install it. To do this you first install the grunt-cli or the grunt command line interface. We'll want to do that globally, because the cli is just a wrapper that calls the version of Grunt that you have installed in your local project. Next we'll need to install Grunt in our local project, so we'll save that as a dev dependency, and we could see Grunt has been added as a dev dependency to our package. json file. Next, we'll add a Javascript file to the project called gruntfile to configure grunt. We'll do a quick hello world example in Grunt to get started, but if you want to go deeper into the topic there's a course by Derik Whittaker called Introduction to Grunt that's a good intro. Every Grunt file starts with a wrapper function that uses the CommonJS module specification to export a function, and passes Grunt into the function. Inside the main function of our Grunt file there's usually three main things we need to do, configuration, loading plugins, and then defining tasks. In order to get hello world working all we need to do for now is define tasks, so let's call the Grunt object, and register a task. We'll give it a name of hello, and then pass it a function. We'll log out hello world, and we have our first task. Now Grunt has a concept of a default task, so we'll register another task. This time we'll make it the default task, and as the second argument we can pass an array of other tasks to run, and we'll run our hello task that we just defined above. Now to run Grunt all you have to do is type Grunt, and we can see that our hello world example is running. Now running the command grunt is the same as running grunt default, which points at the default task, which then runs hello, so this'll give us the same output. We could also run a specific task. For example, we could say grunt hello, and directly call our hello function. Okay, that should be enough to get us started. Let's integrate Babel into our Grunt build. In order to do that we'll need a Grunt plugin named grunt-babel, so we'll npm install grunt-babel, and save that to our dev dependencies. We'll then need to explicitly load that plugin. We could do that here by calling the grunt. loadNpmTasks function, and giving it the name of the plugin. Babel also has an initConfig function, but I paste the code in here, which allows us to pass in the name of a task, babel, in this case, and give specific configuration options for it. We'll call this babel task down below by replacing hello with babel. We can get rid of our hello task now, and all we need is our default task, which calls the babel task, which is configured here, and uses these options, so the grunt-babel plugin looks for a task named babel here, and then runs all of the subtasks underneath of it. We've only got one here called compile, but this word could be foo or blah, it's not important what this is. We'll leave it as compile because that's what we're doing. We send it some options telling it where our source files are, to leave them expanded, not to combine them that is, and to flatten the directory structure, meaning to remove the source/directory from the path when it moves them into the destination folder, which is the dist folder. I'll delete the dist folder here just to make sure we've got a clean environment before our first run, and then remember if we call Grunt it will call the default task here, and the default task will call the babel task, which will run Babel, so let's run Grunt, and our task has completed without errors. If we refresh the project we can see there's a dist folder with our compiled source code in it as we'd expect, so the key takeaways are you need the grunt-babel plugin, you'll need to load that npm task, and configure it, and then you can call the babel task, and have transpilation integrated into your build.

Babel with Webpack
In this section we'll see how to integrate Babel with Webpack. Webpack is a module bundler, so we'll finally get to see one way of getting CommonJS modules working in the browser. Again, I'll be going over the basics of Webpack, but there's an entire course by Joe Eames on Pluralsight that covers Webpack Fundamentals, so I'll npm install webpack to get started. We'll want to do that globally, so I pass it as g or spell out global. We'll also want to install it locally, so that we know we have it as a dev dependency, so we'll add the --save-dev to it, and as you can see, it's now been added to the package. json as a dependency. Next, we'll get a hello world example going with Webpack. I've added a couple files to give us a head start. First, I added an app. js here that's simply document. writes out hello. I've also added an index. html to the root of the site, and have an empty script tag sitting there waiting. We'll fill that in with our dist directory, and a bundle. js file. That's where we'll have Babel write our source code after it's been compiled. I'll save that. To get started we can just call Webpack from the command line, so we can say webpack, and we'll want to pass it as a first argument and entry file. We'll give it src in our app. js file, and the second argument will be where we want it to output to, we'll say to go out to the dist/bundle. js file as we've indicated up above in the HTML page. Looks like it succeeded. Here's our dist directory and our bundle. js. We notice it's a lot of code to sort of manage the loading of the modules, and then finally at the bottom here is our little bit of code, so now if we load our index. html page in the browser we'll see our hello example is working. Okay, now that we've got things working we'll take these command line arguments we're using, and put them into a webpack configuration file. We'll add a new Javascript file to the root of our project called webpack. config. I'll paste in the equivalent code to what we just ran on the command line, and then walk through it, so it starts out with the module. exports, which is the CommonJS format for exporting an object. The object has two properties, that's looking for an entry file, we're passing it our app. js file. By entry they mean the file that is sort of the main method of your web application where most other dependencies will likely be required further down inside the application. The output is just what it sounds like. Where should the bundled code be output to? You give it a path, dist, in this case, and a file name, bundle. js. After we save that file we could run webpack from the command line again, but this time we don't need the additional arguments of the source and dist directory because they're in the configuration file, so we could just call webpack. Switching over to the browser, I reload, and we're still getting our hello. Okay, now that we got a basic hello world working with webpack let's integrate Babel into the bundling process. If we look in main. js here we could consider this the entry point for our application. The application does something very simple here. It just logs out the results of some arithmetic operations, but remember we are importing the arithmetic module up above, which, as we discussed in the module formatters lesson, a module formatter transpiles to CommonJS code, which webpack can bundle up and make available in the browser, so we'll use this file as our new entry point. We need to go into our webpack configuration and change this from app. js to main. js. We'll leave the output to still go to the dist directory into a bundle. js, so our HTML page still points to the right spot. We will need to npm install what Babel calls a loader. Loaders are extension points for Webpack that allow it to work with various tools including Babel, so once again, we'll npm install the babel-loader. The babel-loader itself uses babel-core, the core API library, so we need to install that as well, and we'll save these as dev dependencies. Okay, let's check our package. json, and there we can see our new dependencies. If we hope back over to the webpack config file, besides entry and output, there is a modules configuration section, which takes an object. One of its keys is a loaders array, so we'll give it an array here. Defining a loader, it has three properties, the first is test, which is a regular expression to evaluate which files to bundle, we'll look at all Javascript files. The second argument is any files we want to exclude. We don't want to look in the node_modules folder, and then lastly, we need to define the name of our loader. We just installed it, it's called babel-loader. Save that. If we clear our console, just saw one typo here, this should be module, and not the plural modules, so if we run webpack now our bundle gets successfully created. If we open up the bundle we can see that our arithmetic object was successfully transpiled, and then that code was bundled, so if we load the index page again, we'll see no output except on the console, if we open the developer tools and look, which is the result we expect from our arithmetic operations. You can see for the first time we can see a CommonJS module working in the browser. What's happening is main. js is requiring a module using ES 2015 syntax import statements. This is being transpiled to CommonJS. You can see it here with the exports object being used, and then this code is able to run in the browser because of all this code up here that webpack is wrapping it with that allows modules to run in the browser.

Babel with Browserify
In this sections we'll look at how to integrate Babel with Browserify. Browserify lets you require modules in your browser by bundling up all your dependencies, so it's a module bundler similar to Webpack. Webpack does some different things, Browserify has some different opinions, but it is a module bundler. We'll do a similar demo to what we did with Webpack. We have an index. html file that has a script tag that points to the distribution folder, and the bundle. js file within that. We'll start with a simple hello world by using this app. js file, which writes out hello. We'll start by bundling that. Then we'll move onto our main. js, which actually uses a module, but uses ECMAScript 2015 modules, and imports the operations module. To get started, if you don't have Browserify installed already, you need to npm install browserify, and we'll make that global, so it's available from the command line. Remember, we could just do the -g. Okay, we have Browserify installed globally, but we don't have it as a dependency of our project, so we want other developers to be able to pick up that dependency, so I'll npm install browserify again, but this time I'll make it --save-dev, a local dev dependency, and we can see it's been added to the package. json as a dependency with its version number. Next, for Browserify to work you need to the destination directory that we're going to compile into, the dist directory in our case, to already exist, so I'm going to create an empty dist directory. Next, we'll invoke browserify from the command line. We need two arguments. One is the default argument, which is the entry point for the app. Ours will go to the src/app. js file to get started, and we'll direct the output to an outfile in the dist directory called bundle that we've already referenced in the index. html. Now there are shortcuts for --entry and --outfile. If you've seen different arguments, --outfile could be just -o, and --entry could simple by -e. I'm just using the longer arguments here, so it's clear what's going on. Browserify ran successfully. If we look in our dist folder we'll see that we have a bundle. js. The modules are being bundled similar to Webpack except the surrounding code has already been uglified, so you see just short variable names, and all the code collapsed onto a couple lines. If we run this it works as we'd expect, and we have hello world working with Browserify. Now let's integrate Babel. To use Babel we'll need to npm install babelify, which is a browserify transformer, which will compile a Javascript with Babel before bundling up the modules, so they can run in a browser. We'll save this as a local dev dependency, and verify it's there in our package. json. If we run browserify as we did previously, but this time instead of running on an app. js, which has no modules, we'll run it on main. js, and you'll remember in there we have the arithmetic package importing the operations module, and we'll add an additional argument of a transformer, and call babelify. Looks like that ran successfully. If we check out our bundle file we can see that first our operations module was exported, and then is required and used to console. log out arithmetic operations. Let's run the page again. We see no output on the page, but if we look at the console we get 2 and 2, which are the expected output of our arithmetic operations.

Babel with React
In this section I'll be going over how to integrate Babel with React, a Javascript library for building user interfaces. I'll just be covering the basics of React. If you want more information on React I suggest the React Fundamentals course by Liam McLennan, and also the Building Applications with React and Flux course by Cory House. We'll get started by installing React with npm. We'll need to install react plus the react-DOM library, which is separate now, since they have React Native for mobile applications, and these will be production dependencies. In other words, they'll need to be deployed with our code, so I'm going to do --save instead of the --save-dev we have done before, and we can see these dependencies have been added to the package. json file under the dependencies node. If we look in our node modules folder we'll see that we have a react folder and a dist folder for distribution, and we have a react. js file there. We also have a react-dom folder with the dist folder, and the react-dom script there. To use React without a module system we need to include both those scripts in our index. html. I'll paste them down here at the bottom before my app. js script in the dist directory. App. js in my source directory right now is an empty file where we'll eventually put our React code. The only other thing in our index file right now is an empty div with an id of content. We'll use that as the container for our React component, which you'll see in a moment. The way that our Javascript compiler Babel helps with React is different than what we've seen so far. In all the other use cases we've been compiling future Javascript back to ECMAScript 5, so it can run in back level browsers, but Babel is capable of other types of Javascript compilation, and an excellent example is the ability for it to compile React's jsx syntax into a Javascript file. I'll show you concretely what that means in a moment, but first we need to install an additional Babel plugin to enable the react. jsx compilation. We want to npm install the babel-preset, in other words, this is a group of React plugins, and we're going to only use these at dev time during compilation, so we'll say --save-dev. If you go to the babeljs. io site and look under Plugins you'll see the React preset here, and there's the command we just ran. We'll also need to add it as a preset, so I'll grab the value here, switch back over to our editor, go into our. babelrc configuration file for Babel, and add an additional preset of react. Now we need to write a little bit of React code to see this work. I'll go into my empty app. js, call the ReactDOM, render method. The first argument is a React element. That's going to be the jsx syntax, which is essentially HTML inside of Javascript. I'll write a quick h1 and say Hello World here. The second argument is the DOM element that's going to be the parent of this DOM element when it's rendered, so we say document. getElementById, and pass it the name of content, which if you remember back on our index page maps to this div right here. Okay, now we need to run Babel on our source code as we've done previously. Let's go into our package. json file and create an npm script called build. We'll take out the existing contents of this one, and call Babel. It'll know to use the local Babel in the node_modules folder because that's how npm scripts work. We'll tell it to compile our source directory, and send that to the output directory of dist. Let's delete our existing dist folder here, so we can see this work. Now we can go down to the console and run the build script. We do npm run, we could say run-script, but run is all that's needed, and we'll say build because that's the name of the script above. Looks like we've successfully compiled our one file, and let's look at the before and after, so we can see what Babel's doing on our behalf. Babel's taking this inline HTML known as jsx, that is the HTML in the middle of this Javascript file, and it's compiling it into what we have in our dist directory, which is a call to React. createElement that creates that element represented by the h1 in the jsx. Remember our index page is pointing to this app. js file in the dist directory, so the compiled version, and we've got react and react-dom included as scripts, so if we run the index page we'll see our Hello World is working. We could even turn our npm script into more of a development time configuration, let's call this build:dev, and add a -w for watch, and it will watch source files for changes. Let's see that in action. First we'll start our dev build, I'll do npm run, and this time we'll do build:dev because we changed the name of the script. The code's compiled, and it's watching for other changes. If I go up here, and add some more HTML, let's say I'll add a div to contain everything, and then throw in an additional paragraph here, and I'll say this is some content, and save that. If you watch closely below you'll see that the app. js was compiled again. If we switch over to the browser and reload you can see how Babel's helping us transpile the inline HTML they call jsx that we have in our Javascript file, and how Babel's future is clearly that it can generically compile Javascript, even in ways we can't yet imagine that will be useful to our development process.

Summary
In this module we looked at three different ways to integrate Babel in your build. First we looked at build automation tools like npm scripts, Gulp, and Grunt to help run Babel as part of a more elaborate, repeatable build process. Then we looked at how we could better organize our code using module loaders like Webpack and Browserify to wrap our code up into modules. Lastly, we looked at how Babel can compile Javascript used in Javascript libraries and frameworks, for example, compiling jsx in our react. js code. In the next and final module of the course we'll look at integrating Babel with NodeJS, and in our tests.

Babel with Node.js and Unit Tests
Overview
In this module we'll be going through the ins and outs of using Babel to compile your NodeJS code, as well as your unit tests. We'll look at several ways to compile your Javascript code to run on NodeJS. The first few, babel-node, and the require hook are convenient, but not recommended for production. Using the command line interface to compile your code to ES5 is the recommended approach while being sure to require the Babel polyfill. Lastly, we'll show an alternative to using the Babel polyfill, the Babel runtime, which doesn't pollute global scope. Once you start using Javascript language features you'll want to use them everywhere, including your unit tests. Look at how to setup both Jasmine and Mocha to compile your tests with Babel.

Babel and Node Versions
In this section we're going to be talking about using Babel with your NodeJS applications. Let's start by looking at the kangax ECMAScript 6 compatibility table again, but this time let's focus on the server runtimes, most notably, these three columns, which show NodeJS's support for ECMAScript 2015 language features. As you can see, the current stable version of Node 4. 0 at the time of this recording has support for 49% of the language features, but if you're like many people and on version. 12 of Node you will only have 16% of the language features available to you. Let's look at how we can make more of those language features available by using Babel in our NodeJS applications. There are three ways to use Babel with Node. The first two are generally only used in development, I'll explain more about that later, and the last will be what you want to be doing in production.

Babel-Node
If we just call node without passing it a file we get a REPL or a Read Eval Print Loop, basically a language shell for Javascript, so at that point we could create a variable a = 1, and also log out that variable. When you install the babel-cli in the bin directory you get a babel-node executable. Babel-node is meant to be a drop-in replacement for the node executable, but will first transpile your code with Babel before running it in the V8 engine, so if we cancel out of the node REPL, and start up babel-node. which again, is an executable that's a drop-in replacement, we get a similar REPL. Now note that earlier in the course in order to have the babel-node executable available we had to npm install the babel-cli globally to make it available at the command prompt, and as you can see, we've saved it as a dev dependency in this project. If I start up babel-node I can use ECMAScript 2015 language features. For example, if I create an array with 1, 2, and 3 in it, and call the map function, and use and use an arrow function to increment the numbers in the array we get the result 2, 3, and 4. If you remember, map is provided by the Babel polyfill, so when you run babel-node the Babel polyfill is automatically being required for you, and that's why this code works. Again, this isn't for production, but it's a nice interactive language shell where you can play around with most of the ECMAScript 2015 language features. As you've seen earlier in the course, the node executable can take a file from the input stream. If I send in a source file, for example, main. js, let's pop that open so we can remember what's in there, this is importing our arithmetic module, and calling the add and subtract methods and logging them out. We did run this code successfully earlier after we transpiled it, but right now if we run the code before it's transpiled in node we'll get an error because it doesn't recognize the import keyword, however, if we took that call to node, and changed it to babel-node the code will be transpiled on the fly for us, and it works.

Require Hook
Let's look at the second way we can use Babel from within node. The require hook, it lets you switch on Babel transpilation from within NodeJS. After you do all modules you require, except for npm modules, are automatically transpiled. As with babel-node, the require hook generally isn't recommended for production use, but rather to make local development easier. For example, in your unit tests. To use the require hook we'll npm install babel-register, which is the package name that includes the require hook. We'll save that as a dev dependency. If we go into the source directory's main. js file, and we require the babel-register, save it, and then run this source file under node you might expect it to transpile this code on the fly, but it doesn't. That's because you have to remember these files that get transpiled by the babel-register are the files that are required with the require statement, but main. js is the entry or start point of our application, and it isn't getting required into another file, so it isn't getting transpiled, so what we need, and what I have in this source CommonJS directory is a copy of those files, but I've changed the main. js file to not use ECMAScript features like imports or the let keyword, however, the arithmetic class still uses ECMAScript modules, but this should work because the require hook will transpile it. Let's try it. I'll go into the src-commonjs directory, I'll require babel-register, which basically establishes the require hook. We'll run it again, but this time from the src-commonjs directory, and the code works because of the require hook. Again, this isn't recommended in production, but when you're in development this can be a convenient way to get your files transpiled on the fly. Now note that in this case the polyfill is not automatically there, so for example, if I add to the main. js file here some code that uses an ECMAScript 2015 language feature, such as the string, includes function, which is polyfilled, and I save it and run it, it won't be able to find that includes function. If we look at our package JSON we don't even have the polyfill installed, so we'll npm install the babel-polyfill, and save it as a dev dependency. Once that's in our project I can go into my main. js file, and right after my babel-register I can require the babel-polyfill itself, save the file, rerun the main. js, and even the language features provided by the polyfill are available now. Just to reiterate, not something you want to use in production, but this can be convenient as you're developing code.

Command-line Interface (CLI)
The last way to use node with Babel is to use the cli, the command line interface, to transpile all your files, and then on deployment just run the code normally with node in production. We showed this earlier, but let's review. Let me grab this chunk of code that uses the includes feature, and add it into our source directory's main. js, and remove the babel-register that won't work in there because it's the entry file, so we'll run Babel from the command line. It's available here because I installed it globally. Remember, if you're using it from an npm script or another build tool like Grunt or Gulp you wouldn't necessarily need it installed globally, but it makes the demo easier to follow, so I have the babel-cli installed globally. I'm going to compile the source directory, and set the output directory for the transpiled code to dist. Okay, now is we refresh our project up here we've got a dist directory with our transpiled code, and if I run that code in node by pointing at the dist directory, and then main. js, the call to string. includes is not working because we haven't included the polyfill. We can do that in one of two ways in our source file, so if I go down to src main. js, and at the top here just require the babel-polyfill, and save it, compile the code with Babel again, and then run the compiled code in the dist directory. The babel-polyfill has added to the prototype of string, the includes method, so it's globally available, and the code runs. Since we're using ECMAScript 2015 modules a nicer way to do this would be to simply import the babel-polyfill, save that, compile it, and run the file in node again, and it still works because the import statement is being compiled in the dist directory into a require statement by Babel. Let's use one more ECMAScript 2015 language feature that's polyfilled, a promise. I'll just create a promise object to see if it's available in the global namespace, so I'll say let promise equal a new promise, that takes a function, which has a resolve, and a reject. Compile that code again with node, and it still works. Let's look what that code for the promise got transpiled to. With the exception of some white space it looks basically the same. That's because the polyfill added the promise object to the global namespace, so that you could just ask for a new instance of it like we are here. This is convenient, but risky because anyone else who creates an implementation of a promise object in a library you use in your project can replace the babel-polyfill implementation, and cause version conflicts. In the next section we'll look at an alternative to using the babel-polyfill that doesn't pollute global scope, the Babel Runtime.

Babel Runtime
Notice that we are adding to the global namespace, for example, promise is just available in the global namespace. The. includes function is available off the string globally. If another library or another version of this library would step on that function we could run into problems. This generally doesn't happen when you're building applications, but when you start building node modules to be reused in other people's projects this can be a problem. If you prefer not to add to the global namespace because you're worried about version conflicts Babel provides the Babel Runtime. Let's go back over to our source file, remove the polyfill, so that it's no longer globally included, and we'll npm install the babel-runtime, and notice we'll do a --save here because this is a production dependency, the runtime will need to be available, and deployed in our production code. In addition to the runtime itself, what we want to do is add an additional Babel plugin called the babel-plugin-transform-runtime, and we'll save this as a dev dependency because it's a plugin that's transpiling our code. What this transform does is it takes the transpiled code, and instead of leaving it as promise = new promise it will import or require the promise library from the runtime, and then instead of calling new promise it will use that imported object. Let's run it, so you can see this better. The last thing I don't want to forget is this is a plugin, so in our babelrc we'll need to add this to the list of transforms that happen, so we'll call the transform-runtime plugin as well, then when we compile our code if we inspect the main. js in the dist directory, and we scroll down to where the promise is created, we can see that the new operator is being called on the promise2 object, and then the default function is being called on it. If we look up higher in the file we'll notice that the code to polyfill promises from core. js is being required into an object called _promise, then it's running through an inline Babel function, and sent into the promise2 object, and that promise2 object is used to create the promise, instead of the promise coming out of the global namespace. If we run this compiled code it still fails. The promise code succeeds, but the instance method on the string of includes is no longer recognized. That is because the Babel plugin transform-runtime is not able to pick up that global usage of an instance method, and transpile it correctly, so the takeaway is the Babel runtime can keep you from polluting the global namespace, and having version conflicts with other projects when you're writing a library, but has limited support for instance methods, so you have to be careful which ES 2015 functions you use because some of them won't be available when using the runtime. If we go back to the source file, and comment out these lines that use an instance function, compile the code again, and run the code, everything works. If we examine the output we can see that the promise is fine, but the includes function, and other instance methods are not available with the babel-runtime.

Babel with Jasmine
Let's look at how we can integrate Babel into our unit tests, so that we can write ECMAScript 2015 in our unit tests themselves. We'll start by looking at the popular unit testing framework Jasmine, and in the next section we'll look at how to do this with the Mocha testing library. We'll start by installing Jasmine into our demo project, babeldemo. We've got the same familiar source files in here, arithmetic, main. js, and sort. js, and as you might guess, as we've done with all the other tools we've used, we can npm install Jasmine for this project. We'll start by making it global, but I will also install it locally, so that we can save it as a development dependency, and use it inside our npm scripts, and now you can see Jasmine is listed as a development dependency in our package. json. Jasmine has an init command that sets up some of the configuration files. After I refresh Webstorm you'll notice it created a spec directory here. If we look inside the spec directory there's a jasmine. json, which is a configuration file for Jasmine. We won't change anything in that just yet, but I will run another Jasmine command called jasmine examples. This added two directories, the lib directory here, as well as the jasmine_examples underneath the spec. We've got a couple of Javascript files here now that we can unit test. We have a player, but the player's just the constructor function, and its prototype is augmented with some methods, as you can see here, and then exported using CommonJS syntax. Song looks about the same, and then we have a spec for the player itself. This gives us our first Jasmine test of run. You'll notice that the syntax and summary is describe blocks, which are essentially groupings of tests, and you can nest the describe blocks inside of each other. There's a beforeEach function, which is synonymous with the setup function that you might be used to. Any time you see an it, an it is a test, so we've got describe blocks that act as suites or groupings of tests, and then it blocks nested inside there, which are the tests themselves. Unit testing in Javascript is very similar to server-side frameworks with the exception of the fact that most of the testing frameworks take advantage of the fact that you can nest tests inside each other, so that you get a nice hierarchical organization of your tests. At this point, we can just run Jasmine. It'll pick up the settings from the support jasmine. json file, and run the five tests we have in there with no failures. To make sure that we're using the local version of Jasmine installed in our node_modules folder here we'll use an npm script inside of our package. json. I'll add a test script whose implementation right now will simply be to call Jasmine. By doing this again, we're ensured that it's going to run the version in our node_modules folder version 241 that was just installed. Remember from the npm scripts section that there are certain script names that are special and don't need the run keyword, so we could just say npm test, and our tests have passed, and so we've now successfully run Jasmine from an npm script. What if inside this player spec file here a spec is synonymous with a test in these testing frameworks. We want to use ECMAScript 2015 syntax, let's say an arrow function, for example, so I'll change this from a function to an arrow function. Now if I run it we get a failure saying the arrow function is not recognized. To get Jasmine transpiling the spec files with Babel we need to install what's known as the Babel require hook. It lets you switch on Babel transpilation from within NodeJS. After you do all modules you require, except modules installed with npm, are automatically transpiled. The package with the require hook is called babel-register, and we'll save that as a dev dependency. If we refresh our package. json we'll now see we have babel-register installed, but we need to tell Jasmine about it. To do that we go into the spec folder, the support folder inside that, and find our jasmine. json file, and we add a Javascript file to the helpers array, so we'll throw a comma here, and then add the path to the node modules babel-register node. js file. Note that this path is relative to the spec directory defined above in the config file, which is why we're only going up one level instead of backing up two relative paths to get to it. Okay, we'll save this, and run our tests again, and now our tests are passing with ECMAScript 2015 syntax, that is this arrow function here we've added. Now we could change these all to arrow functions, but remember, it's not just this one language feature that we now have available to us, it's all the ECMAScript 2015 language features that Babel is configured to handle that are now available inside our spec files. To demonstrate this better let's use one of our existing files in the source directory, our arithmetic. js. It just has the add and subtract functions off the operations object, and remember that we import it here in our main. js. We'll now write a unit test similar to what we have in this main. js file to test the arithmetic operations, and we'll use the ECMAScript modules as we have here inside the test. Let's start by going to our spec folder, adding a new Javascript file (Typing). We could switch over to main. js and grab our import statement from there, and copy it into our spec file. We'll need to change the relative path to.. /src here to get to it. I'll use a couple code snippets to quickly create a describe block to test the Arithmetic Operations, it should add numbers, we'll expect the operations. add of 1+1 toEqual 2. If we run our tests again, we'll see that the new spec passes using ECMAScript modules inside the test itself.

Babel with Mocha
In this section we'll look at how to integrate Babel with Mocha. Mocha's a Javascript test framework running on node. js. If you want more information you can go to mochajs. org. For our babelmochademo I'm starting with a blank project, except for that I ran the npm init command, and created this empty package. json file. I'll start by npm installing mocha globally. I'll just use the -g abbreviations this time. I will also install Mocha locally here with the --save-dev flag, and I'll add one additional npm package chai. Chai provides several different assertion syntax that could be used with Mocha, and if I refresh the package. json you can now see the versions of Chai and Mocha that are dependencies of my project. I'll create a test directory, and inside that a test Javascript file. First I'll initialize one of Chai's assertion syntaxes, the should syntax, by requiring Chai, and then invoking it's should method, and capturing that into a local variable. Besides the assertions, Mocha's syntax is the same as Jasmine, so I'll use my jasmine live template here to start a test suite testing the array. I'll nest another describe inside that, and indicate that I'm testing the indexOf function. Then I'll get to the test itself, I'll say it should return -1 when the value is not present. Now if I create an array, let's say 1, 2, 3, and call the indexOf function, and ask for the item at the fifth index. That should equal -1 because there is no fifth item in the array. Okay, if I go down to the console, clear it and run Mocha, we can see we've got our first test passing already, so you may be wondering, Mocha by default looks for a directory named test. If you wanted to put your test in a different directory you'd simply pass it on the command line when you call it. For example, if you put in the spec directory you'd call mocha spec here. Next, we'll get Babel transpiling our test file, so we can use ECMAScript 2015 features. In particular, we're going to use ECMAScript modules instead of the require statement at the top. It's worth noting that passing arrow functions to Mocha is discouraged because the lexical binding of the this value inside of an arrow function makes them unable to access the Mocha context, so statements like this. timeout will not work inside an arrow function, so a little gotcha you might want to be aware of, but I still want to use other ECMAScript 2015 features in my Mocha tests, in particular, ECMAScript modules, so let's get that working. If we change this require statement up at the top to an import, and we import the entire chai library, we then still need to invoke the should function to augment the prototypes of objects, so that they have the should function available off of them. For example, indexOf has should directly off of it in this case. You'll notice we're also using the ECMAScript 2015 feature of the const keyword. If we save this file, and try to run our Mocha tests we'll get a failure on the import statement, as we'd expect. Let's look at how we get this working. We need to npm install a couple things. We want to save them both as dev dependencies. I'll open our package. json, so we can see them inserted. We need the babel-register, so anytime that we require a library, as long as it's not an npm module, it will get run through the Babel transpiler. We'll also need babel-core because in this project, if you remember, we don't even have Babel installed yet, so we'll need babel-core as well, and lastly, you'll remember from our first lessons that Babel won't do anything to your source code without a plugin or a preset. Let's grab a whole bunch of plugins with the preset for ES 2015. Let's install all that, and we can see those new dependencies have been added to our package. json. We'll need to add a Babel configuration file, remember that's. babelrc, and we'll paste in an object with a key of presets that points to our ES 2015 preset, so that Babel knows to use those plugins to transpile our code. The last thing we'll need to do is go into our package. json and add an npm script to run our tests, we'll call it test. We'll call Mocha, but we also need to tell it to use the Babel compiler. We do that by saying --compilers, and then js: for the Javascript compiler, and then send it babel-register. Again, babel-register is known as Babel's require hook because it hooks into any CommonJS require statement. In this case, our import statements here will become require statements, and sends the code to the Babel transpiler, so now if I run our test, npm test, our test is passing using the ECMAScript 2015 syntax, including ECMAScript modules, and the const keyword.

Summary
In this module we looked at how you can use Babel to compile your NodeJS code, as well as your unit tests. We saw several ways to have Babel compile your NodeJS code, and learned that the cli is best for production use. We also discussed the Babel runtime as an alternative to using a polyfill, and demonstrated how to setup and configure it. Finally, we looked at how the require hook can be used by Jasmine and Mocha to compile your test files on the fly with Babel.

Conclusion
JQuery's popularity can be attributed to it enabling developers to safely use Javascript in all browsers. I'm excited about Babel because it enables developers to use new Javascript language features across all browsers. Thanks for watching this course on Babel. I'm Craig McKeachie.
