A general solution to building and deploying code managed in GitHub can be tough, especially when multiple technology stacks are involved. In this course, Getting Started with CircleCI, you will learn the basics of creating CI and CD pipelines using two of the most popular DevOps tools in the market. First, you will learn how to automatically build your projects in response to code changes. Next, you will discover how to incorporate CircleCI into the GitHub pull request workflow. Finally, you will explore how to build intricate, powerful CD pipelines. When you're finished with this course, you will have the skills to start building your own CI and CD processes with CircleCI and GitHub.

Course Overview
Course Overview
Hi everyone, my name is Floyd May. Welcome to my course, Getting Started with CircleCI and GitHub. I'm a software crafter with almost 20 years of experience architecting and building software systems in a wide variety of industries and technology stacks. I use both CircleCI and GitHub daily, and I'm very excited to share my experience and knowledge with you. Both CircleCI and GitHub are among the most popular DevOps tools available in the market. They complement each other very well. In this course, we'll help you integrate them in a way that supercharges your teams' ability to deliver high quality software. In this course, we are going to cover the basics of CircleCI and how it integrates with GitHub. Some of the major topics that we'll cover include automatically triggering CircleCI builds from source code changes in GitHub, incorporating CircleCI builds into the GitHub pull request workflow, and designing complex CD pipelines with parallel jobs and manual approvals. By the end of this course, you'll be ready to use CircleCI and GitHub to automate your own CI and CD processes. Before beginning this course, you should be familiar with managing source code in Git and GitHub, have a reasonable understanding of editing YAML files, and have a clear understanding of the command line utilities that you would use to automate builds and deploys for your own particular technology stack. I hope you'll join me on this journey to learn CI and CD with CircleCI and GitHub with the Getting Started with CircleCI and GitHub course here at Pluralsight.

Creating Your First Build with CircleCI
Introduction and Tools
Hi, this is Floyd May with Pluralsight, and this course is Getting Started with CircleCI and GitHub. In this module, I'll guide you through using CircleCI to set up an automated build that facilitates a simple continuous integration workflow. CircleCI is a Software as a Service provider for automated builds. It integrates directly with GitHub and works very nicely with the features that GitHub provides for team collaboration and software development workflow. It has a free tier for open source projects, and a paid subscription-based model for closed source projects and for larger open source projects that require more computing horsepower. It supports building any technology stack whose build tools can run in a Docker container from a command line, which means you can support almost any programming language you'd need using CircleCI. The tools that we'll be using in this course, other than CircleCI of course, are Git. We'll be using the Git command line interface to create commits, push commits to a remote repository, make branches, and make tags. GitHub, we'll be hosting the Git repository we're using in GitHub. We'll also be navigating through GitHub's UI quite a bit, as well as some significant use of GitHub's pull request features. YAML files. CircleCI's configuration is specified using YAML syntax, and so some familiarity with YAML will be helpful. And the command line. You'll need to have a clear sense of the commands that you need to use to build, test, and deploy any project that you'd be interested in using CircleCI to automate. In the case of this course, I'll be using Node.js, but I'll also call out those places where you'd replace Node.js commands with commands that are appropriate for your own tooling, whether it be Ruby, Java, Python, Go, .NET, and so on. If you've got a solid grasp of each of these things, then this course is for you and we're ready to get started.

Using Git Push to Trigger Builds
What we're going to do is use CircleCI to set up a continuous integration build in a trunk-based development workflow, which is to say that developers will push new commits directly to a single trunk branch. Usually this will be the master branch when using Git source control, indicated here in blue. Then each commit will trigger a new build. Those builds will let us know if each commit passed all of the tests. A key element of this kind of workflow is that a failing test needs to cause a build failure. Let's go see how this is done using CircleCI. For this next demo segment, we'll be going back and forth between the CircleCI web dashboard, our editor/IDE, in my case Visual Studio Code, and the command line, in this case we're using PowerShell. Here we are ate the CircleCI home page at circleci.com. we're going to choose to sign up for CircleCI. We're now presented with a choice to sign up with either GitHub or BitBucket. In our case, we want GitHub. Now we can see that CircleCI has delegated authentication and authorization over to GitHub. Hooray for not having another username and password to manage. And now we're brought to the CircleCI dashboard. How your dashboard looks may be a little different than what's shown here. In this case, we don't have any projects listed, so I'm going to select Add projects. Here, I have this project called circleci-intro. I'm going to select Set Up Project. When I choose this project, it gives me a number of choices. We'll choose Linux, we'll select the language of Node. In this particular case, CircleCI has automatically detected what language is being used in my repository. Choose the right language for your technology stack at this step, and then next you have instructions for what to do. The choices we made above helped CircleCI create a sample config.yml file. These instructions guide us to create a folder called circleci at the root of our repository, and put this config.yml inside of it with the contents of the file that it's generated for us. Let's go do that real quick. We'll create a new folder here, create a new file inside of this folder, and paste in the contents. In addition, let's take a closer look at this file. Here the restore_cache and save_cache bits are optimizations that CircleCI has put into the file for us. In our case, we're using Node, and so what this does is it speeds up later builds so that it doesn't have to re-download every NPM package. This would be similar in a .NET stack if you were downloading packages from NuGet, or in a Java stack downloading packages from Maven, RubyGems for a Ruby project, and so on. Next, let's look at this run directive here on line 29. I'm not using Yarn, I'm using NPM, so I'm going to change this to npm install. Again, this is going to vary based on your technology stack. And then again on line 37, npm test, and then also, what I'm going to do is I'm going to add an additional task to just say Hello Pluralsight. Now here at the command line it's going to add this new file, .circleci / config.yml. Let's make a commit. Notice the commit message is initial commit of config.yml, and then let's pus that up. Now let's head back over to CircleCI's web UI and see what happened. Here under jobs we can see that a build has succeeded, and if you notice, here's our commit message, initial commit of config.yml, the one we just created. By pushing to the GitHub repository, we triggered a build. If we click this build, we can see the command line output of the build. If the build were still ongoing, we could see the command line output in real time as the build is executing. Here npm install, here npm test, and then here echo Hello Pluralsight. There's the output for each of the commands. Notice the passing test. And then, going back to Jobs, you notice the indicator here, a green checkmark and success. If the build is ongoing, you'll see blue here. For failing builds, let's go see how that works. Let's trigger another build, but this time we want the build to fail. Here we are back in our editor, in this case Visual Studio Code. What I'm going to do is add another test that I expect to fail. In this case, 1 shouldn't equal 2. This should fail. Let's go make a commit and push up that commit. Again, note the commit message, intentionally failing test. And now let's head back to the CircleCI dashboard. Here we see the build for that most recent commit executing. Again, all we had to do to trigger a build was to push up a new commit to GitHub. Now, if we select this new build while it's running, we can see the output from that build in real time, and we can also see, eventually, that this build will fail. Notice the failure here, notice the red indicator. If we go back to the Jobs overview, we can see that this build has failed. Also, if we go back into this build, you'll notice everything ended at npm test. The Hello Pluralsight command that follows the npm test command in our config.yml, never executed. This is intentional behavior of CircleCI. It does not execute later steps in a particular build if earlier steps fail. Now let's see one more element of how CircleCI runs, or doesn't run builds, when you push up commits. Let's head back to Visual Studio Code. Here I'm going to get rid of that intentionally failing test, and then head back to the command line. Notice in square brackets I'm putting this text, skip ci. Now I push up that commit. Now let's head back to the CircleCI dashboard. We see the commit, but it's shown in gray and isn't being built. So now let's talk about what we've just seen. We simply followed CircleCI's onboarding instructions, and were able to easily set up a trunk-based CI workflow. As we pushed commits to our repository and GitHub, CircleCI built our project at each commit. We saw the use of skip ci to prevent CircleCI from automatically building a specific commit, we saw a passing build, and we also saw a failing build. At this point, I'd like to take a moment to discuss a best practice with continuous integration. Always make sure that your builds can fail. The purpose of a CI build is to sound an alarm, that is a build failure when a bad code change gets committed. Here are some key reasons why build failures boost the productivity of your software development workflow. First, a timely build failure means that the code changes that caused the failure are still fresh in the author's mind. It's much harder to fix a problem after you've been away from the office for a weekend, or you haven't worked on this particular project in a couple weeks. We want to know as soon as possible, so that it's easiest to fix. Next, false negatives in build statuses, that is builds that say everything is okay when it's not, cause waste to accumulate. If a bad code change gets introduced and no build failure occurs, we get a false pass shown here by the mask icon, and then further development is done based on the faulty code in that change. Then it puts those subsequent changes at risk. That further development has the potential to be wasted effort, because it was based on faulty code. And third, false negatives from CI builds can harm morale. It can be quite frustrating to discover that a bug was introduced weeks ago, that it could have been caught easily by a CI build, but that the build was somehow misconfigured. So, again, it's essential that your CI builds can fail. Build failures are an essential component of getting the most value out of your continuous integration workflow.

Tour of the CircleCI Dashboard
Now that we've worked through setting up a continuous integration build with CircleCI, let's take a tour of the CircleCI user interface. Here in the upper left is the account picker. In GitHub, you can have your own personal account, like mine shown here, but you can also be a member of any number of organizations. For instance, the GitHub organization for my employer is here. If I were a committer for a popular open source project, the GitHub organization for that project would appear here as well. I could select it and use the UI to interact with CircleCI builds for that organization. On the left-hand side of the screen is the main menu. Here the default view is jobs. We'll also take a look at the workflow tab in later modules. We'll also take a look at the Settings here in a little while. For now, in the jobs view, we can see the build jobs that we've already completed here in the middle section. This pane here shows for each repository in my account the branches and tags that are currently eligible for builds. This section here also becomes really important as you use CircleCI automation with more than one repository. It's also important to remember this little gear icon in the middle pane. This gives you access to the CircleCI settings that are specific to each of your repositories. This is different than this tab on the left, which allows you to access organization-wide or account-wide settings. Here in the upper right section of the UI you see the status gauge. Just in the past few months, CircleCI added this indicator to make it easy to see at a glance whether or not CircleCI and all of the various cloud-based providers that it integrates with are working correctly. It's important to understand that with CircleCI their build servers are hosted on Amazon Web Services, and so if AWS is having issues, then that might mean that CircleCI is also having issues. In addition to that, GitHub may also have degraded service or other issues, and that can affect CircleCI. In addition to CircleCI's servers that live on AWS and GitHub itself, there are over a dozen other cloud providers that CircleCI integrates with, whose outages may cause problems when using CircleCI. When you click the status gauge, it shows you a detailed status indicator. If you click it, it will take you to CircleCI's status page, which shows you a detailed report showing the status and history of each integration with CircleCI's various cloud providers. Before we finish up the tour of the CircleCI UI, it would be remiss of me to leave out CircleCI's excellent documentation. If we head back to the CircleCI dashboard, you can navigate to the documentation from the support menu. In particular, I want to call your attention to the Configuration Reference here. CircleCI supports some powerful features that are all configured via the config.yml file, and so this reference is very useful as you're configuring your own CI and CD automation.

Build Limits
Let's take a look at CircleCI's pricing model. As we've already seen, a push to GitHub can trigger a build. Those builds are executed in containers, specifically, Docker containers. Each organization or individual user account only has a certain number of containers available. If we ask CircleCI to execute more jobs than we have containers to execute them, the later jobs will be queued, and won't be executed until earlier jobs complete and free up containers that are in use. Let's go see how this works in practice. Here I've pushed up a number of commits in Rapid Fire, and as you can see we have some of the jobs for those commits building shown in blue, and some of those jobs are queued, shown in purple, waiting for the earlier jobs to finish. In this case, all of these jobs pertain to a single repository, but the containers are, in general, shared across all repositories for the same GitHub organization. With that, let's go look at the organization settings. This is where you can configure the paid options if you're using a paid tier for CircleCI. In the case of this course, we're using a public repository, and so we're eligible for CircleCI's free tier, which gives us up to four containers. For private repositories or for public repositories with high volume development, you can pay a monthly fee to reserve a certain number of containers, which controls the number of concurrent build jobs you can run across all the repositories in an organization. This is CircleCI's pricing model. You pay for a certain number of containers. In determining how many CircleCI containers you might need, which also means how much you might need to spend on CircleCI, I recommend a trial-and-error approach. CircleCI says that they have an average of 2-3 containers per full-time developer across all the organizations that they serve. Some of the factors that weigh in to how many containers you might need include the developer count. More developers working independently will probably need more containers than fewer developers. Build times. longer build times means more time waiting for a container to free up. And, build complexity. Some build processes may have many jobs that need to be run for a single commit. More complexity might necessitate more containers. As I mentioned earlier, much of the value of a continuous integration workflow is shortening the feedback loop so that developers can catch problems as early as possible. CircleCI has a tool that can help you understand the length of that feedback loop, and the impact that container count has. Let's go back to the CircleCI dashboard. If you select Insights on the left menu, you'll see a chart that illustrates job times and the length of time that jobs were queued. Significant queue time means that you can shorten the feedback loop by purchasing more containers. CircleCI places limits on jobs to prevent unbounded resource usage from creating infinite wait times or potentially destabilizing CircleCI's infrastructure. We'll take a look at each of these limits one at a time. First, CircleCI times out builds that haven't produced output in 10 minutes. This is rarely an issue for valid builds, but it can stop a hung process from monopolizing a container indefinitely. Let's see what this looks like. Here inside of config.yml, I'm going to add a command that just sleeps for 11 minutes. This is just the Unix sleep command. I'm using 11m to designate 11 minutes. Now when we take a look at the build output we can see that we're stopped here at this sleep command. After 10 minutes have elapsed, CircleCI kills the build and marks it failed. Here we can see the log revealing that we went too long without output. CircleCI also limits build containers to 4GB, and will kill builds whose memory utilization exceeds that. To demonstrate this, I've put together a simple program to do unbounded memory allocations. Let's look at the build failure from exceeding that 4GB memory limit. Here we see in the logs that our process received a killed signal. This is probably going to be the only clue that you'll get from a build failure where you exceed the memory utilization limit. Sometimes a build needs longer than 10 minutes, however, long build times can lengthen the feedback loop we talked about earlier and monopolize containers. CircleCI places a 4-hour timeout on all jobs. Obviously this timeout won't come into play for a hung process that produces no log output, as we just saw, so we'll need something a little more sophisticated to show this happening. In addition, we'll see how to cancel and restart builds. Here in the CircleCI dashboard, we can see this build running. Let's go take a look at the real-time log output. Here we can see the infinite loop that I've put together that will keep this build producing log output every 30 seconds, however, it won't ever stop. This should trigger our 4-hour build timeout. If ever you're in a position where you know a build won't finish in a reasonable amount of time, you can always use the Cancel Job button near the top of the screen. Let's cancel this job. Notice it shows us that the build was cancelled. We can also see back at the dashboard that the build was cancelled. If we go back into this build, we can use the Rebuild button to start a new build job at the same commit. So here we are back in our real-time log output. We know this build won't finish, and it will just run in an infinite loop, but rather than making you wait 4 hours to see this happen, suffice it to say, your build will fail at that 4-hour mark.

Leveraging CircleCI in the GitHub Pull Request Workflow
Status Checks and Badges
Hi, this is Floyd May with Pluralsight, and we're going to be talking about leveraging CircleCI in the GitHub pull request workflow. In order to understand how CircleCI and GitHub's pull request workflow fit together, it's important to start with an understanding of GitHub's status checks. GitHub provides a facility for third-party integrators like CircleCI to specify the status of a commit. GitHub calls this a status check. GitHub maintains the data associated with each commit per each integrator so that we can look back at each commit and see whether or not they passed, failed, or are still pending with respect to each integrator, like CircleCI, that provides a status check. GitHub status checks retain pass, fail, or pending status information for each commit. Status checks also retain integrator-specific information like the link to the CircleCI build job that is associated with the commit. In addition, it's common to put status badges onto public repositories, so that it's easy to see whether the build for the latest commit is passing or failing. It's common to see status badges in a project's readme file. In this next demo, we'll take a look at where to find status checks in the GitHub UI, and we'll see how to incorporate a CircleCI status badge into a public repository's readme file. Here we are at the home page of our GitHub repository. If you select the commits tab, you can see a list of the commits in reverse chronological order, newer commits at the top. Many of these commits have status indicators, checkmarks, x's, and this yellow circle. If you click these indicators, you can get more information, including a link to the CircleCI job. The indicator shows whether the most recent status check for that commit passed, failed, or is still pending like this one. If you rerun a job on CircleCI that fails, say, because a package repository was down, CircleCI will update these status checks on GitHub with the most recent build. If we go back to the home page of our repository, we can see that GitHub automatically displays the README file rendered into HTML. If we were to go to a popular repository, like, say, React, we can see a number of status badges. In this case, React uses CircleCI, and the build for the most recent commit on the master branch for the React repository is passing. Let's add a status badge like this one to our repository. Here we are back at the CircleCI dashboard. If you remember, I cautioned you to be careful to understand the difference for the account or organization-wide settings here and the _____ repository settings here. In this case, because we want a status badge that's specific to a repository, we'll go to the repository settings. Notice in the menu in the repository settings we can see Status Badges. This section here shows us the markdown code that we would need to embed into our README file in order to display a status badge like this one. Let's go back to the repository in GitHub and edit the README file to put this badge into its markdown code. Here I'm editing the file. I'm just pasting in what I copied from CircleCI. We can use the preview to see what the badge looks like. We'll add a commit message, and push that commit. Now we have a status badge in our README. Next I'll push up a commit that intentionally fails so that we can see what that status badge looks like when we have a failing build. Now I've refreshed the page after pushing up a commit that fails. Notice the status badge shows failed now.

CircleCI and the GitHub Pull Request Workflow
Now let's talk about pull requests. A pull request is some branch that has forked off from another, and then we want to merge it back in. GitHub has some fantastic collaboration tools around pull requests, and CircleCI fits right into the GitHub pull request workflow. In particular, CircleCI's integration with GitHub status checks creates a tight integration where CircleCI builds fit into the pull request workflow, making it easy to understand whether your builds pass before merging a pull request. Let's talk about some of the details of how status checks and pull requests fit together. First, status checks are associated with commits, we've seen this just a moment ago, and commits are commits regardless of whether they're associated with a pull request or not. We've already seen how CircleCI represents build statuses in GitHub with status checks, and so there is no additional work to be done to integrate CircleCI into the pull request workflow, since it's already driven by status checks on commits. Second, CircleCI automatically starts a build per push, not per commit. It would be unfortunate and wasteful if you pushed three new commits to GitHub, and then you had to wait for builds for all three of those commits to finish. CircleCI only builds the latest commit for a branch or tag if more than one commit is pushed at a time to GitHub. And third, GitHub status checks are integrated into the GitHub pull request UI so it's easy to make decisions about whether to merge a pull request or not that are informed by whether or not your CircleCI build jobs are passing or failing. Let's go take a look at this in action. Here I am at the command line, and I've created this branch entitled example-pull-request. If you notice, it has two commits on it since master, and I'm going to go ahead and push this branch up to GitHub. And now I'll go ahead and create a pull request for this branch. Once I've created the pull request, we can see that the build is still pending. If we wait a moment, we'll see that the build passes. Here we can see that the build has passed. If we select Show all checks and then use the Details button, we can go and see the build logs for the specific build that pertains to this pull request. Let's go back to the CircleCI dashboard for this repository. Now, notice we see both the master and the example-pull-request branches in this left pane. If we click the example-pull-request branch, it filters this right pane just to those builds that pertain to that branch. If you remember, I pushed up two commits that pertain to this branch. Let's go back and look at those commits in the command line. We can see these two commits here that are ahead of master, but we only see builds for the second one with the commit message of update readme. That's because CircleCI only builds the latest commit for a given branch. If you push up more than one commit, only the latest one gets built. While we're talking about only building when necessary, let's take a look at something else in CircleCI. You can configure CircleCI to only build commits that pertain to pull requests so that work-in-progress commits that aren't part of a pull request don't consume containers and interfere with other team members being able to run builds. Sometimes it can be helpful to push work in progress up to GitHub before it's ready to be reviewed, built, and merged. Let's take a look at how to control whether CircleCI builds commits that aren't associated with pull requests. Here in CircleCI in the repository settings, under Advanced Settings, we see this setting called Only build pull requests, and this controls whether or not to build every latest commit for every branch that gets pushed, which is the default, or to only build commits associated with pull requests. If we turn this on, CircleCI won't build commits on branches, unless those branches are associated with pull requests. Let's turn that on, and now let's go back to the dashboard. Notice here I've pushed up another branch called irrelevant-branch. Notice in gray that it says NOT RUN. CircleCI is telling us that it won't run the build for this branch. That's because of the setting that we just changed. Let's go back and change that setting again and then we'll push up another commit to this branch. Now, after pushing up another commit to this branch, it's being built even though I haven't opened a pull request for this branch. So, again, the only build pull request setting in CircleCI controls whether or not to build branches based on whether or not they're associated with pull requests. If you set it to "on", CircleCI will only build branches that are associated with pull requests. If you set it to "off", CircleCI will build every branch you push, regardless of their association with a PR. Let's talk about another scenario. Let's say we have a pull request where the build is passing and we're potentially ready to merge, but we receive code review feedback. In response to this feedback, we have additional commits that we'd like to push to that pull request. Then, when the build passes, the pull request can be merged. When this happens, regardless of how the Only build pull request setting is set, the additional commit will also be built automatically by CircleCI. Let's go see this in action. Here I've pushed up a branch and opened a pull request for that branch. Let's go look at the changes, and let's add some code review comments. (Typing) Now we can see in the Conversation view here these comments in the context of the code that they pertain to. In addition, if you notice, prior to the code review comments we can see the commit that I pushed up, and we can see the status check for that commit. Now I'll go push a couple of more commits to address these two code review items. Now, if you notice, I pushed up two commits. Only one of those commits has a status check on it. Again, CircleCI only builds the latest commit for a given branch. It would be a waste if we had to wait for a build for this earlier commit to finish before we could see the build for a later commit. Now, CircleCI is indicating to us that this commit has passed its status check, and all of the checks have passed, meaning we're ready to merge this pull request. This brings us to our next topic. GitHub has the concept of a protected branch. You can configure policies on protected branches so that the branch can only receive new commits via pull request. You can also configure these policies such that the pull request's status checks must all pass. In our case, those status checks are being set by CircleCI job execution. In other words, you can configure branch protection policies in GitHub such that you can only add commits to a branch via pull request, and only if the status checks pass. In addition, you can also do things like require a code reviewer. Let's see how this works in practice. Here in the GitHub UI, I'm going to navigate to the Repository Settings. In the GitHub Repository Settings under Branches, we can configure branch protection rules. I'll add a rule. We want to protect the master branch. In this case, we want to require a status check to pass before merging, specifically, the CircleCI status check. Notice that GitHub shows us the kinds of status checks that it's seen in the last week, and then we'll finish creating the rule. Now that I've created this rule, let's go take a look at a pull request. In this case, we have a failing build, and here GitHub is telling us that required statuses must pass before merging. I'm not allowed to merge this pull request because it fails the policy, however, because I'm also an administrator of this repository I can override the policy here. Probably not a great idea to do that, but it is an option if you need it. Let's see how this looks when I push up another commit to this pull request so that it passes the policy. Here we can see the next commit with the passing status check, and now this is lit up green indicating everything is ready to go, this branch is ready to be merged. Using policies on protected branches can be very helpful for safeguarding the quality of your code and preventing bad code from accidentally getting merged. One of the benefits of storing the configuration details for CircleCI build jobs in your repository is that it allows you to have diverging build definitions, that is, the contents of config.yml could be different between two different branches. This brings a few advantages. First, having the build configuration as a part of your source code means that changes to the build configuration are stored in the repository so that you can see the changes over time. Those changes also go through the same processes as the rest of your source code, like, say, code review. Second, this gives you an opportunity to experiment with build configuration changes in isolation so that you can see how changes will behave without jeopardizing the stability of your master branch. And third, having the build config as a part of the repository makes it clearer when code structure changes require build configuration changes. Those changes to code and configuration usually occur in the same group of commits. In some cases, the very same commit. Let's go see how this works. Here we still have much of the automatically generated contents of config.yml from the previous module. First, I'm going to clean up some of these comments, and then I'm going to add a new build step. This step is just going to echo additional build step, but it helps us understand that this is a change to how the build is executed but it only applies to this new branch that I'm creating. Now let's call this new branch build-change-experiment and push it up. Here I'll make a new pull request from this branch, and then from the pull request UI I'll go take a look at the build log in CircleCI. Notice here's our new step in the build. Now, let's go over to the master branch, to the latest commit, and let's manually re-trigger a build. Notice here in this manually triggered build on the master branch the experimental change isn't present. However, here on our build-change-experiment branch, the new build step is present. One of the beauties of this technique is that if this additional build step required a few cycles of trial and error to get it working correctly, it wouldn't affect other developers' activities. I'm safe to experiment and try new things in isolation, until it's ready to merge. Now let's go back to GitHub and merge the pull request. Now, let's go take a look at the build on the master branch after merging that pull request. The new build step that we added as a part of the pull request, now that it's merged into master is present on builds in the master branch. Again, using the pull request workflow can be very useful in experimenting with build configuration changes in a safe way.

Review
Let's go back over what we've seen in this module. First, we've talked about what GitHub status checks are, in that they are pass/fail indicators that link to integrated providers like CircleCI to show details of each check. We also saw how we can add a status badge to easily visualize the build status of our repository in our readme file. We saw how CircleCI only builds the latest commit per push, rather than building each and every commit. CircleCI does this to prevent wasted time to keep the developer's continuous integration feedback loop as short as possible. And finally, we took a detailed look at how CircleCI fits into the GitHub pull request workflow. We see how the status checks fit into the pull request UI, and make it easy to navigate to CircleCI from a pull request. We saw how we can configure CircleCI to skip building branches that aren't associated with pull requests. We saw how CircleCI continues to build commits that are pushed to a pull request's branch, for instance, in response to code review. We saw how to apply policy enforcement to prevent merging pull requests whose builds don't pass. And finally, we saw how to leverage diverging changes in config.yml to experiment with changing configuration without destabilizing the master branch.

Creating a Continuous Delivery Pipeline with CircleCI
Introduction to Workflows
Hi, this is Floyd May with Pluralsight, and we're going to be talking about creating a continuous delivery pipeline with CircleCI. Up to this point, we've focused primarily on the touch points between CircleCI and GitHub, but in this module we're going to explore some more powerful features of CircleCI itself that enable robust versatile CI and CD pipelines. The essence of continuous deployment, or CD, is to have a well-automated process from getting the work done at the keyboard of a software developer to production usage, that is in use by actual end users in a reliable, repeatable way, and to use that automation as a tool to prevent problems from making it all the way to production. However, the kinds of process steps in getting from keyboard to production vary widely, as does the complexity of those processes. Some projects and organizations can handle a very simple process, and some organizations need more flexibility and robustness. Here CircleCI really shines, in that you have an excellent amount of control and flexibility in managing your CI and CD pipelines. Again, I'm going to remind you about CircleCI's documentation, which is an excellent resource as you work through building your own CI and CD pipelines. In the previous modules, we've seen how a job definition in config.yml controls how jobs are executed in CircleCI. A single job definition can be executed many times as new commits are pushed to the repository. We've also seen how a job can have multiple steps that are executed in sequence. Now we're going to explore a feature of CircleCI called workflows. A workflow definition specifies the relationship between different job definitions. A workflow is comprised of one or more jobs, and the way that those job's executions are ordered. Jobs can be ordered in series, or can fork and enable parallel execution of multiple jobs in the same workflow.

Configuring Serial Workflow Jobs
The simplest relationship in a workflow is one of simply executing jobs serially, one after the other. Typical scenarios for this might include build and test. It's common to execute a build as a single job, and then execute tests on the output of the build, build-test and deploy. It's also common to combine build and test into a single step, and then do a deploy when the build-test job finishes, and build, test, and deploy. Of course, it's also really common to see three jobs execute in serial for build, test, and deploy. Let's go see how to configure workflows for executing jobs in order. Here I've stripped down the config.yml to just a single job with a single build step. Now let's add another job entitled test, and add a build step to it. Here in the build and test jobs, these commands are whatever is appropriate for your particular technology stack. I'm just using echo commands here as placeholders, but fill in whatever makes sense for your technology stack, whether it be JavaScript, Ruby, Python, .NET, Java, and so on. Next, let's add a workflow section, and then we'll name our workflow build-and-test. Under this workflow, we'll define the relationship between these two jobs. The way we do that is by specifying a dependency relationship. The test job requires the build job. The test job won't run unless the build job succeeds. First, let's see how this works when the build job fails. I'll force the build job to fail by exiting with a non-zero exit code, and then we'll push this up. Here we see that the build job has failed. If you see here, this says build-and-test. This is the name of the workflow that we just created. If we click this, we are taken to the workflow page for the commit that triggered the build. Here we see that the build has failed, but we can also see that this test job is present, but of course it hasn't run yet because the build job failed. Let's see how this works when the build job succeeds. I've updated config.yml to remove the intentional failure and pushed up a new commit. Here we see that when the build job succeeds, the test job has run afterwards. If we take a look at the workflow page, we can see the build job and the test job in series. Let's add another job to our configuration. Back at config.yml, let's make another job and we'll call it deploy. Naturally, we wouldn't want to deploy if the tests don't pass, so we'll say that the deploy job requires the test job. Let's push this up to CircleCI. Back in the CircleCI dashboard, we can navigate to the workflow and see the series of jobs we've defined. The test job didn't run until the build job passed, and the deploy job didn't run until the test job had passed. We also see this nice graphical representation of these jobs in the workflow page that show us how these jobs execute in serial.

Configuring Parallel Workflow Jobs
CircleCI also supports running builds in parallel. Depending on the number of containers available, CircleCI will run builds in parallel based on how you specify the dependency relationships in config.yml. In this next example, let's say we've got an app that has a frontend and a backend. Maybe these are even different technology stacks. We'll configure a couple of build jobs called build-frontend and build-backend. Since these are at the beginning of the workflow and have no dependencies, they're candidates for running in parallel. Next, let's say we want to test each component in isolation, but we also have some integration tests that require both of them. Then, once all these tests pass, we can deploy. Here we are back at config.yml. Let's set up our jobs, then we can configure the relationships. Here's build-frontend and build-backend, here's test-frontend and test-backend, here's the integration-tests job, and then we can keep our deploy job. Now, in the workflow, let's set up the relationships. The frontend and backend have no dependencies, but the test-frontend and test-backend jobs both require their respective builds. Next, the integration-tests require both the frontend and the backend builds to be complete. Finally, the deploy job requires all three test jobs. Now let's push this up. Here in CircleCI, we can see the graphical representation of the workflow we just configured, and we can see how, over time, CircleCI takes advantage of the opportunity for parallelism in this workflow configuration. We saw both the build-frontend and build-backend jobs executing in parallel, we saw the test-frontend, integration-tests, and test-backend all work in parallel, and we didn't see the deploy job begin until after all three test jobs had completed. You more astute learners might have already picked this up, but in case not, the relationships between jobs in CircleCI workflows form a DAG, that is a directed acyclic graph. The acyclic portion of that means that cycles aren't allowed. If, for instance, we defined a workflow like this where we have a cycle, then it would be a workflow that wouldn't ever finish. It would go from build to test to deploy, then back to build, to test, and then deploy, over and over and over again. This is probably not what we want, so CircleCI will prevent this from happening. Let's go see how this works. Here I've defined a configuration that has three jobs, build, test, and deploy, and the workflow here defines them in a cycle. Let's push this up, and go take a look at the CircleCI UI. If you notice, CircleCI tells us that it's encountered a build error. When this happens, you can see that it shows you a config processing error. In this case, the error message is rather cryptic, but we can go back and examine our config.yml and find the cycle. If we remove the erroneous cyclic dependency, we can see that CircleCI has parsed our configuration and correctly interpreted it as a series of jobs. We've just seen how to configure the relationships between CircleCI jobs in a workflow. We've seen jobs that execute serially, that is one after another, we've also seen how to configure jobs to run in parallel. We've also seen that the relationship between jobs in a workflow is a DAG, a directed acyclic graph. We saw how CircleCI validates that we can't have workflows with cycles in them, which would create an infinite loop of jobs that trigger other jobs.

Sharing Files Between Jobs with Workspaces
When arranging jobs in workflows, like, say, a build, test, and deploy workflow, it's common to need build artifacts from earlier jobs in later jobs. For instance, the build step is likely to produce some sort of compiled output. It would be wasteful to repeat the steps in the build job in the test job so that we can have the build output to run the tests against. Then, in the deploy job it would also be wasteful to rerun the build steps yet again so that we'd have the build outputs available to deploy to a server. CircleCI provides something called a workspace for each workflow run, so that a job can store files in the workspace for later jobs to use. In the case of our build, test, and deploy workflow, the build job would store build artifacts into the workspace, and then the test and deploy jobs can simply read those files from the workspace rather than wastefully rebuilding them. Let's go see this in action. Here we are at config.yml. Here in our build job we'll create a folder called build_output, and then we'll create a file in that folder called compiled_output.txt. Next we'll use this CircleCI directive called persist_to_workspace. This will persist the contents of the build_output directory, which we'll specify here as root, and then we'll use star for one of the paths to indicate that we want to persist all the files in the directory into the workspace. Next, for the test and deploy jobs we'll use the attach_workspace directive, and we'll attach the workspace at home /repo/workspace. Then we'll use the ls command in the test and deploy jobs to verify the presence of compiled_output.txt in each job. If the file isn't present, the ls command will return a non-zero exit code, which will cause our builds to fail. Let's push this up. Here in the CircleCI UI, we can see that each of our jobs have passed in this workflow. If we go take a closer look at the test job, for instance, we can see that the ls command completed successfully, indicating that the file is present. It's also important to understand that CircleCI creates a new workflow, and by extension a new workspace with every commit. For instance, let's say we have two separate commits on the new feature branch that have been pushed independently. For each push, CircleCI will run a different independent workflow with its own build, test, and deploy jobs. Each workflow will also have its own workspace. In addition, let's say we have another commit pushed to the master branch. For these three commits, each commit has its own independent workflow and its own workspace. That means you can use the workspace feature without worrying about cross talk between commits or branches. We just saw how to use workspaces in CircleCI. Workspaces allow you to store files so that later jobs can read those files. Workspaces are isolated to each workflow, which corresponds to a single commit.

Filtering Jobs by Branch and Tag
In cases where you're using a workflow that has something like, say, a deploy step in it, like this one, typically you wouldn't want to deploy the code from anywhere but the master branch, that is, we only want to deploy code that has passed the pull request process. On other-branches, we don't want that deploy job to run. CircleCI supports controlling which jobs in a workflow run based on which branch they're on. That way, in this workflow here we can disable the deploy step everywhere but the master branch. This also plays into how workflows are specified, such that we can disable entire chains of workflow jobs by disabling a single job based on branches. For instance, let's say we have a more complex workflow like this one here, where we build a deploy package first, and then we have a separate job that executes that deploy. By disabling the prepare-package job, we disable the deploy job by extension. Let's go see how this works. Here we are at config.yml. As you can see, I've updated the workflow definition to add a filter to the deploy job. Here this filter specifies that we only want the deploy job to run on the master branch. Let's push this up, and let's see how it behaves on both the master branch and on a different branch. Here we are in the master branch. We can see all three of the jobs in our workflow have run. Now let's go take a look at another branch. In this case, on other-branch we only see two jobs. The deploy job has been filtered out. Now, let's go in the opposite direction. Let's make a job that only runs on branches that are not master. Here we are back at config.yml. In this case, we're going to make a test-environment job, and this is to represent maybe a manual testing environment that we might want to use as a part of the pull request process to do some exploratory testing. Here we'll add this job to our workflow, we'll indicate that it requires test, and then we'll specify the filter so that it ignores the master branch. Now let's go take a look at this in CircleCI. Here we are on the master branch, and as you can see, the test-environment job isn't present, but if we go to our other-branch we can see the test-environment job has run on other-branch. There is another facet to job filtering, and that's using Git tags. Let's say we use a naming scheme for tags like this, where we have a v followed by three dot-separated numbers which represent a version number. Let's say we're building a package intended to go to a package repository like NPM or RubyGems, and when we create or update a tag using this naming convention, we want CircleCI to publish a new version of our software. However, we only want this to turn for tags, and never for pull requests or for the master branch. Let's see how this works. Here we are back at config.yml. Here I've specified a new job called publish-package. Now what I'm going to do is define a new workflow. In this case, we're going to call it publish. The only job we want to run under publish is the publish-package job, and then we want to specify some filters. In this particular case, we only want to run this job on tags that match the given regular expression, but there's also another step that we need to perform here, and I'll show you why. Let's push this up to CircleCI. After pushing this up to CircleCI, here we are on the master branch, and the publish-package job has run. The mistake that we made was that we only opted into tags, but we didn't opt out of the default behavior, which is to build on every branch. Let's go fix that. Here I've added an additional branch filter that ignores all branches. Now when I push this up, this next change shouldn't build in CircleCI. Here we can see since that erroneous run of the publish workflow, the publish workflow hasn't run again since we added this additional commit with the commit message of exclude branches from publish job. Now let's push up a tag. Here I've just pushed up a tag called v1.0 .0, and here the publish-package job ran as a result of the push for that tag. We just saw how to use branch filters to control whether or not to run jobs. We also saw how later jobs don't execute if an earlier job isn't run due to a branch filter. We also saw how we can use tag filters to control jobs. By default, CircleCI ignores tags entirely, and so tag filters are opt-in only, but behave much the same as branch filters. If you have jobs that are filtered to tags only, don't forget to exclude branches from those jobs.

Using Secrets, Schedules, and Manual Approvals
Earlier in this module, we've seen how we can leverage CircleCI to run jobs that may do things like deploy code to a production environment, or publish packages to a package repository, however, in order to do these things they require specifying some sort of authentication information, that is, jobs like this have to deal in secrets. CircleCI has some facilities for managing secrets, however, it is always your job, whoever you are and whatever your job functions might be, to exercise caution and think carefully about security when handling secrets. Primarily, CircleCI's secrets management is done using environment variables that you can specify per repository. You enter the name of the environment variable, the value, which is the secret you wish to use, and CircleCI stores that data for you so that it's available to your jobs. When you do this, the values stored for each environment variable is, from the perspective of the CircleCI UI, write only. The secret goes in, but it doesn't come back out. Reading the value of the secret can only be done within a job by accessing the environment variable. This yields an important element of secret management with CircleCI. Anyone with access to create and push commits to your repository, even pull requests, can potentially have access to the secrets that you've entered into the CircleCI dashboard. Therefore, committers are granted trust to be able to manage those secrets appropriately. This also means that appropriate steps must be taken in the build definitions to ensure that secrets aren't accidentally leaked into the build logs, especially for public repositories where the CircleCI build logs are also public. Let's go see how we can securely leverage a secret in a CircleCI workflow. Here in the CircleCI dashboard, I can specify the secret that I want to manage by going to the Repository Settings and to the Environment Variables. I select Add a variable, in this case the variable's name is MY_SECRET, and the value is a value that you shouldn't see because it's secret. Now we can use the MY_SECRET environment variable in our jobs. Here in config.yml, I'm going to use that secret in this echo command, and then here in the build logs we can see that we've leaked that secret. This is an important element of security that you want to keep an eye on as you go through your code review process. Most command line utilities make it difficult to leak secrets to the logs like this, but it's something that you want to pay close attention to, especially when you're making changes to your build definitions. Sometimes it can be useful to begin a workflow on a schedule. This can be useful for a number of reasons. Scheduled jobs are more predictable than those triggered by pushes since pushes are essentially triggered on demand. Scheduled jobs can help with capacity issues if you find that branches have a high frequency of new commits being pushed and are having issues with long queue times. Scheduled jobs can also create opportunity to do work that is best handled in off-peak hours, like database maintenance or load testing. CircleCI supports starting workflows on a schedule using standard CRON syntax to define the schedule for the job. Let's go take a look at how this works. Here we are at config.yml, and I've defined a workflow called perf-tests. In this case, the only job that runs is a job called perf-testing. Notice the triggers key here where I specify a schedule. This is a CRON syntax schedule definition that says run this job at 2:15 a.m. every day. Notice also that we have the opportunity to do branch filtering under the schedule as well. Here I'm filtering it just to the master branch. Often it can be easy to overlook when discussing CD pipeline automation, that there's a lot of value in introducing a human element into the CD pipeline. CircleCI supports a manual approval job whose only purpose is to pause a workflow until a human approves it and allows it to continue. A manual approval can be useful to help control the timing of workflow execution in the face of dynamic events that are hard to automate around. If, for instance, a deployment introduces a few seconds of downtime, it might be wise to hold that deployment if, say, there's an important demo going on right now. Let's go see how this is done. Here in config.yml, I've introduced a new job called hold. This is an approval job. Notice that hold requires test, which means the workflow will stop after the test job completes, and then the deploy job requires the hold job to have completed. Let's push this up to CircleCI and see how the manual approval process works in the CircleCI dashboard. Here we are, and our workflow is on hold because of this hold job. If I click it, I get a dialog box to confirm whether or not I want to approve continuing the workflow. When I click approve, it allows the workflow to continue.

Review
That wraps this module. Let's review. We've seen how we can arrange jobs in a workflow by specifying them as a DAG, a directed acyclic graph. We've seen how complex workflows support parallelism in jobs, allowing multiple jobs in a workflow to run at the same time. We've also seen how to use filters to control which jobs run for which branches and tags, and how to schedule workflows to run at specific times. We saw the facilities that CircleCI provides for handling secrets, and the security concerns that you are responsible for to prevent leaking secrets. We saw how to introduce a manual human approval step into a workflow. A manual approval can be useful for navigating around dynamic events that you can't really plan for. Once again, I want to refer you back to CircleCI's excellent documentation, which reinforces everything you've seen in this course. In addition, the documentation can help you get started with some of the more advanced features of CircleCI that we didn't cover in this course. Well, that's it. This should get you started automating your own CI and CD processes with CircleCI and GitHub. Thanks so much for watching, and thanks for using Pluralsight.
