The basis of any good, modern Redux application is the ability to orchestrate asynchronous calls to outside APIs, while working with the mostly synchronous language of JavaScript. In this course, Redux Saga, you'll learn the skills you need to vastly improve your Redux application performance and development time. Throughout the course, you'll be building a non-trivial shopping cart application, where users can add or remove cart items, see shipping and tax totals, and check out, all while keeping state synchronized with the server. First, you'll delve into Redux Saga, its uses and origins, and how it fits in with other Redux middlewares. Next, you'll explore nearly ever Redux Saga effect, each illustrated with an example. Finally, you'll discover Redux Saga channels, testing, and other advanced topics. By the end of this course, you'll have the necessary knowledge to build a whole application using Redux Saga.

Course Overview
Course Overview
Redux Saga. Whether you are one of the nearly 10, 0000 coders who have started on GitHub or one who's just starting to learn about it, it's a library that can rapidly accelerate your web application development. What I love most about Redux Saga is how it directly saves me time when writing all sorts of everyday applications, dealing with vendor endpoints, saving data to databases, and communicating with APIs are just a few of the ways you can use Redux Saga. In this course I teach you how to do exactly that over 7 modules with hours of explanation and over 100 visual aids. In my course, Redux Saga, I teach you the practical skills you need in order to master Redux Saga, both at work and at the home office. We'll learn about sagas and asynchronous ES6, then move onto Redux Saga effects, channels, and testing. Overall, I can't believe how much information I was able to pack into this short course. By the time you've completed watching this course you'll know how to build a whole application using Redux and Redux Saga. In the demo application we'll be building, a nontrivial and full-featured shopping cart component that would feel at home on any ecommerce giant's website, you'll learn to orchestrate asynchronous threads, handle Ajax request with just one line of code, and execute numerous concurrent API requests all with plenty of instruction and my own detailed explanations. Are you still writing your JavaScript code using promises and callbacks? Still stuck on Redux Thunk? Don't be among those left behind, instead, learn the new, better way, not just for building React and Redux applications, but for all of your asynchronous needs. If you're ready to write better applications with fewer lines of code and rapidly accelerate your career by learning the skills that are in demand today, then get ready to begin your own saga with Redux Saga. Start watching the first module now.

Introduction
Introduction
Hello, and welcome. I'm Daniel Stern, also known as the Code Whisperer, and in this course we'll be learning all about Redux Saga. This first clip will serve as an introduction to this course and to the first module. Let's begin by taking an overview of what we'll be learning in this introductory module. First we'll be asking the important question, why should you learn Redux Saga? As we all know your time is very valuable and it's important that you select the libraries that you should learn correctly. We'll also answer the question, what is Redux Saga? Redux Saga is a library quite unlike many JavaScript libraries we're already familiar with. And so it makes sense to take some time to uncover exactly what it is. In addition, since Redux Saga naturally tends to overlap with other broad topics, including Redux and React, it's important that we lay out what we will and won't be covering in this course. After that we'll have a look at a course roadmap, which will tell us approximately what we'll be learning and in what order as we proceed through this course. We'll take a look at the prerequisites for this course, what technologies will you need to have installed and what technologies do you need to understand in order to get the most out of this course. Finally, we'll get to the most exciting part, of course, running the finished application. We won't be completing the whole application in this first module, of course, but by having a look at the finished product you'll have a good idea of what to expect and what we'll be building over the course of the upcoming modules. In the next clip we'll discuss why you should learn Redux Saga.

Why Redux?
Why should you learn Redux Saga? Are there compelling reasons to do so? Let's find out. So, first things first, Redux Saga is a tool that's built and designed for real-world applications. It's not an esoteric library used for drawing pictures or creating academic analyses, it's a library for getting things done. And whether you're trying to communicate with an outside API, or a database, or even directly with another client application, Redux Saga has all the tools that you need to do this. I can say from personal experience that Redux Sag has become my go-to solution, not just for any of my client applications, but also all of my server applications. It's not even that Redux Saga is so good, it's just that the way it works is perfect for all those use cases that I had before that there was no convenient way to solve. Next, Redux Saga has a large and growing user base of contributing users who are continuously adding new features and making sure the existing features work properly. As we can see here at the Redux Saga GitHub page, Redux Saga has many watchers and even more stars. There are a healthy number of open issues at 90, which makes up about 1% of the total starring activity. I consider this ratio a good ratio of issues to stars. You can see from the time of me making this the last commit was only 3 days ago. Probably between the time that I produce this and the time that you watch it, even more commits will be released. It's a library that's actively being improved, and this tells you that if you learn it you're not likely to be left with an unmaintained library that doesn't work anymore after just a few short months. Finally, as I hinted at before, Redux Saga is not just great for client applications, but for any node-based applications where you are using asynchronous functionality before, it's just great. So, there will be teaching Redux Saga in a client context, once you've learned it you can apply it to everything you do on the server as well. This makes it an exceptionally valuable library to learn and a very good way for you to spend your time in learning it. In the next clip we'll be demystifying things a bit and asking what is Redux Saga?

Who This Course is For
What is Redux Saga? I've spent some time already talking about how great Redux Saga is and why you might want to use it, but if you're still confused about what Redux Saga is, that's okay. Like we've mentioned, Redux Saga is a library that doesn't fit the mold of many other libraries you may be familiar with. Let's take a look at what that means. So, Redux Saga is, at heart, a piece of Redux middleware. It fits in next to your other middlewares and consumes actions that come out of your application to run the sagas. I say very important because it really is, in my opinion, the middleware for managing your side effects, your asynchronous communications. And by extent, it's important to recognize that these external communications are very important and they make up the heart of almost any modern web app. So if you're familiar with Redux Thunk then you'll already understand a bit about what middleware's about, but Redux saga is much more sophisticated. We could probably explain Redux Thunk in just a single video, but Redux Saga is going to take the entirety of this course to really understand. At its core, Redux Saga manages side effects. That means that you use it to make database calls, API calls, manage an interval timer for some kind of physics-based engine, basically anything that you are handling with Redux Thunk before, anything that doesn't fit into reducers or selectors. Now with all the added ease that Redux-Saga brings us it also brings more complexity to our applications. Redux Saga depends on the yield keyword, which is part of ES6. While yield is useful and up and coming construct it's still very much unknown to a large amount of developers. If you're not familiar with it, don't worry because we're going to learn all about yield in an upcoming module. This added complexity discourages many developers, but as we'll see in the upcoming modules it really isn't so complicated, and with a little hands-on practice it's easily mastered. In many ways, a highly simple, but useful model, to regard Redux Saga is that it is a black box that consumes and emits actions. So, we all know that a Redux application occasionally just creates an action, a user clicks something, a timer goes off, and an action springs into existence. Redux Saga consumes these actions and then, depending on what's inside the saga, may or may not emit a different action later. We'll come back to this model in time. An additional important note is that it works without Redux. Even though Redux is right in the name and it's by default a Redux middleware, it can be configured to consume any action string. Now, this may sound surprising, but actually it isn't at all. Redux Saga is so useful and its uses go well beyond simple Redux applications that there are many occasions when you would want to use Redux without Redux Saga, a simple server demon, for example. And finally, as we've established to a fair degree, Redux Saga is an effective tool for managing async operations. On the flipside, it's overkill for any application that's only doing synchronous calculations, such as some kind of offline calculator. The application we'll be building uses lots of async operations so Redux Saga is perfect for it. In the next clip we'll review what we will and won't be covering.

What This Course Will/won't Be Covering
Redux Saga is a useful, but high-level technology. It sits high on the shoulders of giants and depends on an understanding of various different, simpler technologies in order to get very far with it. While we will cover some of these, we also expect that you already know certain topics. Now if you don't, don't worry because we'll also be suggesting what courses you can watch before watching this that will inform you of those topics. So here's what we will be covering. We'll be teaching you about Redux Saga and all of its effects. A Redux Saga effect is like a tool within Redux Saga for accomplishing some kind of asynchronous goal. We'll be dealing in detail with the yield keyword. By the end of this course you'll have used yield many times and hopefully have gained an intuitive understanding of how it works. We'll be learning about forking processes and creating a multithreaded application. And we'll very much be going through the day-to-day things that you'll need to know to build a real-world application with Redux Saga. I've tried very much to design this course as though you, the student, were in a real-world development environment, and the tasks that you're doing now are parallel to the ones you'd be expected to do as a high-level JavaScript or a Node programmer. On the flip side we won't be covering these topics. So we won't be teaching you anything about basic Redux. Redux itself isn't too complicated compared to Redux Saga so it's expected that you already understand how to use Redux quite well. The same goes for React. Now React is a small, but crucial part of our application in that it creates the view of everything, so without it the user wouldn't see anything. That being said, we're not going to be teaching you how to use React. There are other great course for this that I will mention momentarily. But if you don't know anything about React you're going to want to watch these courses I'm about to mention first. Finally, Node. js and Express are going to be used to form the bedrock foundation of our application. These are technologies that every developer should know and they're covered in detail in other courses, so we won't be teaching you how to do these things here, it's expected that you're pretty comfortable using Node. js and running an Express application on top of it. I'll be recommending some courses to watch to learn these technologies in an upcoming clip, so if you've decided that you want to learn more about Redux or React before moving onto the rest of this course then stick around as prerequisite courses will be suggested. In the next clip we'll have a brief look at the course roadmap.

Course Roadmap
And now that we've covered the necessary introductory nuts and bolts let's roadmap what we'll learn in the course to come. First we'll learn all about sagas and Redux Saga. We'll gain a familiarity with their history and also how a Redux Saga saga differs from a traditional functional programming saga. We'll learn all about asynchronous ES6, including the yield keyword. Then, we'll take a whole module to one-by-one explore Redux Saga's effects and implement them in our application. We'll take some time to discuss channels, an advanced feature in Redux Saga that sagas use to communicate with one another. Finally, we'll deal with testing. Redux Saga makes testing applications very easy, and as we know, testing is important, so this should be a great chapter for anyone who's interested in Redux Saga. In the next clip, we'll be covering course prerequisites.

Course Prerequisites
Let us take a few moments to discuss the course prerequisites. What are the prerequisite technologies you're going to have to know and have installed in order to complete this course? First, you'll need Node. js. It's expected that you understand Node. js and also that you have it installed on your computer. We'll be using a Git, the version control tool to get our applications set up and also track its progress. Finally you'll need administrator privileges on whatever computer you're using since we'll be installing some global packages. Of course, in a pinch, you can just have the administrator present and have them approve anything you need to install, but really, it's much better if you have the privileges yourself. So it's expected that you have these technologies, and if you don't, don't worry because I go over how to install them in some other courses that I'll be recommending at the end of this clip. Here are the prerequisites skills you'll need to have. As we've discussed, you'll need to have a good understanding of Redux. You'll also need to know about React and using it together with Redux in the React/Redux framework. You need a good understanding of ES6, such as the spread operator, the rest operator, arrow functions, but not yield, yield we'll be covering. And you'll need to be familiar with Node and Express. Now, if you're not, have a look at these courses first, Mastering Flux and Redux and Advanced Redux, both by the author of this course, yours truly, myself. Mastering Flux and Redux is my beginner-level Flux and Redux course. If you're at all confused about Redux or have never learned Flux, which makes an excellent foundation for understanding Redux, then please, go to the link now and watch the course. It's also a Pluralsight course, so if you're watching this course that means that you can watch Flux and Redux Mastering at no additional cost. Then, for students who are more advanced, but still don't know the full capabilities of Redux, we have Advanced Redux. This course will bring you right up to the beginning of the course we are taking now. So, if you feel like this course is a bit too advanced for you, then please, go to the links here and start on one of these simpler courses. Don't worry, we'll wait for you right here. And in the next clip will be having a peek at the finished application. And my goodness, it is a fine application indeed.

Overview of the Demo Application
As we come to the end of this introductory chapter, it's important that we have a look at the finished application. It's hard to build a skyscraper without having any idea of what the skyscraper will look like when it's finished, and a Redux Saga application is much the same. So, we'll review all the functionality of the application, we'll have a quick peek at the code base and technology stack. Now we won't actually have the application running on in our computers just yet, that will come in an upcoming module, but if you're one of those people that just has to rush ahead and get the application started early, the links to both the server and the client are here on the screen. There are instructions for getting them started on the GitHub page, but again, I'm showing these only for the benefit of people who are really excited about getting the application started well before we're going to be having a build in this course. So here we are at the application. As you can see it's a simple, but nontrivial shopping cart application. As we all know, shopping carts are everywhere on the web. Many business people consider the web a tool for commerce and how can you buy or sell anything on the web without some kind of shopping cart widget? At the top, the shopping cart absorbs the user data from the server and displays it here on the top. Then it hits a separate API to get the contents of the user's cart. If we try refreshing the page, you'll notice how the various elements load in at different times. That's because they're all being managed by a saga. Of course, don't worry, the application doesn't actually run slowly, the server's been configured to add a delay to any responses to symbolize what it might be like if a user was using this on a slow connection. You can add or remove items from your cart. If you add too many of an item that's not in stock, you get an error message, and the action is reversed. Here at the bottom we have a WebSocket-powered widget that tells us if there are support personnel to help us with our shopping cart. And here if we click the Check Out button it will create a series of calls to the server, and this case it'll end in failure because on the server the user's credit card only has 500 dollars. First it verifies the items and then tries to finalize the purchase. As you can see, this application is very exciting and highly nontrivial. We'll be building the whole front-end part, so if this interests you then you're in for a real treat. Finally, for the main application I thought we'd just take a look at the package JSON. This is great to have a peek at whenever you start with a new application, so this tells you all the technologies that this is built upon. As you can see, we're leveraging Babel heavily to let us use the yield keyword in our application. Express is really just used to serve our application, it has not logic, but it makes an appearance nonetheless. As you might expect, our application will be using immutable to create and immutable version of the state. It's a little bit trickier to work with, but makes it a lot easier to avoid making big errors. Isomorphic-fetch is what we'll be using to make asynchronous calls within Redux Saga. We have a host of common React and Redux modules that you're probably familiar with. Finally, Web pack will allow us to serve our application and develop it very quickly. Finally, chai, jest, and mocha are all tools that we can use to test our Redux Saga application, which we'll be doing in the final module. Alright, so hopefully you're as excited as I am to be building this application. In the next module we will begin a formal academic introduction to Redux Saga. Stick with us, it'll be great.

Introducing Redux Saga
What Is Redux Saga?
In this module we'll be introducing Redux Saga. We'll be laying out all the foundational information that you need to interact with this course and with Redux Saga in the most efficient manner. We begin this module with a simple, but important question, what is Redux Saga? First and foremost Redux Saga is Redux middleware. That means it needs to be added to a Redux store somewhere in the middleware chain for it to have any effect. Once it has been added as middleware it consumes the actions that come out of your application. In response, it occasionally dispatches other actions or creates side effects. Side effects include interactions with databases, with outside APIs, etc. Finally, unlike other middlewares, like Redux Thunk, Redux Saga maintains continuously-running processes, called sagas, to manage the logic of the application. Using these Sagas effectively is a large part of what using Redux Saga is all about, but what are sagas? In the next clip, we'll find out.

What Is a Saga?
What is a saga? The word saga has many different definitions, even within the world of computer programming. Let's have a look at one or two. So a saga in general functional programming is a series of reversible transactions. Sagas were designed to replace single, huge, locking transactions. For example, a deposit to a bank would require changing various different spreadsheets. The traditional way would involve locking all these spreadsheets, changing a value, then unlocking them. Whereas with a functional programming saga you would break the transaction into small steps and if there was an error anywhere along the way you would reverse all the steps that you've taken. Now to manage all this, sagas use a process manager to keep track of what's been done and what other actions need to be taken. Now sagas in Redux are quite a bit different. So, in Redux Saga sagas are more characterized by their long-runningness than their reversibility. Things done by Redux Saga can be reversed, but there's little mention of reversal in the Redux Saga docs, and in practice, it's not something that happens too often. Rather a saga is a process that runs in the background that creates side effects for your application. One unique thing about sagas that we'll be exploring thoroughly is that they're made with ES6 generator functions. There are many reasons for this, but the simplest one is that ES6 generators and yield result in better, more maintainable, and more concise code. Like functional sagas, Redux Saga also has a process manager, but that process manager is Redux Saga itself. The various sagas that you have running all communicate with Redux Saga, and Redux Saga stops or starts the various processes as is appropriate. So, to summarize, here's what sagas actually do, they listen for actions and then dispatch other actions. They dispatch actions and listen for them using tools called effects. In an upcoming module we'll be exploring every effect that Redux Saga has to offer. In addition, sagas can modify external APIs or change system files or access databases. In your Redux application all of this side effect functionality should be isolated in your sagas. In the next clip we'll answer the question why you should use Redux Saga.

Why Use Redux Saga?
So at this point you may be wondering, why should I even use Redux Saga, isn't Redux Thunk or just middleware enough for my use cases? Let's have a look at some other rationale. So, Redux Saga makes side effects easy. Almost all side effects require some sort of asynchronous functionality and since Redux Saga uses yield and generators you can often get this asynchronous functionality in a clearer and more concise way than without them. In addition, Redux Saga has many advanced tools that cover almost all real-world use cases. For example, using Redux Saga you can fork a process into several different processes, or stop a process so that another process can run. Finally, Redux Saga is quite sophisticated, it has way more features that Redux Thunk, which is just a simple connector. When you get down to it, Redux Thunk lets us solve a lot of problems with our Redux application, but it encourages a lot of bad coding practices, like putting a lot of logic inside your action creators. Redux Saga offers solutions to these problems that are much better, the tradeoff is that Redux Saga is more complicated and takes longer to learn. In the next clip we'll have a direct comparison of the two libraries.

Redux Thunk vs. Redux Saga
The most obvious comparison you can make with Redux Saga and any other library is between it and Redux Thunk. These are the two main Redux middlewares, and it wouldn't be surprising if in your workplace or business you have the discussion, should we use Redux Thunk or Redux Saga in this application that we're building? Now, personally, I believe almost all cases call for Redux Saga, but, let's have a closer look. So Redux Thunk is a common middleware used in many Redux applications, so is Redux Saga, in this sense they are very similar. Redux Thunk was created by the original creator of Redux, Dan Abramov. Too, as we mentioned earlier, solve necessary issues with the structure of a Redux app, like how to deal with side effects. On the other hand, Redux Saga was created by a third-party developer. They did so because the use cases provided by Redux Thunk and existing middlewares simply didn't match their needs. Redux Thunk doesn't use any special JavaScript contacts and you can throw it into almost any application that's already running Redux. On the contrary, Redux Saga uses more advanced structures like generators and yield and only works in environments that support that. Now, lately, yield support has gotten a lot better, so in environments like Chrome you can use it without any precompilation. However, you're always going to be more limited choosing Redux Saga than a Redux Thunk. Redux Thunk doesn't really have any built-in ways to manage asynchronous calls. If you have to make an asynchronous call and then wait for its response, and then make another call, and another call, you're stuck with either a pyramid of callbacks or a chain of. thens. On the other hand, Redux Saga is designed to leverage yield and generators to make asynchronous simple. I can't really stress enough how much easier it is to do async after you master generators, yield, and Redux Saga. We'll be doing so in a large number of demo videos that are coming up in an upcoming module. Finally, if you have multiple different thunks for doing different things, there's no way to organize side effects between them. At best, you need to create some kind of cross-channel communication or create a different thunk for every tiny action you want to do. On the other hand, Redux Saga is well designed for having a lot of sagas running in parallel. You use effects to communicate between sagas and tell the Redux Saga to stop one and start the other. Alright, in the next clip we'll be setting the application up.

Setting up the Application (Demo)
In this clip we'll be setting up the application. Similar to a real-world application, like the kind you might use in your office or freelance endeavors, this application consists of two components, both of which you'll be running on your local system. The first is the server component. The server component answers all our API requests and doesn't use Redux Saga. We'll just be installing it, and running it, and then using it. The client application is where all our Redux Saga logic will be stored. Now I want to note that since I've started to use Redux Saga I find it's also excellent on the server, that we won't be covering its server applications in this course. We'll begin by installing and running the server. Now it is recommended that you code along with me at your workstation, wherever you are. So we'll be cloning the server from the GitHub page, which we'll be visiting in just a minute. We'll then install the dependencies and run the server to make sure it works. Then we'll explore the HATEOS interface that I've set up to make it easier to understand. So, here I am, the URL for downloading the server is here. To clone this to your computer you can just click the link here for Clone, or if you're sophisticated with Git you can do it in any way you want. So, clone the shopping cart server to your computer. So here I am in my shopping cart server, I'm using WebStorm, my IDE of choice. WebStorm has a 30-day trial, so if you want to try WebStorm out without paying right away, then you can. Even factoring in the cost though, WebStorm's just a great IDE for making web applications. There's not a lot to this server. If you look at server. js it's just some very simple routes. It's basically designed to look and act like a server while glossing over a lot of the complexity. So open up a terminal to the directory where the server's installed, then run npm install and npm start. (Typing) You should get a message saying that the server's listening on port 8081. If you're having any errors it probably means your global dependencies aren't installed correctly. So review the troubleshooting instructions in my course, Advanced Redux. Once it's running, let's visit local host port 8081 in Chrome. So this is the server, and these are all the routes we'll be using in our Redux Saga application. You can see there is a route to get user information, a route to the get the cart, routes to add items or move them from the cart, really all the routes and more that you'd expect from a serious application. If you click any of these URLs, it takes you to where the route would be and gives you an example of the return JSON. Not so much to be concerned with here, just remember to have your cart server running at all times while you're doing this course. Now, for the exciting part, let's set up the client application. Setting up the client application is going to go a lot like setting up the server, except for one key difference. The client application has a few different branches in different levels of completion. I recommend you start with the begin branch. The begin branch has the whole application, except all the sagas. It's a house without anyone living in it. And over the course of this course we're going to bring it to life. So we'll be cloning it, then installing the dependencies, and ensuring that the application is working. If you don't want to code along and just want to start with the final version that's available on the master branch of the GitHub repo. And, like I mentioned before, there's detailed troubleshooting instructions in my course, Advanced Redux. You can also find the written instructions at the URL there. So here I am at the repo for the redux-saga-cart. First you'll want to jump to the begin branch. The begin branch is very similar to the master branch, but, as I mentioned before, it locks the sagas. So, we'll clone this repository to our computer. So, here we are in the cart. First, you're going to want to check out the begin branch. Next, you'll run npm install and npm start. (Typing) While that's running let's have a peek at the directory structure. The application has a public directory, which contains the CSS and the shell index. html. The app is all a React app so it just runs inside this app container. The server is a simple connecter that lets us use socket. io in conjunction with our application. The SRC contains a simple Redux application, which we'll discuss in more detail as we proceed. Let's go to Chrome in port 8080. So if you navigate to port 8080 this is what you should see. Even though it's telling you to please wait, I don't recommend it, because until you add the sagas to this application the loading will never complete. However, if you've gotten this far you are ready to continue with the rest of the course. In the next clip we'll be adding our first saga to the application.

Installing and Configuring Redux Saga (Demo)
In this clip we'll be installing Redux Saga into our client application and configuring it to work with our store. We'll first install Redux Saga from npm, and then we'll set it up as middleware for our application. This part is simple, but it contains key steps that you'll need to use every time you implement Redux Saga. So here I am inside the cart. First things first, we want to install Redux Saga. So open up your terminal, and install, with a save, Redux Saga. Now, let's go to our getStore file. Here we are inside getStore. First, let's import the create saga middleware utility from Redux Saga. Just put it anywhere here among these existing imports. Whenever we invoke this it creates new saga middleware. So we can have as many middlewares running as we want in different parts of our application. Here we have a list of middlewares. We're going to put the saga middleware at the beginning of this list. But first we'll create it. We'll say saga middleware is equal to an invocation of createSagaMiddleware. Now we'll add the sagaMiddleware to our middleware chain. And since that's as far as we're getting in this clip, we'll just add a log here to make sure everything's working. Now, if you visit the application, and you may or may not need to restart to the server, you'll see the saga middleware-implemented message. Congratulations, you've added Redux Saga to your app. In the next clip though, we'll be adding our first saga.

Creating Your First Saga (Demo)
In this clip we'll be creating our first saga. We're going to create a basic user status saga, without any functionality quite yet. We're going to organize the sagas with an index file and run them all using the middleware. We'll conclude by making sure that our simple saga is running. This is a preview of the upcoming module where we actually build out all the sagas, in between this and that we'll be learning about all of Redux Saga's effects and the yield keyword. For now though, if you don't completely understand what's being programmed, don't worry, this'll just build muscle memory for when you are really implementing sagas in the upcoming module. So for starters, let's create a new directory in our src folder called sagas. And we'll create a file in there called currentUserSaga. So all we're going to do is export a function, but not just any function, oh no, we're going to put a star after this function call denoting that it's a generator function. Now if this is pretty new to you, don't worry, because in the next module we're going to be explaining in detail what it all means. We'll call the function currentUserSaga. You don't have to include the word saga in all your sagas, but it's something I like to do to make it clear that that's what it is. Now we're going to create a while loop. We'll say while true. Now this is another thing that might look weird because, as we know, a while true loop outside of a generator function is destined to throw an error and make our computer crash. But, when you're inside a function star there're certain things you can do to pause the code for a period time. The simplest way to do is this is with delay. So we'll import the delay utility from Redux Saga. So, what delay does is it creates a promise that resolves after a certain amount of time, but all that a developer needs to know is that if you put it after the yield keyword, the next line of code won't run until that much time has passed. We'll just put in 1000. Then we'll put a console statement letting us know that our loop is finished. (Typing) And there we go, our first saga. It doesn't exactly do too much, but I think we've still learned a lot. Now let's create an index file to organize our sagas. And we'll export the currentUserSaga. Now we'll create a file and the route of our src directory called initSagas. This file will contain a method that takes the saga middleware and runs all the sagas through it. So we'll import all the sagas by importing the index file of sagas. Now we'll export a function called initSagas. So it'll take all the values of the exported sagas, and then for each of them we'll call sagaMiddleware. run, making sure to keep the scope correct. Finally, let's call initSagas in our getStore. We'll import it. (Typing) Now at the very end we'll call initSagas. As an important note, sagas can only be initialized after the middleware has been placed inside a store. Alright, so with this all in place, let's see what happens in our application. Now, if you did this all correctly, you should be seeing what I'm seeing. Notice the loop counter of the user saga keeps going up. But notice how the computer doesn't crash. If you've gotten this far, congratulations, you've successfully used yield and the delay utility, both very powerful tools. In the next clip we'll sum up this module.

Conclusion
My goodness. That module was just packed with learning, and it was only the first one. I hope you're as excited as I am to proceed with the rest of the course. But first, let's summarize what we just learned. So, we learned that Redux Saga is a fusion of some of the ideas in functional programming sagas and the use of asynchronous ES6. We also learned that at its heart it's just middleware that manages side effects. We established that it's superior for most serious business applications, superior to thunk. We learned that while sagas do the actual action taking and action dispatching, as well as side effects, Redux Saga manages all these sagas and make sure they interact in an appropriate way. In the next module we'll be taking a deep dive into ES6 and generators.

Asynchronous ES6 and Yield
Introduction
In this module we'll be learning about Asynchronous ES6 and Yield. Let's start with a quick introduction. First, we'll discuss the yield operator, what is it, and what are its advantages and disadvantages. We'll learn about generator functions and how they contain the yield keyword. After that we'll look into the yield keyword's strange relationship with ES6 promises, another tool used to get asynchronous performance. And finally we'll learn about how to wrap generators so that they'll work outside of a generator environment. In the next clip we'll discover what is yield.

What Is Yield?
What is yield? If you've been studying JavaScript for a few years, you've probably heard this keyword come up again and again, but it's only just recently become widely supported in a number of browsers. So, what is yield? When you get down to it yield is a special keyword, it's a keyword that delays the execution of code that comes after it. It's a keyword that doesn't have any effect unless you put it inside a generator function. We'll be discussing more about generator functions in the next clip. In fact, if you try to use the yield keyword anywhere, but inside the direct the scope of a generator function, you'll get an error and your application will not run. Ultimately, the yield tool solves a similar problem as promises and can be used with promises to greatly reduce the amount of code that's actually required to make them run. Now, let's look at some examples. Here's an example of an asynchronous call using callbacks. This is not with yield, but a more traditional way that you're probably very familiar with seeing. So, any code that you want to actually run after your API call is complete you have to place inside the scope of the callback. If you place code after the API call, but not in its scope, it will run it before the call is resolved, it runs basically not in the order that you expect. And then, let's say, inside here, if you have to make another API call and then another after that, the code will drift right in what some have called the pyramid of callbacks. Here's an equivalent example using promises. As you can see, the promise has a similar problem. Any code you want to have access to the data you have to place in the scope of the method that you've passed to them. Code that you place outside of this chain event call is going to run before the promise resolved, usually not what you want. And then, if you have a chain of. then calls it's not going to go to the side, like with callbacks, but it will get longer and longer, growing downwards with each additional then call. Now, here's an equivalent example using yield. As you can see, it all fits into one line of code and there's no additional scope created. Code that you want to have access to the data variable you just have to place it on the next line, the same way you would do it with synchronous code. Unlike callbacks or promises, yield calls don't tend to grow to the right or downwards, they always take about one line and tend to be very compact.

Advantages and Disadvantages to Yield
So, what are the advantages and disadvantages to yield, why might you or might you not want to use it instead of a promise or callback? So, as we saw, yield requires significantly fewer lines of code, and since code gets harder to maintain the more lines of it there are, this is a big advantage of any application. There's also less indentation. The code does not go sideways or downwards. As a result of it not creating additional scopes, it's really easy to read, much easier to read than a series of callbacks, and you can easily understand what's going on. It's easier to debug, since you can place any suspect code inside a try and catch block and quickly determine any error that may be occurring. Finally, if you're running a generator function using yield and there's an error in the promise, the execution of the code stops, it doesn't just keep going like if there was a problem with the callback. This can be a good thing, as there are far fewer silent failures and errors that may occur. But what are the disadvantages? So, first of all, yield only works inside a generator function. If the function you're working in isn't a generator function, then you need to create another function or wrap the function, or a number of different options. But, you're going to need to use more tools than if you were just using callbacks. You have to use more plugins in your build system to use yield, you have to use a few different Babel plugins, whereas with promises you could just use those out of the box. As time goes on, the number of plugins that are required to run generators in yield will go down naturally, but for now it is an important consideration. In callback, or promise-oriented architecture, there's no strict need to handle your errors, your application will still run if it runs into an error, just maybe not as expected. However, with a yield-based application if it runs into an error that's not handled, it will crash. In addition, beginner developers may not be familiar with the yield keyword, it is one of the newest features of JavaScript and a very unfamiliar one. So if you're the senior developer in a company and there are many beginner developers that are working on the team, you may have to devote additional resources to train them to use yield. And finally, execution stops on an unhandled error. Now you'll remember this was an advantage too, but it can be both an advantage and a disadvantage. The disadvantage side of it is it will cause your application to stop running, when maybe the error was very small and only related to sending data to some kind of analytics API, for example. On the other hand, it can be advantage because you will notice whatever error is causing your application to stop and it will fix it, so your application will have fewer errors at the cost of fewer silent failures and potential graceful recoveries. In the next clip we learn about generator functions.

Generator Functions
Let's take some time to discuss generator functions. We know that generator functions are a special environment in which the yield keyword can be used, but is there more to them? So, a generator function is a special JavaScript function that has a star after the word function. Calling this function returns a generator object. Now, when you invoke the generator function, the code itself doesn't actually run, it only runs when you call the next method on the generator object. A key point to note about generator functions is that they can return or yield multiple values. Unlike a normal JavaScript function that runs until the end and returns its final value, a generator can return multiple values, as we'll see in the upcoming clips. So here's a normal function. This function just adds two numbers. Now, in a normal function, to get the result you just have to call the function. And in this case, data would be equal to 3, 1 + 2. With a generator function doing a simple action like this is bit more complicated. Now, with the generator function getting the same basic result is a bit more complicated. As you can see, the internal code is the same, but first, we have to create the generator object by calling getValue with the required arguments. Then, if we call. next the code will then execute up to the next return, or yield, or the end of the code, and whatever value is returned will be the. value property. In this case, data is again equal to 3. So the extra step here is this next call. Generator functions are harder for doing basic things, but when we have more complicated things our functions are trying to do, it's a lot easier to do it this way.

Creating a Generator (Demo)
In this hands-on demo clip we'll be creating a generator. So first, you're going to want to download and run the latest in a long series of utilities that I've put together just to help you learn how to use Redux Saga. Let's go to the URL github. com/danielstern/redux-saga-sandbox. So here's the redux-saga-sandbox. You'll want to clone it from this URL here, and then as per the instructions run npm install and npm start, and then visit local host 8082. So here I am, I have the application on my computer and I'll run npm install and then npm start. (Typing) And, after that, you should have the Redux Saga Sandbox running at port 8082. The sandbox is just a console environment that I've prepared that has a lot of special properties that will help us test our sagas. We'll revisit this in just a minute. So what we're about to do is create a basic generator function that just yields primitive values. We'll practice advancing the generator to its next line of code, with every next call that we do. So here we are back at the sandbox. To get it working press F12. So let's create a generator. We'll say var generator. And I'm using var here because it's easier to use a var when you're just writing inside the console meant as a scratchboard. Inside a file I'd recommend let or const, of course. So we'll make this equal to function*. And we'll just have it return the value 5. Now you may be wondering, can I use an arrow function here, and the answer is no. Generator functions always have to have the word function then a star after, for complicated, technical reasons. Now, if we invoke generator, we can see it returns our generator object. These properties are meant to be private and not examined, but they're there if you want to have a look. If we call. next on the generator object, it returns the value 5. The done variable is equal to true and it's set to true whenever a generator returns something, but can it provide or yield a value in a different way? Let's see. Let's create a new generator. We'll say var generator = function*. And we'll have it yield a series of values. So we'll say yield 1, then yield 2, then yield the numbers 3 and 4, and finally return the number 5. Now let's create a reference to the object by calling generator. (Typing) So, before we start, try and predict what will happen when we call obj. next. (Typing) As you can see, it returns the value 1, the first yielded value. If we call obj. next again, it returns 2. Every time you call. next the code runs until the next yield. If there's a yield on every line it'll just run one line at a time. The done value is false indicating it hasn't hit a return yet, but if we call next a few more times, we finally get to 5, and it doesn't go any farther. Calling it again will return an undefined value. I strongly encourage you at this point to write a few more generators that return simple things and just get more familiar with the process of creating generator objects and iterating through them. Once you're comfortable with that, let's do one more example. Let's write a generator with some asynchronous functionality, similar to what would happen if you called an API. So we'll define a delay generator. So this generator will yield a new promise. The promise takes a method that has a resolve argument, which we'll just call r. And we'll set a time out to call r after 1000 ms. (Typing) And on the next line we'll return some value, let's just say 42. Now let's create the delayGenerator. So if we call obj. next we'll get a promise, but that means we can call obj. next. value. then. Inside this loop we can call various functions and finally call next on the generator when we're ready. In this case, let's just call generator. next using the object and log its value. (Typing) So as you can see, there's no mechanism inside the generator for actually dealing with this timeout. The wrapper of the generator has to deal with it some way by using a. then or by using a different library to wrap the generator. Alright, so that resolves our first trip into the sandbox, please take 10 or 15 more minutes just to play around and write some more generators. Are you curious to see if a certain construct will work? Give it a try, this is a great way to learn stuff, and in the next clip we'll move closer towards understanding yield and promises.

Yield and Promises
In the last clip we used a promise in conjunction with yield, but how does it work exactly? So the function call that follows the yield keyword, if you will call a function, must either return a promise, or an object, or a different data structure, depending on what is wrapping it. Presumably, the code execution will resume when the promise is resolved. The wrapper code can take whatever is returned from the promise and pass it to the generator as the next thing that is returned from yield. If the promise does not resolve, if it throws and error, then the code will actually stop at that line, it won't proceed with an undefined value, but rather, an error will halt its execution immediately. So naturally, if we have to call. then every time our generator needs to do something asynchronous it defeats the purpose of writing a generator, since now our code base is going to be bloated anyways. But there is a way to void this, and it uses Redux Saga, and it's called wrapping your generators, and in the next clip we'll learn and apply what we learned about it.

Wrapping Generators
As we saw, calling. then yourself every time can be cumbersome. To make our code concise and compact we need to wrap our generator somehow. So, when you yield a promise it still must be called manually, somewhere. Now, when you run your generator with Redux Saga, it automatically wraps your generators and automatically resolves your promises for you. So you see, all these concepts are actually closely interrelated. There is another library that we also have access to in the sandbox called co. js. Its purposes is to wrap generators that aren't Redux Sagas. From this point on in the course we will be kind of be redirecting our focus to focus only on the saga kind of generator, but it's good know that using code we can take what we learned about generators and apply them to applications that might not be using Redux Saga. As we can see here, the generator needs the value that's returned from API. call, it's going to store that as data and then return whatever that data value is, plus 5. So if we're calling the generator function manually, the only way to do this is to get access to the promise, wait for the promise to resolve, and then pass the value to the generator. next. This is pretty cumbersome. However, in this case, a saga example, this saga would just run on its own if it was run inside Redux Saga. It requires no wrapper, and note that delay is just a method that returns a promise that resolves after a certain period of time. In the next clip we'll do an example.

Wrapping Generators with Redux Saga and Co (Demo)
In this demo we'll do the following. We're going to make a generator, but this time rather than running it ourselves we're going to run it with Redux Saga. We'll take note that Redux Saga resolves our promises automatically and just sort of moves our generator along for us. Finally, we're going to use co for a similar effect. Just for that I'm confident that you, the student, understands how generators work in more than just one context. Alright, here we are back in the sandbox, which we'll be revisiting several times over the course of this course. So, let's write another variation on our delay generator. So the first line will yield a delay of about 1000 ms and store that as a value. And then we'll do this a few more times. Now whatever we put as the second argument of delay will be passed as the resolution of the promise. In other words, it will become the data, so let's add the values 1, 2, and 3 here. (Typing) Let's also add some logs so that we can see what's going on. (Typing) And then we'll return the three values added together. (Typing) So the first thing we can note is we can just call this generator manually, we can make an object and just start calling next. (Typing) So as you can see, when we call it manually we actually don't have to wait for the promise to resolve at all, we can just keep calling next. But if we do and we don't pass it whatever value is returned then it's not really going to run properly. As you can see it concludes by returning not a number, because at least 1 or data1, 2, or 3 was undefined. So it seems like most of the time we're going to want to wait until the promise resolves to get the right value. Now let's see how Redux Saga would do it. Inside the Sandbox there's a special method called run, which takes whatever generator you have and just runs it as a saga in a sample store that I've put together. So now try calling run delayGenerator. (Typing) And as you can see, it runs on its own. Now when you return a value from a saga, nothing really happens. Sagas, as the name suggests, aren't meant to return anything, but just keep running sort of indefinitely until their purpose is complete. If we try to do the same thing again, the same results happen, because it creates a new instance of the object, with its own understanding of what part of step 1, 2, or 3 it's at. This is a very powerful way to do things. Finally, let's try wrapping this inside co. So we'll create a new object called wrapped, And we'll make that equal to co. wrap, the delayGenerator. So, co works a little bit differently, but still in a very useful way. When you call a wrapped function it will run all the way through, automatically resolving all the yield calls and passing the values back to the generator. When you invoke a co it turns the whole generator into a promise, and calling. then returns the final return value. Let's give it a shot. So we'll call wrapped and then call. then and just log what's returned. Alright, let's give it a shot. (Working) Alright, so when we wrapped it with co it ran until the end and we got our final response. Co and Redux Saga's run are used for slightly different things, but as you just saw, they can both be used to advance a generator function to its conclusion. In the next clip we'll wrap up.

Summary
Wow, wasn't that a great module? I just loved it. These topics that we covered weren't just fun to talk about, they're such productivity boosters for anyone at any level of their JavaScript learning. Let's review. So we learned that yield is a special keyword and it only appears inside generator functions, a special kind of function. Though not always the case, yield is often proceeded by a function call and that function call usually returns a promise. We saw that Redux Saga, at its heart, forms a wrapper than simplifies this generator promise process by resolving our promises for us. We also learned that, if we're so inclined, co can be used for the same effect. Speaking of effect, in the next module we're going to learn about Redux Saga effects, the key component that makes Redux Saga different than co or just calling generators ourselves. It's going to be great, so do stick with us.

Redux Saga Effects
Module Introduction
In this module we'll be discussing and learning about Redux Saga Effects. So first of all, we're going to understand effects, what are they, and how do we use them in our application? Then we're going to have a review of almost every Redux Saga effect and use them in our application. We're going to summarize the following effects over the course of this module, put, select, take, takeLatest, takeEvery, call, fork, and even a few more. We'll also be using the cancel effect to stop threads as opposed to starting them with different effects. In the next clip we'll start to learn about what effects are.

Introduction to Effects
So, effects, they make up the core of many Redux Saga applications, but what are they and what do they do? So, an effect is a kind of utility that's provided by Redux Saga, that is to say it's imported from the Redux Saga package. When you invoke an effect it returns an object that contains instructions, which Redux Saga interprets. The effects don't have any special property outside a Redux Saga application, that's because it's Redux Saga, the middleware, that generates the side effect, be it an API call, or database call, or something else. The effect itself doesn't actually do anything. We'll see this in practice soon, so if you're not sure you understand, don't worry. We can see here that the different effects fall into different categories. The first category is Thread management. These effects, if used properly, result in the creation of new threads, or the yielding of the current thread. There's an effect for creating actions for a Redux app called put. And an effect for getting data from our app called select. Then there's the three Flow control effects, take, takeEvery, takeLatest, which either pauses the execution of the code or forks new code based on when actions are dispatched in your application. In the next clip we'll be learning about our first effect, take.

Take
In this clip we'll learn about take. So take is one of the simplest Redux Saga effects. It doesn't do anything too special, but it just pauses at a particular line of code. And then when the action you specify is dispatched, the code resumes. This effect does not create additional threads, you're still just using the one thread, but pausing it where appropriate. And since we use the yield keyword to do this, whatever the properties of the action are, are actually passed to a running saga when the action occurs, very convenient if we're not sure what the properties are going to be. Now, we'll take a shot at actually using take in some live code. So, for this demo we're going to experiment with take using the Redux Saga sandbox. And all take will do is pause the execution of the code until the action we decide is dispatched. Alright, so here we are in our Sandbox. Now you can see the take effect by calling effect. take. And we can pass it any string, we'll just call the string MY_ACTION. And what's returned is an object. As you can see, no information is stored in this object as we didn't put in it, it's really quite simple. So let's define this in a generator. We'll create a generator and we'll call it mySaga. So we'll start with a console log. (Typing) Then we'll yield an effects. take, and we'll wait for an action called SET_STATE. (Typing) And we'll store what's yielded in a variable. (Typing) And we'll end the saga by console logging with the state is. (Typing) Now, let's give the saga a try by running it inside Redux Saga, we'll call run and then pass it to saga. Ah, okay, so we get our first message, Saga begins, but we don't get our second message. That's because the code pauses when it gets to take. Do you know how we can make the code continue? If you guessed calling store. dispatch, you're right. So we'll call dispatch and we'll pass an action of type: SET_STATE. (Typing) And as you can see our second console log runs. It got the state and it knows the value that we passed in that action. And that's how take is used. I recommend you take another 5, 10 minutes just trying out some more ideas with take inside the Sandbox while we have it open.

Put
In this clip we'll learn about put. Put is one of the simplest Redux Saga effects, and one of the easiest to understand. Put dispatches an action to the rest of your app. It's functionally very similar to just calling dispatch in a different part of your application, except, since it's an effect, it won't do anything unless it's inside a Redux Saga context. Unlike some other effects, this doesn't pause the code execution or really do anything fancy in any way, it just dispatches an action. So if you have been using Redux Thunk or React Redux in the past, it's the same as calling dispatch, in, for example, a container component. Now we'll give using put a try. So we'll use put to dispatch actions in the Sandbox. Now, whatever code is waiting for this will be paused until the action is called, if it's using a take effect. So we'll use take to verify that the way we think put works is really how it works. Okay, let's begin. First, let's write a saga to consume the action that we're going to be putting out. The saga called mySaga from the last clip will do just fine. So I just brought it back by pressing up a few times in the console, but if you've refreshed your browser or don't have it anymore, just copy it down again from what you see, and we'll run mySaga. So now the saga is waiting for the SET_STATE event to continue. So we'll create a new saga called putSaga. And all we'll do is yield effects. put. And here we'll describe an action. So when this saga is run it will put the action SET_STATE into the store. Can you guess what the end result will be? Let's see. We'll now run the putSaga. (Typing) If you guessed that mySaga would complete running, you're correct. And you'll notice that mySaga actually got the value from putSaga. So, take and put can be used to pass data from one saga to another. Take 5 or 10 minutes to play around some more with put, and we'll see you in the next clip.

Call
We'll now learn about the Call effect. While the call effect is dead-simple to use, it's one of the harder effects to understand, due to its limited applications. So, the call effect simply calls whatever the specified method is. It's very similar to invoking the method directly. In other words, it's just like you're calling the method. So, why would this effect even exist? Well, as you'll recall, since effects don't actually do anything outside of Redux Saga, if we call a method, instead of yielding to it directly, we can have so that that method isn't really called during a test, very cool. Let's give using call a shot. So, in this example, we're going to call a method from within a saga, and we're going to see the difference between using call and directly invoking the method. And we'll be using call a lot more in the module on testing, since it's so closely related to how you test Redux Saga applications. So, here we are in the Sandbox, and let's just write a very simple function. And the function will just console info, whatever we want, just a quick sentence. Now, we'll create a saga that just yields to the function. Now let's see what happens when we run the saga. You can see we get the message saying the function was called. Now let's rewrite that saga to use call. So we'll yield effects. call and then just pass the function without invoking it. Now if we run the saga, you can see it works in the exact same way. Like I said, call is pretty simple to use because it's just like invoking a method regularly. But, in the upcoming modules we'll see how using it in our application can make it more testable.

Implementing Take, Call, and Put in the Application
Take, call, and put are all used in conjunction to achieve day-to-day business goals. Now that we understand all three, we can implement them in our application. So we're going to work with the currentUserSaga. The currentUserSaga is going to use take to wait for a GET_CURRENT_USER_INFO. Since this information is only to be fetched once it's appropriate to use take, instead of takeEvery or takeLatest, which we'll be learning about in some coming clips. Then we're going to update the current user status saga so that it will call the server API once it receives this action that it's waiting for. Then the data that comes back from the server is going to be used to put information to the app using the put effect. This will automatically trigger the reducers and the display components that have already been prepared. In short, this time our saga will actually be affecting how the application looks. It's very exciting, so let's get started. So here I am in the redux-saga-cart. Make sure you have the cart, as well as the cart server running. Now, before we get started note how in App. jsx we're calling getCurrentUserInfo after our app mounts. This is basically a condensation of what would happen if a cookie or a user key were stored in local storage, and then we fetched it, and used that to determine whose user info to get. We'll just assume it's always this U10000 user. So that explains where the original get user info action comes from. So here we are inside our currentUserSaga. We won't be needing this loop now, so let's just get rid of it. We also won't be needing the delay utility this time. So first let's quickly note, now in the application it says Please wait while we fetch your user info. This just lasts forever because the user info isn't fetched, yet. So we'll import the effects we need, take, put, and call. We'll also be needing one more, apply, and apply works just like call, except it changes the scope of call. And we'll also need fetch from isomorphic-fetch; this is equivalent to request or, in JQuery, and it just lets us call the API we need. Now, let's import the actions we're concerned about. Let's get the GET_CURRENT_USER_INFO constant and the setCurrentUser action creator. Take a minute to visualize how you would structure this saga. Remember it has to call the API once it receives the getCurrentUserInfo action, and then put the data back out, but first we'll take the getCurrentUserInfo action and store the ID that's returned. And we should be seeing our console log saying that the ID is U10000. If you're seeing what I'm seeing you're on the right track. Now we'll call the server and store whatever's returned in a variable called response. So we'll call fetch and the second argument is going to be the URL that we pass to fetch when we call it. And we'll just type in the URL of the user info route. Now, in order to get our sensible value out of the other response we have to call it response. json, but since response. json is tied to the response scope we have to use apply. Apply is like doing call, expect we also get to bind the scope of the method to whatever we choose. It's pretty simple in practice. We'll make our data variable equal to yield apply and the context will be response, and the method will be response. json. The reason we do this is we get an error if we just try to call response. json. Response. json relies on the this scope to tell it where it is and give it access to utility methods. Let's add a log to see the data we get. As you can see the data is eventually returned from the server. This is a real asynchronous call that we're doing. We can delete these logs now, we don't need them anymore. And lastly we'll put the data to the application. So we'll call yield put and we'll invoke the setCurrentUserAction creator, passing in the data. Alright, check it out, now when we load up our application it fetches the user data and eventually updates what we see on the cart. It's really cool to finally be doing something like this with sagas. In the next clip we'll be implementing fork.

Fork
Fork is, perhaps, the most challenging effect so far that we'll have to understand. What is fork and how do we use it? So, the first thing to understand about fork is that it works a lot like call. You pass it a method and the method is invoked. However, you can't capture the variables that are yielded from a forked application because the caller continues to run instantly without pausing. When you use call the code stops until the called function or generator completes, but with fork your existing thread of code just keeps right on running. So when you use fork the child process that you've created is dependent on the parent. If the parent makes an error or if it is cancelled, then all the forked processes are cancelled as well. Forked methods can use a finally block, similar to a try/catch block, to tell if they've been cancelled or if their parent has errored. Now, let's try using fork within the Sandbox. We'll create a method that loops and creates a fork of a different method. We'll notice how the first thread does not pause when it calls the second thread. And we'll also note that as this loop runs it will continuously create more instances of the second loop. Alright, so we are in the Sandbox. We're going to define a function that loops and simply does a console log every 1000 ms. Now we'll define a saga and the saga will loop and every time it loops it will fork the function FN. So we'll say yield effects. fork fn. And then we'll delay for about 500 ms. And now let's run the saga. So you can see that continuously more and more FNs get called. As the saga loops it creates more and more forks, but the forks can all run independently. Be sure to refresh your page at some point to stop this from executing. Now, of course, as we've learned, you can cancel fork defects, but we're going to learn more about that in the clip on cancelling. For now let's see how we can implement fork in the application.

Implementing Fork in the Application
In this clip we'll be implementing fork in the application. This is really exciting as it's at this point that we really start using saga for things that would be very difficult to do without sagas. We're really getting into the business applications of saga and improving our own code as developers. So why ever would we need fork? Well, in the previous chapter we called the user, mystic. So basically a saga will exist that will get a list of all of the items that a user has in their cart as IDs. Then a saga is going to fork a process for each one of the IDs and make a separate Ajax call to get it. This allows the information to resolve in whatever order the server decides is fastest. And this results in the items appearing for the user potentially faster. So, in this demo, first we'll create a fetch cart saga, which gets a list of the item IDs once the user info is in. Then it'll create a separate item details saga, and that saga will fork a process for each item and fetch those details. So, let's start with the fetch cart saga. We'll create a new saga and call it the fetchCartSaga. And we'll export it from our index to make sure that it's automatically run. So for this we're going to need to takeLatest, put, and fetch. We're also going to need the SET_CURRENT_USER constant and the setCartItems action creator. Now, we'll export our fetchCartSaga. So we'll start by yielding to a take of SET_CURRENT_USER, we're going to wait until current user is set by the different saga before we continue this thread. And let's just update this takeLatest at the top to be a take, and we'll store the ID variable from this take. Now, just like in the previous saga we'll call the API for the cart and get the items by yielding to their JSON. And you can always consult with the server page to see what the URLs are to make various calls, in case you want to make any modifications. Now we'll invoke response. json, but this time, for contrast, instead of using apply we'll just invoke response. json. It's a bit cleaner and takes fewer lines of code, but keep in mind that this code that we've just written is very difficult to test. And lastly, we'll put a setCartItems action that passes the application or items as the payload of that action. And lastly, we'll put a log to make sure that our code has finished running. (Typing) And it looks like I made one little mistake, the user is passed from SET_CURRENT_USER, not the ID. So we'll make user equal to that, and the we'll make ID part of the user variable. Now, as you can see, the cart items are set and we get this three spinners. We know that there are three items, but we don't have any details on those, and those details won't be fetched until we write a saga to do it. Alright, now we're going to create another saga that consumes what the fetchCartSaga puts out and creates new data from that. So we'll define a new saga called itemDetailsSaga. And we'll update our index. Now for this saga we're going to need take, fork, and put, as well as fetch. We'll also need the setCartItems constant and the setItemDetails action creator. Now we'll export a function called itemDetailsSaga. Now we'll yield to a take of the setCartItems action, which we just invoked in the last saga and we'll save those items. Now we'll yield to items. map. Now if you call map and make sure that everything that you return is something that can be yielded, like a process, you can actually call yield and then map and it happen asynchronously. So for each item we'll call fork, and we'll call a method we're about to write called loadItemDetails, passing it the item. Now let's write a method to load the item details. And for now, let's just log the item to make sure that it's correct. And if you check your log you can see that it now is forking a process for each item. But the screen isn't going to update until we actually write that process, so let's do that. So we'll get the ID from the item. Next we'll yield to a fetch API call and then get the JSON of the response. Now we'll get the info, which is the first argument in data, data is an array when you call the item's API. And now all we have to do is put our info using the setItemDetails action. (Typing) And here's application. As you can see, the details for the items load in in a different order. It is really cool to be able to get this much functionality in with just a few lines of code. If you're wondering about the spinners, those are because we haven't loaded the prices yet, which are of course, done by a different saga. So, in the upcoming clips we'll begin handling that.

TakeEvery
We'll now discuss the takeEvery effect. Now that you understand both the component methods it's easy to understand takeEvery as a combination of take and fork. Instead of just taking an action once, it takes it every time it comes, and every time it forks a new child process to handle it. And unlike take, but like fork, when you call takeEvery your main thread continues to execute, even after it's called. Let's do an example where we use takeEvery. So when we create a saga that invokes a method each time a specific action is dispatched. And we'll note how multiple threads can be created in conjunction as we dispatch the action again and again. We'll also note that the thread where we call takeEvery resumes immediately. So we'll create a process and all the process will do is loop every 1000 ms. Now we'll create a saga that listens for a particular event, we'll call the event START_PROCESS, and forks the process for every time it's called. So we'll yield effects. takeEvery, and we'll listen for a START_PROCESS, and then call process. And then we'll add a log to make sure that the saga got to the end. Now let's run the saga. So the saga gets to the end, but our process hasn't been called any times, that's because the saga is still waiting for the START_PROCESS action, let's dispatch it manually. And you can see we've created a Process loop. If we dispatch the event again, a few times, our process loop just keeps looping faster and faster, because we're continuously forking a new process. Now there's not too much more to say here, because if you understand fork and you understand take, you understand takeEvery. But if you'd like to spend another 5 minutes playing around with takeEvery, I strongly encourage it. In the next clip we'll learn about cancel.

Cancel and Cancelled
Ahhh, cancel and cancelled, maybe the two hardest effects to understand, but with our strong understanding of the fork effect, we can easily extrapolate what cancel is supposed to do. So cancel stops a forked process. But, of course, since JavaScript isn't really multithreaded, the process won't be stopped in the middle of the code, it can only be stopped at a yield statement. That being said, the next yield statement it gets to, it won't continue. When you cancel a forked process, it's finally block is invoked in case you want it to respond to the cancel in any way. Of course, if you cancel a process, you also cancel all of the processes that are forked off of it. Cancelled works in conjunction with cancel. It's a method that returns true if the method that it's called in was cancelled. So you can use cancelled in your finally block to determine if your fork was cancelled or if some unhandled error is responsible for the thread above your fork to be stopped, which will therefore stop your fork. So let's use these two dynamic methods in the Sandbox. We'll create a forked process and then we'll cancel it after a short delay. We'll note how the forked process will run until it's cancelled, at which point it stops at the next yield statement. We'll also note how the finally block is invoked. So this is going to be a bit more challenging, so follow me closely. We'll start by defining a process. Now within we'll put a try/finally block. This looks a lot like try/catch, but instead of catch, it's finally. So in the try block we'll put a while true, and inside the while true we'll just loop and do a console log, just like our other processes. Of course, always remember your delays in your while loops, because failure to put a delay or a yield in it will make your application freeze. Now, in the finally block, we'll just log what's returned from effects. cancelled. So now that we have our process, we have to make a saga to call it. So we'll define a saga. So we'll invoke the process with effects. fork, and we'll be sure to keep the variable that's returned, this is the variable that lets us cancel the process. And then we'll delay for 5 seconds. (Typing) And then we'll cancel the process by yielding to effects. cancel. And we'll let everything know it's done with a log. Now what to do you think will happen when we run we run this saga? Let's find out. (Working) Very cool. As you can see the process loops 10 times and then stops. We made a one little mistake though, we have to yield to effects. cancel to get the actual value. So let's go to our process and redefine it. So here when we cancelled into equal yield effects. cancelled. That should work a bit better, and now let's try running our process again. (Working) Alright, so as you can see, cancel is true and our process ends. We've just cancelled a forked process. This is one of the hardest things to do with Redux Saga, so if you feel that you're on the way to mastering it then you're very close to gaining a full understanding of this dynamic resource. In the next clip we'll get to maybe the toughest effect to understand of all, takeLatest.

TakeLatest
In this clip we'll learn about takeLatest. TakeLatest is one of the most complex effects, but also, one of the most powerful. TakeLatest works as a combination of fork, takeEvery, and cancel, all of which we've already learned about. Every time the action it's waiting for is dispatched, it forks a new child process, but it only keeps exactly one instance of the process running at any time. Here's a breakdown of takeLatest in action. So first, an action is dispatched, say by a user clicking a button. Then, takeLatest is triggered and a child process is forked. The child process runs continuously in its own thread. Then, the same action is dispatched, possibly by the user pressing a button again. Instead of forking another process right away, like with takeEvery, first, the child process is cancelled, then the child process is forked. So let's explore takeLatest by using the Redux Saga Sandbox. We'll create a process, which loops and has its own state, then we'll call that process from saga in response to an action that we've specified. And we can note that the process is cancelled and forked every time an action is dispatched. Here we are in the Sandbox, let's start by defining a process with its own internal state. So we'll define the process and we'll give it a variable, timesLooped, and that will be equal to 0. Now we'll run a while true loop that every time it loops timesLooped will be incremented and it will do a console log. So when this process is running, every 500 ms the looped will be incremented and a log will be shown. Now, let's define a saga. So all we'll do is we'll yield to effects. takeLatest. And we'll wait for an action called START_PROCESS, and we'll call process whenever that happens. So we'll define the saga. Alright, so now let's run the saga by calling run and passing it to saga. Finally, let's dispatch the START_PROCESS event. Okay, so we see our looped message and the looped count increments very time it loops, but what happens if we dispatch START_PROCESS again? Let's give it a shot. Ah-ha, so as soon as that's dispatched the loop stops and a new loop is created. As many times we do this, it'll start counting up again and again. (Working) So you see, at heart, takeLatest is just a combination of fork, cancel, and takeEvery. Now let's use takeLatest in the application we're developing. So we'll create a new saga called itemQuantitySaga and it will listen for a particular action, INCREASE_ITEM_QUANTITY. Every time a user adds or removes an item, the process will be cancelled and will make a new process. So here I am in my app. First I'll create a new saga called itemQuantitySaga. (Working) Now we're going to need the effects takeLatest, put, and call, as well as the select effect. Now the select effect is one of the easiest to understand of all, as all it does is return a copy of the application state when yielded to. We'll also need fetch. We're going to need quite a few actions. First we'll need both the INCREASE_ITEM_QUANTITY and the DECREASE_ITEM_QUANTITY constants. Then we'll need the set fetch status and decreaseItemQuantity action creators. And we'll need the FETCHING and FETCHED constants. So, first we'll define an itemQuantitySaga generator. Now in this case we'll yield an array. When you yield an array of effects they're all interpreted in most cases. Here, the first one will yield a takeLatest, and whenever it's dispatched we'll handle it using a function, and we'll write another for INCREASE_ITEM_QUANTITY. So first we'll implement handleIncreaseItemQuantity. So the first thing we'll do is we'll put a set item fetch status to FETCHING. That should prevent the users from clicking again while we're sorting this out. Then we'll get a copy of the user, so we'll say const user = yield select. Now if you pass a selector to yield select it will also invoke that selector, so let's import the user selector from selectors, and we'll pass that to yield select. Next, we'll get the response by calling add to cart for the item and the user with the API. And now we'll just log the response. Now let's temporarily comment out this DECREASE_ITEM_QUANTITY line while we test it, and let's add this saga to our index. Now, if we try to press one of these plus icons, we get our Got response message, so this is working okay. Hopefully you're seeing the same thing as this. So, if the response status isn't 200 that means that the item couldn't be added, usually the reason is there's not enough left in stock. So we'll handle that by dispatching a DECREASE_ITEM_QUANTITY action if that occurs. And we'll add an alert. Then, finally, we'll yield put that the fetch status is no longer fetching. Now if we run our app and we try to add too much of an item that isn't in stock, (Typing) we get a message, and the addition is reversed. So we're using a saga to handle this kind of dynamic server communication. Finally, we'll handle decreasing item quantity. This is very similar, so I'll just type it out and then we'll have a chat about it. So this works just the same as the other one, but since you don't have to worry about getting an item that's out of stock since we're decreasing the quantity, that clause is changed. And also, we want to avoid dispatching to the server this decrease in item quantity, if all we've done is adjusted it locally to reverse the original, hence the local return call. And now, let's uncomment it from the yield statement below, and that should be complete, so let's look at in the application. And now these buttons in our application work correctly, they're even communicating with the server. In the next clip we'll review what we learned about select.

Select
In the interest of covering as many effects as possible, let's take a few minutes to discuss the simplest effect of all, select. So when you yield to the select effect it returns a copy of the application state. This is because Redux Saga is storing the application state and it's capable of passing it to our running sagas. Of course, if you called select outside of Redux Saga it would, like all effects, have no effect. You can, as a convenience, pass a selector to select and it will invoke that selector on the state for you, returning just the properties you want. Select is so simple there's no need to do an example. in the next clip we'll be discussing the spawn effect.

Spawn
As we approach the end of this module, we're beginning to discuss some of the less-commonly used effects, such as spawn. In addition to having the coolest name out of any effects, let's see what the spawn effect really does. So when you call a spawn it creates a new process similar to fork. The caller is not interrupted in its processing and goes down to the next line. In fact, in this sense spawn is almost exactly like fork most of the time. Now the new process is not a child process of the caller. So if the caller errors or is canceled, the new process is not effected. This is the difference between spawn and fork. So, let's practice using spawn. We'll create a saga, which calls a process, and then throws an error. We'll note that how when the call he processes is called with spawn it continues to run. Then, just for comparison we'll replace spawn with fork and see how things behave differently. Here we are in the Sandbox. Let's start by defining a process. In this case, the exact same process as we used last time will be sufficient, so let's press up a few times to gain access to it. And we'll press Enter to commit this process to memory. Now, we'll define a saga. First the saga will spawn the process. Then it will delay for 2 seconds. Finally, it will throw a new error. Now if we run our saga what do you think will happen? Let's give it a try. (Working) So we get an uncaught error at saga as expected, but the loop keeps going. That's because the spawn process isn't cancelled. Just to demonstrate this let's try this again with the fork process. So we'll refresh the page. Now let's redefine the process, in the same manner, and we'll redefine the saga, so instead of effects. spawn it's effects. fork, and we'll leave everything else the same. Now, what do you suppose will happen when we run our saga? Ah, when the error is thrown the child process is cancelled. Spawn is a fairly useful effect, even though most of the time you want your child processes to be cancelled when the parent process has an error. Most of the time the fact that our saga stopped when an error occurs is a good thing, it makes it easier for us debug our applications. In the next clip we'll discuss the all effect.

All
The last effect we'll be covering in this module is the all effect. The all effect is an easy-to-understand, but powerful effect. So the all statement combines a number of take statements into just one statement. When all is yielded to the code execution will stop and will only resume when all the actions that are specified in your all command have been dispatched. The order does not matter. That's all we need to know to implement all in the application, So let's give it a try. So we're going to make an item price saga that waits for two different actions, the SET_CURRENT_USER and SET_CART_ITEMS. Only once all the actions have been dispatched will the code resume and the API call to fetch item prices. So, we'll define a new saga and call it itemPriceSaga. For this we'll need take, all, fork, put, and call, plus fetch. We'll also need the SET_CURRENT_USER, SET_CART_ITEMS, and SET_ITEM_DETAILS constants from the actions folder. And lastly we'll need the setItemPrice action creator. So first we'll define our itemPriceSaga. So we'll start by yielding to all. And we'll pass in an array of takes. We'll take SET_CURRENT_USER, (Typing) and SET_CART_ITEMS. Now, the values that are returned from this take will actually be saved in an array. So the first one, SET_CURRENT_USER will turn an object with a user property. And the second, one with an items property. Now that we have the items we'll yield to a map of them. And for each time we'll call a method that we haven't written yet, fetchItemPrice, and we'll pass it in the ID of the item and the country of the user. Now let's define this function. So we'll get our response value by fetching from the API. And we'll get a JSON format of that by yielding to response. json. Then we'll say the price is equal to the price property of the first element of the JSON, since it's an array. And now that we have the price we'll yield and put the price into our application state. Feel free to try editing this saga on your own if you want, seeing what happens if fork is used instead of call in its application. Finally, let's add this saga to our index. (Typing) Okay. So now when we refresh our application, after the items load in, soon after, their prices roll in. The prices are based both on the item and the user, since the user's nationality is important. Subtotal also works now because it's waiting of the events that we just dispatched. Very cool. As you can see the app has come a huge distance from where it was before. In the next clip we'll wrap up what we've learned in this module.

Module Summary
It certainly has been a very challenging module. Let's review what we've learned. So, Redux Saga effects are things that create plain objects. Redux Saga interprets those objects and executes processes based on what those objects are. Outside of a Redux Saga context the effects do nothing. The take, takeEvery, and takeLatest effects wait for a specific kind of action to either create a new process or continue the existing process. Call, fork, and spawn are all used to create different kinds of new processes. Fork processes, unlike spawn processes, are cancelled when their parent is cancelled or has an error. And it's important to note that the take and call effects pause the execution of the current contacts, whereas most of the other do not. Hopefully you learned a lot from that. In the next module we're going to learn about channels.

Channels
Introduction to Channels
In this module, we'll be discussing channels. Channels are utility provided by Redux Saga that allow us to do things that are more advanced than what can be done using effects alone. Here's what we'll be discussing in this module. First, we'll ask and answer the question, what are channels? Then we'll take some time, learning about and implementing action channels, generic channels, and event channels. Which make up three kind of channels provided by Redux Saga. After that's complete, we'll finish the remaining sagas. Effectively finishing our application all. In the next clip, we'll begin our discussion with action channels.

What Are Channels?
So what are channels? Are they useful to us and our day to day programming? Let's find out. So channels are a bit confusing because there's three different kinds of channels and they're actually quite distinct and used for different thing. The action channel is a buffer. It stock piles actions which sagas can then consume one by one. The event channel is completely different and used to wrap outside event sources. WebSockets make a good example of something you usually want to wrap in an event channel. And finally, there's just channel or generic channel. A channel is used to communicate between two sagas. This can be done with regular actions too but the idea of a channel is that communication is limited between the interest in sagas without other sagas being privy to that information. In the next clip, we'll learn more about action channels.

Action Channels
In this clip, we'll learn about action channels. So, an action channel records all events of a specified type. When you create an action channel, you also specify the types of events or actions that you want your action channel to listen for. Now, when you call take but pass an action channel as a parameter, you get the oldest record and that record is removed. The concern here is that at some point in your application, you might have an action dispatched. But whatever saga is meant to handle it, it's already busy handling something else. In some cases, it's fine if this action is lost but in others, such behavior could result in very unexpected glitches. So for this demo we're going to use the Redux Saga Sandbox. We're going to create an action channel and then a saga that consumes events at a particular speed. What rapidly dispatch a trigger event overwhelming the saga with too many actions to deal with at once. But we'll note how the saga in the end, happens the right amount of times because of the action channel we're using. So here we are in the Sandbox. First, we'll define a Saga and call it update Saga. We'll define action channel by yielding to the action channel creator. We'll listen for an action of type update. Now, let's create a loop. So it will yield to taking from the channel. Then it will log that it got the event from the channel. And here, it will delay for some time. Let's say, one second. Now, let's try running the saga. Nothing happened because the saga is waiting for an update event. Let's dispatch it. As you can see, it logs an update. But what if we dispatch the update in a rapid succession? As you can see, the update logged message slowly catches up to the exact number of updates that were dispatched. Normally, what would happen is the subsequent updates would be lost as the saga waits out its delay before taking a channel again. The delay here symbolizes some kind of a synchronous action that the saga may take. No matter how many times you dispatch update, it will log the update that many times. For contrast, let's try it without using a channel. So, now I've rewritten it so that it only takes the update of that, not a channel. What do you think will happen now, when we dispatch updates in rapid succession? Make sure you refresh your page to stop the original saga from running. Now, let's run the update Saga that doesn't use channels. Now, what do you think will happen when we dispatch say five updates in a row? Update logged only happens once. This is because the subsequent updates are lost as the saga awaits for the delay. I hope this explanation help show how action channels can be useful. In the next clip, we'll learn all about generic channels.

Generic Channels
Generic channels or just channels are a utility meant mostly to facilitate communication between different sagas. So a generic channel creates a special line of communication between two sagas. Unlike what normal actions, you don't need an action type. It's implied that any actions sent through this channel are of a particular type. Let's use generic channels in an example. We'll create a channel and that channel will put actions through to subroutines. We'll take note how action types are not required when using generic channels. So let's define a saga and we'll just call it saga. First, we'll define a generic channel by saying yield channel. Now, we'll define a child process, something meant to handle request. And this child process will take the channel as an argument. Inside, it will have a simple loop. And somehow to the last example will take from the channel a meta console log and then delay for a short period of time. Next, we'll fork the handler a number of times, passing the channel as an argument. So we'll copy this twice. And now there are two handlers. Finally, we'll put an effect to the channel. We'll start by putting the effect just once. So, we don't need to specify a type here, rather we have to put the channel we want the effect to be put to as the first argument. Let's give this saga a shot and see what happens. And it looks like I made one little mistake. If you notice I passed the generic channel creator and not our chan variable to effects. fork. Very good, let's fix this mistake. Now, let's try to run the saga. So we get our got payload message once a handler has handle it. Now, let's try it with two puts. As expected, the payload is gotten by each of the respective handlers. Finally, what happens when we try to put the effect three times. The payload is logged twice. Then when the first handler completes, it loops back around and takes the payload again. The payload has been stored for safe keeping inside this generic channel. And the next clip will do event channels.

Event Channels
Event channels are the third and final kind of channel we'll be discussing. So an event channel, is meant to be a wrapper of an outside source of events. This source of events is usually always WebSockets. Since, other mean of getting outside information like making an Ajax call, has been consistently displaced by WebSockets as more and more browsers support them. Similar to the other channel types, sagas can take from an event channel. But what they are really taking is those outside events. So the purpose of the event channel is to take these outside events that are coming from our WebSockets and change them into actions which react well to the take effect and yield into it. Let's implement even channels in the application. So the application has already been setup up to use WebSockets to communicate with the customer support API. Sometimes, customer support is available and sometimes, it isn't. The client is constantly updated of this via WebSockets. Now, the event channel we're going to create will convert those sockets that normal use callbacks that can't be yielded to into promises which can be yielded to. By doing this, we can then take from those sockets. We'll then create a while-loop which handle these messages. And the state will be updated accordingly. So, here I am in the application. Just as a quick reminder, you going to want to have both this and the cart server running to actually see our application locally. So we'll define a new saga and call it the customer service availability saga. So for this Saga, we're going to need the take and put effects. Plus, the event the channel which is not an effect. So, it comes from Redux Saga and not Redux Saga/effects. Next, we're going to import connect which is a function which is very simple that opens up a WebSocket connection. As we can see, the code for connect is exceedingly simple and familiar to anyone who has used WebSockets before. Finally, we'll need the set customer service availability action creator. So we'll export our Saga. So, first we'll create our socket by calling connect. Then, we'll define a new event channel. Now, event channels can make one argument which is a function that takes a emit as it's own argument. As you may have guessed, when you call emit, it causes the channel itself to emit an action. So, we'll define two methods. One, call enable support message which we'll just emit true and one disable support message which will just emit false. If we'd rope in on server. js, we can see that all that's happening is every 10 second the application is emitting an event. Either support available or support not available. Depending on what the last one was. It just alternates back and forth between the two. So I going to want to take note of these two event types, support available and support not available. So, we'll say, socket. on and we'll use the first event type support available. And we'll handle that by using enable support message. Now, let's do the same thing but for support not available. Finally, event channels must return an object that cancels the channel or removes the listeners. We won't ever need to unhook this channel so we'll just leave this empty but this is where you would put the code for removing listeners if this was the kind of channel that should be creating and uncreating dynamically. Definitely a case that could happen. Finally, we'll add a while true loop. All the while true loop will do is take from the channel and then put the appropriate action. Alright, now, let's just add our saga to the index. And let's see our App in action. Alright, very cool. As we can see, there's a small message at the bottom of our screen. And now, it's changing dynamically every 10 seconds. Using WebSockets is so cool as it really does create a dynamic and user experience. And now, you know how to combine WebSockets with your existing Redux Saga application. And the following clips will add the remaining Sagas to complete our application.

Shipping Saga
In the next few clips, we'll be adding the remaining sagas. To complete the remaining sagas, we'll need to apply everything we've learned in all the videos so far. By completing these remaining sagas. we'll be bringing the app up to its full functionality. Users will be able to add or remove items, see their total and check their card out. This will require us using various effects and channels in combination with one another. First, we'll be adding the shipping saga. Then, the tax rate saga, then the saga which checks for checkout availability. And finally, the checkout saga. Let's complete the shipping saga. First, let's create a file in the saga's directory and call it shipping saga. We'll need the select put and the take latest effects as well as fetch. We need quite a few actions and constants so I'll type them out and then we'll discuss them. So, we'll need the set cart items, the increase item quantity, and the decrease item quantity constant. You recall that we've used all these constants and their action creators in previous clips. In addition, we'll need fetched and fetching the constants that let our app know the status of our API calls. Then, we'll need the set shipping fetch status and set shipping cost action creators. Which allows us to communicate back to the application. Finally, let's get the cart items selector from selectors. So, now that that's out of the way, let's define a generator function and call it shipping saga. So we'll yield to take the latest and we'll pass it an array. In this array, we'll put set cart items, increase item quantity and decrease item quantity. And as the second argument will name a function we haven't written yet, shipping. This is really cool. Basically, what happens is when any of these actions are dispatched, it will start the shipping sub process. But if any of them are dispatch again, it will stop the process and then start it again. It really is an incredible amount of functionality to get in just one line of code. So, let's define the shipping generator. So, first, we'll let the application know that we're fetching the shipping status by putting set shipping fetch status fetched. Then, we'll use the cart items selector to get a list of the cart items. Basically, what this saga does, is it aggregates a list of all the item IDs that are in the cart. And then it sends that information to the server which calculates the shipping for you. As we know, if we were to calculate the shipping on the user's side, there's plenty of opportunities for an unscrupulous user to change the information, maybe edit the shipping to whatever value that you feel like paying. So, we'll turn all the items into a string. This is a little wordy, but we're basically reducing the items to a string by taking each item and then for every unit of its quantity, adding its ID to the string. Let's console log what the item request string is and then check it out in the app. But, before we do so, we'll need to add the saga to the index. So, if you look at the app, you can see what the item request string looks like. It's just a list of the item ID separated by commas. So, if you're seeing this, then you're on the right track. Now, you may have noticed, I made a slight mistake. We want the shipping status to be fetching. It's suppose to be fetched right at the end. Now, we'll pass the string to the appropriate API route and run json on the response to get a json object. The total value that's a property of the json is the total shipping that the user will have to pay. So, we'll put set shipping cost with the new total and then we'll put set shipping fetch status to fetched. And that all looks good so let's check it out in our application. Very awesome. As you can see, now, the shipping value is automatically updated. If we change the quantity of an item, the shipping is updated. This is because the saga is waiting for our events and then running its sub process when they occur. It's very cool to be able to hook this functionality in without needing to modify any of our existing sagas. In the next clip, we'll be adding the tax rate saga.

Tax Rate Saga
Next, let's add the tax rate saga. The tax rate saga is comparably simple compared to the last saga. So as usual, we'll start by creating a new file called tax rate saga. We're only going to need the take and put effects plus fetch. We'll also need the set current user constant and the set tax rate action creator. So we'll export a function called tax rate saga, a generator function. So, we'll start by yielding to take set current user. This will basically stop the saga as soon as it started and it will have it wait until the set current user action is dispatched by a different saga. We'll also store the variable that's returned. So it's important to conceptualize that the first line of code will run at the beginning of the application. But this next line that we're about to write will write whenever the set current user event runs. So, we'll get the country property of the user. And now, we'll fetch the response from the API end point and get its json value. We now have the tax rate stored in this variable. So, let's put it to the application with the sect tax rate action creator. Finally, let's add this saga to our index. Alright, wow, now, the tax rate is automatically fetched once we have our user info. This allows us to calculate the total and the front page of the application looks very complete. Since the tax rate is unlikely to change between when the user session starts and one ends. There's no need to fetch it at any point except at the beginning. Of course, you'll notice that this Check Out button still doesn't work. In the next two clips, we'll be implementing this most crucial of shopping cart features.

Checkout Availability Saga
The checkout availability saga is a saga that tracks whether or not our application in a state that the user can checkout from. It's a relatively simple saga so let's implement it now. Let's start by creating a new file checkout availability saga. For this one, we're going to need take put and action channel. Curiously, action channel is found on inside Redux saga slash effects unlike event channel. You also might notice by now that almost all our sagas need take and put. These are the most commonly used effect and mastering them is an important step in mastering Redux saga. As for actions, we'll need the set shipping fetch status and the fetch constants and the set can checkout action creator. Now, we'll export a generator function called checkout availability saga. We'll start by defining an action channel that set the set shipping fetch status event. Then we'll have a while true loop and inside, we'll yield to taking from the channel. So, every time the set shipping fetch status event occurs, and you recall it, this event is triggered anytime an item quantity goes up and down or at the application start. We're going to put a set can checkout event which will output true if status is equal to fetch. Since we're not making any server calls here, it's actually unlikely that any set shipping fetch types events will be missed. But if we were to put some asynchronous calls or delay in, there's a good chance that an action will be missed if it was being process. This could result in the user clicking the checkout button when they're actually not allowed to. Which could lead to some very confusing results. But with this setup that can't happen. Finally, let's add this saga to our index. Alright, cool. So the application loads out but the checkout button doesn't turn on until all the values are loaded in. It's interesting to know how many events have to happen before the checkout event can turn on. And how challenging it would be to do this all using call backs and promises. As we would in a traditional app. In the next clip, we'll write by far our most epic saga, the checkout saga.

Checkout Saga
In this clip, we'll write the checkout saga. In many ways, the checkout saga is a culmination of everything we've learned. It is an incredibly complex saga that does a huge amount of functionality. You'll need to apply everything you know about generators in sagas to make it. There's no doubt that without generators in sagas, this complexity would take up many files. But in this clip, we're going to write it all in less than a hundred lines of code. So first, we'll create a new file and call it checkout saga. We'll need take call put and select as well as fetch. We're going to to need a lot of constants. So I'll write them out and then we'll discuss what they do. Toggle checking out is the constant that is part of the action that lets us know when the user clicks the checkout button. All the checkout faces are different constants that indicate what phase of checkout we're in. This affects what the user sees as the checkout process continues rather than have one long process that can take minutes to resolve. We're breaking the checkout process app into various phases. The charging phase, the quantity verification phase, and updating the user on what's happening at every step of the way. Now, lets define a saga and call it checkout saga. So, we'll put a while true loop in. And this loop, we'll take from the toggle checking out action type. Whenever the user toggles checking out, we'll call a method we haven't written yet simply called checkout. Now, let's write our checkout function. We'll need the current user's information. So let's import the current user's selector from selectors. And for the first line of code, we'll get the user by yielding to the current user's selector select effect. First, we'll verify that the quantities of items that the user has are acceptable. This check is unlikely to fail given our current safeguards but in the event that something were to change on the server in the middle of a session, this will prevent the user from buying items that we couldn't give them. So we'll start by setting the checkout phase to a quantity verification. Then we'll yield to a call of a function we haven't written yet called validate user. We'll actually call this validate cart. And we'll write a generator called validate cart. Now, conveniently, the API has an end point that will automatically validate the cart of any user ID. We just send it the user and it tells you whether the cart is valid or not. So we'll make a call to that API then get the json value and return it. And we can't forget the user argument here at the top. Now, back in checkout, let's actually store this validated in a constant. Now, we can do some validation. We'll say, if the cart isn't validated, we're going to change the checkout phase so the error phase which will update what the user sees. And then we'll return. This return state will stop any subsequent code from occurring. So so far, in just this few lines of code, we are calling the server to see if the cart is valid. And then, we're even doing some validation before we can continue. This can all be done in the same scope. Strictly because of yield and generators. Now, let's add this saga to our index. And let's add a log here letting us know the cart is validated. Now, let's see if this works in our application. Alright, so when we check the checkout button, this view changes and we can see that the validated cart message appears after a little bit of time. This is all looking good so far. So lets continue along. Next, we'll change the checkout phase to credit validation by putting the appropriate action. Let's create a function called validate credit card. This is very similar to validate cart so I'm going to type it up and then we can discuss it. So, validate credit card calls a different API, the card slash valid API. But is the API conveniently also just automatically validates it based on the user. Unlike cart though, there is a chance that this could actually fail since in the API, the users only have a set amount of money. If you load too many items into the user's cart, the process will actually fail at this stage. So back in the checkout process, let's yield to validate credit card and store the value in a variable. And just like above, if this value is false, then we'll put an error in return. Otherwise, we'll just continue along. So you'll notice that unlike a call back, where we might be checking if the value is correct, this time we're just worried about handling errors. The flow of the saga will just continue along if there's no error that is found. This would also be a great time to add some more information for example, a message to let the user know this is why their transaction failed. Nothing is more annoying than when you're on an e-store and trying to make a purchase and it fails and they won't tell you why. And then we'll put a return statement after that. Now, if it gets to this point, it means the credit card is validated. So we'll set the checkout phase now to a purchase finalization. This is the phase where the card is valid, the cart is valid and we're just basically making the purchase. In the real world, there is a million reasons why this could error. Relating to the API calls we have to make to the actual vendor like Visa or Mastercard's API. So it's really important that we handle this error. Let's just pop back in on our app to make sure it's still running. Alright, so now, it goes along and gets the finalizing purchase on its own. Isn't this just an amazing amount of functionality to get with so little code? Let's wrap this up. So we're going to write a function called execute purchase and not surprisingly, we'll be very similar to validate card. So this method calls an API end point which actually executes a purchase. The API will reply with a success value and that success value will be passed back to the main thread. So now, the main thread will yield to execute purchase and store the variable. You'll note how we're using call here instead of yielding directly. This makes it so much easier to test the application later. Finally, we'll do one last check if purchase successful is not true, we'll go to the error phase. Otherwise, we'll keep going. Now, if the applications gotten this far without returning, that means that the purchase has been successful. So we can set the checkout phase to success. And let's sure it works. Amazing. So we actually get an error because the cart has too much in it. Isn't it just stunning how similar this is to a real world full scale application? Let's try it again but make the payment go through this time. Mr. Hemingway actually only has $500 in his cart. So let's remove items until the total goes down below 500. Now, with a valid total, let's checkout. And it works. Now if you keep getting an error, remember that the server is storing how much money that the user has persistently. So once you checkout, they are not going to be able to checkout again because their card no longer has the funds. In the next clip, we'll wrap up this dynamic module.

Summary
Let's summarize what we've learned in the previous clips. So we learned that we can use generic channels to communicate between sagas. We learned that action channels are similar from taking from the application itself. But they create a buffer which prevents us from inadvertently missing certain actions. Lastly, we've learned about event channels. Event channels can take an outside source like WebSockets which can't be yielded to and wrap it in something which you can yield to. Since callbacks do not really work inside of sagas, this is just critical. In the next and final practical module, we'll discuss and implement tests for our application.

Testing Redux Saga Applications
Module Overview
In this module we'll be discussing and applying testing Redux Saga applications. Specifically we'll discuss methods for testing Redux Saga applications, we'll understand the principles behind creating testable sagas, and then we'll run a couple of test that will exist right within our application. First, we'll discuss testing Redux Saga applications.

Testing Redux Saga Applications
So, testing Redux Saga applications. What are the important ideas that one has to understand in order to test Redux Saga applications properly? So Redux Saga is often implemented to handle our side effects, which means most sagas are designed to make AJAX calls to outside APIs. However, inside a test this behavior can be undesirable as it could actually result in data being changed in a database. So, tests need to somehow avoid making real AJAX calls when they're testing the sagas, which make those calls. However, you'll recall that effects, by default, do not do anything unless they're run inside a Redux Saga. Therefore, if call is used instead of directly yielding to the API method, then the generator can be run without the API actually being called. This first example is an example of a saga that's not testable. If you try to create the saga by invoking the generator, even if it's not inside Redux Saga, the API will be still be called. This, at worst, means data will change on the API and, at best will mean inconsistent results during tests. Here, on the other hand, is an equivalent example. Instead of yielding directly to the API we're using call to call the API method. This saga is testable since, if we just create the generator and don't run it inside of Redux Saga, Nothing will happen and no API calls will be made. By passing an array to call we can specify a context for the method to be ran in. So, as long as your sagas are written in such a way that they use call instead of directly yielding to outside APIs, they're testable. In the next clip we'll discuss several different methods for testing Redux Saga applications.

Methods for Testing Redux Saga Applications
As you may have guessed, there is more than one method for testing a Redux Saga application. The official method of testing Redux Saga applications, as described by the documentation, is as follows. So, rather than running the saga like we've been doing inside the Sandbox, the saga is executed, the next value is called manually. And as it's called manually we can pass mock values to next. This is equivalent to an API returning a particular value during a test. We then test only the effects, the call effects, and the put effects, etc., against the values that we expect them to be. In the official method of testing Redux Saga applications the store is never used, in fact, a Redux application is never used either, the sagas are tested as plain generators. However, is there another way? Here's what one contributor said on the Redux Saga GitHub page. The official way of testing sagas is wrong and puts emphasis on exact implementation and not on results. The contributor goes on to point out that if a particular implementation detail were changed, for example a call changed to a fork or a spawn, without actually changing what happens in the saga, it would still cause the test to fail. So how can we get around this? So, in the alternate method, and I've just chosen to call it this for clarity, there is no right or wrong way to test Redux Saga applications, a mock store and an application state are created. Then the saga is run using Redux Saga. run from beginning to the end. So, since we knew what the state of the application was before we ran the saga in the test, we can make guesses about what the state will be after. Should the saga have updated the user information or the cart items? Then the test passes or fails based on how these comparisons go. The problem with this method is that API calls will really happen since Redux Saga is going to take those calls and do them. So instead of using calls the APIs must be injected as dependencies into your saga. There's not really a built-in way of doing this, so to do so you have to figure out your own way of injecting APIs. So how do the two testing methods compare? Well, in the standard method, also called the unit test method, you have to use call every time you invoke a function. In the alternate method, you can use call and you should because it's clear, but you don't have to, the tests are going to behave the same either way. The standard method only allows you to test effects, there is no application state, so if the test you have in mind goes from putting the application in one state to another, standard unit tests can't help you. However, end-to-end tests exceed at this and they can easily test a before and after state, surrounding the invocation of some saga. On the flip side, with standard tests, if you want to use an outside API you can just import it and use it however you want, as long as you invoke it using call and not directly. However, if you're using end-to-end tests any APIs must be injected as dependencies, probably by whatever is calling them. Failure to do so will result in the same consequences as not using call during standard tests. Outside API calls will actually happen, and at best, this leads to inconsistent test results. Using the standard method, tests are easy to set up, you don't need any store or any state, you just need to have some idea of what values to pass to next when you're running your generator. However, with the alternate method, any test is pretty complex to set up, you have to create a mock store, a mock state, figure out what you want your final state to be, and finally make sure that your saga is written in such a way that all the APIs can be mocked. You'll then of course need to create mock APIs for any APIs you want to use. Finally, a standard unit test fails if the yielded effect does not match the effects you expected to be yielded. However, an end-to-end test fails if the final application state does not match the state that you expected. Overall, both methods are good. In the application we're just going to use standard unit tests as these are the kind of tests recommended by the Redux Saga documentation. However, in the interest of having an investigative and complete course, I've explained to you the alternate testing method. I'm sure to some students the alternate method will sound a lot better, or at least more interesting. And I've prepared some special suggestions for activities that you can do in the conclusion module. In the next clip we'll begin implementing tests in our application.

Implementing Tests for the Application/the User Status Saga Test
We will now implement unit tests within our application. We're going to use the following methodology. Any time the saga yields to our test we're going to inject a mock server response. We can do this by passing our desired server response into the next call. Then, after the saga gets our mock response it will probably try to put out an effect to the application. We're going to compare the generated put effect to what we expect should happen. And we'll take note that throughout our test the outside APIs are not being called, thanks to our usage of the call effect. We'll start by implementing unit tests for the current user saga. You'll recall the current user saga was one of our simplest sagas, now let's add test to it. We're going to call next manually at each step of the generator's execution. Then we're going to put the call and put effects to the test by comparing them against the values we expect. Alright, let's head on over to the application. So the application is already set up to run tests. If you type npm test it will run jest, which doesn't do anything because it tells you that no tests are found, makes sense. Let's start by creating our tests. We'll call it currentuserSaga. spec. js. Now some developers like to put their tests in a separate spec or test folder and that is certainly correct too, but for ease of use we'll just put it here right next to the file it uses. So, to test the saga we're going to need some effects. So we'll import the take, call, put, and apply effects, as well as fetch. Next we'll import the getCurrentUserInfo constant and the setCurrentUser action creator. Finally, we'll import the currentUserSaga, the saga we're going to test. Next we'll write a describe block and a test block within it. So we just call our test, it fetches and puts the current user's data. Let's make sure this works by running npm test. (Working) It looks like jest is seeing our test. So let's write some content for it. First we'll define a mock ID and a mock user. Then we'll create a mock of the JSON method and the response object, very simple. So JSON will just be a no op that does nothing, but when the saga calls it, it won't throw and an error because it's still a function. And the mock response will just contain the JSON method. Now we'll create a generator object by invoking the currentUserSaga. So anything that comes after yield we can test. We notice that the first thing that happens is it yields to a take of GET_CURRENT_USER_INFO. Let's write a test to verify this. We'll say expect gen. next. value. Note how we're passing in the value that's returned by take. Since all the effects do is create objects we can call an effect in our test to create a template to compare what will be returned from the saga. Let's run our test and make sure it works so far. Now if we look at the saga we'll note that it's expecting an object with an ID property to be returned from the first yield. If it's not, the saga simply cannot proceed as expected. So we actually do this in the next gen. next call. So we'll expect gen. next and we'll pass it an object with our mock ID, and we'll expect the value of that to equal, and no we'll invoke the call effect. We expect that the first argument of call will be fetch, and the second will be the URL of the user info API. Now the saga is expecting a response to come back from that yield, so when we call a gen. next we'll pass our mock response. We'll then expect that that value will be equal to yield apply, response, and then calling the JSON method. And let's run our test to make sure it works. So we'll pass the user to the next call. This last effect is really the effect we're most interested in testing, the put effect. We want to make sure that given all our mock values it puts what we expect it to put. We'll expect the value of gen. next, passing a user to equal the following. And we'll expect it to equal what happens when you invoke the put effect, calling the setCurrentUser action creator. Now, let's run the test. Alright, it passes. We can verify that this test is really running by changing a value so it will fail. For example, let's change this test to reflect a different user API. (Working) Now the test fails, and that's useful, since if the API were to change inside the currentUserSaga we'd probably want to be alerted to it in our tests. Let's change this back so the test passes, and that's our first test. In the next clip we'll be writing our second and final test for the application.

Implementing Tests for the Item Quantity Saga
In this clip we're going to test the item quantity saga. As you'll recall, the item quantity saga is one of the more interesting sagas as it has both a success case and a failure case for its communications with the server. So in our test we're going to inject a successful server response and test the output to make sure that the values are as expected. But then we're going to write another test in which we pass an unsuccessful server response and make sure those values are expected. This means of testing is great as it allows us to see what will happen during an often difficult-to-simulate error response from the server. So here I am in the application and I'll create a new file, and I'll call it itemQuantitySaga. spec. js. (Working) Now the itemQuantitySaga exports a few different generators. Right now we're only interested in testing the handleIncreaseItemQuantity generator. Note the error handling clause in the middle that responds to a response status of being not 200. So in our test we'll start by importing fetch, as long as the following effects, call, put, takeLatest, and select. Then we'll import just the handleIncreaseItemQuantity generator from the itemQuantitySaga file. We'll need a variety of action creators and constants, so let's import those and then discuss what we need. So we got the INCREASE_ITEM_QUANTITY, DECREASE_ITEM_QUANTITY, FETCHING, and FETCHED constants, as well as the setItemQuantityFetchStatus, DECREASE_ITEM_QUANTITY, and INCREASE_ITEM_QUANTITY action creators. These are also the constants that are needed to test both the other generators in the itemQuantitySaga, in case as part of the additional exercises you want to write some more tests. We'll also need from JS, from immutable, and the current user selector. So we'll describe the itemQuantitySaga. Now we'll define two values, item and user, and then before each test we'll give them a default value. So within this describe we'll describe handling increasing the item quantity. So at the top of this we'll define a gen, but just leave it undefined for now. Now we'll put another beforeEach, which will apply to everything in the handleIncreaseItemQuantity describe block. Now as you can see, with handleIncreaseItemQuantity it has three yields yielding a setItemQuantityFetchStatus and other predictable things before it gets to the point where it may yield one thing or may yield another depending on what the server responds as. So here, we can create a new instance of the generator. Then we can expect the next value to equal the put effect to set the item quantity status to FETCHING. And after that we can expect the user selector to be invoked. Now we'll write another expect, but here in gen. next it's important that we pass the mock user. That's because this is going to affect how the generator runs in the following calls. And we'll expect it to equal a fetch call to the cart add API. Now let's write our test. So this test will be what happens with the item quantity is increased successfully. So now at this point, gen has created our generator and brought it right up to the point where it makes the server call. So we'll expect gen. next, and here's where we inject the mock server response. For it to be successful the status needs to be at 200, so let's do that. And we know that if the value is 200, then all the saga will do will put a FETCHING status FETCHED action out to indicate that its fetch is complete. Let's make sure that runs. So that passes. And just to make sure it works let's change this to failing case. Let's inject a status of 500 here, but still expect that the next thing is item quantity status fetched. And as you can see we get a detailed error indicating that this is not the expected value, very good. Finally, let's write our failing test case. First let's change this back to 200. Now let's define another test, increasing quantity unsuccessfully. So as you can see, if the status response isn't 200, first it puts a decreaseItemQuantity to effectively reverse what's been done in the first call before putting the itemQuantityFetchStatus to FETCHED. So we'll expect the value of gen. next when status 500 is passed to equal a decreaseItemQuantity event of some kind. Then we'll expect the output of gen. next. value to set the fetched status to FETCHED. And there's ours test. Let's just remove this status:200 here, and we can run our tests by pressing the test button here in WebStorm or just by calling npm test in our terminal. So, as you can see, testing Redux Saga is very easy and highly precise. In the next clip we'll wrap up this module.

Conclusion
It has been a brief module, but one simply jam-packed with information. Let's review what we've learned. So the purpose of Redux Saga effects is largely related to testing, and it prevents the side effects of the application from actually occurring if it's not being run in the application. We learned that sagas must be written using call, if we want to test them, because doing otherwise would directly call outside APIs. We don't need to inject our dependencies or change our sagas in any way, as long we're using unit tests. We also saw firsthand how easy it is to test and effect against the expected value of the effect. Finally we learned that there is support for end-to-end testing methodology that exists thanks to a community of developers who are interested in finding other ways to test. And while this course didn't actually write any end-to-end test you are certainly encouraged to write some end-to-end tests in your own applications or even for this one. In the next module we'll summarize all we've learned across all the previous modules.

Conclusion
Course Summary
In this module we'll conclude this course. We'll start with a summary of all the topics that we've discussed. First, sagas. So a saga is a long-running thread, or function. Even though JavaScript has just one real thread, we still imaging sagas each having its own virtual thread. The idea behind sagas originated in banking, as a way of breaking one large locking transaction into several small non-locking ones. In JavaScript a saga refers to a special kind of ES6 generator, in that it yields Redux Saga effects instead of just promises or numbers or strengths. Next, let's review the key points about asynchronous ES6. So we learned that the yield keyword is a special keyword that can only exist inside generator functions. When the thing that's yielded by a generator is a promise, then the code stops executing until the promise resolves when it's being run in Redux Saga. The same is also true for co. You can use a while true loop to create a generator that loops forever. But, all generators stop execution if they encounter an unhandled error. Next is effects. Effects are created through Redux Saga effect creators, and when you invoke an effect creator all you get is a regular JavaScript object. When an effect is yielded inside of a Redux Saga application Redux Saga generates side effects. These side effects can include dispatching an action to the application or even making an outside API call using AJAX. However, if you yield an effect outside of Redux Saga nothing will happen, as it just a plain object. So by using effects wisely we can abstract all our side effects and other challenging asynchronous code into Redux Saga effects. Next is channels. Channels are there to help us with our corner cases, the tricky cases that we can't seem to solve with effects along. We saw that event channels can be used to handle WebSockets or another outside source who's purpose, like WebSockets, is to give us real-time data. And we also learned that action channels queue actions of a particular type so that you can't miss them. Regarding testing, we learned that unit tests verify what the value is of effects that are yielded by our sagas. Sagas are advanced manually during tests by calling next, and therefore a saga that's supposed to take a long time can be tested almost instantly. We learned that you have to use call in your sagas instead of yielding to API calls directly. Otherwise, it's very difficult to test them. And we also learned about end-to-end tests. End-to-end tests require injecting mock APIs and creating a mock store, and then testing the final value of that store against expected values. In the next clip we'll discuss ways that you can continue to develop this application.

Continuing Development of the Application
The application that we've developed over the course of this course is an outstanding example of how to build a shopping cart app using very few lines of code. Here are some ways you can continue developing the application. I strongly encourage you, especially if you have the time, to spend 2 or 3 hours after the completion of this course developing the application in whatever way you want. Here are some ideas. So you can add another page where users can view items and add different items to their cart. You can even add new items to the server side of the application to suit your own particular tastes. You can manage when the user sees the cart or the items by using React. And Redux Saga can be used to add the items to the cart. You can write some more tests. We only tested two of the sagas, but there are plenty more that could have some tests written for them. Writing tests is good since it makes you really have to understand what's happening inside sagas to do it properly. Next you can implement some end-to-end tests for this application. As you'll recall, end-to-end tests involve mocking a store and injecting API calls directly into your sagas. End-to-end tests are very cool and some people even argue that in this case they're more valuable than unit tests, so this is definitely worth spending some time doing. Finally, update the checkout screen to provide more information to the user. If there's not enough items in stock, how many more do they need to remove so that the transaction will go through. If they don't have enough funds, how many funds are they missing? I'd love to see what you come up with, so if you finish any of these subprojects, do mention it in a discussion or tweet at me so that I and other students of Redux Saga can see the great work you've done. In the next clip we'll wrap up this course.

Thank You
Wow, it has been a truly amazing course. I can say without exaggerating that I've probably learned more and been more challenged while preparing this course than any course that I've made before. I've learned a ton about Redux Saga as I prepared this course, and I hope you've learned even more while studying it. Life is full of distractions and it's very difficult to stick with a course until the end, but since you're watching this video I know that you've watched the entire course, unless of course, you've just skipped to this video, in which case, go back and watch any videos that you've missed. To the rest of you, I want to say thank you, and congratulations. By completing this course, you've shown to me that you have everything it takes to succeed in whatever web development career that you want, whether you aspire to be a junior developer or you're trying to become the number one CTO in the entire industry, there's no doubt that this course has been a great way for you to spend your time. So, if you liked this course, be sure to give it a five-star rating and to tweet about it. Also tweet at me, @danieljackstern, and let me know what you thought. I look forward for you to join us in my next course. For now, have a good day and keep on coding.
