Routing in single page applications like those written in React.js helps to display the right content and components, but static routing can be very limiting. In this course, Client Side React Router 4, you'll learn how react-router-4 offers far more capability with dynamic routing and provides a unique model for routing in React.js applications. First, you'll learn the fundamentals of routing in react-router-4. Next, you'll begin to put react-router to work and by nesting and testing routes. Finally, you'll dive deep into advanced route handling techniques with React.js and even handle routing state in redux. By the end of this course, you'll have a very good working grasp of React Router 4 and its new dynamic programming model, which will change the way you write React code.

Course Overview
Course Overview
Hi everyone, my name is David Starr, and welcome to my course on React Router 4. You can find me at ElegantCode. com. React is the fastest growing JavaScript framework for single-page applications today. As any React application grows in complexity, introducing routing is a great way to organize and modularize the components in your application. Even if you've used React Router's previous versions, you're in for a new world with React Router 4. This course is a must for anyone using routing or who thinks they might want to use routing in their next React application. React developers moving up from previous router versions will definitely want to code their way through this course because React routing is no longer static, it's dynamic. Dynamic routing is a whole new paradigm, and this course shows it in full effect. Some of the major topics that we'll cover include static versus dynamic routing, routes as components, nested routes and parameters, storing routing data in a Redux store, recursive routes, and by the end of this course you'll be ready to tackle your next React web app with confidence and organize it cleanly using React Router 4. Before beginning the course, you should be familiar with basic React web apps, webpack, and npm. I hope you'll join me on this journey to learn cutting-edge React skills with the Client Side React Router 4 course, at Pluralsight.

React Router 4 Is Different
Introduction
Welcome to this course on React Router 4. My name is David Starr, and you can find me at ElegantCode. com or @elegantcoder on Twitter. For this course, I'm going to assume that you're already familiar with building basic React. js applications. We'll explore React Router 4, a new technology to use in your React apps. React Router 4 is different than React Router 3, and different from pretty much any client-side routing system you may have seen. Combining the problem of routing with the power of React components will enable you to build sweet apps, like this one. I'm kidding of course. We'll use this application framework throughout the course and gradually add features to the application as we go.

Routing Basics
Let's spend just a moment on the fundamentals before we dive into React Router and examine what routing is in the first place. So what is routing? This is a typical URL we might see, this one points at a course on Pluralsight. Routing is using URLs to drive functionality of the UI. Some parts of the route may simply point at folder, other parts of the route may be passing arguments to a web page or server. The application may be dynamically loading pages or other components based on segments of the route. Some segments of the route may actually be arguments to the web page or components used to look up content from a database. Often the server reads the route and takes care of serving back an appropriate web page, but single-page applications can take advantage of routing to drive their behavior too. React Router, as you may have guessed, is a routing technology for use in your client-side React. js applications. Client-side routing isn't unique to React. This is a typical static routing setup for an Ember application. By convention, Ember has a routes. js file in which all routes are declared up front. React Router 3 worked this way too, using static routes. Note the nested route for /rentals/rental_id. This ultimately gives us a URL of rentals showing some number. The :rental_id is likely a database key. These configurations are read at application startup and are used to declare all feature routes that may be found in the application. All told, this is a good example of a static routing model.

React Router
For those who have used React Router 3, you're probably used to seeing code like this. Here there's a parent or master route which contains some child routes that build out the route via the path attribute. The component attribute tells the React application which React component to render when that route is encountered. This React Router 3 example is static routing, where routes are all configured ahead of runtime and typically in one place, just like the other static routing solutions. React Router 4 is accessed as an npm package that helps us use routing as a core part of our React. js application. React Router 4 is broken into 3 packages with React Router providing the core functionality. You should almost never have to install React Router directly. That package provides the core routing components and functions for React Router applications, but there are two packages that re-export the functionality of the react-router package and build on top of it to provide environment-specific capabilities. Unsurprisingly, the react-router-native package provides routing capabilities for React native applications. React-router-dom provides capabilities for client-side, single web page applications in React. This is where we'll be focusing in this course. We won't be looking at the native or isomorphic capabilities of React Router 4, and you may already be noticing that React Router 4 is a big departure from React Router 3. The configuration for React Router 4 will look familiar to you, but there are some major differences. A minor difference is no index route, for example, which we saw in the previous slide. A bigger difference is that we have two routes declared here inside of MyComponent. This means we don't have to declare all of our routing up front. React Router 4 takes a very component-centric approach in its design. All routes are simple components themselves. This enables very different scenarios for routing, which the creators of React Router 4 call dynamic routing. Users of React Router 3 would often set up a single JavaScript file to hold an entire route configuration, which would get pretty big and complex, thus isolating them to a single file. In React Router 4, routes can be sprinkled all throughout our application. We'll start to see how this works in the next module.

Summary
This was a quick start to our course. We examined what routing is in the first place, noting it can be a client or server technology. We looked at the fact that React Router 4 is distributed via 3 packages with the react-router package being the heart of functionality, shared by react-router-native and react-router-dom for web applications. We saw some examples of static routing, which is read at application startup and doesn't change at runtime. Lastly, we saw a small example of how React Router 4 changes this model and allows embedding of routes within components. In the next module, we'll quickly look at some of the more important differences between static and dynamic routing.

Dynamic Routing
Introduction
Hello, this is David Starr. We're going to start diving into Dynamic Routing with React Router 4.

Exploring Dynamic Routing
Before jumping all in on dynamic routing, let's look at some differences between dynamic and static routing one last time. This will be our last look at static routing. Well first of all, static routing really means that we define our routes up front, that is to say, before runtime. Dynamic routing declares routes that may be encountered at runtime and executed accordingly. Static routing declares routes as part of application initialization; they're read and held in application memory throughout the lifetime of the app. With dynamic routing, we can sprinkle routes throughout our application as appropriate. Because we've declared our routes up front in static routing, they're loaded before rendering actually occurs, and nested routes are accomplished by hierarchically arranging our routes so that they have children, and those routes might have children as well. But in dynamic routing, we nest routes with pattern matching, as we'll see in upcoming demos. And finally, in dynamic routing, routes are just components like anything else you might find in React. js. Now, enough about static routing, let's see how dynamic routing came to be. In the documentation for React Router 4, co-creators Ryan Florence and Michael Jackson describe their thinking about making the resulting routing model. And I quote, "It was only a matter of hours into development that we had a proof of concept that we knew was the future we wanted for routing. We ended up with an API that wasn't outside of React, but instead an API that composed or naturally fell into place with the rest of React. " The result is a dynamic routing system for React applications. Here's a basic dynamic routing scenario. We have an application here and the white portion containing the tabs at the top might be a containing component. Dynamic routing takes place as your app is rendering. So, a route is declared inside the container component. This is the same component that contains the links or tabs at the top of the page. The user clicks on tab 2, which links to a path matched by the path attribute of the route embedded in this component. This renders Component2. It's pretty much that simple. Now let's see it work for real.

Demo: Dynamic Routes
Show us some code. You got it! Let's take a look at dynamic routing in practice. The first thing we need to do, of course, for our application is bring in the package react-router-dom, and we'll do that npm install. There we go. And now we're going to go ahead and call npm start, which is just going to run webpack, our local dev server. We've got a good build there, excellent. Now we're looking at our app component. This app component is the main component that shows content in the white pane of our application. We want to replace the Welcome to the Course with a component that will be rendered by a route that matches the top level of our application. So to do that, we're going to start by doing an import HashRouter, which is a type of router in the react-router-dom package, and we bring that in by convention as Router. Of course we're going to need a route, so we went ahead and brought that in. Now one thing about routers is that they may only have one child, so we're going to wrap it around the div instead of replacing the div with it. And now, we need to add our route. We'll say Route, and then we have to give it a path attribute, which is going to match the root of our application, and then tell it what component we want to render, which in our case is the Home component. Watch up at the top, I'm going to use a feature of my editor here, my IDE, which is WebStorm, to insert my reference to that Home component. I'm going to be doing that throughout the course, so I just wanted to make sure you understood what was happening when I did it. Great! Now let's go have a look at our application. Alright! We're living that code life and we've got our Home component showing up. Let's look inside of our Home component. It's doing nothing more than rendering that image with a little styling, a very simple component. This will be our home page from now on, and one of the things we've already mentioned is that routes are simply components themselves, which means we can have more than one of them. In our case, let's just add four and see the application now has four instances of that route all matching against the root if we check the URL up at the top. Notice the hash that comes after the URL. This was present in React Router 3, and it's there now because we're using HashRouter. HashRouter is actually doomed to be deprecated in future versions of React Router, and instead we're encouraged to use BrowserRouter. Now if we save and look and at our application, we can take off the hash and we still have all of our images showing up and we don't have that ugly hash at the top. Now this is looking a little silly, so let's get rid of at least two of these routes, and I'm going to change one of them to match on the route of foo. And now let's go over to the URL that we just created, foo, and we've got two images showing up. Now why is this? It's because the first path is matching on the root and the second one is matching on the foo. So we have to be careful of partial matches like this. There are a couple of ways to deal with this problem. One is to add the exact property to the home root. We can come back over here and now see that we've only got one image, this one is being rendered by the foo path. Another way to do this is to add a Switch component around our routes. What this Switch component will do is return the route that matches first in the set of routes contained by the switch. So, if we look at our application again we see that one image is being rendered, and that image is being rendered by this Route. We'll take the foo away, go back to our browser, get rid of foo, and go back to our root, still getting just one image, which demonstrates to the effectiveness of that switch statement. So we'll go ahead and get rid of that second Home component, and now we want to add a sidebar link to link to our Home component. To do that let's go up to our Sidebar component, you can see there's nothing in there this time other than a className. We can bring in a Link component, which is going to come from of course react-router-dom, and we put in the to attribute, which in our case is going to be the root, and we'll just say Home here. Of course, we want to give it some style, so we'll give it a className of navLink, and now we have a link to our Home page on our router, and if we click it just takes us right back to this page. So if we go to foo, our route is still going to match of course, but when we click Home it takes us back to the root. Now you know, when we type foo into our browser, this route probably shouldn't be matching on anything even though it is by side effect matching on the route that we've declared in this switch. So, what do we do about this? We can add the exact attribute, you can add it this way or we can say true, go back to our browser, and see that foo give us a blank page. Our Home component is no longer routing. If we click our Home link, that takes us back up to the root of our application and we get our image. So the exact property is saying that the match for the route will only occur if the path is an exact match for the URL that's been put into our browser.

Summary
This was a quick trip through dynamic routing. Static routing is the traditional way applications declare and define routes. This is done up front and the route's load is part of the application initialization. Dynamic routing is different. Routes are just components and may live inside other components. As we'll see in futures demos, nesting is done through pattern matching within the path attribute of a route. In our next module, we'll take a look at the implications of client-side routing working along side server-side routing.

Client and Server Routing
Introduction
Hello, this is David Starr back again talking React Router, this time focusing on the differences between server and client-side routing. Now this is going to be a very short module examining how client and server-side routing must often coexist for our application to work. It's worth spending a few minutes on this topic because it's so easy to make this complex and it doesn't have to be. We already saw the difference between static and dynamic routing in single applications in an earlier module, but there are implications for routing that might typically occur on the server as well. Let's have a look.

Client and Server Routing
We're going to start by discussing server-side routing. A client makes a request to the server as is typical, the server processes the request in the running app, the server replies with a new HTML page, and of course that goes back to the requesting browser. Now this is how the majority of web pages work. We serve up an entire web page at once based on the request made to the server. Server-side routing is the most common form of routing outside of single-page applications and most web developers are familiar with this idea regardless of the stack they use. This typically depends on some middleware or framework that's used by the web server to service requests. In our case, we'll walk through a model of how this works. The client makes a request, here's a typical URI to which we're making this request. Now the server receives that request and then checks to see if there are any routes that match the URL being requested so that they can service the request by a predesignated route. When that happens the server executes some code, some things happen, and a response is given back to the client. The new page on the client was generated completely on the server and serves back out an HTML page with the new UI on it. Since you're watching a React course, you're a JavaScript developer. Now here's an aggressive route handler one can see in Node. js plus Express in a server-side application. In this example, all requests are going to be serving up a static HTML page from the public directory. The HTML file then calls out to the JavaScript and our client-side application is off and running. This is how we always, always serve up our single-page web application by always returning a single HTML page that calls back to it. In the server-side web application worlds, the downside is that a full web page is typically returned all at once. Using a React application, only those parts of the web page that need to change are updated. Speed is one big advantage of client over server-side routing. Client-side routing isn't a panacea, it has its pros and cons too. For example, some pros are that it's typically faster than server-side routing because in some cases it doesn't even need to make a round trip. Transitions between components are easier to implement, and of course it's easier to render partial views showing only those code elements on the page that changed. This means rendering only part of a page without getting the whole thing back from the server, so no round trip for the entire UI. Now cons. Often without doing something like code splitting, our JavaScript application is served up all at once on the first request, and that can be quite costly in terms of performance. Not only that, routing on the client can be more complex than it is on the server. Additionally, SEO may not work as well as it does when you've got server-side routing in place. And when we mix up route handling between the client and the server, things can get a little complex pretty quickly. So we're going to look at how a client and server typically work together to serve up a single-page application. The client-side routing is handled on the client-side application. The trick in order to do this is that two things need to happen. The server should server up the SPA application for any route that it wants the client application to handle. The client has to handle that route that the server chooses not to handle. Let's look at that flow. The user makes a request, if the React application is already loaded then the React app will respond directly, but let's assume for a moment that the React app isn't loaded yet. The server provides the browser with the HTML and the JavaScript that contained the React application. This allows route handling to be managed by the client and a response served directly from the client-side React app goes back to the requesting browser, but most applications are going to be mixed mode. If the client application is already loaded it will service a route if that route is known to the client. If the route is not known to the client, the request will pass through to the server. So we make our original request out to our single-page web application, the route's not known by the client, and so the request gets passed to the server. The server will handle the route as needed. This is particularly common in login scenarios where we're trying to serve up a login dialog. In this case, we'll likely choose a server route to handle the login page, and of course, the response goes back as a complete and whole web page all the way back to the requesting browser.

Summary
I told you this was going to be a quick module, and it definitely was. We talked a bit about server-side routing and how that works. We looked at some code samples where server-side logic served back a client-side, single-page application. We talked about how client-side routing often isn't going to handle a route and will pass the request down to the server, and this means that our server and client need to work together, which often means declaring routes on the server and on the client, but ensuring that they don't collide with each other.

Examining react-router Components
Introduction
Hello, this is David Starr back talking React Router 4. Now we're going look at some other functionality included in React Router that just makes life easier. Some of the techniques you'll see are new React Router 4 components and others are new capabilities of the route component itself. Let's jump in.

Demo: Prompt Component
React Router 4 gives us a component that we can use to prompt users when they attempt to leave our web page early. It's like asking, are you sure you want to navigate away from this page right now? Let's see how it works. Now the first thing we're going to want to do is add a link in our sidebar to the new component that we'll be putting in place. So we'll add a break there at the end of that line, and we'll name the Link just Prompt, and the Link itself will be the route prompt. And speaking of routes, the next thing we need to do, of course, is open our App. js and add a new route. So we'll come down and add that new Route, and of course we want to match on Route, but we don't yet have the component that we want to render. To get it, we'll create a new directory called prompt, and then I'm going to paste in a component that I've already created so you don't have to watch me create an entire component. We can go back to our App. js where we're defining the route and put in our NameForm component as the one we want to render on the prompt path. Now let's have a look at our application. We're prompting for completion of this form, enter your first name and enter your last name. So I'll go ahead and enter my first name and then I'll navigate back home. No problem, but I lost the data in my prompt form. So, if I type in David Starr and I click Home, I still get no prompt saying that I'm going to lose my data without submitting it first, which is what we want. I'm going to close our DevTools here as we don't need them, and come back into our editor. We'll head over to our NameForm component and look through it just a moment. In our state initialization, we're going to hold a firstName and a lastName, and then whether or not this component is valid. Valid means that I've got both a first and last name entered. We go down into our render, we can see we've got a FormControl and another FormControl for the last name, not terrifically interesting, and then we've go this onSubmit. Well, we've got a button here with an onClick event that goes our onSubmit function. This onSubmit looks to see if either first or last name are empty, and if they are then we're not yet valid. However, if the inverse is true, then we are valid and we get to take some action. In this case I'm just going to throw up an alert, but what we could do is we could call out to a database, we could redirect to another page, this could be part of a login sequence, whatever it is that you want to do when you take an action when you know that this state is valid. So how do we warn our users that they don't yet want to leave the page because their form is only halfway filled out. What we'll do is we'll add inside our div a new component, Prompt, we'll bring that in from react-router-dom, and then use the attribute when this. state is valid not equal true. Then what we want to do is provide a message, and in this case we'll simply say Leaving this form will lose your data, and then we'll close out that component. Let's head back over to our application and see its new behavior. We'll click Prompt, we'll put in David, but the form of course is not yet filled out, so I'm going to navigate back to Home, but before I do I get this warning, Leaving this form will lose your data, and that's the intent of the prompt component. If I click OK, I go ahead and navigate away. If I put in a little data, and then try and navigate away and hit Cancel, of course I stay on the page and I can complete filling out my form, and that's the prompt component.

Demo: React Component Properties
Now we'll look at some special properties that are passed down to React components if they're children of the primary router. Those properties are props. match, props. history, and props. location. Let's have a look at what that really means. Remember, our React components are going to get match, location, and history. Let's start by using the React DevTools that we can add as an extension to our browser. If you are a React developer you've probably used this already. We'll drill down through our Router and and then through our Switch statement, our Route, and finally we get to our NameForm, which is the component we created. Notice down at the bottom that we have the three Props, history, location, and match, and we can open up each one to see what values each contains. Match contains whether or not it was an exact match as per the property on the route, parameters is something that we'll get to in a future module, and we can see the path and the matching url. Now the path may be different because we may have arguments declared on our path, and again we'll look at this in a future module. But now let's open up location. We can see that we've got a key, a pathname, and search. Search, again, is a property that we'll look at in a future module as we take advantage of passing arguments on our routes. And finally, we've got our history property. Now the history property is basically the window history from the browser, and as such it's mutable. The location, however, is non-mutable, which is very important because in almost all cases we want to use this props. location property. If we drill down into history, you can see that it has a history. location property, which we could use to garner the information that we just saw. Again, history. location is mutable, so we want to avoid if we can. And we can actually look at these properties and work with them in a component. Let's do that. I'm going to create a new component, and we'll call it PropViewer. I'll paste in the implementation so you don't have to watch me type it all out. Notice that all we're doing here is we're doing a props. match decomposition, so we're getting match passed in as an argument to our PropViewer. Now of course I'm going to need to include a Link in the Sidebar, and we'll call it props. And over here, again, Props. Finally, just like always, we need to add that route. So we'll head over here. You know, we don't actually need this exact property, and we said that our Route was props and our component to render is PropViewer. Great! Let's head back to our application and take a look at our Props, and we will go head and leave the form. You can see that we've got our match. url showing up just fine. Now we can also bring in to our PropViewer the location, and let's use location. key just to see what value shows up. There's a unique key for the location that we browsed to. So we do have access to all of these properties right off of props. match, props. location, and props. history. We'll use props. match a lot in React Router 4.

Demo: Link and NavLink
You've seen the link that we've been using in creating our sidebar. It's a simple link. Now we're going to replace that with a new component called NavLink that react-router-dom gives us. Let's take a look at what advantages NavLink has over a simple link. Now the easiest way to change our links to the nav links is to simply do so like this, and we'll go ahead and import NavLink. We're currently using the className navLink for our links, and we've got a className property. We're going to have a new property called activeClassName and it's going to point to our CSS declaration of activeNavLink, and we'll add this to each of our NavLinks. Now let's see what that does for our application. First of all, you can see that the Home link is bold. Let's go to Props. Now you can see that the Props link is now bold too. This is all that the activeNavLink CSS class is doing for us, but should Home really be bold right now? Let's click Prompt and see what happens. Well, Props goes back to being normal size, but Home didn't. Let's go back to Home, we'll say OK, and you can see that Home's not changing for us. Let's go back to our code. And it turns out that we can add a property to this NavLink that works in tandem with our route. It happens to be the exact property, and that means that our activeClassName will only be applied when we have an exact match. Let's go back to our application. And now we can see that the Home is not bold until we click it, and now Props is regular size, and toggling back and forth shows us that our activeNavLink is working. So that's NavLink that works with the extra activeClassName attribute that simply looks at some CSS, and don't forget that exact property if you seem to be having trouble where the simple NavLink or className CSS is not being applied.

Demo: 404 - Page Not Found
You may have noticed before that we when we get a route or match a route or fail to match a route because one doesn't exist for the path we're calling, we don't get a proper 404 page not found page returned to us, we just get a blank screen. Let's see how to rectify that. First let's see what I'm talking about over in our application. If I go to localhost foo, I just get a blank page. We'd like to provide a better 404 experience here. To do that, we're going to simply drop in a new component, we'll call it PageNotFound, and I'll just paste in the code so that you don't have to watch me type this all out. All it'll say is Page Not Found and include an image from our assets folder, but we do need a route to make sure we're matching paths that don't exist. So to do that, let's take a current Route and remove from it the path, and then give it the component of PageNotFound. Let's go back over to our browser and we can see now that we have a nice 404 error page. If I come up here and change this to bar, we'll see the same error page. So that we can link to easily, let's add to our links in our sidebar. So we'll go to our Sidebar and duplicate that line, and we'll say this is going to be link to foo, and we'll do a page not found, or Not Found. If we come back over, of course, we should have a Not Found menu item, we'll go Home, Not Found works great. But you know what, I'm starting to get a little dissatisfied with our Sidebar code. This code repeats itself several times, violating the don't repeat yourself, or DRY, principle. What can we do about that? Instead of watching me type it all out, I'm going to paste in the solution here. We'll make an array of our links and render them through a mapping function and show them as an unordered list. Now the one link we won't do that with is our link to the root of our application, and the reason for that is it has the exact property on it and the others don't. Let's take a look at our browser and make sure this is working. Oh, it doesn't seem to be. It looks like we forgot to add a className, so we need a className of nav. Now let's take a look at our browser and it looks like we're good to go again. Alright, it looks like we're living that code life with a nice refactoring.

Demo: Render Property
You may have noticed that all of the routes we've used so far have rendered components that don't have any properties associated with them. They're not expecting any properties in their prop types. So how do we get around that? We use the render property of the route rather than the component property. Let's jump into our browser first, and then we'll code that up. Notice that I've added Color menu item. When I click it, I just get our 404 Page Not Found error. Let's add the component we need, and then the route to support it. The first thing I'll do is create a new directory, and we'll call it color, and within there I'll go ahead and paste a component that's already configured, and notice that it's looking for the properties of color and text. It uses color simply to change the background color of a rectangle that will render to the page and it uses props. text to add some text to the page. It's also going to show us match. path. But how do we create a route that's going to render this component properly? Well to do so, we'll first match our color route, we'll say color. And you might think that we would do something like put ColorSwatch in here, and then add the properties of text= foo, and that would pass that property right along to the component; however, it doesn't work that way. Instead, we're going to use the render property. Now the render property actually takes a function as an argument, and within that function we return the component that we want to render. Here we're able to add our properties; color we'll add as red and our text property will render also as the word Red. Let's see if our component is rendering. There it is. When we select Color in our navigation, this is exactly what we would expect to see. So remember, if you have a component like ColorSwatch that we need to pass attributes to, we use the render function that takes a function and returns the component we want to render.

Demo: withRouter
Those among you paying really close attention may have noticed something odd about the ColorSwatch component. What we've done here is set it up so that we can pass our standard property types of color and text to the component, but it turns out that when we use the render property of our route rather than the component property of our route, the component that we return does not get the match, location, and history property off props automatically. The way we deal with that, we go into ColorSwatch here, is the withRouter higher-order component. A higher-order component is nothing more than a function that takes in a component and returns another component. What it does is add the location, match, and history properties that we would get if we were to render with the Routes component property. The withRouter higher-order component works at any level below a given route and returns the properties from the route under which it's located. This can be an embedded component, three, four levels down even, within a component hierarchical tree. If we wrap our export with the withRouter, we get access to those things that we're used to. Now remember, we had a perfectly working ColorSwatch here, red showing our path, which is color. Let's go back to our editor and remove the withRouter higher-order component. We'll hit Save, head back to our browser, and notice that we've now got an error and we're not rendering anything. We can see where we were trying to read the property path of undefined. So, what's undefined? Well of course, match is undefined in our props. match. path, so if we add our withRouter back to our ColorSwatch, head back to the browser, and we now have our component back. Wrapping our component with the withRouter causes something a little different to happen in our rendering tree. Notice that we've got a Route here, I'll put this out so we can see it better, we've got a Route here, and this is the one we're matching on, color, of course. If we open this up we can see that we've got a withRouter component that's holding our ColorSwatch, and it currently has only the properties of color and text, those are the ones we passed in of course. If we open up one more down, we can see that there's another Route here, and within this Route we have the actual ColorSwatch. Now we have our history, location, and match. So remember, if you don't have access to those properties, it's very easy to get them so long as your component lives under a route by using the withRouter higher-order component.

Summary
We saw a lot of new things in this module. Prompt component can be used to prompt a user to stay on a given page when they try and navigate away. A great use case for this is when is someone is filling out forms. You saw that unlike the standard Link component, NavLink has the extra property of activeClassName that can be used in our CSS to differentiate a link that is currently active. For situations where users hit an undefined route, you saw how to handle that with a custom component using a simple route with no path property. This enables us to give a custom page back for a 404 error. You also saw how to pass standard properties to components using the routes render property, which returns components from a function. And finally, you saw how the withRouter higher-order component can pass the route properties down to child components, giving them access to match, location, and history properties.

Putting react-router to Work
Introduction
Hello, this is David Starr back again to talk about React Router 4. This module is going to be very demo-heavy, and we'll look at creating some custom links and routes. You'll also get a look at how we might handle log in or security in a React application with the help of React Router. Let's dive in.

Demo: Custom Links
React Router 4 depends a lot on composition over inheritance, and with that in mind we're going to create custom link. Now why would I want a custom link? I might want to log an event ID, say from the click event into our linked tracking system. Looking at our browser, you can see I've already added a link in the sidebar to the Logging component. So we have a Logging Home with a Link 1 and 2 and some Front Matter that shows up from a child route. Let's take a look at that code. Well of course I've already added our Route, and here is our LoggingHome component that's being rendered. We'll jump into that component and see that we've got something pretty simple here, we've got a pure component that we are bringing in the decomposed props. match. Here's something that's a little bit new. We're using match. url in a templated string, and the reason we might do this is so that we can always match the current URL that would allow us to pass around this component to different places within our application. So if we look at match. url in our DevTools, we can that we get the /logging path, which is exactly what we see up here as our URL. I'll go ahead close that and we'll jump back to our code, and see that we're just using standard links here, so we're using a React Router Link with a to, and then of course after the lorem we've got a special and unique ID. Now, if you were really doing logging in your application, your links probably wouldn't end in a unique ID like this. You might take advantage of the data- HTML5 standard or a special attribute holding this ID, but for simplicity's sake, we're going to handle our unique IDs like this. We have a very simple LoggingDefaultMessage component. It's a pure component that does nothing more than return an h3 and a paragraph with Front Matter and Lorem ipsum. So we'll jump out of that and look at a little bit more interesting part of our application, we're going to build out our links here to be links that would log that event ID should we choose so. So, I'm going to create a new JavaScript file, and we'll call it LoggingLink, and I'm going to paste in the implementation so that we don't have to spend a lot of time looking at me type this out. Let's start here. Here we're going to return an actual standard React Router Link that we would get from react-router-dom. Remember I talked about composition, so our LoggingLink is going to contain within it a standard React Router link, and that's where we're going to get our functionality. We'll go ahead and spread this. props across our Link, that's going to give us the to attribute, and then we'll put in our onClick handler, which will call this. handleCLick for us. Now we need something to put in as the text of the Link. What goes here? Something to go inside of our Link. Luckily enough, all we have to do is reference this. props. children, which will provide for us all of the children material that was in the Link up at the higher level in our application. It could have held tags or just text as ours does, but this where we get our Links 1 and 2. Let's see what handleClick is doing for us, and the answer is not too much. We're just splitting on our url delimiter, and then we're getting our eid, or event ID as we'll call it, and then we're sending out an alert. This is an approximation or a simulation of doing any kind of work we'd like to do. This could be logging an event or anything else one might imagine. In our case, we're just going to show the work by sending out an alert. The last thing we have to do is go back over to LoggingHome and change our Links to LoggingLinks. We'll need to bring that in as a dependency, and then add LoggingLink to our second Link, and we should be good to go with our LoggingLinks. Let's see. Here we are in our browser, we're looking at our Logging Links, and when I click Link 1 I get a message that tells me the Link is going to this unique identifier. Perfect! We say OK, and the link finishes its job of navigating to that link. We can click on Link 2 and see the same behavior, this time with a different unique identifier. So we have our own custom links that do their own custom work, and this is how you can extend links and many other React Router 4 components to give custom functionality to those out-of-the-box components that we get from React Router. And in our next demo, we're going to do a similar thing, only this time with a route.

Demo: Custom Routes
Now we'd like to create a custom route, and with custom routes we can accomplish all sorts of tasks. In this case, we're going to simulate that logging event again, but remember, you can do all kinds of different work. Let's head over to our code. I've added a Lorem component to our folder, which we'll look at a little later. It doesn't do very much, it just shows some information about the destination we've landed on. We're going to link to it from our new route. So, here I'll create a custom route, and we'll create JavaScript file to hold it. We'll call it of course LoggingRoute since we have a LoggingLink, and here we're going to do some interesting things. We're going to create a component, as we said, called LoggingRoute, and it doesn't need propTypes from us, I was using a little template there that I created, and instead of props, we're going to do something that you may not have seen before. We're going to put in an object. The object is going to have a component, and we're going to name this component ComponentToRender because that's what we'll be doing with it, and then we'll take those JavaScript properties and spread them out, oh, we need a comma here, there we go, across the standard route that we'll be creating. And remember how we wrapped Link inside of our LoggingLink, we're going to do a very similar thing here where we create a Route and we'll go ahead and put those rest properties in place. Now we're going to render. Remember the render attribute of a route? It lets us pass parameters to components that our Route wants to render, but it does so with a function. So we can say equals, and then kind of throw in our function declaration here. We'll just use a simple alert again to simulate that we're doing some work with inside this render, and then we'll return our ComponentToRender, and I forgot to take props in as an input arg to our function. And now that we have them, I'll go ahead and spread those props across our component that we're rendering. It looks like we need to include a reference to Route from react-router-dom. Now we should have our LoggingRoute all ready to go. Let's head back over to our LoggingHome and we'll throw in our LoggingRoute. So we'll change this to a LoggingRoute, bring in that component, and we'll do something significantly different here in our string template. We'll say lorem, which is going to be a good match for our route, but now we're going to declare a parameter, and we do that with the syntax of colon, and then the parameter name, which in our case will be eid, or event ID. This is the first time we've seen parameters on our routes in React Router, but this is how they're set up. If you've seen similar routing mechanisms, they tend to look like this. Node. js, for example, with Express declares route parameters in this way. We can take off the exact property and we'll throw our Lorem component in here as the one to be rendered when we hit our LoggingRoute. Now let's not forget what our LoggingRoute is going to do. It's going to do a little work, which is that it's going to alert us to something I didn't show very closely a moment ago, and that is we're going to be pulling the event ID off props. match. params. eid. So match has a params property which is going to hold all of the named parameters that we might include in our route, and then we can just call them by their name, in this case. eid. After we get our alert, we should be able to see the results of our Lorem class, which is going to show us our match. params. eid, which we were just looking at. We'll see the requested path, which will give us an idea of the difference between match. path and match. url, and finally, a Time Stamp just to show that we're changing screens as it can look a little similar as we toggle back and forth. Now just to clean up, we'll get rid of that prop-types import. Let's head over to our browser to see if this works. I'll reload the page, we've got Link 1. We remember that this coming from our Link, clicking the Link is Logging our event ID. Okay, great. We'll say OK. Now we get another pop-up, another alert, this is the one we embedded into the route. Route is Logging the same unique ID. We'll say OK. And now the Lorem component renders and we can see the unique ID, followed by our path, which in this case shows us the :eid parameter. Were we to look at match. url, we wouldn't see the parameter there, we would see the unique ID as part of the original URL that it was being linked to. We can go ahead and go to Link 2 and go through the same flow. Of course there are a lot of different things we could be doing inside of our render function than just throwing up an alert. We might, for example, want to log whenever a route is triggered or in some way keep track of it for use in Google Analytics or something like that. Next we'll see how we can use custom routes in a security situation.

Demo: Private Route
What about protecting an area of our site that should only be available to logged in members? We mentioned earlier, this logic could happen on the server, but it can also be done through async calls to services and visually managed on the client. Let's see how we might protect a route using React Router 4. Here we are back in our application, and I've added a menu item called Private over here in our sidebar. If I click Private, however, I get a Page not found 404 error and we need to add a route and component to render at the private URL. Before I add the route, note on the left under the secure directory we already have several components laid out. The components that we have laid out really are content components and don't have much to do with the security of them at all. We are going to secure them up though. To get started, we'll create a Route called private, this will match the URL that's being requested, and we want to bring in the ProtectedHome component. Let's go back to our browser and see that we actually do have content at the private URL. So this route is rendering the Protected Page, and we can click Child 1, Child 2, Home, but this Sign Out button doesn't even make sense yet. If we click Sign Out, we're going to go to a sign out page or a logout page that doesn't actually exist yet, and we'll eventually get to that because we need a route to handle that logout page. We'll get started by adding a very special route, and it'll be a private route. To create it I'll come to secure, we'll create a new JavaScript file, and we'll call it, of course, PrivateRoute. We'll need to import React from react, and then declare our component, it'll be const PrivateRoute, oh, I've got a typo there, equals, and we'll use the implicit return for a component here. Finally, we'll export the default PrivateRoute. The magic, of course, is what goes in between these parentheses. Now this is a function, so let's set it up so. Remember that in our arguments to our function, we don't have to just take props, we can take an object. In this case, we'll take an object with the property of component and the value of that will just be Component. This is our component to render, just like we did earlier in our logging example. And then we spread our JavaScript rest attributes across our object, and we're good to go with the more interesting things. The next thing we're going to do is declare our route. This is the Route that we're wrapping to get the real route functionality we need. We'll bring it in from react-router-dom and the first thing we may as well do is spread those JavaScript properties across our Route, and then we'll take advantage of the render property, which itself takes a function if you'll recall. And again, we'll make use of the implicit return of a component syntax here. Now, we'll pass in props, but the next thing we're going to do is a little different. We have a service, and we'll call the authService. isAuthenticated. Now if this is true, then we'll let things proceed as they should, we'll let people into the protected route, if it's not true, then we won't. Let's take a quick look at this authService though so you can tell what it's doing. It is an emulation of real a authService that one might call. All we're doing is we're setting a cookie on the client. If the cookie's there, you're authorized, if the cookie is not there, you're not authorized. Simple enough. So, if we are authenticated we want to return the Component that we took in our object up top. We're also going to spread our props across that Component. The next thing we might want to do is handle the case where we're not authenticated. Well, what would we want to do here? Well, we want to Redirect someone to a different URL. In this case, we're going to Redirect the unauthorized request to the login page. We need to bring in a reference to our Redirect component, and now I think our component is good to go, but we do have to remember to add it to our app where our Routes are declared. So, we'll just call this PrivateRoute, import it, and we should be good to go. Let's see what happens in our browser. If I go Home, we get a good rendering. If I go to Private, we get redirected to the login page, which is exactly what we wanted. We want to have to go to that login page anytime a request is made and the user is not yet authenticated. We'll just drop in our Logging component so you don't have to watch me type everything out. In our state we're holding whether or not someone is logged in. We come down to our render and we determine the target location we want to redirect to in the event that the user is in fact logged in, so we do a Redirect to target. We have a Form down here, of course, where people can input their Email Address and their Password to log in to our application. And then we have a very simple login method that gets called from onClick of the Form Button, which signs into our authService and sets our state accordingly. Now the last thing we have to do here is go back to App, and we will need a Route to handle the login path, and of course, the component we want to render there is Login, and we'll import it and head back to our browser. We now have a login page where I can put in my email address and a password, and I can sign in. Now what happened here? We went to protected, that's not what we should've done. I know where our problem lies, and it's up here in our Login page where instead of directing to protected, we should be directing to private. So let's go back over, and we should be logged in, hit our Private link, and in fact we do get to view the content that would otherwise be protected. Now we can hit the Sign Out button. Sign out takes us to a logout page that doesn't yet exist. Let's bring that component in. This is a very simple component that I'll just drop right into place. All we're doing is taking advantage of the componentWillMount lifecycle method, and we sign out any time anyone loads this component, and then redirect back to the login page. But of course, for this to work we actually have to give it a Route. This will be the logout path and the Logout component. We bring in a reference, go back to our browser, and try this workflow. So we'll go to Private, we have to put in our credentials, and hit Sign in. Great! We can see our content. We can browse to Child 1, Child 2, and we can even hopefully sign out, which takes us right back to our login page, which is exactly what we wanted. There is something that we could improve upon, and let's go back in to the application to see what that is. We'll put in a Password, sign in, great. Now I'm going to navigate to Child 2. If you look at the URL, we are trying to access the root/private/2. I'll take this and put it in my paste buffer so that we can emulate the idea of creating a bookmark; we want to be able to bookmark to this page, which we currently can't do. Let's prove that. We'll sign out, we'll go to Home, and put in this page. Now since we're on the private route, we should get our login page, which we do, excellent. Again, I'll go ahead and log in, and what happened? We went right to our Home page, we didn't go to the page we actually bookmarked or wanted, which was the Child 2 component. This is easy enough to deal with. Let's go back to our PrivateRoute. In our PrivateRoute we're currently telling our Redirect no matter happens, we always want to send our user to the login page. I'm going to replace this with an object that has in it a pathname that again points at the login page, but it also has some state, and that state is an object that contains a target, which then brings in our props. location. So, our login location state is going to be different. Let's see the impact on our application. I'm going to sign out. I'll come up to our nav bar and put in our private/2 route. Of course we get challenged with a login, and I'll just log in real quick here and put in our password. And boom, we get taken right to that Component 2, which is what we wanted. Excellent! Now we have a login page that protects all of the components and routes underneath our parent route and allows us to bookmark a page so that we can go there later even if we get challenged by a login page.

Summary
Wow, that was a pretty big module. First, we took a look at creating our own custom links and we showed that we could perform some operations or write some code in the middle of a linked transition. We also saw that we could do similar things with our routes. We can execute code as our routes are executing so we can do things like perhaps log the fact that someone went to our route. We got our first taste of adding parameters to our routes. If you'll recall the :eid, or event ID, that we used. We'll see more of that in the upcoming module. And finally, we saw how to create our very own secured route so that we can protect parts of our website and restrict them just to members who should have access.

Nesting Routes
Introduction
Hello, and welcome to the Nesting Routes module of the React Router 4 course. This is David Starr, and I'll be discussing how we extract arguments from routes and pass them throughout our applications. This is pretty quick and easy, but it is the heart and soul of route parsing, so let's get started.

Route Parameters
Here's the simple Route with two parameters, firstname and lastname. Route parameters are designated by a colon in the path attribute of the Route. Getting access to these params is very straightforward. You can access the route parameters in the string returned by props. match. params in our rendered components. The match object provides easy access through the child property of params, and then we just use the same name you gave the parameter to access its value. Notice there is a /bio at the end of this Route match. This enables us to do something like match a biography component without making that the first thing people see when they look at your URL. Essentially, this means we can embed parameters into our routes any place we wish.

Demo: Multiple Route Parameters
I'm going to start simply by parsing some route parameters and seeing where that takes us. I'm going to go back to our color example that we used earlier in the course. Let's dig in. Here we are in our application that we've been using the whole time. We're at the Home page, and if you'll recall we had a Color link. We used this as an example for rendering from a path, being able to pass properties to a component that we want to render. I've gone ahead and added a menu item called Smart Color. When I click Smart Color, if you look up at the top of the screen you can see the URL that we've linked to. But what's going on here? It says Green, and then gives the hex code of green. Why aren't we seeing that? And in fact, why aren't we seeing red? We should probably be seeing a 404 error right now. Let's take a look at our app. If we start by opening our App. js, we can see our reason right away. It's because we're actually matching on the path of color, so this Route is firing, rendering the ColorSwatch that passes the text of Red and the color of red. So, let's go ahead and add a new Route so that we can get the behavior we want by using route parameters. We'll say color, then we want the text as a parameter for what we'll render to the color div, and then we want the color of the div. And of course we're not going to use the LoggingHome component, we'll use the SmartColorSwatch component; you haven't seen this yet, let's dive into that. You can see up in the inline style that we're using match. params. color. Down near the bottom in our return where our jsx is, we can see match. params. text. That'll show up inside of an h2. Inside of an h3, match. path will be rendered, and that should show us not the URL, but the path with the parameter arguments defined within it. Let's jump back to our application. Look at that, we now have a green box that says Green, and you can see our path there, /color/:text/:color. It works just as we thought. Now, what if we were to change this to LightGreen? There we go. It renders just as we would expect. Or what if we change this to yellow? We're doing it all through the use of route parameters. But here's a behavior I want to draw your attention to. If we come back over to our app and look at our Route, we can actually take away the color. Even though we're matching on that now, we can match on /:text/:color, the /text param will be at the root of our URL. Let's see what that looks like. So currently we're rendering color, light green and yellow. One thing we can notice is that the text reads color. Well what are we seeing here? Let's parse out our URL. The first thing it gets matched on is the text that's going to appear in the box, which happens to be color. There we can see color right there on the screen. The second thing that will be parsed out is the color that we would like the div to be, the box, it's light green. The yellow hex code is no longer a parameter, light green is the color parameter, and our inline style is taking that as a directive. We can get rid of this by taking away color, and we go back to our LightGreen with yellow, we should probably at least put Yellow in there as the text. The point we're making here will be more obvious if we go back to our Route. Again, the Route is matching on /:text/:color. Well, if we add our color back in, hopefully we'll go back to what we expect, and I click Smart Color, and look at that, we have Green back and we have a complete path, and we can see that in our URL string at the top of the browser. So we have to be somewhat careful about the order of our routes and how we structure them to receive parameters.

Demo: Parameters and Nested Routes
Now we'll get just a little more involved in how we parse routes and and other parameters that are coming in from our URLs. We'll look at nesting parameterized routes and how to deal with query strings. Let's get to it. We're starting from our Home page again and notice that we now have a People link in our sidebar. So I'll go ahead and click that, and as usual we'll find a 404 error because we haven't yet implemented a route that will link us to a component for /people. Let's add that route. Here we are in our App. js where we've been defining our routes, our primary routes at least. We'll go ahead and define a new one for people, and the component we want to render here is People. I've already brought that component in and we'll walk through it in just a moment. First, let's look at the results of adding the Route. Look at that, we now have a nicely rendered table, and some people's names who are Pluralsight authors, and we can even delete and add people to and from the list. So, call myself an author for Pluralsight here, and there we go. We can exercise this web page. Let's have a look at the component behind this page. This is all happening in the People component, which I've already included in this project. Let's walk through what's happening. Firstly we set up state, and we need a list of people, but we're going to initialize to an empty array. Then we need a Name and Occupation in the event that a person is going to add a new individual to the list, that's all that's there to hold, not very interesting. In our componentDidMount though, we're making a call out to an API that we've initialize up at the top underneath our imports. Let's look quickly at this API so you can see just how complex it is, which is not at all. It's just simply a class with a function that returns an array of the people that we're seeing on screen; it returns their name and occupation. Moving further down in our code file, we can see that we're building a list of people using the JavaScript map function to walk through that array and build up that list. We'll come back to that in just a moment. First notice the simplicity of the table that we're rendering. We've got a Table, it has headers, and then we're inserting the results of that people mapping function. Down at the bottom, we can see the components that allow us to add a new user or a new name to the list. And finally, there are functions that respond to events like an onDeleteEvent, onDeletePerson, onNameChange, onAddNewPerson. These functions I'll let you explore on your own, they're not particularly germane to React Router. But let's scroll back up to our mapping and see what's going on in here. First of all, we're creating a linkUrl, and this is a big URL. First we're matching against the current URL, which is /people, and then we're matching against the person's ID number, this might be a database lookup key, which in this case is just person. id. And then we're doing something new, we're passing query string parameters. Here's our question mark, our name equals the person's name, and our occupation, of course, equals the person's occupation. Well this is a big URL and we're embedding it as a link around the person's name. Here we're creating the entire table row that's needed for each person. We'll see their ID, their name as a hot Link, and then the delete button should we choose to click that. Back in our browser, we'll click on Scott Allen, and we can see the URL that's being called there. The first thing we need to do is match against his ID number, /people/2, and we can do that with a new route. Let's add it to App. js. Okay, we're going to add our second people route, and it's going to match on the Route parameter of id of course. The next thing we're going to do is specify the component we want to render, which in our case is PersonProfileContainer. Let's look into this component. The intent of this component is simply to fetch a set of programming languages from a JSON file. It does that in componentDidMount through an HTTP request, and then sets those languages in state. Now that we have them, we can pass them to the PersonProfile component through its languages attribute. Let's check out the PersonProfile component. And there are a lot of things going on here, but let's look at the basics. First of all, we want to render a name and occupation at the top of the screen. Ultimately we'll list the programming languages that this person understands and knows. Now in this div we just have an image, that's a placeholder image that might be of that person, and some Lorem ipsum that could be description of their career, hobbies, what have you. Notice at the top that we're setting name and occupation to null, so that when we follow our link we're not going to be rendering anything. Let's see what that looks like. Okay, back over here in our People route we're going to click on my name, and you can see that in our URL at the top we're getting our /1, that's our ID parameter on the route. We then have our query string parameters of name and occupation that come next. Now as we said, the first thing we'd like to do is add the name and occupation at the top of the screen. Let's head back to our component and see how we can do that. We know we won't be wanting to set these to null, so let's don't. Let's instead look at the following code. As you may imagine, we want to parse the query string, and JavaScript provides a URLSearchParams function to let us do that. Remember that props. location. search will contain our query string parameter, this is coming straight from React Router, but it turns out that the URLSearchParams function isn't compatible with some browsers. If we have a look at what browsers it's compatible with, we can see that Internet Explorer has no support for the function and Safari has questionable support for the function, so we probably don't want to go with that solution. I'll leave this code here for you to inspect when you pull down the code for this module. Next let's open up a better way of getting those query parameters. Here we're using querystring. Querystring is available to us from the query-string package we import. Let's go up to the top and look at that import. You can see that we're importing all as querystring from query-string, that's just an npm package that we installed. So we're parsing props. location. search and getting the query string parameters from it that we need, name and occupation. Let's make sure that our component is still rendering name and occupation as we want. It looks like it is. Let's check out what's going on though in that location. search. We use our React dev tools and drill into our application, coming to our PersonProfileContainer. We'll go down one more and look at PersonProfile itself. So here we are at PersonProfile, and now we can open up the languages, and you can see that we have the languages that came in as a parameter to Props, but we're interested in location. search, which contains our query string parameters. So this is the place from which we parse our query string parameters, and remember we're doing so with the query-string npm package. Great! Now we want to see what programming languages each person knows. We'll add here a component that I've already created for us, it's called the LetterList, and this will provide a list of letters from which we can choose to see the languages that this person knows. We're passing in our Programming Languages as a prop, our name of the person as property, and the occupation of the person as a property. Let's take a look and see if our LetterList is rendering. And there it is, right at the bottom of the page. We can that our letter list is showing A through Z, so there must be a lot of programming languages that David understands. Now we want to be able to click one of these links and see the list of languages that David masters. We're going to do that with a new route. Just below the LetterList, we're going to include a new Route, and this Route will use its render property to render a component called LanguageList. We'll look at LanguageList in just a moment. First, let's take a look at the path that we've created. Well, we're matching on props. match. url, and right now that looks like this, people/1, or some ID, and you can see by the route that it will be languages/, some letter, perhaps S. So if we get a match on that Route, then we're going to render the LanguageList. Let's take a look at what LanguageList will do for us. First of all, LanguageList is bringing in the letter that we're clicking on via a Route parameter. We have a componentWillReceiveProps where we do the same setting, and this is just to prevent an oddity in React where we would have to double-click the first letter otherwise. In our render function, we have a dirty little secret. It turns out that David along with all of the other programmers are going to know all languages, so this comes from the getKnownLanguages function, which simply loops through and returns all of the languages that start with the given letter we've clicked on. Once we have those languages, we use JavaScript's map function to build up a list and a link to that language on Wikipedia. Let's see all this in action. Looks like we've already clicked on D, let's click on H, M, and O. You can see there are a lot of languages out there. If we click on Object Lisp, we get its Wiki page, and this is true of any language that you might click on. The interesting parts of what we've done here are present in the URL at the top. We've defined a route to people/id as a route parameter. We then had the word languages followed by another route parameter, which we defined as :letter. We then pass a query string with name and occupation, and we parsed that query string with the query-string npm package. That was a good trip around working with route parameters and with query string parameters.

Summary
All in all, that was a pretty good module. We saw how to handle multiple URL parameters even when they're not next to each other in our route string. Remember, we had the word language between our route parameters in our URL. Then we got to see the right way to parse query string parameters with the query-string npm package. In the next module, we're going to look at how routing can work with Redux to store state.

Integrating Routing with Redux
Introduction
I'm back. David Starr here talking React Router 4, and this time we're going to be integrating our React Router state with Redux. After all, if Redux gives us a place to store all of our state data, isn't our routing data just as valid to be in the Redux store? One of the main reasons people want to store their React Router state in the Redux store is for debugging, time travel, and other things provided by the Redux DevTool's plugin browser that we'll be using. Let's get started.

A Quick Lap Around Redux
We have a demo coming up, and in it we'll use the Redux DevTools Chrome extension. You'll see that we need to plug a little middleware in for this tool to work properly and we would probably only do that in development environments. That said, it's well worth it as I think you'll see. This is a really cool tool for debugging, fast forwarding, and replaying your actions in a Redux application. If you're watching this module, you may already have some experience with Redux, but we're going to take a quick lap around the model just to ensure we're all speaking the same language. I'll start with the store itself. The store is the source of truth for all state. Think of it as an in-memory database for all of your application's state data. React components subscribe to changes in state that occur in the store. State changes are passed down to components as properties. Sometimes when working with this pattern the components are called views. Components dispatch action requests to action creators. Action creators are exactly that, functions that create actions. In Redux, action creators simply return an action object. React components that have a reference to the store can call store. dispatch, passing an action creator. So our action creator has just created an action; that action is usually just a small object carrying a lookup key and some state. Actions are payloads of information that send data from your application to your store. They're the only source of information for the store to change its state. Reducers inspect the actions that have been dispatched to see if they need to do some work. If an action triggers a reducer, the reducer changes the state in the store according to the new state action. The reducer is a pure function and returns the next state. Reducers never mutate state, but instead create new state and pass it on to the store. That's pretty much a round trip around the model. Once the reducer has a new state ready, it gets picked up by the store and that completes our loop around the Redux architecture. For more information on Redux, there are several really good courses in the Pluralsight library.

Demo: Router State in a Redux Store
We already have a Redux application in place and it's a departure from the application we've been using throughout the rest of this course. So let's first take a quick tour so you know what the application looks like, and then we'll start changing it to modify our store to keep React Router state inside it. Okay, here is our super simple Redux application. As you can see, we're still living that code life, so that's a good thing. All this does is give us a list of people and places. In both cases, we're able to add new records, I'll add My House as a new place, and we can delete things. I'll delete Mr. Burn's house. If we pop over to People, we can see Bart Starr; he's a bad student. I'll add myself in here, David Starr, and my occupation will be, in fact let's just say a Pluralsight author. We can add that person. So that's really all there is to our application, places and people, and we can add and delete them from our tables. This is a Redux application, so let's take a look at that base architecture so that we can then get into adding React Router state to our Redux data store. In this application everything kicks off with index. js, the root file from which we start crawling the rest of our application to assemble a bundle. We've go all of our imports up here at the top and we're using BrowserRouter as our router. Here's our App component; it's wrapped by our Router component. Before we get there, let's have a look at initialState. InitialState is nothing more than a couple of arrays on an object, and that gets loaded by this import statement. So initialState becomes what will feed into creating our store, which is what we do on the next line. We create our store by passing in our reducers. If you're comfortable with Redux, this should look very familiar to you. We'll just pop into reducers and see that we have a peopleReducer, placesReducer, and then using combineReducers we put those together into one single rootReducer that is then returned and used as this reducers object that we're going to pass into createStore. So we pass in our reducers and our initialState, and then go ahead and mount our application. Notice we're passing store as an attribute to our App component. Let's see what the next level down looks like. It's a very simple application with only three Routes. First we have our Header. All that header does is allow us to toggle back and forth between places and people, so not very interesting. We have a Route for our root path, which takes us Home where we get to see that code life. Our people Route, of course, takes us to our PeopleContainer component to which we pass store as a property, and the same thing is true for our places Route and PlacesContainer. Now let's see what we can do to change how the application behaves so that we can put our React Router data into our Redux store. The first thing we're wanting to do is add some new packages to our package. json. React-redux gives us a provider. This is a wrapper that makes the Redux store available to all connect calls in the component hierarchy below. This library helps keep our route state in sync with our Redux store. And history, we have to provide a history to the new router component that we're going to be using. This ensures that our routes will stay in sync with our location in our history in our store at every moment in time. Let's go ahead and start up our application with npm start, and we've got a good build going here, and we're off to the races. And of course, here's our application. It looks like it's working. We can go to Places and People, good. Almost all of the work that we're going to do to add state into our application will be done here in index. js. We're really wiring up our application from the very beginning. The first thing we're going to do is import the createHistory function from the package that we brought in, history, and we'll grab the function createBrowserHistory. We're going to use the history of our browser to feed into some middleware. To take advantage of it, we have to constitute a history object using our createHistory function. Now here we're going to start to build up the middleware we'll use in the enhancements to our store so we can see and replace state and actions that will make more sense pretty soon. We say const middleware = routerMiddleware, taking that history object as a parameter. We don't have middleware included in our imports, so let's bring that in from react-router-redux. I'm going to take this import statement and move it up to the top where it belongs, alongside the other import statements, and in fact, let's do the same with our get initialState. Now all of our imports are at the top where we expect them to be; things look a little cleaner. This next line of code is the magic line that lets our app work with the Redux DevTools, as we'll see in a few minutes. This is a store enhancer providing more functionality to our store. I'm just going to paste in this line of code so that you don't have to watch me type this out. Compose is a functional programming utility and is included in Redux as a convenience. You might want to use it to apply several store enhancers in a row. We need to include it in our application, so we'll import it from redux. Now we've already been creating our store, but we can give it a third argument, and that is the enhancers that we want to add to our store, that is additional functionality through the application of middleware. We can say applyMiddleware, and we bring that function in from Redux. And finally, we'll just spread out our middleware as the argument to that function. We want to take advantage of an application wrapper called Provider, and we'll import Provider from react-redux. We're also going to change the type of router we're using. We want to include a new router type called ConnectedRouter, and we'll bring that in as Router by convention, and that comes from react-router-redux, just like our routerMiddleware. We won't be needing our BrowserRouter anymore, so we can let go of that, and come down to where we render into our application. We're going to wrap this with the Provider component and clean our code up a bit there. Now our Provider wants the store passed in as an argument, so we'll go ahead and do that. This is just like the app is currently taking store as an argument. Now the use of Provider is meant to save us from having to pass store down to all of our other components in our application, and this makes great sense, there is a great desire on many people's parts not to pass the store down so far in a Redux application. Passing properties down in deeply nested component trees can be a pain after all. There's a technique called context that allows for an alternative to this technique, which is what the provider is trying to take advantage of, but it's experimental and we're going to avoid it in our example, even though this is what the Provider wrapper promises to make possible for us. Why are we going to ignore this capability? Because in the words of the current React documentation, "If you're still learning React, don't use context. There's usually a better way to implement functionality just by using state and props. If you want your application to be stable, don't use context, it's an experimental API and is likely to break in future releases of React. " So we're going to take the approach of continuing to pass store down into our App component. Now I know for the purists this may not be the exactly how they'd like see it done, but it's the most practical from a long-term maintenance point of view. We're going to go back to our application and see how things are working. Oops, before I do that there's one thing I forgot, and that is we have to pass our history object to our Router as a history property. So we'll pass in history, and now let's jump over to our browser and see how things are working. Great, we have an application up and running. We can still see Places and People. I'm going over to our Redux DevTools extension, and we can see the Actions and we can see the State of our current store. So, in our current store we have places, each place has a name, we have people, each person has a firstName, a lastName, and an occupation. So we're spying on our store, which is great. Let's delete something, let's delete Moe's Tavern. Now we can spy on our action that we just dispatched. We dispatched an action with the type of DELETE_PLACE. Every action has to have a type attribute; this is the key used by the reducers to decide what to do with this particular action. So we wanted to delete Moe's Tavern. So if we delete all but one of our places, we should be able to go to State, open places, and we see there's only one place left. Let's add at least one more place to our list. And you saw that it appeared right there in our tool. If we go to Action, we can see that we dispatched an action for ADD_PLACE, carrying the name attribute of My House. This is a really cool tool, and we've only seen part of it so far. You can see that it's actually tracking the different things that are happening, the different actions that are taking place, as it goes along. And we can replay them. We can jump back in time and you can see our application responding accordingly as we move back and forth and replay the state changes in the application store. Let's take it all the way to the end. But you know, if we look at our state we've got people and we've got places, but we don't have anything for our routes. This is, after all, what we were after in the first place. So what's missing? It turns out that what's missing is a reducer for React Router. So where we are combining our reducers we need to add one for React Router, we'll call it router, and it will take the routerReducer. But where does that come from? Well, we can actually import it directly from react-router-redux. Now let's have a look at our state. Back in our state we can see that there are changes when we toggle back and forth between People and Places, and that the router is showing the differences over here on the right. We can see the actions that are being dispatched, a location change, and the payload is a path name, search, hash, and key, just like we might expect. The type, the key for the router reducer, is shown right here. Now the magic question, what's in our State store? And it turns out we now have our current state of our router in our store. Let's back up a few actions and see what happens. You may have noticed during playback that although we were seeing our route data change on the right-hand side, we weren't seeing the application change and flipping back and forth between People and Places on the left-hand side. This is due to a current bug in the Redux DevTools, which is slated to be fixed and is open on their GitHub Repo. It has to do with the initial location being null. This is an incredibly rich debug environment, letting us spy on our application and even the route data that was true at a moment in time. If you're using Redux in our applications, you've got to get a hold of this tool. It's called Redux DevTools and is available as an extension in the Chrome store.

Demo: Router State in a Redux Store
In this quick module, we saw a trip around a Redux-based application. You saw the tool Redux DevTools, that is an extension to the Chrome browser. It helped us see what data was running around inside of our application and our current state. This tool is highly recommended for building Redux applications. Finally, we saw that our router state really can be managed in the Redux data store. In the next module, you'll see some tips and tricks that just make React Router fun to work with.

Routing Tips and Tricks
Introduction
David Starr back for our very last module of the React Router 4 course. This module shows a few techniques that you can use or expand upon to do even cooler things. For these examples, the idea is to get the idea, not to use the samples as they are. Here's what's coming up in this module. We're going to be looking at what happens when we use routes in a recursive model, and then, although we visited it, we're going to take another look at redirection and how we might use it a bit differently. And finally, how to smoothly transition between routes, which is just a cool technique to have under your belt. So let's get started.

Demo: Recursive Nested Routing
So what happens when you put a route in a route in a route inside a route? Well let's find out. We're back on the home screen. You can see to the left I've added a Recursion menu item. If we click it, we do get a component that shows up, and if we look a little more closely we can see what's going on. If we look up at our URL or our route, we're taking the route parameters of :text and :color and using them to structure the box that we see. So in this case, we're passing Top Parent for text and Yellow for our color. Now let's take this idea and build on it so that we can add children to this top-level parent. Let's start with the path that I defined for this route, which is /color/ text parameter and a color parameter. When we get that match, we're going to render the component RecursiveColorSwatch. Let's open RecursiveColorSwatch and see what it's doing right now. So far it's doing very little. It is pulling in those two parameters of color and text that are in our URL, and for color it's using that variable inside the style that we're going to apply to the box that appears on the screen. And then finally, for text it just shows up as an h2, that's the title of the box if you will. And finally, we show the match. path just so that we can continue to see how our paths are building out. Now that we've seen the component, this view of our component rendering makes a bit more sense. This is a great start, but what about adding children so that this actually becomes a recursive model? I'm going to paste in some code here rather than force you to watch me type it in, and we'll bring in Links from react-router-dom. We can see that we can add a child or close a child depending on which link we click. All Close Child does is navigate to the current URL, all Add Child does is append another color and text parameter to the current URL. We could make it more interesting than gray, but all of our child boxes are just going to be gray. Now that we've done this, let's see if the recursion is working yet. Well, we've got our Top Parent, and we've got Add Child and Close Child, let's add a child. Nothing's happening. We can Close Child and nothing happens there either, and why not? You can see that the route is changing, or the URL is changing at the top of our browser. Let's go all the way back to the root and jump back into our code. In order to make this work, we're going to put a nested route right here inside the component. We'll bring Route in from react-router-dom. If you look closely, you'll see that this is exactly the same route that we embedded in our App. js file. It just so happens that we're now embedding it inside this component. Now let's see what happens when add and close children. I can add a child, add a child, and add a child. My path starts getting really long there, we can see the path that we're following, and you can see up here the URL that matches the first part of that path. Now, let's close the child, close the child, and close the child. There you go. Simple recursion using routing with routes embedded within routes. This can be very useful for doing things like building breadcrumbs or drilling down into data structures.

Demo: Redirecting in Switches
Let's say you have an old link on your site that doesn't link to anything that matches a new route, what are we going to do? Let's go find out. Let's start in our App. js file where we've defined all of our primary routes. In this case, we've defined a new Route for unicorn that's going to render a component also called Unicorn. There must be something very magical in there. Let's add a link to our sidebar. We come into our Sidebar and instead of creating another standard link by appending to our links array, let's add instead an image link. So to do that, we can simply put a Link around an Image tag. We have a decent Image tag here, but you may be noticing something wrong already. Our Link is to pets; it's not to unicorn, it's to /pets. This may very well happen to you because I've got an old link coming into the website or I've got a previous route that we no longer use, and we need to somehow get pets to resolve now to unicorn. How do we do that? Let's first look at the current behavior. Well, there's our unicorn link there on the left. We've got our image in our navigation, so we click it and of course, we get a 404 Page not found because in our App. js there's no matching route for /pets. What we can do, however, is we can add a redirect into a switch statement. So we can add a Redirect and we'll say that it's going to /unicorn and it's coming from, guess where, /pets. Now let's see what happens when we go back to clicking our unicorn in the sidebar. Hey, look at that. We've got ourselves some Unicorn Love there, and if you look at the top you can see that our URL is /unicorn. If I mouse over our image link, we can see down at the bottom left that it's a link to /pets. So I click it and we get that Unicorn Love, and just because, we can flip it from left to right. This a very valid and standard use of redirect within a Switch statement and can help you get out of some messy situations once you have legacy pathing already on your website.

Demo: Route Transitions
Wouldn't it be great if every web page change or every component change wasn't so abrupt? That's where transitions come in. We can make things go much more smoothly. Let's check that out. To see how transitions work, let's first look at some things we already in place. I've added a link, Transitions, to our sidebar. When I click it, we do get a component, and it's just a very simple component displaying some Lorem ipsum text. This is the Home, if we click Lorem 1, we get Lorem 1 and a different set of Lorem ipsum text, Lorem 2, a different paragraph, Lorem 3 yet another. We can always come back to Home as well. Wouldn't it be cool if instead of having such an abrupt transition as we do now, we would be able to fade from one component to the next, from Lorem 2 to Lorem 1 to Lorem 3, and just watch that fade over time maybe a half a second, or 300 ms, just enough time to make things look a little smoother. Let's see how we can pull that off. Let's first get a sense of what's going on in our application so far. We've defined a new Route for transitions and the component that we're rendering is Fade. If we jump into the Fade component, we can see that we've go the menu items up at the top, Home, Lorem 1, 2, 3, and they're grabbing some styles that are defined down here off of a styles object. We then have a Switch with Routes in it. The first Route matches to the current url, which is going to be the home route, and then the parameterized route with id on it is going to match to Lorems 1, 2, and 3. This of course is a nested route inside of a rendered component, but how do we get that nice transition to work? First, we're going to install a package called react-transition-group. We're installing react-transition-group into our package. json file. Now we should be able to get going again with npm start, get a build, and be up and running. We can head back over to our application, and note that this hasn't done anything yet, of course, we've just installed the package, we haven't made use of any of its capabilities or features. To get started adding transitions to our application, we're going to import the component TransitionGroup from the package that we just brought in react-transition-group. And we'll use this to wrap our Switch statement because that's where components switch out and where our transitions need to occur. But that's not all. We're going to need another component to help us get the transitions in place because there are different types of transitions we might want to use. In our case, we're going to use CSS. So, we're going to bring in the CSSTransition and use it within our TransitionGroup. Now the CSSTransition is a rather long component tag, so I'll paste it in, and we'll just walk through it quickly. Each CSSTransition has to have a key, a unique key, so we're choosing to use the location. key, which we know is always unique. And then we have classNames, that's plural, equals trans, and trans turns out to be a prefix to the CSS rules that we're going to put inside of our style sheet. We'll see what this means in just a moment, but remember, you can get caught up on making the mistake of naming this className instead of classNames, plural, because name, of course, is what React always wants us to put in. Timeout is the time in milliseconds over which we want the fade to occur. Now it turns out the rest of our work comes down to style sheets. Let's head over to our index. css and we're going to put all of our rules for fades and transitions right here. The first thing we're going to have is a. trans-enter rule, and we'll set its opacity to 1 and z-index also goes to 1. So whatever is entering onto the screen comes to the front with an opacity of 1. And just like we have a trans-enter, we're going to have a trans-exit, and this one is going to make whatever was on the screen previously disappear, simply by saying display: none. Let's go see how our web page is behaving right now. We're on the Lorem Home. We get the changes, but we're still not fading in between our components. We have one last magical rule to add to our CSS style sheet. The name of the CSS rule starts with. trans in both cases of. trans-enter and. trans-enter-active. This ties directly back to the trans prefix on our CSSTransition component. So what goes in here? First, we'll start with an opacity of 1, but we want to ease into it, so we're going to say transition our opacity over 1000 ms. We want a full second of transition. And the effect we want is to ease-in. Now let's go check out our web page. It looks like when we transition between our components we're still not getting that fade, and you know what, like so many things in React, I'll bet it's a CSS problem. Sure enough, I can see it right away. When we enter, our starting opacity should be 0. Now let's jump back to our web page and see what happens. We can go to Lorem 2, Lorem 3, and we can see the fading occurring over the course of 100 ms, or 1 second. This is a nice way to transition between pages or components on your website. Of course you don't want the transition really to take a full second, and in most cases 300 ms looks pretty nice, but I wanted to use a full second so that we could see it work well on video. Using the CSS transition is the easiest way to pull off these transitions because it makes it all about the CSS. And remember that we get this behavior from the react-transition-group package.

Summary
Well here we are, wrapping up not only this module, but the course itself. In this module, we saw that we can structure routes in a recursive way. This might be a good technique for building breadcrumbs for example. We also saw we can not just use routes, but also redirects inside of switch statements. And finally, we saw that we can transition between different routes very smoothly to a nice aesthetic effect. Thank you for sticking with me through the module and the course. Now get out there and start using React Router 4.
