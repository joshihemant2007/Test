resource at root react-practicle-start

In this course, A Practical Start with React, you will first learn why React is so great. After this module you'll be able to determine if React is for you and/or your team. It will also provide a basic overview of the mechanics of a React app like tree reconciliation and the use of JSX. There's also a brief comparison with alternative libraries and frameworks included. The next module teaches you how to set up a development environment efficiently. You will see create-react-app in action and the setup of Visual Studio Code and Chrome developer tools is covered. Following this, you will cover the structure of an app like the folders that are typically used, the JavaScript entry point and the use of ES2015 modules. You'll also see how the top-level component works and how to place components in folders. Next, you'll touch on components. The difference between function and class components is covered as well as state and props in a component. Also expect explanations on lifecycle methods, error boundaries and ways to compose components. The fifth module is a collection of additional tips to enhance your React experience. Type checking with prop-types is covered as well as separating UI from state, React Router, Flux & Redux and unit testing with Jest. After watching this compact course you are ready to create React apps!

Course Overview
Course Overview
Hi everyone! My name is Roland Guijt, and welcome to my course, A Practical Start with React. I'm an independent software developer and trainer based in the Netherlands. React is one of the top JavaScript libraries out there, but is it for you? In this course, I'll answer this question for you. And if the answer is 'Yes, ' then I'll get you started not by going through tons of slides but by showing you how to build an app. With an investment of just 90 minutes, you'll have enough knowledge to unleash your creativity using React. Some of the major topics that I will cover include Is React for you?, setting up a development environment, the anatomy of a React app, and building and arranging components. Before beginning the course, you should be familiar with JavaScript up until at least the ES 2015 implementation, also known as ES6. For me, React really puts the fun back into programming single page applications. If you view this course, I'm sure you'll get as enthusiastic as I am. So don't delay. Continue with the first module and enjoy your React journey.

Should You React?
Module Overview
After watching this first module, you should be able to know for sure if React is for you or your team or not. I'll first show you the app we're going to build during the course. Next, I'll tell you about what you should know before watching this course. If you're good to go, I'll show you why React is awesome. Working with React is working with components, and I'll show you what that means. And, finally, I'll do a basic comparison between React and the two most popular alternatives--Angular and Vue. But let me show off the app we're building first.

What We're Building
During the course, we're building this app. After building it, you'll know all the basics of React. Globomantics is a global real estate agent, fictional of course. There's a featured house on the home page, and the user can search for houses by country using the drop-down. After selecting a country, there's a list of available houses. When the user clicks on a house, it shows the house's details. If a customer is interested, there's a feedback button that reveals a feedback form. Now let's move on to what you should know before starting building.

What You Should Know Before Starting
Before learning React or any other JavaScript library, please be sure you have JavaScript up until ES 2017 under your belt. I'm assuming that you know how to use ES6 classes and arrow functions, for example, but also async/await. If you're unsure, I would recommend doing an assessment on Pluralsight to see if you have enough JavaScript skills and brush up your knowledge with other courses if needed. Also, a basic understanding of bootstrap, especially the grid system. I'm using version 4. This is not a must, but it helps. Now we dive straight into a demo showing off React.

Smart DOM Updates
I'm kicking off with a demo straightaway to show you the coolness of React. The purpose of this demo is we show you how smart React is with updating the browser DOM. I'll start off with an example without React and then compare it in the same app with one that does use React. In your favorite editor, I'm using Visual Studio Code here, create an HTML file with the basic HTML structure. Add a CSS file with a split class, and reference the CSS from the HTML. Add two divs to the body, one with the ID dateJs and one with dateReact. Include three JavaScript files. One is the React core library. One is react-dom, which will give React the ability to interact with the browser. And another script is called script. js, which is custom. Create variables for the two divs using JavaScript's getElementById. Now create the function called render. In the function, we set the innerHTML with a jsDiv. Put a div with a CSS class split in the innerHTML, in the div, just the text JS template, an empty input, and a paragraph rendering the current DateTime using an expression. To make this work, be sure to use backticks to mark the beginning and the end of the string. Below the function, call setInterval calling the render function each second. Now show index. html in the browser. You can see the time is updated every second. Back to script. js, in the render function, now let's do the same by using React. Call render on the ReactDOM global object. We want React to render a div, so I create one using the React API by calling createElement on the React object. The first argument is the HTML element you want created. The second argument is an object containing the attributes the element needs. Notice the differences between HTML and this syntax, the use of className instead of class to set the CSS class for example. The contents of the div element are determined by the following parameters. First, we want a text called React template. We want an empty input element and a paragraph containing the date. To render this element, we call ReactDOM render with the element we want to render and the div we want it rendered in. This is the dateReact div we captured earlier in the React div variable. Wow! That's a lot of work, and it seemed unnecessarily complicated if you compare it with the vanilla JavaScript code. But don't switch to another channel yet. Life will get easier with the explanations that follow, and something potentially mind-blowing will emerge if we show this HTML in a browser. At first glance, the two implementations seem to be the same. But check out the F12 tools of your browser, and take a look at the HTML elements that are rendered. You can see the dateJs div is updated every second as a whole, but a dateReact div is not. Trying to type something in the input of the JS version is a challenge because of that. But in the React version, it just works. Even though we told React to render the whole thing every second, React is smart enough to just update what's necessary. Let's see how it's pulling it off in the next clip.

The React Element Tree
React doesn't use HTML directly. It uses a tree of JavaScript objects to define the UI. Each element is created by calling React. createElement. This tree is then used to create the HTML that a browser will understand. But wait a minute. That means that we're writing a UI in JavaScript and not in a separate HTML file anymore like we did for ages. Correct! Keep listening.

Separation of Concerns
One of the two JavaScript libraries I added for the demo in the index. html file is React itself, which contains the base functionality. React-dom contains everything needed for browser support. The React engine and object tree transformation are separated for a reason. React is designed to be open-ended. There's also a project called React Native, for example, that renders an object tree with mobile controls to different mobile platforms. The object tree is not a UI directly. It is an instruction for how the UI should be rendered. React hands over this instruction to the DOM library, which will then render it, in our case, for the browser. The philosophy of React is that what's displayed in the browser or any other output should be only a reflection of the state of the application, nothing more. This alone is probably a major difference if you compare React with other libraries or frameworks that you might have used before. Maybe you have used others that use two-way data binding. React is different. It renders the UI from the object tree every time it needs updating. Luckily, it does so in a smart way as you saw earlier in this module. It works with something called tree reconciliation, which I'll cover in the next clip.

Tree Reconciliation
In the case of the demo, I showed you the object tree changes every second. Of course, many other things can cause a change in the tree. New data that's being pulled in from the server or user input can cause changes. Each time a complete new object tree is created when a change occurs. Now here's the magic explained. After the new object tree is created, the old one is kept. React has a smart mechanism that quickly compares the two trees. In this case, only the innermost p element is changed. So React instructs the renderer to only redraw that element. Only when that's done, React disposes of the old tree. Cool, right? Well, there's one thing that's not so cool. It seems like a hassle to create each element in the way we did. I'll explain how to make this easier in the next clip.

JSX
Instead of writing this awkward React. createElement syntax that's not very friendly to the human brain, we can also use a syntax that seems like HTML. I emphasize the word seems like that for a reason. The equivalent of the React. createElement tree on the left in a special syntax called JSX looks like this. That's a relief. This JSX is translated by a tool to the React. createElement syntax. The tool we're going to use in this course is called Babel. Babel is specialized in converting one syntax to another. To see how it works, I go to the Babel website and paste in the JSX from the slide. As you can see, it translates it to JavaScript. I'm going to show you later how you can set up tooling to do this automatically. Now let's see how what I've told thus far fits together.

The React UI Workflow
In the React app, you typically write HTML like JSX to define a UI. The JSX is translated into JavaScript with React. createElement statements by a tool, in our case Babel. Each time the app has to render to the browser, a JavaScript library called ReactDOM uses these elements to generate the actual HTML elements for the browser in a way that only the updated elements are rendered. Notice the differences between the JSX and the HTML. JSX uses className instead of class to designate a CSS class. And the input element is also different. Handling the UI like this is a major feature of React, but it's not the essence. Let's look into that in the next clip.

Components
React is a JavaScript library for creating components and composing them. Writing a React app is creating components and putting them together. Each component has a name and has three distinct characteristics. It can accept input from other components by using what is called props. In JSX, these are written like HTML attributes. Secondly, it can maintain an internal state. And, thirdly, it knows how to render itself. In the process, it can use other components. We write that part in JSX. Let's take a look at the finished app we're building in this course. We're building the app for Globomantics, a global real estate agent. On the landing page, I can see a header, a search functionality, and a featured house. These are all components. When I choose a country in the search component, a table is displayed, which is also a component. Because the application's state changed when I chose a country, React determined that the UI had to be re-rendered, and it did so using the smart tree reconciliation mechanism so that only the part of the UI was redrawn which changed. A React application is a composition of components. We start with a top-level component often called App. This component renders other components such as in our case the Header, a FeaturedHouse, and SearchResults. Each of these components can also render themselves using more components like HouseDetail and ResultRow. Each component maintains an internal state, and when something has to be passed on to the other components, it uses the props of the component to do so. There's an entire module dedicated to the ins and outs of components later on in this course. Let's take a look at alternatives to React in the next clip.

Alternatives to React
Now that you have a feeling of what React is, I'll talk a bit about its alternatives. Angular and Vue are the most popular other choices. First of all, no matter which choice you make, you're good. They are all excellent choices. Apart from some differences I'm going to point out, it comes down to personal taste or the taste of your team. If you, for example, after trying React still don't like the fact that you don't write the UI separately from JavaScript, just use Angular or Vue. I'd recommend writing a small app in all of them before you choose. React, Angular, and Vue all use components to put together the app. Of course, the way they approach a component is different, but the overarching principle is the same. Angular is different than the other two. It's a framework, and React and Vue are libraries. That basically means that React and Vue are made for one thing--UI composition. Angular offers almost everything you need in your app out of the box like routing, dependency injection, and a framework of JavaScript objects. This can be a good thing because it's like a one-stop shop, where, for the others, you probably need to choose and incorporate other libraries. But it can also be a challenge to get started because of the higher learning curve. React and Angular have giant companies behind them, where Vue is maintained in a small shop depending mostly on community contributions. All of the options are released under the MIT license, which is a very permissive license. In terms of data binding, Angular uses two-way data binding by default, but one-way data binding is supported. And Vue and React use one-way data binding. React defines the UI in JavaScript, and the others use HTML. Having the UI in JavaScript feels strange at first. But Angular and Vue write JavaScript expressions in HTML, which is weird for the same reason. Also, there is no explicit interface between JavaScript and HTML, and that makes it hard to debug sometimes. In my experience, finding solutions for problems in the React app is faster than with the other two.

Summary
Here's the summary. I took off by demonstrating how React does smart UI updates using tree reconciliation. JSX saves you from writing tedious React. createElement code in the render function of components. Components are the essence of React. Finally, we looked at alternatives. In the next module, we're setting up our working environment.

Getting Ready
Module Overview
Getting ready to start developing a React app is the goal of this module. First, I'm making sure you have the latest version of Node and npm. Next, we'll create the starting point for our application with a tool called create-react-app. Then we see how we can deploy the app to production. We're also preparing the editor we're going to use, Visual Studio Code. And we'll install a plugin in Chrome that helps to debug React apps.

Preparation
First, make sure that you have the latest version of Node. js installed. The easiest way to do that is to download the installer package from nodejs. org. Npm is a Node package manager. It is updated more frequently than Node itself. To make sure you have the latest version, at the prompt type npm install npm@latest -g. Next, you'll see why we need all this.

create-react-app
Now change to the root folder where you want the app to live, and type npx create-react-app globomantics to create the initial Globomantics app. Npx was installed when we installed npm. It executes an npm package directly. It downloads the starting point for an application using the latest version of React. Besides that, it configures a complete environment to develop in, in which we will explore a bit further. In a moment, I will start a development web server by typing npm start. Start in this case is a script that gets executed by npm. If you take a look at the package. json file, you can see that apart from all the dependencies to packages, the start command is mapped to a call to React scripts. And there are more commands defined. When I type npm start at the console, you can see that the development web server is starting, and a browser is launched with a template app. It runs the app in development mode. That's not the fastest mode it can run in, but in return it gives you as much context information as possible, which is great for debugging. Before create-react-app existed, you had to install and configure all the needed tools manually to get this running. Now we are up and running within minutes. Create-react-app installed and configured all kinds of tools for us that make up the development pipeline. If you take a look in the node_modules folder, you can see all the bits and pieces. There are two tools there that play important parts. Webpack is a smart bundler that packages up our components that are in modules in the application. And Babel translates JSX into JavaScript. It also translates our ES 2015 and higher syntax to ES5 so all the browsers can run the app as well. Now start up the development server again if you closed it, and open up App. js in an editor. Notice the JSX in the render function. Now type something that makes JSX invalid, and take a look at the browser. It immediately detects that something is wrong. Build actively watches the changes in the app and generates an error within info that lets us easily fix the problem. You get all this context information because the build is running in development mode. Let's talk about production mode next.

Production Mode
To create a build that runs in production mode, a build without debug information but one that runs faster, type npm run build at the console. It creates a build folder which now contains everything that is needed to run the app on a web server. Let's see what's in the newly created build folder. You can see it has created a minimized index. html file that references one bundled and minified CSS and JavaScript file. The JavaScript file contains not only React itself and React DOM, but also all JavaScript present in the app. Now when this application is used, the browser only needs a few requests to load up the entire app. Let me introduce you to my editor of choice next.

Visual Studio Code
As the editor I'm going to work with, I chose Visual Studio Code because I generally like it. It's lightweight, cross-platform, and it seems to be the most popular editor these days. Its integration with the React setup is great. Install it by downloading it from code. visualstudio. com. Visual Studio Code is not required to create React apps of course. There are many other great editors out there that work perfectly. To open up your project, open a console window, change the folder to where you created the app, and type code dot (. ). Or you can just start Visual Studio Code and choose the Open Folder option. Now go to the View menu and click Extensions to open the extension console and type chrome debug. Install the Chrome debugger. And since we're here anyway, also install Simple React Snippets. We will use the snippets later on. A handy feature of Visual Studio Code is its terminal. Instead of starting the development server in a separate window, you can also start it from this tab. If it's not visible, just go to View menu and find Integrated Terminal. In Visual Studio Code, press the Debug button in the sidebar and press the Run icon. You can also press F5. Because there's no launch configuration yet, you'll get the choice to debug with Node. js, which is supported by default, or Chrome. You've just added Chrome support by installing the extension. Choose Chrome and a launch. json file is created, which is a configuration file for Visual Studio Code. Change the port to 3000, which is the port the development server is running on. Now press Run or F5 again. A separate instance of Chrome launches. Now to get to App. js, find the top icon, press it, and look under the src folder. In App. js, set the breakpoint at the render function, for example, and refresh the browser that has just launched. The breakpoint is hit. Now set the breakpoint at some JSX line. When I refresh the browser, you can see that it gets hit too because in the background, JSX translates to JavaScript. Press Stop and change something in the text that is rendered. After a second, the browser adapts to the change after I save the file so the development server is still monitoring changes. If you're like me, and you don't want to save files explicitly every time to trigger a refresh, turn on auto-save in Visual Studio Code in the File menu. Next, let's see how we can make Chrome aware that we're using React.

React Developer Tools
In Chrome, go to the Extensions screen, and press the hamburger icon, and click Open Chrome Web Store. Search for React developer tools and install them. Back to the app in the browser, press F12. And now you should see a React tab on the right side of the menu. If you do not see it, try to restart Chrome and Visual Studio Code. The power of the extension lies in the fact that you can see the entire react component hierarchy. So this is not the HTML you're seeing but the JSX. By clicking on a component, you can inspect the props and the state of the component in the right pane. This is a great tool for debugging.

Summary
We looked at setting up the starting point for an app in this module. Create-react-app is great for that purpose because it also sets up a complete development pipeline for you. Apart from seeing it run in development mode, we also made a production build. And we looked at tooling. Visual Studio Code is a great free editor with debug facilities. And the debugging experience becomes even better when you install the React developer tools in Chrome. In the next module, we're going to look at the structure of the application.

Structuring the Application
Module Overview
We're examining the project structure of a React app in this module by scrutinizing the app create-react-app created for us. There are several folders like the public and the src folder. We'll see what's in there. Also, we'll take a closer look at the build output and how a React app is bootstrapped. It's important to grasp the concept of modules, so I'm digging into that. We're also making a start with understanding components by changing the default app a bit. But, first, let's take a look at the basic structure.

The Public Folder
Let's take a look at the files that are in a project. Besides node_modules, there are two folders. One is called public, and the other is called src. Everything that is in public will not be processed by Webpack. So when creating a build, favicon and manifest. json and any other files you add to public will be copied to the output folder untouched. Index. html is a slightly different story. This one acts as a template. In it, there are references to something called PUBLIC_URL. When creating a build, this will be replaced by the actual public URL. Also, only files that are in the public folder can be referenced by index. html. There's, of course, also a title. Let's change that one now. When I scroll down, you can see there are no references to JavaScript files. Seems strange, but I'll get to the explanation of that next.

The src Folder
When taking a look at all the files that are in the src folder, notice that there are several JS files and CSS files, as well as the React logo. Everything that is in the src folder will be processed by Webpack and made available to it. Let's see what Webpack does exactly. Type npm start again. What actually happens is a build within memory output. One of the differences with the production build is that all generated files are kept readable. They are not minified, so they can be debugged in the browser. Now in the browser, watch the Network tab in the F12 tools and refresh. You can see that the main request to localhost returns the index. html, but the PUBLIC_URL template code in index. html is now replaced, in this case simply by nothing because the public folder is in the root. Also notice that if I scroll down, there is now a reference to bundle. js added. Now if you turn your attention to the transferred files again, you can see the bundle. js is downloaded. But besides the React logo and to request use to utilize WebSockets, there is nothing else. So besides the logo, all files that are in the src folder are now bundled in bundle. js. Let's open bundle. js. It's somewhat tedious to read. But when I look for a CSS className that was used, you can see the JSX syntax has been translated to JavaScript. And the CSS that was in the CSS files has been incorporated in a JavaScript file as well. Now let's take a look at React's entry point.

React's Entry Point
The index. js file in the src root folder is the entry point for a React app. You can rename or delete all the other files, but index. js, as well as index. html, have to stay as they are. Most of the JavaScript files in the src folder are or will be modules. Modules are part of the ES 2015 specification, and Babel implements that standard. Normally, a module can only import other modules. But Webpack makes it possible to also import other stuff like CSS or images. With index. js, we import the two React modules we need, React for the React engine and ReactDOM for browser support. Then we import the index. css file, a module called App, and an object from the registerServiceWorker module. When importing another module, the file extension is omitted. So import from. /App instead of. /App. js. The /. in front of the file name means that it should search the local file system. So in this case, index. css, App. js, and the registerServiceWorker are all physically in the src folder. Without this prefix, Webpack looks for an installed npm package with a specified name. This is the case for React and ReactDOM. The line that is the actual entry point calls ReactDOM. render. ReactDOM is an object that was exported from ReactDOM module and imported in this one. The first argument of render specifies the top-level component of our app that should be rendered. As you can see, this is JSX syntax, which will be translated into React. createElement JavaScript code. A second argument is an HTML element where the app component should be rendered in. In this case, an HTML element with the ID root. When I switch back to the index. html file, you can see there's a div with that ID. The app root component with all its children will be rendered inside this div. Before we dive into the app component, let me talk about modules some more for a minute.

Modules
Let's say we have a module. js file with a class called component, which contains a method called doSomething. To make this file a module, we need to export something from the file using the export keyword. In this case, we want to export the class component. Exporting the class enables other modules to import the class. Should the file contain other things that are not exported, these things are just not available to other modules. We could also export multiple members of the module by just separating them with commas. Members can be classes, functions, or any kind of variables. Any module that wants to import things from this module must request what it wants by name between curly braces. So in this case, it requests something called component. This will work because something with the name component is also exported by the other module. After the from keyword, it must then specify the file the module is in without the extension, so in this case, module. js in the root. In the module with the import statement, the member then becomes available by the name of the member. So in this case, the class component is made available, and I can call component. doSomething on it. It is also possible for a module to export one default member using the default keyword. The importing side then doesn't have to use the curly brace syntax and also it can use any name. So here comp is imported, but component is exported. And comp is not enclosed in curly braces. A mix is also possible. Only one member can be the default, but other members can be exported as well. The importing module then has to use a mix of curly brace and non-curly brace syntax. Let's take a closer look at the top-level component called App.

The Top-level Component
We saw earlier that the entry point of the app renders a component called App. This is the top-level or root component. That component is imported first from a file called App. js. We can deduce two things from the way the import statement is composed. App. js is a local file because of the. / syntax in front of the file name. And it exports a default member because there are no curly braces around the App declaration. When I switch to the App. js file, you can see the latter is indeed the case. The module imports two objects from the React module. The React module is not part of our project. It is an npm package. There is no local file reference. First, the default object we call React is imported. This one has to be imported always because the component won't work without it. There's also something imported called Component. And it also imports a logo and a CSS file. The component itself is a class that extends Component, and Component is the class we imported from the React library. Each component must have a render method. The render method typically returns JSX like this one. In this case, it only returns components that have an equivalent in HTML like div, header, img, and h1. But we're going to add a couple of custom components in the next module. Remember, JSX is not HTML. And the img component has what looks like a src HTML attribute, but it is a prop, something that the component gets as an argument. In this case, it's an expression and closed in curly braces. It mentions the logo we imported. Webpack will replace this with the actual location of the logo. Another thing worth mentioning are the braces around the JSX. Because JSX translates to JavaScript, writing a return statement without the braces is not going to work. There will be nothing behind the return keyword. So JavaScript will assume that we forgot the semicolon to indicate the end of the line and place it itself and ignore everything else that is below return. I'm adding Bootstrap in the next module. For the Globomantics app,

Importing External Modules
I'm using Bootstrap to make everything look nice. To install it, type npm install bootstrap@4 in Terminal. This installs version 4. Bootstrap is going to help with positioning elements with its grid system, and we're going to use some of its built-in CSS classes. The only thing I have to do to make Bootstrap available in the app is create an extra import statement in index. js, the file with the entry point. The import statement loads up the Bootstrap CSS file, which is now located on the node_modules. Bootstrap will now be available in all child components. In other words, the whole app. Now we're ready to create the app in style. But, first, I have another tip to make the app even more structured.

Placing Components in Folders
Using modules is doing great things for the structure of the app. Here's another feature that works great for more structure. I'm creating a folder called main-page under the src folder. I'm using main-page, but React and Webpack aren't opinionated about naming. Just use any naming convention you like. Move App. css, App. js, and logo. svg to the new folder. Now rename App. js to index. js. In index. js in the root folder, so this is not the renamed file but the entry point file, change the from part of the import line for the App component to just the path of the new folder, not specifying a file but the whole folder. Webpack will automatically understand that it has to use the index. js file that is that folder. And also rename App. css to main-page. css for more clarity. Don't forget to also change this in the import statement. When I run the app, you can see it works as before. What we gained is more structure. I can now easily see what stuff is for the main-page and what's there for the root level.

Summary
In this module, we looked at the initial structure create-react-app created for us. I talked about the public and src folders and the way a React app is bootstrapped. You saw how modules are used in a React app and how they work. Also, we examined the top-level App component, and we looked at how to bring in other external modules. Finally, I showed you a nice feature to bring even more structure to your app. You can place all files that belong to one component together in one folder. In the next module, I'll show you how to build different types of components yourself when I build the rest of the Globomantics app.

Understanding Components
Module Overview
This module is about creating components and arranging them. I'll start off by adding a simple component. You'll learn that there are two kinds of components. Components have props and state. We're looking into that as well. Lifecycle methods enable you to react to a lifecycle change in your component. And last but not least, the emphasis of this module lies on building the different types of components we need for the Globomantics app. Let's create a simple component first.

Creating a Simple Component
Let's create the first custom component for this app. That will be the header of the page that shows the logo and the title. Add a new JavaScript file to the main-page folder called header. js. Every component must import a default object from the react library. This is needed for JSX to work. Secondly, we'll need the Globomantics logo, so we import that as well, and copy the file to the main-page folder. I'm now pasting in a function. It is an arrow function that returns JSX. When you return JSX in a component, you must always have a root node. In our case, it's a header. But it's also possible to return an array of JSX nodes in a component. The header component has a className, row, and child nodes have co-classes. This is the grid system of Bootstrap, which allows me to position everything correctly. Inside the first div is an image with, as a source, the logo. The next div just contains some text with the subtitle CSS class. In main-page CSS, I delete all the stuff that's there and add a couple of classes. One is a subtitle class. The other two we're going to need later on. One thing left before the component is finished. Add an export default statement with a function name. I'd recommend to give each component a name starting with a capital letter so it's clear what's a custom component and what's not. Now in the index. js file of the root main-page component, add an import statement for the new header component. Also remove all JSX that's already there in the render method, and create a div with a class container. Container is also a Bootstrap class. Next, render the component by using the imported name as a tag. If a development server isn't running anymore, start it now and keep it running for the remainder of this module or if the browser gets automatically updated whenever we change something. As you can see, the header works. I'm investigating the difference between class and function components next.

Class and Function Components
You've probably noticed that the app uses two types of components. The header component is just a function that outputs JSX directly. It is not suitable for much else. But if your component just does that, it's enough and really lightweight. The top-level App component in the main-page folder is a class component. A class, of course, can have all the methods and other members you want. And in React, class components are the components that support state and lifecycle methods, which I'll explain later on in this module. So as a rule of thumb, if you just want to render some JSX in your component, use function components. For everything else, use a class component. Next, you'll see how to use props.

Props
All components can also accept props. Props are arguments that are passed in from the outside to the component. Let's change our header component a bit. The first argument passed into the function by React is a props object. The props object is meant to be a read-only object. Now instead of the hardcoded subtitle, let's render subtitle of props as the message. Use the curly braces again to indicate an expression. Now the component that uses Header, in this case the App component in the main-page folder, can pass in a subtitle by writing it what in HTML will be an attribute. When I switch to the browser, you can see that it works. In the next clip, I'm fetching the house data.

Fetching Data
In the Globomantics app, we're working with data that would normally come from a Web API. But for the demo, I use a file called houses. json. I put it in the public folder so that it gets copied to the build unmodified. You can download it as part of the demos from this module from the Pluralsight website. The file contains five houses--two from Switzerland, and three from the Netherlands because I like to promote my home country. Each house contains an ID, address, country, description, price, and photo ID, which we're going to use to load photos from a stock photo website. To load the data in the index. js of main-page, create an arrow function in the class called fetchHouses. In it, I use the fetch API to read the file. Fetch is only available in the newest browsers. But for all the browsers, there's a polyfill which we get for free because it's included in the template app create-react-app created for us. After it's done fetching, I get the JSON from the response, and when that's done, I assign the result to this allHouses. A good reason to use arrow function is that this is always the so-called lexical this. This is always a reference to what's directly around the arrow function, in this case the class object. For our next component, we will need a featured house. I'm adding a function that picks a random house from the list of houses. I then call the function in fetchHouses. The featured house is stored in the state of the component. And that's the topic for the next clip.

State
I store the featured house in the state object of the component by calling setState. State is private data for the component. Props can be used to send state out to other components, but a state object itself is private. Calling setState triggers a re-render of the component. React does this smartly. The browser only updates the parts that need updating, and child components are only re-rendered if needed and asynchronously. Also React guards that re-rendering doesn't occur more than needed. Everything you put in state should be used in the render method. If you have data that you have to store in the component not needed for rendering, just store it in a private property like I did with allHouses. State is read by just reading from the state property. But it should never be set directly. Always use setState for this. SetState triggers the needed re-rendering. All state updates are merged. In the next slide, you'll see what I mean by that. First, the state property should be initialized. Then we can add to the state by calling setState. In this case, we're adding a property called featuredHouse with as a value the featuredHouse object. We can omit the property name if the value is named the same. FeaturedHouse is added to the state object, so the entire state object is not overwritten. Now if we add something else to the state like a countries array, again, it is added to the existing state object. Back to our App component, one possibility to initialize the state is to create a constructor. A constructor has the props as a parameter. If you add a constructor, you must remember to call the base class constructor with these props. After that, you can initialize the state object by setting it to an empty object, or you can provide initial values for some or all of the state properties you're going to use in this component. Another way to initialize state is by using property initializers like this. It's nice and clean. And because it's not a constructor, you don't have to call super anywhere. This is my preferred way to do it. One thing I need to remember is to call the fetchHouses function somewhere. Let's do that in the next clip.

Lifecycle Methods
Lifecycle methods are methods that are called automatically by React on a class component when the lifecycle status of a component changes. A good place to call the fetchHouses method is the componentDidMount lifecycle method. ComponentDidMount is executed by React just after a component is mounted. So that's a good place to fetch data. Mounting, by the way, means adding the components to the tree of React components, which is called the DOM. I'm not using an arrow function now because React calls it and assures that this is the lexical this, but you can if you want. Here are some other methods in the mount lifecycle. They are all optional except render. You already saw the constructor of the component class. You can initialize state in a constructor or do some other initialization of the class if needed. You already know what render does. Besides returning JSX, render can also return numbers or texts. It is then rendered directly in the browser, or null if you want to render nothing. ComponentDidMount occurs just after rendering as I told you. So you can do initialization here that needs the DOM. There are also lifecycle methods for when a component updates. GetDerivedStateFromProps occurs just before the props are received. A default behavior is that every state change triggers a re-render. But by returning false in the shouldComponentUpdate method, you can stop the re-rendering. The rest of the methods are self-explanatory. There's also a lifecycle method to hook into if the component is unmounted, that is removed from the DOM, and one to make the component an error boundary. The next clip explains what that means.

Error Boundaries
A component can potentially render many child components. These child components can render their children and so on. Now let's say something goes wrong somewhere in a child component at any layer. Then you could end up with a partially rendered component tree and maybe a nasty error message. That's not very friendly to the user. Therefore, the component that is the root for the object tree can implement the componentDidCatch lifecycle method and show a friendly UI if one of its children went sideways. Here's an example. If a child component throws an exception, this component sets hasError in the state to true, which causes a re-render. That happens asynchronously, but it still has a chance to log the error. In the render method, the hasError property is checked. If it's true, it renders the error UI. If not, the normal UI. Now let's continue building the app by creating some more components in the next clip.

Nesting Components
In this clip, we'll create a featured house component. It will contain a Featured house banner and another custom component called house, which we will reuse later on. Create a new file on the main-page and call it featured-house. js. If you've installed the Simple React Snippets plugin in Visual Studio Code, type imr Tab to add the import React line. Then type sfc Tab for a stateless function component, and type the name FeaturedHouse. As you can see, the export statement is also added. We'll need the props passed into this component. They are provided as the first parameter. In the function body, we test if the props contain a house. If so, we're rendering a banner and a House component we are creating in a second. We're passing on the house object we got in the props to the props of the house component. If there's no house in the props, we return a div with just a message. Since the house component is going to consist of multiple files, create a new folder for it. It's nice that every component can have its own CSS. So I add house. css with some CSS for the price of the house. Add index. js, type imrc Tab to add an import statement including component. And also import the CSS. And since this component is going to have state, type cc Tab to create a class component. A property initializer is already used to set the state to an empty object. In the render method, pull out house from the props and use this JSX. It renders all properties of the house object. And the photo ID is used to pull the image from a stock photo website. To make the house component work in featured-house, we have to import it specifying the folder. Now the only thing left to do is to import the FeaturedHouse module in the App root component module. And then render FeaturedHouse in its render method passing in the house prop, the value of which we can pull from the state. We stored it as featuredHouse. And now every time setState is called passing in an updated featured house, the house component and thus the browser UI will update. Take a look at the browser to see that it works. We're working on the search functionality in the next clip.

Binding Component Props
We're building the parts to filter the houses by country in this clip. For this component, we need a list of distinct countries to pass into the component we're going to build. I'm creating this list in the root component by adding a determineUniqueCountries method which maps the allHouses array with house objects into a string array with countries. Put that in a set to make them distinct, and then it makes an array of that set. If the houses aren't loaded yet, I'm just returning an empty array. Then I insert null at the first position in the array because I want the first choice to be blank. And then I add the country list and the state. I'm calling this new method in the fetchHouses method after determineFeaturedHouse. Now add a file to the main-page folder and name it house-filter. js. This is the code for it. I already covered most of what's in here except the select component. The value prop of the select component is bound to the search property in the state. When the user selects a value, setState is called automatically by the component to change this search value. When a change occurs, I want to do something. So the onChange event is bound to a function. The onSearchChange function just gets the new value for now, but that will change. I'm talking about the option list inside the select in the next clip.

Mapping Arrays to Components
Just like the HTML element select, there's a list of options inside the select component. I create an option for each country by using the map function on the array. I expect a list of countries to come in from the props. The value of each option is a country string, and a display text for the option is the same string. When rendering lists of components from arrays, React has to know which component to update when a certain item in the array changes. For that reason, we must also specify a unique key for each option component. In this case, we can use the same string because it's unique. Now in the App root component, we can render the new component by importing it and writing JSX for it in the render method specifying the country list and the state as a prop. And, again, it's looking nice in the browser. But right now, nothing happens when I select something. We're fixing that in the next clip onwards.

Passing Functions to Child Components
The App root component is in charge of the houses because it stores all houses internally. So I want it to filter the houses when a specific country is selected in a drop-down, not the HouseFilter component. It's easy to do because we can take a function defined in the root component and pass it as a prop value to the HouseFilter component, which will then call it. Here is a filterHouses method in the root component, which accepts a country string. In it, I create a new array of houses filtered on country name. I put that new array in a state, and we put the country the user selected in the state as well. Now I add a second prop to HouseFilter called filterHouses with, as a value, the function we created. In the HouseFilter component, I can now just call that function with, as a parameter, the selected country. Great! But the drop-down still doesn't do much. Hang on while we work on the final stage of this functionality in the next clip.

Components in Variables
While you were switching clips, I added the code to make the selection grid work. There's a new search-results folder with a root component in index. js that renders a table and child components that are the rows. We first take a look at that child component named search-results-row. It's a function component that renders tr's with td's containing house data. A tr has an onClick event that calls a function that prevents a default click response and calls the setActive house function that is expected to be passed in the props. But there's a parameter, the house object for this row, that is also passed in. The parent component in the search-results folder that renders a table is called SearchResults, and it expects a list of filteredHouses in the props. I map this array to a list of SearchResultRow specifying the unique key, which is the ID of the house, as a string. I'm also specifying the house and the function setActiveHouse, which this component also expects in the props. The result of the map, an array of SearchResultsRow components, is stored in the variable, which is then rendered later in one go in the render method by writing it as an expression. There's not much to show yet in the browser because we are not using the SearchResults component yet. We will do that soon. But in the next clip, I'm taking a step back first to make sure you still understand what we're doing.

Multiple Layers of Components
Here's an overview of how the search functionality is going to work. App is the root component which renders the SearchResults component as a child but only when there's a specific country select in the drop-down. The SearchResults component then renders SearchResultsRow components as its children. The root component is going to contain a setActiveHouse method. The function reference is passed on to SearchResults, which doesn't call it. It just passes it on to the SearchResultsRow. When a row is clicked, the setActiveHouse method is called, and in the implementation, the active house will become part of the state of the root component. As soon as there's an active house, the grid must be rendered instead of the existing featured house. I'm continuing the implementation of this in the next clip.

Varying Render Output with Component Variables
In the App root component, I'm adding the implementation of setActiveHouse, which is very simple. It just sets the state with the passed-in house calling it activeHouse. If the user makes another selection in the drop-down, I'm resetting this value to null in filteredHouses because activeHouse won't be current anymore. In the render method, we now have to make some changes. The header and the HouseFilter are always on the screen, but I want the FeaturedHouse to be only visible when the user didn't select a country. When a country is selected, I want to display the grid with results. And when a user has clicked a row in the grid, I want to show the selected house. The solution is to declare a variable. I render the variable instead of the FeaturedHouse component. Now we can determine which content should be rendered by using if statements. If there's a country selected, we assign the SearchResults component to the variable passing in the country, filteredHouses and setActiveHouse props. If there's an active house, we want to display that house with the HouseDetail component we already created when we did the FeaturedHouse component. And when none of this is going on, we want to display the FeaturedHouse. Don't forget to add the import statements for the missing components. Now let's take a look at the browser. We did it! The final feature will be a way for users to get feedback if they are interested in a house. And that's up next.

Form Controls
In the house component, I want an icon to make feedback possible. When the user clicks it, a form should appear. To make this happen, I've added the icon as a PNG in the house folder, and I've added an Inquiry component, which initializes the state values corresponding to the input fields to empty strings. The component renders a form with text inputs. Their value is bound to a state property, and the onChange event to a method. The corresponding functions prevent the default behavior and set the corresponding state with a new value. The Submit button of the form is disabled when the length of name or email is 0. Every call to setState will trigger a re-render if needed and, thus, enable the button as the user types. The Submit button also has an onClick event handler that prevents the default, gets the house the inquiry is for from the props, and gets all contact information from the state. The omitted implementation here is to send the data from both objects in an email or something. In the house component, I'm importing this new component and the envelope image. I'm adding a state property that initializes to false and an inquiryToggle method that inverses that Boolean. That method is used in a new instance of the img component just under the house. description. The image is imported as emailIcon. And when that icon is clicked, the inquiryToggle method is called. I can now just create a variable again filling it with the inquiry component if inquiryShown is true. I'm making it null when it's false. Rendering null is fine. It will just render nothing. Now I can just render the inquiry variable below the image. Let's go test in the browser. Yes! The application is now feature complete.

Summary
You've learned Component 101 in this module, and most importantly, you are now ready to unleash your creativity by building and arranging components yourself. The next module is a collection of tips and tricks to enhance your React dev experience.

Augmenting Features and Tooling
Module Overview
You now know the basics needed to create your own React app, but there are still a couple of things to point out. I'm talking about separating component state from UI first. After which, we will take a look at the built-in way to type check props. Routing requires a separate set of components. I'll show you how that works. The context API in React is a great way to share global data. Also, a brief introduction about Flux and Redux to let you determine if this is for you or not. Next, we're looking at ejecting. That means assuming control of the create-react-app build process. Unit testing is supported out of the box with Jest. I will brief you on that. And, finally, the ins and outs of progressive web apps with React. I'm starting off with separating state from UI.

Separating State and UI
Separating state from UI in a component is considered a best practice by many. The reason is separation of concerns. When you think that having state, logic, and UI in one class isn't a good idea, this is something worth considering. The downside has a bit more complexity. Although the Globomantics app is still relatively small, the App root component already contains a lot of code. Methods and render logic are all thrown together in one class. Here's a solution that uses a different approach. I've created a file called app-presentation, which contains a function component that essentially just has the render part of our original component. I've copied and pasted the render implementation from the App root component, and instead of passing in state in a child component, I now expect everything to be in props. Of course, you have to move over the import statements as well. In the render method of the original component, I now just import the new component and render it passing in everything it needs by using props. Now you might or might not like this. Just pointing you to the possibility. Next, we'll see how we can make the code more error resilient.

Type Checking
React does a great job when it comes to producing error messages at development time. Let's switch to featured-house component. When I delete the house prop of the child House component and take a look at the browser console window, it's already producing a pretty good error message. Since House is undefined, I can't access the property 'country. ' But we can do even better. First, install the prop types npm package by typing npm install --save prop-types. Then in the house component, type impt Tab on the import line to import prop types. Just before the export line, add a propType object property to the House type specifying that the house prop should be an object that is required. You could omit isRequired when you only want to do type checking if it is passed in. When we now take a look at the browser, you can see an error message that is a bit more descriptive. In this particular case, it doesn't seem like a big deal. But as applications become more complex, this makes debugging much easier. If you like this, it's a good idea to introduce this pattern in all your components. To optimize performance in production, these checks only run when your application runs in development mode. If you'd like for these errors to come up at development time, you should take a look at using React in combination with TypeScript. I've done a course on TypeScript in the same style as this one. Routing is up next.

React Router
The demo app works great as it does, but it works only on the root URL. When I select a country, for example, the user's perspective is that we change to another page, maybe she is inclined to press the Back button in the browser to go back to the previous page. But that doesn't work because the URL is unchanged. The most used solution for this is called React Router. The cool thing about React Router is that it is just an extra set of components. In this app, I've tried to graph the basics of React Router. I can click the links that each render a different very simple component under the header. Each link actually changes the URL that gets a specific component to render. As you can see, the browser has a history now, and I can press the Back button. I've used the default create-react-app template here and installed the package by typing npm install --save react-router-dom. Now I can import four components from the package in the App root component. Below it, you can see three different components that get rendered by clicking on the links. They are very simple function components, and they are now together in one file with the App root component for simplicity sake. Scrolling down to the App component, the root node is BrowserRouter. This is the actual router component. It tracks the history of the browser and makes that available to all child routing components. BrowserRouter assumes a server that can handle dynamic requests. You need this one most of the time. But should you have a server that can only serve static files, you can use the HashRouter instead. In a ul, I'm rendering the three links. The Link component is also part of React Router. Each link points to a relative URL. The Route component determines what should happen if a certain relative URL is hit. So for the root, it should render the Root component or search the Search component and so on. The Switch component around the Route components makes this a routing table. That means React Router will start with the first route and work its way down until a match is found for the current URL in the browser. And then it will just stop evaluating the rest of the routes. By default, it also matches if the match is just a partial match. So when I type /search in the browser, the first route will be a match already because of the slash. Since slash is the root, I don't want that. So I'm marking this one as exact. Now if there's something behind the Root URL, there will be no match. I'm talking about context in the next clip.

Context
A component tree can quickly grow. The Root component could have many children. The children could have many children, and so on. What if you want to pass information that is considered global to a tree or sub-tree of components, for example, what language these components should use? Or what the username is? You could use props of course. But it seems unnecessary to pass on the same information over and over again to each component. This is where context comes in. In this example, no context is used. The theme with the value dark is passed with a prop to the child Toolbar component, which does nothing with it. It just passes it on to its child ThemedButton also with a prop. And then the ThemedButton uses it to set the theme prop of a standard button component. Here's the example with context. In the first line, the context is created with just a string 'light' in it, which acts as a default value for this context. In this case, it's just a string. But it could be an object as well of course. Right now, the context is declared in the same file, but you would typically export it from a module and import it in the component modules that need a context. This example is just presented this way to make things clearer. The Root level component tells the context that it is the provider of the value, and it provides the value "dark. " Then it renders the Toolbar component. The Toolbar component itself doesn't do anything with the context, but it renders a ThemedButton which uses the context and declares itself as a consumer of the value. The value is caught using an arrow function. So the value "dark" will be in the theme variable. The ThemedButton passes this to a standard button component with a prop. Because the context has a default value, a provider is not a must. Without it, the ThemedButton would work with a light theme. But why the complexity with provider and consumer? Well, in this case, the value set in the provider is kind of static. But what if the value was dynamic because it was taken from state or a prop for example? Then the context would take care of updating the value automatically across all children. In the example I showed you, there was just one consumer. But you can have many with the same provider. It will know exactly where to update the value because all the consumers of the value are known. The topic for the next clip is Flux and Redux.

Flux and Redux
Flux is an architectural pattern, and Redux is one of the implementations of the pattern. If you don't have problems designing applications in the way we designed the Globomantics app, you don't need Flux. Flux was born because Facebook was using React with very complex applications. They struggled with issues where actions triggered cascading updates that led to unpredictable results and code that was hard to debug. Problems occurred because top-level components got too heavy with logic and responsibility. Should you have the same problems when developing a complex app, Flux may be the solution. But keep in mind, Flux adds a lot of complexity to your application. Flux architecture introduces a new way of thinking about state and resulting UI updates. One of the most important new concepts is that state is now stored outside of components. Due to the nature of this course, I'm only covering Flux and Redux on a conceptual level. In Flux, there's the concept of a view. A view is a React component. When something happens in the view that could be interesting for the rest of the application, it creates an action, which is basically an object with data defining what has happened with context information. The dispatcher is responsible for watching the actions that come in. Dispatchers receive and distribute actions through stores. It knows where to send the action because stores subscribe to a particular action. The store determines if the action is relevant for them. If it is, the store changes its state and instructs the view to re-render. The dispatcher typically has multiple subscribing stores that each take care of updating a particular view. If you're interested, I encourage you to go to the Redux website to take a look at the examples. We're ejecting in the next clip.

Ejecting
Create-react-app is great to get up and running with a complete development environment in minutes. It configures a build configuration using defaults. But what if you don't like this configuration? Maybe you want to add things to the build pipeline or change a Babel setting for example. In these cases, you can eject. Let's see what happens if we do that. Just type npm run eject in the terminal window. Since there's no way back, you are getting prompted if you really want this. Once it's done, there's a config folder added to the project. In it are all JavaScript files that make up development pipeline. You can now modify how Webpack prepares a build for example. But what's the downside? As you saw when you use npm to create a production build, for example, react-scripts is used to make it happen. React-scripts is updated on a regular basis. If you want to go to a new version, you can just bump the version in package. json. Once you eject, you're on your own because react-scripts isn't used anymore. All build logic is now in your project so you have to maintain it yourself. As a compromise, you could look at forks of create-react-app that let you modify more than the original without the need to eject. You can find an example by using this link. Unit testing is up next.

Unit Testing with Jest
When we created the Globomantics app with create-react-app, it also created an App. test. js file. It already contains a unit test. The unit test creates a div, calls ReactDOM render to render the Root component, which is the actual App component that is imported, and then it mounts it again. When there are no exceptions, this test will pass. Create-react-app uses Jest, a unit testing framework also by Facebook. You can easily run the test by typing npm test in the terminal. It passes, yay! Just like npm start, the command keeps running in watch mode. Every time we make a change, it affects this unit test. The test will automatically re-run informing us right away about any problems. Besides checking if components render without error, you can also use the expect global function to assert that conditions are true. The possibilities of Jest would warrant a separate course, so I'm not getting in to more detail here. But you can take a look at the documentation of Jest by following this link. Progressive apps are up next.

Progressive Web Apps
When working with create-react-app, by default the production build, so only the production build, is a fully functional, offline-first progressive web app. Progressive web apps are faster and more reliable than traditional web pages and provide an optimal mobile experience. Without doing any extra work, we already created a progressive web app. Here is how it works. On the left side is the browser requesting the app with all its assets. That is, the HTML, JavaScript, CSS, images, and so from the server. The response gets cached by a service worker. Maybe you have noticed the JavaScript file for it in the project. On each subsequent request by the browser for the app, the needed files will come from the cache instead of the server. In the background, the service worker will check for updates at regular intervals at the server if a connection is available. Keep in mind that when users view your app, they could potentially see an out-of-date app because the service worker didn't do an update yet. Offline functionality is great for devices that don't have a constant connection to the internet. But if you want to maintain this offline support in your app, there might be extra work involved. What if the houses in the Globomantics app were stored locally but were fetched from the server? To maintain offline support, I could then write code to store the houses in, for example, local storage once they are fetched and use that cached data as a fallback scenario when there is no internet connectivity. So progressive web apps are great, but they require some more thought when server interaction is required.

Summary
In this final module, you saw how to separate the concerns in a component. And debugging can be made easier by using type checking. We also looked at how to route URLs and the way to share data across components with context. I talked about Flux to give you a sneak peek into its architecture. And by ejecting, you can take control of the build pipeline create-react-app created for you. We also looked at Jest, a unit testing framework. And you learned the basics of a progressive web app. Thank you for watching this course! I hope you have fun creating React apps.
