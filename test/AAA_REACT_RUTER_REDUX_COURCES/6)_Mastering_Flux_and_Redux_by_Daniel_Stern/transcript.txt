At the core of any solid web application is an effective and well-managed data model. In this course, Mastering Flux and Redux, you'll learn the skills and technologies necessary to manage your application's data model in extremely efficient and standards-compliant ways. First, you'll learn all about the popular data-modeling libraries Flux and Redux; their differences and similarities, how they relate to one another, and which is appropriate for what kind of projects. Next, you'll apply what you've learned in four modules packed with hands-on demos where you will build a 3-part Flux and Redux application featuring a message board, a TodoMVC page, and a control panel. Then, you'll explore the skills needed to create any Flux or Redux application, modeling changes with actions, and developing idempotent functions for reducers. Finally, you'll create Redux stores with reducers and middleware, combining reducers, using and implementing a dispatcher, and much more. When you're finished, you'll have a deep understanding of both Flux and Redux, allowing you to implement them for any project you choose, integrate seamlessly into any workplace project employing either of these technologies, and get started towards developing your own implementations and middleware.

Course Overview
Course Overview
Hi everyone, I'm Daniel Stern, also known as the code whisperer, and welcome to my course, Mastering Flux and Redux. I am a web developer and contributor to the open source community, authoring many notable libraries, including the widely used Angular Audio Module, and the popular tool, Range. CSS. In addition to having numerous other courses here on Pluralsight, Redux is among the 30 fastest growing libraries on GitHub, which makes sense considering that it revolutionizes the way your web applications manage data. In this course, we're going to learn both Flux and Redux, building on the lessons learned from Flux to truly understand and use Redux effectively. Some of the major topics we will cover include building applications with Flux, building applications with Redux, understanding unidirectional data flow, modeling changes to application state with actions, and creating reducers using pure functions. By the end of this course, you will be able to build an application independently using Flux or Redux, or integrate into any workplace project already implementing these technologies. Before beginning this course, you should be familiar with HTML, JavaScript, ES6, and Node. js. From here, you should feel comfortable diving into Flux and Redux with courses on building React applications with Redux, creating Redux middleware, and building Flux applications. I hope you'll join me on this journey to learn Flux and Redux, with the Mastering Flux and Redux course at Pluralsight.

Course Introduction
Introduction
Hello, and thank you for choosing Mastering Flux and Redux. I am Daniel Stern, and I'll be your instructor for this course. I have many years of experience writing JavaScript and Node. js code, so I hope you'll find this course as interesting to watch as I found it interesting to create. In this video, we'll take an overview of what's to come in this chapter. First, we'll take an overview of the course, a broad look at what will be included and what technologies you'll know by the end of this course. We'll review what we will and won't be covering, so if you're concerned that this course may overlap with knowledge of technologies that you already have, you're going to want to have a close look at this video. Next, we'll take a close look at who this course is designed for and who will benefit most from watching it. I've tried to make this course broadly applicable to all those except the very most advanced students, so I recommend you have a quick look at this video to make sure that it applies to you. Next, we'll take a detailed roadmap of the chapters that are going to come in this course, what we're going to learn, and the order these topics are going to come. If you're the kind of person who likes to stay organized, then this is the video for you. Finally, we'll look at what the prerequisites are before starting the course, what technologies will you need to know and what softwares will you need to be familiar with. This will be discussed in the prerequisites video. Alright, in the next video we'll be taking an overview of the course.

Course Overview
In this video, we'll be taking an overview of the course as a whole. This course aims to teach students both Flux and Redux in a highly practical manner. As Flux is a precursor to Redux, we'll start by learning Flux from the ground up, and then apply that knowledge to learning Redux. We'll implement our new knowledge of Flux and Redux in a sample application. So first we're going to learn about Flux, what's its history, what's the logic behind it, what's its current status in the online community. After that, we're going to implement Flux in an application. We'll be building a control panel using Flux, and then implementing Flux's ReduceStore to build a tasks page similar to the functionality you might see in a common TodoMVC project. After that, we're going to learn about the relationship between Flux and Redux. What knowledge of Flux can you take and apply to your learning of Redux? It turns out that a lot of the information about Flux actually applies to learning Redux, like actions, reducers, and more, and we'll cover all that in the chapter on learning Redux. After we've learned how they interrelate, we'll learn Redux, especially the things that are different from Flux. Generally, they're very similar, but Redux adds some interesting functionality, and we'll devote a chapter to learning about it as well as its history and its role in the online community. Finally, we'll take our knowledge of Redux and implement it in our most ambitious application so far, a messenger service similar to the kind you might see in Slack. Overall it's going to be a very interesting course, so I hope you stick with us.

What We Will Be Covering
Before we go any further, it's important to have a discussion of what this course will and won't be covering. This course will provide a comprehensive tutorial on both Flux and Redux, and by the end, students will be able to confidently implement an application in Flux or Redux, and seamlessly integrate with a team that's already using these technologies. Though Flux and Redux are closely tied to React, we won't be covering React or JSX at all. Though React is a hugely popular library, it's also quite complex. There are a lot of features, and in my opinion Flux and Redux are very useful without React. By avoiding React, we'll teach Flux and Redux in a way that will let you apply it to any frontend you wish, be it React, or Angular, or something of your own choosing. Now we won't be covering ES6 or Node in this course, but you will be expected to have some knowledge of them, at least enough to keep up during the live examples, so if you don't know anything about them, I can recommend some excellent courses in the next slide. During this course, I'm going to provide you with complete code examples, so in theory, with no knowledge at all, you should still be able to code along at home, just by copying what I write. However, we won't be covering the basics of Node or ES6. If you're not familiar with these technologies, I recommend you watch the following courses first. First is the course, Rapid ES6 Training, available here on Pluralsight. The URL to access this course is available on the screen. As the name implies, it's rapid, so you should be able to complete the course fairly quickly and come back ready to learn. Now if you want to become a bit more familiar with Node before moving on, I recommend the course, Play by Play: Node Web API with John Papa and Sam Artioli. That's available at the URL listed on the page. Overall, if you want to watch these videos first, it's up to you, the key factor is are you comfortable with your knowledge of ES6 and Node? If so, then proceed. If not, then reconsider taking a quick look at these courses first.

Who This Course Is For
Now we must ask the question, who is this course for? Are the technologies within and the style in which they are going to be presented, applicable to you? Will it help you in your day-to-day coding? Let's find out. This course is designed to appeal to students with a broad range of skills relating to the technology. Students who have never used Flux or Redux will find this course very useful, as the from the ground up approach I've decided to take will allow you to learn these skills without being complicated by other technologies. If you don't know anything about Flux or Redux, this really is a great place to start. Additionally, if you already have some experience with Flux and Redux, you should still find at least the most part of this course useful, as this is a thorough analysis of almost all the features of both of these libraries. After watching this course, you can definitely say that you have a full overview of the breadth of the topic. This course is suited to people who are using Flux or Redux in a workplace environment. If you're on a project and the architect has chosen that Flux or Redux is the tool to use, by taking this course you'll be able to participate more efficiently and fluently with a development of the application. Additionally, if you're an architect and your responsibility is to choose which technologies the teams are going to use, then this video should also be extremely useful. Whether or not you choose to implement Flux or Redux, this will give you an overview of the advantages and disadvantages of using those technologies. By the end you'll definitely be more well informed of which to use. Finally, if you're an entrepreneur and you like to build entire websites yourself, put them on the internet, market them, the whole 9 yards, then this video is for you. I personally have found Flux and Redux to be highly leveraged libraries that are well suited to projects created by just one or two individuals. If you are an entrepreneur or a solo developer, I do strongly recommend that you watch this course, because it is likely to save you much more time in the long run than it will take to watch. So if any of these people sound like you, then I recommend you continue on to the next video.

Course Roadmap
Let's take a quick minute to have a look at the roadmap of the course. More thorough than the overview, this will be a look at the course, chapter by chapter. So chapters 1 and 2, this one and the one that follows, will introduce you to high-level concepts, this chapter, the introduction to the course, and the next chapter, the introduction to the two technologies, Flux and Redux. After that, we'll devote two chapters to Flux, one to talking about its various strengths and weaknesses, its history and place in the community, and another to implementing it in an application. As previously mentioned, we'll be implementing Flux two ways. One, a basic Flux implementation, and second, a more advanced implementation using a ReduceStore. Using the ReduceStore will prepare us for chapters 5, 6, and 7. These chapters will follow much the same pattern as chapters 3 and 4, except regarding Redux. First we'll learn about Redux and its strengths, its weaknesses, and how well it's supported, and then we'll implement it in an application. In chapter 7, we'll take a minute to implement and learn about a synchronous Redux, which is a challenging but highly practical skill that must be learned for most real world web applications. Finally, in the last chapter we will review everything we've learned and make sure that all the concepts were well understood. I will also recommend some further learning to take on after completing this course at that time. Now, if that's all sounding good, let's move on to the prerequisites for this course.

Course Prerequisites
Now if you like learning technology as much as I do, you're probably very eager to get started. However, there's one more thing to do and that's to make sure you understand the technologies and skills that will be required to succeed in this course. In terms of technology, you should know JavaScript and ES6. You will also need to have some knowledge of HTML and CSS, however all this code will be provided for you, so even the most basic knowledge will do. Finally, you'll need some basic knowledge of Node. js, as this will be the platform on which we build our application. You are going to need the following technologies, which will take a minute to install in an upcoming chapter, but here's a preview. You'll need to have Node, I'm on version 7. 2. 0, but any compatible version will be fine. You'll really want to have Git on your computer, as this will give you access to the project files which will ensure your success in the course. A text editor will of course be required, but this is the first course in which I'm recommending a text editor, WebStorm. WebStorm has really good support for ES6, and we'll be using that heavily. This is a paid software, but in an upcoming video we'll be going through the process of downloading a free trial, which should give you long enough with the software to complete this course. Finally, in order to help with the installation of various packages and Node, you'll want to be an administrator on your computer. It is possible to complete this course as a guest, or on a computer at your college or workplace for example, but it's not recommended. Logging in as an administrator before you start the course will ensure that all the technologies are installed correctly, and with the proper permissions. That's all there is to the recommended technologies, and this chapter. In the next chapter, we'll be introducing our two technologies, Flux and Redux.

Introduction to Flux and Redux
Introduction / Why Learn Flux and Redux?
Hello and welcome to this chapter, Introduction to Flux and Redux. Before we go ahead and actually learn these technologies, it's good to learn a bit about them; what's their history and why should you as a developer or entrepreneur learn these skills? We'll be covering four things in this chapter. First, we'll consider why we should learn Flux and Redux, what are the benefits of learning these skills, are there other skills that would be more valuable, or are these the best use of our time? We'll discuss that in this video. Following that, we'll learn about the relationship between Flux and Redux, why are we teaching both together in the same course, and why are they always mentioned together? We'll learn how one relates to the other and how this will affect the rest of the course. Next, we'll discuss the separation of view and model. In this course, we're not teaching React, a view engine, at all, and in this video, we'll explain why this is the case. Finally, we'll take a look at the finished application, a guided tour if you will, of the app we'll be building using Flex and Redux. So, why learn Flux and Redux? Debugging my application for the fifth time this week is awesome, said no one ever. The reason why no one would say this is awesome is because debugging applications can be a chore. Really we'd like our applications to work properly the first time we build them, and not break, and this is something that Flux and Redux can help us do. Now if we look at Flux and Redux on GitHub, we see some very promising results. With 12, 000 and over 24, 000 and growing stars respectively, Flux and Redux are some of the most popular and fastest growing libraries out there. At the time of writing this, Redux was also number 56 among any language on GitHub, and among the top 30 fastest growing libraries as well, also in any language. I say this to emphasize that Flux and Redux are popular and actively maintained libraries, especially Redux. If you learn these, you're not going to have to worry so much about these technologies being forgotten or not being maintained or quickly being deprecated, you know you're working with a library that has lot's of people using it, and that means this library is likely to stay alive for a while. Plus, at the workplace, people are probably going to choose which libraries to implement for their project based largely on popularity, so by learning these, you'll be ready to use those libraries in those projects when that time comes. Now, just what makes these libraries so popular? Well, one can always speculate, but here are a few reasons I think apply. First of all, they both have great community and enterprise support. Both these libraries are closely related to Facebook, which is one of the largest and most respected technology companies in the world. Developers from Facebook either created or support both these libraries, and as well, the community of individuals like me or you who also contribute to Flux and Redux is also very significant Next, they're both simple light-weight libraries, they don't try to do the whole world, they just do one specific thing very well. Flux weighs in at about 2. 5kb, and Redux at about 6. 83. These light footprints have little impact on the time it takes for users to download and compile your app. In addition, it lends to the libraries ease of understanding. Neither Flux or Redux are too complicated, they all do straightforward things that can be explained using clear principles. Next, Flux and Redux, both being modern libraries, have a lot of support for ES6 and ES7. They're built with things like the Spread Operator, and classes in mind. We'll be using lots of ES6 and ES7 in this course, and you'll find it will be quite necessary to use these libraries to their fullest. Now with people using more ES6 and ES7 in their applications every day, this makes Flux and Redux a natural choice. Finally, both applications work well as a data model for React. Flux specifically says it's for React right on the GitHub page, and Redux is often immediately considered as a data model for React. Since React is so popular and used in a large amount of modern projects and websites, Flux and Redux naturally find themselves included, piggybacking if you will on React's wild success. All in all, this explains why Flux and Redux are so popular. Hopefully you can feel confident that learning these libraries, you'll be able to apply what you learned for many years to come. In the next video, we'll learn how the two libraries relate.

How Do Flux and Redux Relate?
In this video, we'll be discussing the relationship between Flux and Redux. It is a little bit unusual for a course to teach two technologies, sort of in parallel, like this one. But you'll find that Flux and Redux, while not being the same, are closely related along many veins. Now as Eric Elliot said, Nondeterminism is a bug in itself. What he means by this is that in applications where you don't know what the result of a particular action will be, if clicking a button will cause one thing to happen or another, makes them extremely difficult to debug. Well Flux and Redux are both designed to mitigate this problem of nondeterminism. Of course, we'll be discussing this in much more detail in future videos. So, how are Flux and Redux similar? First of all, they share a lot of the same vocabulary. We'll be discussing things like reducers, actions, dispatching, and more in both our discussions on Flux and Redux. These words have largely the same meaning from one library to the other, so once we've learned the vocabulary for Flux, we'll find Redux a lot more easy to understand. In addition, as we discussed, Flux and Redux are both lightweight libraries, neither weighs much more than 5kb, so it makes them easy to include in any application. Lastly, Flux and Redux are both just a data model, they don't render anything to the page, they don't do any direct to server communications, it's just a place for the part of your application which handles your view, like React or Angular, to find out what that view should be. So in a fact, Flux and Redux do very much the same thing, but in different ways. I've prepared this diagram to help explain what makes Flux and Redux similar, and what makes them different. We're going to go over it now, but I do encourage you to return to this video and this slide later when you're more familiar with Flux and Redux, to review it again, as it is a very dense and useful diagram. So first, let's look at what makes them similar. They both use actions, and action creators. If you're not sure what these are, don't worry because we'll explain them thoroughly in an upcoming video. Just for now if you don't understand, try to absorb the vocabulary so you're more prepared to follow along later. The both enforce one-way data flow, which is where components in your application don't intercommunicate, but go through a single source. They're easy to implement, not requiring too much boiler plate, or even knowledge to get started with. They're not tied to any view engine, you can use Flux and Redux with any view engine you want, be it React or Angular, or even Amber or some other engine, jQuery. Now the version of Flux does have a few integrated ties to React that make React the dependency of it, but this does not mean you can't use Flux with Angular. As we've said a few times, they're both quite lightweight, and they both use reducers or functions that take a state and an action and return a new state, as an intracule part of those libraries. We'll discuss reducers in a later video as well. As far as differences goes, let's take a quick look. Now with Flux you have a dispatcher that's separate from the store, you could have numerous stores, but in Redux, you only have a single store and the dispatcher is built right into that store. So there's just one part in Redux, where in Flux there would be many. In Flux, you don't have to use reducers, it's just recommended because they make it easier to debug your application, but in Redux you have to use reducers, it's required, and in many implementations of Redux if you don't use a reducer, you'll get an error and be unable to proceed. Finally, Flux is the precursor to Redux, whereas Redux evolved from Flux. If there was no Flux, probably we wouldn't have thought of Redux yet. At the same time, we should expect Redux to be more sophisticated and yes, complicated, than Flux. This is important to keep in mind, especially because in this course we'll be taking it in that order, learning Flux and then evolving into implementing Redux. In the next video, we're going to talk quickly about separating the view and model.

Understanding the Separation of View and Model
In this video, we're going to understand the separation of view and model. View, what you see, and model, the logic or skeleton behind it, are both important concepts. Why though, should we keep them separated, and what does that have to do with the rest of this course? So let's quickly look at the differences between model and view. Now you might think this is pretty elementary, but many times in many courses, concepts like Redux and React will be intertwined, even though one is a model and one is a view. Let's have a look. So a model is what developers are working with. The end user probably isn't going to know that any model exists, however the user will be seeing the view, if there's something wrong with the view, even a basic user with no technical knowledge will realize that something is wrong. This is important because as a developer, remember you're going to be dealing with the model almost every day. You want it to be easy to understand and work with, so you don't get sick of fixing the bugs that inevitably crop up. Likewise, when you're working with the model, you won't be able to add new features and fix bugs quickly, if you can't, then your model isn't very good. On the other side with a view, performance is really the most important thing. Sure it's great if a view is easy to debug, but if it's slow or choppy you're just going to be limiting yourself compared to what you could get with a different view. This is one of the reasons why people like React so much, because it's very performant, using a virtual DOM to rapidly update the HTML faster than could be done with just JavaScript alone. As far as models go, Redux and Relay are both popular. In fact, there are dozens of popular models, but we're not going to talk about them so much. View wise you have many popular and very familiar sounding libraries like React, Angular, and JQuery. It's no coincidence that some of the most popular JavaScript libraries which everyone recognizes, React and Angular, are both libraries that are principally concerned with creating a view. Admittedly Angular and jQuery do a lot more than that, but those are just helpers. At its core, it's something that helps you put forth to the user what you want them to see. Finally, a quality of a good view is that based on the model that's behind it, you should be able to predict how it looks. If you have a surgeon React component and I give you a particular model or some data that's backing it, you should be able to tell me what that component is going to look like. It isn't a game of guessing where you have to program it and then maybe it'll look one way or a different way, even a situation where the same component with the same model might look different in two different situations, just based on how the user is using it. So in this series of videos, we're not going to be using React, we're not going to be using jQuery or Angular, we're not going to be using any view at all, we'll be using JavaScript to create the simplest possible view imaginable, with absolutely no bells or whistles, and the reason for this is we're going to focus entirely on the model side of things. Now just because this choice is so unorthodox, I thought I'd explain why exactly we're not using React during this course. It's a decision I made on purpose based on the following things. First of all, you don't have to know React or learn it before beginning this course, if you know JavaScript, you know enough. Maybe you want to learn React as well or after, but that's up to you. In my opinion you don't need to use React with these libraries, and you should have the tools to use whatever view you want. In addition, JSX, in integral part of React, is powerful but it's tricky. You need to compile it from JSX to JavaScript, and admittedly we will be using Compiler in this application, but we need to install new things to it. In addition, there are various additional rules to using JSX, which really, I didn't want to skim over, they deserve their whole course. Additionally, the React API is subject to rapid changes, and we don't want the API to change after we've completed the course. Redux on the other hand is much simpler than React and it's unlikely that we'll see these key concepts change probably ever, so ultimately the reason why we won't be using React in this course is so that you the student are able to choose React, or Angular, or any other choice. There are some great courses on Pluralsight about React, and we'll have a quick discussion about them at the very end of this course. In the next video, we'll have an overview of the application.

Scenario Overview / a Look at the Finished Application
In this video, we'll be taking an overview of the scenario of this course by quickly looking at the finished application we'll be building. Basically, you are a web developer at an up and coming startup. You've been tasked with single handedly developing a company's flagship application, an all in one workplace productivity app. Your MVP, or Minimum Viable Product, has three features. The first and simplest is a control panel where users can change their username and select a few other preferences. We'll be building this with basic Flux. Next is a tasks board, basically a to-do list, or TodoMVC if you're familiar with that, a place where members of the team can share things that need to be done with other members of the team. We'll be using Flux but we'll be using part of Flux called a ReduceStore, which is a more advanced implementation. Finally, you need to build a messenger service so users can communicate with each other in real time. This is going to be the most complicated and difficult to debug part of the application, so you're going to use Redux to build it since you know that while it takes a little bit of extra setup, Redux is great for debugging and really easy to get to the bottom of problems that may occur. Ultimately you've chosen Flux and Redux as the backbone of your application because hey, it's going to be a lot of work doing this all by yourself. You can't afford to choose an unreliable or inconsistent way of managing your model, you need something that's easy to debug and also compatible with the latest technologies. Now I just want to note here that if this was a real application you'd probably just pick one, Flux or Redux, to implement for the whole thing. But, this is a course and we're having a bit of fun with it, so in this example you'll be using both. So let's demonstrate what it is we'll be building. We'll be reviewing the final application that we're building with Flux and Redux. This includes a control panel, a tasks board, and as we previously mentioned, a messenger service. So here we are at our application. Simply entitled Productivity App, it's an application with a few different features that lets users be more productive. You can see right off the back I've used Bootstrap to style this. That's because I believe that the finished product you make should be presentable, you should be able to actually show what you're building in this course to future or current employers, and for them to well be similarly impressed by its ease of use and style, leaving you to focus on the explanation of what technologies you implemented. Let's have a look at the control panel. So the control panel is very simple, users can update their username in real time, and can change their font and how big it appears on the screen. This functionality's all backed with Flux and we'll be building this page first. Next, let's look at the Tasks page. So the Tasks page is a TodoMVC style component in which users can add new tasks and complete them. You can check tasks to indicate they've been completed, and you can hide any tasks that have been completed to focus only on the ones that are still fresh. Finally, and most interestingly, you can undo every change you've made to this application by pressing the Undo Last Change button. This is an amazing feature granted to us by an integral part of Flux's ReduceStore, which is the ability by design to store previous states. This is going to be a really exciting one so I hope you're looking forward to it. Finally, the Message Board. So here is a message board and you can type a new message to send to your peers. Notice how it appears at the top and there was a slight delay. This application is simulating asynchronicity so that we'll have a chance to learn about Redux's asynchronous actions and its support for communicating with servers. In addition, we can change our status to Online, Away, or Busy, which don't do anything yet, but Offline makes it impossible to type a new message. So there's a few different things going on and components that are interacting with each other on the Message Board. So that concludes our look at the application and this chapter. In the next chapter, we'll be taking a good long look and explaining all the fundamentals of Flux.

Understanding Flux Fundamentals
Introduction
Welcome to the next module in Understanding Flux and Redux. This module, entitled Understanding Flux Fundamentals, is all about understanding Flux. Before we can build an application with Flux, we have to understand what the principles are that went into making it, and how it works. In this chapter, we'll be discussing the following things. First, we're going to touch of Flux basics; what is Flux, what's the rationale behind it, and where can it be used? We'll discuss unidirectional data flow, which is a one-way means of transferring data that Flux uses to manage the data that's put into it. We'll talk about the Flux Dispatcher, which is the part of a Flux application that other components use to send messages to different parts of the application. We'll talk about Flux Stores, which is the part of the Flux application that any component can go to, to get a relevant part of the data model that's up to date. Next, we'll discuss the ReduceStore. The ReduceStore is very similar to the regular Flux store, but it's more advanced and will prepare us for learning Redux in the second half of this course. Finally, we'll learn about idempotency, or function purity. Idempotency is an important concept for any programming application, but it's extra important for ReduceStores or Redux, since they only work with these kind of functions. In the following module, we'll be implementing all these things, so it's important to pay attention now to gain a good understanding. In the next lesson, we'll begin discussing the basics of Flux.

What is Flux?
In this lesson, we're going to discuss what is Flux? This, even from the point of view of a course, is a difficult question to answer, since the word Flux can mean different things to different people. It may refer to a particular library or an architecture for building websites. According to the GitHub page for Flux, Flux in an application architecture for React, utilizing a unidirectional data flow. So at face value, we can say that Flux is an application architecture. The quote says that it's for React, but I personally find Flux to be appropriate for a wide variety of different front-end view engines. We can also determine that the unidirectional data flow is an important part of what makes Flux what it is. The image on the left is the logo of Flux. So Flux is a way to manage your app's data model. In an application, you're going to have various components and then a centralized data model backing it all up. For example, in a TodoMVC application you need somewhere where the actual Todo items and whether they're completed or not is stored. There are many ways of course to manage this data, and Flux is just one of them, but it really works well. So in addition to this, Flux can also refer to a popular implementation of this architecture, in other words the Flux Repository on GitHub. It's important to make this distinction. Sometimes individuals will talk about Flux, referring to the architecture, and other times they'll refer to the library, and it's important to be able to tell which one is which. In this course, Flux will almost always mean the application architecture and not the particular library. So the first mention of Flux was on May 6th, 2014 on the Facebook developer blog. This means that even now Flux is still fairly new and is constantly evolving and changing. Now the implementation of Flux that's available on GitHub has React as a dependency for some of its features. It's meant to work with React, but in principle the Flux architecture works with any view. In this course, we'll be implementing Flux ourselves, so as not to be limited by the React dependency. In the next video, we'll explain unidirectional data flow, which is a core element of how Flux manages applications.

Unidirectional Data Flow
Unidirectional data flow is the means that's implemented by Flux to manage the data that flows through your application. In a Flux application, any changes to the data model start out as actions, or a description of a change to data. The actions are passed to the dispatcher, which we've already mentioned briefly. The dispatcher then notifies the stores, which notifies the views. The views in this case are equivalent to our components, be they Angular or React, and it's at this point that the, how the application appears actually changes. The user might then change the model again by interacting with an interactive part of the view, like a button or a text input. Rather than going directly to the affected components, this action is sent again to the dispatcher, which once again goes through the stores to propagate the data to the relevant places. So what can we determine about unidirectional data flow? So the state of the application ultimately comes from stores. Your components are going to look to the relevant store in your Flux application to find out what the data model is that it should be using. Components don't cross-communicate with each other. This is the heart of unidirectional data flow. If a change in one component would affect another, for example, an input reflecting the user's name and a widget in the corner displaying that user's name, these components don't directly communicate with each other at all, instead they go through the dispatcher, probably ending up at a username store, which both components would then read from. In addition to actions being the preferred way to change the state, there really is no other acceptable way to change the state. You have to create an action and send it to the dispatcher, that's what makes the data flow unidirectional, the dispatcher is at the top of the application. Actions first flow up to the top of the application to the dispatcher, and then down to the stores where they become changes to the data model, and finally back down to the components where they're displayed. Actions are not sent to the store or other components but always directly to the dispatcher. We can take a look at unidirectional data flow using the following example. Let's imagine you have a good friend somewhere far away and you want to send them a letter. So this letter represents an action. You take the letter and you send it to the post office, the post office represents the dispatcher since this is where all letters go before they go to their destination. The post office sorts the letters and sends the relevant one to your friend's mailbox. the mailbox represents the store since it's what the component, or your friend in this case, actually refers to, to find out if there's a new letter. After the recipient has read the letter a reply is sent, but the reply isn't sent directly to the person who sent it, instead it goes back to the post office where it's once again sorted and sent to the appropriate recipient. This cycle can repeat many times with data never going directly between the people who are communicating. In practice, a Flux application works just like this. In the next video, we'll talk about the Flux dispatcher in greater detail.

The Flux Dispatcher
In this video, we'll be discussing the Flux dispatcher. The Flux dispatcher is a central part of any Flux application, but it's also one of the simplest parts. It's easy to understand and can be implemented in just a few lines of code. Now a dispatcher basically just does two things, it receives actions, or requests to change the state of the application from components, this is called the dispatch functionality of the dispatcher. The dispatcher also broadcasts actions. This usually happens directly after it receives actions, and this is called the listen functionality of the dispatcher, as in other components are listening to the dispatcher and waiting for a broadcast. If you can understand these two fundamental things, you basically have a full understanding of dispatchers. So what are the advantages of using a dispatcher? Well as we just saw, the Flux dispatcher is easy to understand, it only really does two things, and they're both intuitive. It's easy to add middleware, or code that runs every time a change happens in your application, to a Flux application because of the dispatcher. All actions go through this central component, so if you say you wanted to debug by putting a console login every time that happens, it's very easy to do if you've made your application with a dispatcher. Lastly, components do not communicate with each other directly. This is of course an obvious consequence of sending all your communications to the dispatcher, but it's actually a very good thing in of itself. Cross communication between components is very difficult to debug because you may have hundreds of components all going on at the same time. Speaking from personal experience, I've encountered countless bugs that are caused by components communicating directly, so by implementing Flux from the beginning, we can remove this large key source of errors from our application. In the next video, we'll talk a bit more about actions.

Actions
In this lesson, we'll discuss actions. Actions are the individual commands that are used to tell the dispatcher and stores that you want the data model to change in some way. Taken on their own, they're incredibly simple and only take a few minutes to understand. So what do we know about actions? All changes to the Flux application state are modeled by actions. An action described change to the state, usually a small granular one, and in the application there's no other way to make the data model change. If you can think of any possible change to a data model, like a user's name changing or his age being incremented by one, it would be modeled by an action. All actions generally have a type and a value. The words that may be used to refer to these two things may change, but generally what they do is the same. A type describes what kind of action it is, is it an action that changes the user's name, or updates their age? And a value, what is their new name, or what is their new age or how many years are we incrementing their age by? Actions are interesting in that they originate either from the user of from the server, they rarely come internally from within the application, but rather they represent a change that the user has done, so actions have a very intimate relationship with how the user is interacting with your page. For everything that the user might Todo on your page, there's an action for it waiting to be dispatched at the right time. So here's a typical action, it has a type and a value and it takes the form of an object. Actions can take any form, like an array or a string, but the typical kind is usually an object just like this. It has a type and a value property, but as I said before, these words could really be anything and you may find them changed in different implementations of Flux. For example, a kind instead of a type. There's also other ways to represent actions that are just as good, if less common. An action can be an array with the type as the first input and the value as the second. It can also be a string with the first part and the second part being separated by a colon. Strings are useful since they can't be changed once they're already referred to by a variable. And as mentioned before, you may encounter an implementation where instead of type, the word kind is used, and instead of value there's text. There's no limit to the different kinds of representations of actions and there is no perfect way, although because of the way that JavaScript handles objects, they tend to be good for this kind of data structure. Now you'll often hear about something called an action creator or an action generator. All these do is return a function given the appropriate arguments. So in the code example above, there's a simple action creator that given a type and value, returns an object of this kind. It's commonly used as a helper, simply to make sure you don't make a mistake. Notice how in this one you don't need to know that the words type and value are the keywords for this object, you just have to know it's the first and second argument to pass to this action creator. They can include advanced logic such as error checking, or even asynchronicity. We'll learn about that in a much later video, but for now this is all you need to know about actions.

Flux Stores
In this lesson, we'll discuss Flux stores. Flux stores decide how a particular action actually results in the changing of a data model. As we just learned, actions tend to be very basic, so we need a bit more functionality to determine how the data model is actually going to mutate. The formula used to determine the new state of the application is basically as follows: you have your previous stage or how the application currently is. An action comes in and then combined with the previous state you get a new state. In this case the store for the particular part of the data model would be listening to the dispatcher for these actions. So what do stores do exactly? Well a store does two things mostly. First, it allows components to get a copy of the state. The store is taking in these actions and constantly updating the state, and it gives a copy to the state to components whenever they want. So if you have a component that displays the user's name and it needs to update, it can simply make a request to the username store and the username store will give them a copy of the state representing what that user's name is. On the other hand, stores do not allow components to directly modify the state. So you might have your component and it might get a copy of the user's name and it might try to tell the store, you know what, let's just change the name to something else, the store will not allow this, in fact you have to go through the dispatcher to get the store to make any changes to the state. In a Flux application, each store usually represents one unique slice of the state, so you might have a store to store user's preferences, and then another store to store say the user's favorite restaurants, and another store still to keep track of the friends that the user has on your application. But no matter how many you have, these two principles still apply. So, as we've learned, a Flux store handles just one part of the data model. It can handle multiple and in Redux this is what happens, but generally the smaller the slice of your applications data model a particular store manages, the easier it is to debug. A store has no API for modifying the data, there is no command to say change username in the store, you must go through the dispatcher. This is okay though because all stores listen to the dispatcher. It filters all actions coming down from the dispatcher and when an action irrelevant to it comes up, it changes the state accordingly. Whatever logic it uses to modify the state is strictly within itself. It's a black box basically that other components of your application use to get the state of the application in a reliable way. So what are some advantages to using a store? Well as we mentioned before, there's not cross communication between components. This is good since we're beginning to see that this is a large cause of errors in applications. It makes it easier to debug just one part of the application. If you have a problem where the user's name is being displayed wrong, you know it's probably a problem that originates within the store that manages the user's name. Components can't change the data model directly, which basically means no surprises. Any changes that happen to the data model, you'll be able to know about them since they have to go through the dispatcher and a store. Finally, all the logic relating to a particular part of a data model is centralized. So if you're trying to figure out what exactly is happening with the username when the user tries to change it, you can just go to the relevant store and look at the code there. In the next video, we'll be looking at a more advanced form of the store called a ReduceStore.

The ReduceStore
The ReduceStore is one of the more complex parts of Flux. If you've taken a Flux course before, you may remember that they didn't mention the ReduceStore at all. Due to its complexity, it's the part of Flux that people like to kind of gloss over, but in fact it's critical to know this since it will really help us understand Redux in the second half of the course. Even the name, ReduceStore, implies there's some relationship to Redux. So here's a modified version of the diagram that we used to explain the store. In this case, everything is the same except that there's also a reducer. Basically the difference between a ReduceStore and a normal store is that in a normal store the equation, or how the action actually changes the state, is totally arbitrary, it can be implemented however you want inside of the store. However, a reducer forces us to use a particular kind of function to do this, and this is what a reducer is, it's a kind of function, so let's learn a bit about the ReduceStore. The ReduceStore inherits all the functionality from the store, so it still listens to the dispatcher and notifies components of changes. There's basically nothing a store can do that a ReduceStore can't do, but there is stuff that a ReduceStore won't do. For example, a ReduceStore never mutates the state, rather it creates a copy of the state every time that represents the state before and after the change. This is an awesome limitation since having a copy of the state that represents each of the previous states of the application let us do things like troubleshoot or create undo functionality much easier. The ReduceStore also responds to actions consistently. Taking another look at our diagram, if we have a particular state, state A, and a particular action, action B, every time you combine this action and this state, the new state will be identical. With just a normal store there's no guarantee that state A plus action B will equal state C every single time, but in a ReduceStore this is guaranteed and this is an important part of what makes them easy to use. No matter how many times a particular action is added to a particular state, the new state will be the same, and as we've mentioned before, the ReduceStore can revert to previous states since it never mutates any of them. So, just to make sure that we understand everything clearly, let's compare the Flux store to the ReduceStore. The Flux store can mutate the state. Maybe it shouldn't, but there's nothing there stopping it, and most of the applications will do this. a ReduceStore can't mutate the state. It needs to return a copy of the state if it's changed, or it's not valid. On the same vein, the state before and after the change can be the same object in memory if you're using a store, but a ReduceStore has to provide a new object if the state has changed. This can be handy as it's easy to compare objects that are the same and objects that are different in JavaScript. In a store, you can implement the logic for responding to an action any way you like, but in a ReduceStore it must be implemented as a reducer. We'll learn more about reducers, but they're basically functions that given a state and an action return a new state, and the logic of a reducer must be pure in that no matter how many times you run it on the same state with the same action, the result will be consistent. In a store, there is no such need for the logic to be pure, but as we'll find out it's generally a good thing when this pattern is observed. In the next video, we're going to be learning more about these pure or idempotent functions.

Understanding Idempotency (Pure Functions)
As we begin to wrap this module up, I wanted to take some time to explain idempotency, or pure functions. A lot of the time you'll hear the word idempotency talked about in relation to Redux, but I thought it was important to discuss them here in the chapter on Flux because of their use in a ReduceStore. So let's get right to it. What is idempotence? So idempotence, or idempotency, and these words are basically interchangeable, I looked into it and sometimes people say idempotence, sometimes people say idempotency, nonetheless, it means the same thing. Given the same inputs, a pure or idempotent function will always return the same output, regardless of the number of times the function is called. This is a quote from medium. com. Pure and idempotent in this context basically mean the same thing. So the core of a pure function is that given the same arguments, the same result will always come back. That's what makes them pure, they are reliable, and they don't interact with other scopes. So if there's a different part of your application, a pure function can't refer to it. By definition, all the logic from inside a pure function is just that, it's contained inside the function. In this sense, methods that return a different value every time, like Math. random, simply cannot be inside a pure function. In addition, if a function is pure, the result can be cached. Once you've say, if you have a pure function that add A and B, once you've added A as 5 and B as 50 once, you never need to run the function again, you can just remember that with those two arguments, the result was as such. Since the function is pure, this will be true no matter how many times you run the function. So here's some examples of some pure functions. They always return the same result, given the same arguments. So in the first example, no matter what you pass it, null is returned. This is pure since it's consistent for no matter what you pass it. Another pure function is simply returning the argument that's passed. This is also called an identity function. Another example would be a function that adds the two arguments together, or a function that returns the greater of the two arguments, in the case of numbers. So all the methods on this page are pure and they're appropriate to be used as a reducer. Here are some examples of non-idempotent functions. They don't always return the same value. So in the first example, the value might be different every single time, based on what comes back from Math. random. There's a very small chance that this function would return the same value twice, but it's not a guarantee. In the second example, by using new Date, you're guaranteed that every single time you call it the result's going to be a little bit different. Finally, in the third example, even if this function seems to give the same result every time, even if service. getSomeValue always returns 1, the function isn't pure since we don't really know that service. getSomeValue is going to return the same thing every single time. If it itself was a pure function, then we could say that the function implementing it was also pure, but we don't know that so it's not. For this reason, impure functions can't be used as reducers. Alright, in the next module, we're going to actually build an application using all these principles that we've learned. So, get ready to code along and when you're ready please join us in the next module.

Module Review
Let's have a quick review of everything we've learned this chapter. So we learned that Flux is an application architecture and that its main feature is one-way or unidirectional data flow. We learned that the most central component of a Flux application is the dispatcher, which registers listeners and these listeners respond to actions, which it also dispatches. Flux stores is where the applications state is, it's the place where the actual data is kept. Flux stores don't have any API for changing the data, they only respond to actions that come from the dispatcher. We learned that the ReduceStore is like a store in that it implements all the functionality of the store, but it requires that you use a reducer inside it, as well as a few other small things, which we'll see in a coming video. Finally, we learned that pure functions are like functions but they always return the same result every time. We went over a few of the other rules of pure functions but basically if it can return a different result given the same arguments for any reason, it's not a pure function. In the next module, we'll be applying everything we've learned about Flux as we build an application using Flux.

Building an Application with Flux
Module Overview
Hello and welcome to the next module, Building an Application with Flux. In this module, we'll be building an application using the Flux framework which we'll also implement. To get the most out of this module, you'll need to code along at home. But first, let's look at what we'll be covering in this module. First, we'll take an overview of the application that we're building, then we'll install the necessary dependencies to make the application, we'll set up a development environment that will allow us to write ES6, we'll go into some troubleshooting techniques that you'll be able to apply for this entire course, we will implement a dispatcher, which as we've learned is part of Flux, we will also implement stores, we'll create actions which we'll use to represent changes to our data model, we'll implement a ReduceStore based on the store that we've created, and finally, we'll learn to undo actions in our ReduceStore. In the next clip, we'll go over installing basic dependencies.

Installing Basic Dependencies
We will now install Node, Git, and the other basic dependencies that form the bedrock of this application. First, we'll need to install Node. js. If you're on Windows, go to nodejs. org to install. So, from here, just download the version with the latest features. If you're on Mac, you'll want to install Homebrew, and once that's installed, use it to install Node. js. This will ensure that Node. js has the correct permissions. Next, you'll need to install Git so that you can update the project files from the GitHub repository, as well as keep track of your work. So, to install Git, I've gone to git-scm. com/downloads. Here I'll find a download link for whatever operating system I'm on. On the right, one appears automatically based on what the website thinks would be correct for your system. So, just click that and install Git before moving on. Finally, you'll need a text editor or an integrated development environment. The first option, which I'll be using, is WebStorm. WebStorm does cost money, but it has the best support for ES6, plus there's a free trial. So here I am at jetbrains. com/webstorm/download. Just click the DOWNLOAD button and you'll get your free trial started. I personally find the software to be of great value, so you may feel inclined like me to purchase the software after the trial is complete. Alternatively, if you want to keep your whole stack completely open source, then you can go with ATOM text editor. I find ATOM to be a good text editor, if not as good as WebStorm. So, if ATOM is your choice, go ahead and install it before continuing. In the next video, we'll be setting up an environment for developing ES6.

Previewing the Application
Starting in this video, we'll be building the control panel portion of the application. The control panel is the simplest part of our application and it only has two functions. It allows the user to update their name, and as well the user can update their preferred font size. So let's take a look at the control panel that we'll be building. To begin working from right before where we implement this control panel, check out the branch, flux-start, or use the starting course files. So, here's the Control Panel. As we can see, it's very simple. Here the user can update their username or their font size. Both of these changes will be represented by an action which we'll create. So, now that we know what we'll be building, let's get started.

Setting up an ES6 Development Environment
In this lesson, we'll be Setting Up an ES6 Development Environment. Now if the average student is going to run into trouble coding along, it's because something is wrong with the ES6 development environment that has been set up. So please pay attention closely and follow along to everything I do to set up the environment. So we'll need to have the following dependencies installed: we'll need babel-core to transform our ES6 to ES5, we'll need babel-loader for loading our ES6 files, we'll need the babel-plugin-transform-object-rest-spread to use the object rest spread operator that we'll be using extensively in this project, we'll also need the babel-preset-es2015 to transform the rest of our ES6, we'll need webpack to serve our application, and finally we'll need webpack-dev-server to update our application as we go along writing it. Now the preferred way to install these dependencies is to either grab the project file or the GitHub repo and run npm install. So here I am at the GitHub repository for this application, at github. com/danielstern/flux-redux. To clone it, I just click this Clone or download button, and then Copy this. Next, I'll go into a folder on my computer that I've selected to hold this project. I'll open a Git terminal at this location, and if you installed Git you should see a Git Bash Here option if you right-click. Now I'll type git clone, and I'll Paste in what I copied. Now I can see here I have a flux-redux folder, and here's the application. It should also be in roughly this state if you used the starting project files. Now I'll move my Git Bash to that directory, and I'll change my branch to flux-start. Finally, I'll run npm install, and after a little while the installation should be complete. And our environment is all set up. Now there's one more step, mostly for Windows. The depth dependencies you have in this directory should work globally, but sometimes that can be a little bit tricky to get working every time. It's safer to just install the dependencies globally as well, so we'll say npm install -g, for global, and we'll just list the dependencies we have and their versions. So there we are. If you want to do this step, then copy what I have written on the bottom of my screen now. You may not need to do it, but if you're on Windows this is a good chance that this will help you in case you you run into any technical difficulties. So press Enter to install those, and we should be all set. In the next lesson, we're going to look at some more ways to troubleshoot the application in case it's not working for you.

Troubleshooting the Application Workflow
In this lesson, we'll go over some strategies for troubleshooting the application. You may choose to skip the next video and return here only if you're having problems getting the application working. So what are some issues that could be affecting our application? The first possible issue is a lack of administrator privileges. Make sure that you're both logged in as an administrator and have installed Node as an administrator. Relating to this, if you're on a Mac and you've installed Node not with Brew but with the installer, this could be causing your issues. So go ahead and install Node with Brew if you're on Mac. Finally, and especially on Windows, incorrect global dependencies may be causing your application to malfunction. So, as per the previous video, please go ahead and install the dependencies globally using the -g flag, followed by typing each dependency out by name. Here are some other ways to solve common issues with the application. If you don't have the latest Node version, go ahead and install it. The version I use is @~7. 2. 0, so if you have a version that's much earlier, or even much later than this, you might want to consider switching to the same version I used to make the course. In addition, as we've mentioned before, a good way to solve any issues is simply to clone the repo from the closest starting point. The closest point to where we are now is in the branch flux-start, but there are six different branches for different points in the course, so there'll be one that applies to you. Finally, as mentioned before, and this is a very common issue, you have to remember to install your dependencies locally by running npm install, and if necessary, installing them globally with the -g flag. Alright, so that's all the troubleshooting we'll need to worry about for now, in the next video we'll scaffold the application.

Scaffolding the Application
In the interest of time, we won't actually go over the scaffolding of the application. Please just grab the project files or the repository from the appropriate branch and start from there as none of this stuff is really related to Flux, it's just boilerplate that I've kind of put in it so that the application will look good no matter what and it'll be presentable for you as a demo piece, should you choose. So briefly, let's look at what we have to get started. Inside the public directory is an index. html file. All this has right now is links to our various other pages. marked up in standards compliant Bootstrap. Our control panel page looks much like our index page, except it also has a couple of forms, a text input for the user's name, and a couple of radio buttons for the size of the font. This main. css file is very basic and just provides some styles to help Bootstrap look proper. We have an src directory which is currently empty, a gitignore directory that is created automatically and mostly ignores the node modules folder. In our package. json, we'll notice our dev dependencies as well as a start script. And this start script calls webpack, which is configured in webpack. config. js. There's a lot going on here, but sufficient to say that the loaders property tells webpack how to turn our ES6 into ES5, and the entry property tells webpack what JavaScript to serve based on what page we're visiting. To run our application from here, type nmp start. Ignore any errors for now as that's to be expected. Finally, navigate to localhost:8080 on your computer, and here we are. You can see that the app is looking quite sharp. If we click Control Panel, we can see here's our Control Panel where the user will update their settings. Of course, nothing happens yet because we're about to write the Flux based JavaScript that will make this website tick. In the next lesson, we'll implement a dispatcher.

Implementing the Dispatcher
In this video, we're going to implement a dispatcher. Not only are we going to write the specifications for a dispatcher like we were writing our own Flux implementation, but we'll also implement it loosely in our application to see what happens. So we'll be having a dispatcher with dispatch and listen methods, very similar to the Flux library you might find on npm. We'll then connect the dispatcher to existing forms that are already on the page. So, where we are now is where the Flux start branch begins, or where the project start course files for this module leave off. Since the last video, we've added a control-panel. js file that is empty. So, let's implement our dispatcher. We'll create a New, Directory, inside src and call it flux. We're going to try and make this look as similar as possible to the actual real Flux implementation, except of course we'll have more control. So we'll create New File, and we'll call it Dispatcher, with a capital,. js. So we'll export a class that will be our dispatcher. First, we'll give it a constructor method which will run whenever the class is instantiated. We'll create a property on the Dispatcher called __listeners, and in constructors we'll just send it to an empty array. We'll create our dispatch method, the dispatch method takes an action as an argument. When you call it, it will take each thing in this. __listeners, and assuming each one is a function, referred to as listener, it will call the listener function with the action as an argument. So in this case, each listener will be a different function that various components pass to the dispatcher to be invoked at this time. Finally, we'll add the register functionality. register will take a listener, and as you may have guessed, all it will do is push that listener to the list of listeners. Now believe it or not, that's all there is to it for a Flux dispatcher, let's see it in action. First we'll go to control-panel. js. First, we'll create an index. js file for our flux directory, and all we'll say here is export dispatcher from the dispatcher file. Now, if we go to control-panel. js, first we'll import the dispatcher from Flux. That's why we added the index, to give us this nice syntax at the top. You'll also notice this import statement is ES6, but since we created our environment, we can use it. We'll initialize our dispatcher by creating a constant and making that equal to a new instance of dispatcher. Next we'll add a listener to whenever anyone changes the name input on this page. We'll get an ElementById of the document, and the name of that ID is userNameInput. Then we'll add an EventListener to it, and on the event called input, we'll run the following method. Now this method as an argument is going to take an object and the only part of an object we're interested in is the target properties, hence these curly brackets inside the round brackets. We'll get the value of the target, which is what has been typed in, and upon receiving this change, we'll dispatch an event. (Working) So we'll say. dispatch, and we don't have any actions yet so we'll just pass a string that's not finished yet. Finally, at the bottom we'll add a listen to the dispatcher to see what's going on. So whenever listen is, whenever the callback pass to listen is invoked, it'll be passed an action, which will basically effect how listen responds to it. So in this case we'll just console. info the action. And a slight mistake there, that should be register. Now, in our application, if we type into the Update Username box, you can see that it's dispatching whatever has been input into the box, and our dispatcher is broadcasting the information to whatever it's interested in. Since we haven't created actions yet, this isn't really holding any data like what the updated name is, but soon it will. Finally, we'll do a similar thing for the radio buttons. We'll say document. forms, which gives us a list of all the forms, and we'll call the form called fontSizeForm. We'll get the property of that called fontSize, which is our radio button, and we'll do something for each of those buttons. We'll add an EventListener, and on the event change, we'll run the following script. We'll once again dispatch another very basic string-based action. So now if we look at the finished application, whether we update in this input, or update the Font size, the dispatcher is dispatching an action related to that. In the next video, we'll implement a store to actually keep track of what these values are.

Implementing a Flux Store
In this lesson, we'll be Implementing a Flux Store. Flux stores work in tandem with the dispatcher to run the application. First, we'll create a store class that all stores will inherit from, then we'll implement a store which inherits from that class to track and manage the preferences of the user. We'll connect the store to the dispatcher so that the store will update whenever an appropriate action is created. So here I am in the application, I'll create a New File in the Flux directory, and call it Store, with a capital. js. Now let's implement Flux stores. We'll export a class called Store. This class will have a constructor. Now the constructor of the store takes an argument, and that argument is actually equal to the dispatcher that the application is using. So in the constructor we'll create a listeners array just like in the dispatcher, and then we'll register with the dispatcher, and we'll say this. __onDispatch, which we haven't written yet, we will shortly, and we'll make sure that method is bound to the value of this when it's called. So let's add that method. We'll say __onDispatch, now in this case we want any class that subclasses this to overwrite the onDispatch method. It's just sort of a placeholder since every store is going to do it differently. So we'll have this throw an Error, so it'll let us know if we didn't overwrite this. Next, back in the constructor, we'll create a new value, this. __state. This value represents internally what the state of the application is, and because of the underscores we can say that this isn't supposed to be accessed by outside components. So we'll make this equal to this. getInitialState. (Working) Once again, this will throw an error where once again it's supposed to overwrite this in our new store. Next we'll add some public API to the store. We'll add addListener, which works in much the same way as register works in our dispatcher. Whatever is passed will simply be added to the listeners array. Lastly, we'll have an internal emitChange method to call whenever something inside the store has changed, and when it's called all it will do is call each listener and call that function passing the state. This is a convenience function if anything. (Working) Alright, so that's actually the whole implementation of the store. So let's use this store implementation in our application. First, we'll go to index. js in flux, and we'll adjust export (Store) from ' /Store', much the same as we did above. Now inside control-panel. js, first we'll import Store as well as Dispatcher from flux. Now here, below our listeners, we'll define our user preferences store. So we'll create a new class UserPrefsStore, and it will extend Store. Remember that we have to define getInitialState and onDispatch for the store to work. So getInitialState just returns the original values for whatever it is is being held in the store, so we'll just have it return a simple object with userName: "Jim" you can make that username whatever you want if you want to mix it up on your end, and fontSize: "small". We'll add our onDispatch method, and since our actions aren't set up yet, we'll just say Store is ready to dispatch, followed by the action. Actually we'll make that Store received dispatch. Finally, we'll add a method that's not part of the original store, getUserPreferences. As we know, stores don't let you change the state but they let you get a copy of the state whenever you want. So for this method we'll just say return this. __state. So here's our user preferences store, it's all set up. On the line below, we'll initialize it. We'll call it userPrefsStore and we'll make it a new UserPrefsStore. As you'll recall we have to pass it in the dispatcher, but we already have one. One last thing before we test it out, let's take our instance of UserPrefsStore and add a listener. The listener is a function which takes an argument that's equal to state, and we'll just say console. info ( The current state is followed by state. Finally, one more thing. Whenever we are done the onDispatch method, if something's changed we have to call emitChange, or else the application won't know about it, and we'll save that. Now let's have a look at our application. If we make any changes, we can see that our store is correctly hooked up to the dispatcher. Every time we update it we get a new version of the state. Now admittedly the state isn't changing, but in the next video we'll be changing the state relative to the actions.

Implementing Actions and Action Creators
We want our application to actually update when something changes. For this we need action since actions describe a change that happens to our data model. We'll make two actions. The first for userNameUpdate, and this will take a name and just return an object that represents that action. We'll make the type equal to UPDATE_USERNAME, and the value equal to the name that was passed. And let's actually take this and make it a const, so we'll say UPDATE_USERNAME and we'll say const UPDATE_USERNAME = UPDATE_USERNAME. And let's create one very similar for fontSizePreference. So this works pretty much the exact same way, it's passed the size and returns an action of the appropriate shape. We'll also have to create a const here, const UPDATE_FONT_SIZE_PREFERENCE = UPDATE_FONT_SIZE_PREFERENCE. Now we can update these dispatches to use the actions instead of just these random strings. So we'll change TODO_NAMEINPUTACTION to we'll call userNameUpdateAction, and pass it the name. And for font size we'll call fontSizePreferenceUpdateAction and pass it the target. value. Now if we look at our application, when we press Small, it receives an action that indicates the font size preference has been updated to small. When we press Large, that value is large, but still nothing changes on screen, so let's fix that up. So in the onDispatch method, we'll add a switch statement, and the switch will change on action. type. We'll have a case for UPDATE_USERNAME, and you'll see now why we use those constants, and a case for UPDATE_FONT_SIZE_PREFERENCE. So if the action type is UPDATE_USERNAME, we'll change the username in the internal state of the store, and after we'll call emitChange. Note that emitChange should be called only when a change has happened, so if neither of these switch statements occur then we know nothing's changed and you shouldn't call emitChange when nothing has changed. For UPDATE_FONT_SIZE_PREFERENCE we'll do much the same. We'll make the state. fontSize equal to the action. value, and we'll also call emitChange. So here in our userPrefsStore listener, this is going to be called every time this state changes, and this is where we can update our page. So let's update the HTML to reflect the font size. We'll create a new method called render, you'll note this looks a lot like a React application does. This render method will take an object that has a property userName and fontSize. So here in userPrefsStore we can call render and pass it the state. And all we'll do here is we'll update the document. So we'll change the ElementById that's called userName to be the userName that's passed, and we'll update all the fonts on the page relative to what the font size is. We'll also update the fontSize value which will change the radio buttons. Now we can have another look at our application. If we try and update our username, it works, the username display here is updated. Here on the right we can see all the met information of what's really happening. An action is being dispatched which is being received and interpreted by the store, which alters the state which is red in the render function. Alright, so that makes our Control Panel basically finished. In the next video, we're going to wrap it up.

Completing the Control Panel
In this video, we're just going to wrap up the Control Panel page by adding some features we'll use in the rest of the app. So we'll implement local storage to keep the user preferences once the page has been refreshed. This is purely for style. And we'll add a call to render at the beginning. First things first, we can delete this call to the dispatcher which is console log something since our app is now working. We'll call the render function right at the bottom of this script and we'll pass it the userPrefsStore. getUserPreferences. This will just start the page with the default layout that the store has set out. Next we'll update getInitialState. InitialState will now return the following: if there's a local storage property named preferences, return a parsed version of that, otherwise, return the default that we defined in the previous video. Next, we need to store this somewhere so every time that the userPrefsStore is updated, we'll update local storage, and we'll pass it a stringed version of the state, and that's all there is to it. Now if we update the username, and refresh the page, those changes are persisted, thanks to local storage, and we can use these values on these values on our other pages as well. That concludes the Control Panel. In the next section we'll be taking a look at the Tasks page.

Module Review
Let's review what we learned in the previous module. So we created implementations of the Flux store and its dispatcher. We used actions to describe changes to the applications state. By using actions every time, we can really create a Flux application. We sent all the changes in our application through the dispatcher to be propagated through the store and then the rest of the application. We had no component to component communication. In the next module, we'll be using a ReduceStore to build the Tasks page.

Building Advanced Applications with Flux
Module Overview
Before we get started, let's take a look at what we'll be covering in this module. We'll be implementing a ReduceStore by building on what we've already created with the regular Flux store. We'll be creating a reducer that will fit in to the ReduceStore. This reducer will fit the template of the reducers we'll be using in Redux, and probably the reducers you'll be using in any future projects you do. We'll find out how to correctly copy the state, rather than mutate it, which will prevent any unexpected errors in our application. Finally, we'll learn how to undo actions by reverting to previous states. It should be a challenging module, so we hope you'll stick with us.

Tasks Page Overview
We will now construct a Tasks page using Flux. The task page will be similar to the Control Panel page, except instead of just using a Flux store we'll use a Flux ReduceStore, which is both more complicated and more powerful. Let's take an overview of the functionality of the Tasks page. So the Tasks page is very similar to a TodoMVC, or a todo list that's built with a particular framework, in this case a Flux ReduceStore. It does the following things: you can create new tasks or todo items to be handled at any time, you can complete existing tasks, you can filter which tasks are shown based on completion, and lastly and more interestingly, you can undo actions by reverting to a previous state. So we'll now preview how things will look at the end of this segment. Now is a good time to check out the branch, flux-midpoint, which is where you'll want to start to complete the Tasks page. So here we are at the completed Tasks page. As we said, they're a list of tasks and you can update them by adding a new task. You can mark the tasks as completed or not completed with these checkboxes. You can show or hide the completed tasks, and best of all you can undo the last change to revert to a previous state. That's what we'll be constructing, so in the next video we'll get right to it.

Scaffolding the Tasks Page
We will now scaffold the Tasks page, in other words, we'll add the necessary boilerplate, JavaScript, and HTML to actually make the page exist. Then in the coming videos we'll implement a ReduceStore and put that functionality into the page. So for this demo we'll update the webpack configuration so that the Tasks page can be displayed, and we'll add tasks. js and tasks. html. Really simple stuff so let's go over it. Here we are in the application. I've gone ahead and switched to the branch flux-midpoint. You can do so my typing git checkout flux-midpoint. If you're using the project files instead, just grab the files from the folder called midpoint, and be sure to run npm install. So I've gone ahead and already added the scaffold HTML and JavaScript that will be needed since we want to conserve our time to focus just on writing the JavaScript. So I've added a task. html, this page is very similar to the previous page on the Control Panel. It has some bootstrap navigation, and then here's some very simple HTML elements that make up the form which we saw in the previous video. Now I do strongly recommend you just start from the project files, but if you want to create this page yourself, here it is on the screen to be copied. In addition, we've created a ReduceStore. js file which is currently empty. We've added a reference to the ReduceStore in the index file, and we've created a tasks. js file, which is also empty. Here in webpack. config we've added a new entry, tasks, which tells webpack that when we go to /tasks, it wants to serve up the tasks. js file which we'll be adding to shortly. In the next video, we'll be implementing a ReduceStore in our ReduceStore. js file.

Implementing the ReduceStore
In this video, we'll be implementing a ReduceStore. Not only is the ReduceStore an important part of Flux, but it connects many ideas to Redux, which we'll be covering in an upcoming module. So we'll be constructing a ReduceStore, and as we mentioned it will extend Store, so a lot of our work has already been done for us. Much like a store, the ReduceStore processes actions, however components are notified automatically if the state has changed. We'll also add undo functionality, but that will be in a later video. Okay, let's get started. So here I am in my text editor and I have the ReduceStore. js file open. First, we are going to extend Store with this, so we need to import Store first. So with Store imported from the Store file, let's create a class, ReduceStore, that extends Store. We'll give it a constructor method, and like Store it takes dispatcher as an argument. First we'll call the constructor of the superior class or the Store class, this will create a listeners array and a few other things. (Working) So we'll say super and pass it to dispatcher. Next we'll add a reduce method. The reduce method will take an arguments state and argument action, which is the common signature of all reducers. However, since you have to define this method when you extend a ReduceStore class, it will just throw an error in its current state. So we'll say Subclasses must implement reduce method of a Flux ReduceStore. Finally, we're going to overwrite the onDispatch method of the store so when it receives a dispatch it will create a newState, and the newState will be equal to the outcome of calling reduce on whatever the previous state was with the action. Notice how we haven't changed this. __state, we've just created a new one. Next we'll ask is the newState the same as the old state? (Working) If it is the same then nothing has changed and nothing needs to be done, however if it's different, we'll take the new state and make that what this. __state is equal to. And of course we'll call this. __emitChange, which is the automatic part of notifying the listeners. And that's all we'll be adding for now for the ReduceStore. In the next video, we'll be implementing the ReduceStore in our Tasks page.

Developing the Tasks Page: Adding Basic Functionality
Now that our ReduceStore is set up, we can implement it on the Tasks page. In this lesson, we'll be doing the following things: we'll create a default state for the application, and we'll create a Tasks Store which will inherit from the ReduceStore, but add a bit of functionality to it. We'll implement a reducer for our new ReduceStore, and tying it all together we should have a mostly functional application. So, let's jump right into it. So here we are on our tasks. js page. First of all, we're going to need a new dependency, so let's open up our Terminal, and install shortid, nmp install --save shortid. So with that taken care of, first we'll import the required dependencies we need. shortid is a library that lets us generate a random id for various purposes, so we'll import the generate method of shortid. Next we'll import our dispatcher and ReduceStore, but we won't need the regular store from our Flux implementation. Next we'll create a new instance of the dispatcher and call it the tasksDispatcher. Now let's define our Task Store by extending the ReduceStore. First of all, since this actually extends Store, we have to overwrite the getInitialState method. This can be easy to forget since we're working with ReduceStore, but it implements all the functionality of the store. So the initial state will be an object with a tasks property, and each task will have an id, content, which is what it appears as, and its complete state. So here we are, we have a task for updating styles, adding unit tests, and whatever else. If you want to make these tasks have different names for your version, I strongly encourage it. Lastly the application state also keep track of whether the complete items are shown, so we'll add a Boolean called showComplete. Next we'll define a getState method. All getState will do is return a copy of this. __state. Finally, we'll add a reduce method. For now we'll just put a console. log here while we build the rest of the application, (Working) and we'll return the state. Remember that reduce methods always return either the state or a copy of the state, they can't just return nothing. Below that we'll instantiate our TasksStore. Finally, we'll add a call at the bottom to our tasksDispatchers just to make sure everything is working, (Working) so we'll add a TEST_DISPATCH. Now if we go to our application we can see it doesn't work yet but we can see our Tasks dispatch and the object state that's being returned here in the console. (Working) We're almost there, all that needs to be done is the remainder of the Tasks page needs to be implemented.

Rendering the Application
Next let's hook the form elements up to the dispatcher. So we'll create three new constants to define different actions, a CREATE_TASK action, a COMPLETE_TASK action, and a SHOW_TASK action. Next we'll define an action creator for our CREATE_TASK action. So you can see all it does is create an action called CREATE_TASK with the content that's passed in. Very similar to the actions we made in the previous video. We'll make one that works almost the exact same for SHOW_TASKS, with just a type and a value once again. Finally, we'll add an action for completing the task, which will be a bit different. So to tell our application we want to complete a task, we need to specify which task it is. So in this case, not only do we pass in an isComplete Boolean, but we actually need the id of the task we're referencing, that's why we needed to use shortid on this page. Net we'll add a render method, (Working) and this method updates what appears on the page, based on the state of the application. So first we'll get the section where we want to output our tasks by using document. getElementByID. (Working) We'll get a reference to the state. (Working) Now above this we're going to define an HTML template for the representation of a task. So we'll call it TaskComponent, (Working) and as an argument it will take an object with three properties, the content, the complete status, and the id. Now I'll put this in round brackets so that whatever I pass will just be returned automatically, and we'll create a tag to represent our TaskComponent. (Working) So for each TaskComponent it will create a section that has an input, as well as the name of the task, which is represented by content. Now back in our rendered method, we'll create a variable called rendered, which will actually be the HTML that the tasks are going to be represented by. (Working) So we'll say state. tasks, and then we'll filter, (Working) and it will be based on state. showComplete. So if showComplete is true, then we can just say true, return all the tasks. If not, only return tasks that are not complete. (Working) Then we'll map this list of different objects to our TaskComponent like so, interesting syntax to do that, and then we'll join this array with an empty string. (Working) Now that we've created our HTML, we can say tasksSection. innerHTML, and it's now equal to rendered. Then at the bottom let's add a call to render to do it right at the beginning. Now you can see our list appears, but it's not dynamic yet because we haven't added in any event listeners. So first we'll add a listener to our newTask form, (Working) and it'll listen for the submit event. (Working) First we'll preventDefault, that'll stop the page from refreshing, then we'll read the value of the input, which will tell us the name of the new task. (Working) And so if name is defined, if it's anything other than emptyString, we'll dispatch a new CREATE_TASKS action. (Working) And we'll make the input empty so the user can enter a new one, (Working) and we'll add a listener to the showComplete button. (Working) So when the showComplete button is clicked, we'll dispatch a showTasksAction with the value of the complete checkbox be it true, showComplete, or false, don'tshowComplete, via the dispatcher. So here we are back at the application, and we can see if we change Show Completed, or try and add a new task, nothing changes, but we get this message here. We actually haven't implemented our reducer, so we have to do that now, and once a reducer is implemented the whole page will come together.

Implementing a Reducer
For our application to work, we need to implement a ReduceStore that either returns a copy of the new state if the state has changed, or just returns the existing state if it's the same. So let's do that now in the reduce method of our Tasks Store. So first we have to create a newState, and we'll just leave that undefined. Now we'll do a switch on the action. type. First let's respond to the CREATE_TASK action. So we'll make newState equal to a copy of our existing state. So we'll make an object, then using the spread operator we'll copy all the properties of that object from state. Then we'll also define tasks and copy state. tasks. This will create a copy of our object with a copy of the array as well, otherwise it would be a new object but the same array and we'd be accidentally mutating our array if we changed it. We'll push a new element to this array, with id, content, and an automatically false completed value since we just added it, and we'll return the newState. Next we'll respond to the SHOW_TASKS action. We'll make a newState and make it equal to the old state except for the showComplete value, (Working) and we'll return the newState. Now if neither of these switched statements come true, then we're going to default to returning the state. Remember if the state changes you return a copy, but if it doesn't you have to return the original state. Now whenever the state does change, the tasksStore will emit a change, so we have to listen to that and call render, just like that. Now let's go to our page and try adding a new task. As you can see it's being added because the reducer is updating the state in response to the action. Show Completed also works, but if we changed these checkmarks nothing happens yet, we still haven't added that functionality, so let's do that now. So when we render the application, we have to add a listener to each of the check buttons next to the tasks to note if they've been completed or not. So here in render, we'll get all the elements that are named taskCompleteCheck and run and run a forEach on them. Now for each of these elements we'll add an eventListener and listen for the changeEvent. We'll get the id of whatever element has been checked, (Working) so we'll use the attributes property to get that value. Next we'll determine if the action made the item complete or not complete by looking at the checked property, and with all this data gathered, we can now dispatch an event to the tasksDispatcher. (Working) We'll call completeTaskAction and we'll pass it an id and the checked property. Lastly, we can't forget to respond to this in our reducer, so we'll add a new case inside our reducer for COMPLETE_TASK. We'll create a newState by copying the old state, and we'll just use this exact syntax from above. Next we'll find the index of whatever the completed task was by matching the ids. (Working) Then we'll update the tasks array of the new state, so that the task at the affected index is now either completed or not completed based on the actions value. Finally, as you may have guessed, we have to return the newState, and that should be all set. Now if we check a task, and then change Show Completed, that task is now hidden based on whether it was completed or not. We can add new tasks, and those all work too. One thing remains though and we can't undo the last change yet, that's because we haven't implemented that. In the next video, we'll do so.

Undoing Actions
Now that our ReduceStore is implemented, we only need to be able to undo actions to complete it. In this demo, we'll do the following things: we'll add a revertLastState method to the ReduceStore, and we'll connect the undo button to the ReduceStore, which should tie it all together. So here I am back in our project, now we'll go to the file ReduceStore. js. First, we need a way of keeping track of this history, so in the constructor we'll add a new property to this. __history, and make it an empty array. Next when we call onDispatch, if we know that we're going to replace __state with a new state, we're going to preserve the old state by pushing it into history. Since we never mutate the state, only copy it, these copies in the history will be preserved and not altered in any way. (Working) Now all our states are being preserved. Finally, we'll call a revertLastState, which will take whatever the latest state is in the history and make that the state property. So we'll say if the length of the history is greater than 0, (Working) then this. __state will become the value of this. __history. pop, which gets the last one. Now since something's changed, we have to emitChange, and we now have a revertLastState API, so let's implement it in our Tasks page. Back to tasks. js, so here in tasks. js we'll add a listener to the undo button and we'll just call tasksStore. revertLastState directly. I know this is a little bit of a hack because it's hard to then reverse this action if we want to redo the last state, it would be better to create an action for it but in this case this is fine. So we'll get document. forms. undo and add a submit listener to it, (Working) and when this happens first we'll preventDefault, then we'll just call tasksStore. revertLastState, and that should be all that's required. And of course, don't forget that e is the argument to this method, otherwise it won't work. Okay, so now if we open up our Tasks page, we can see Undo Last Change works. If we make some changes, we can undo them. And now you know exactly how this works behind the scenes. The ReduceStore can keep a copy of previous states since the state is never mutated. And that completes our task page, all the functionality that we wanted included, because of Flux and ReduceStores. In the next video, we'll be wrapping this up.

Module Review
Let's review what we've learned in the previous chapter. We created a ReduceStore, we did this by extending store, giving all the functionalities of store to this new class. Then we extended our ReduceStore to create our Task Store, and we used these new classes in our application. We used actions to describe changes in the application, but these actions this time were interpreted by a reducer, which has to respond to actions in a consistent way. Finally, we implemented the undo functionality, which as we found wasn't as difficult at all as we would think. If we start with the right principles from the ground up, it's easy to revert to a previous state. In the next module, we'll be beginning our study of Redux.

Understanding Redux
Module Overview
Hello and welcome to this module entitled Understanding Redux. In this module, we'll learn and apply almost everything there is to know about the library Redux. In this video, we'll have an overview of everything that we're going to learn in this module. We'll have a look at the application we'll be building, the scenario that makes it necessary to use Redux. We'll ask and answer the question what is Redux? We'll have a look at the relationship between Flux and Redux, we'll discuss and demystify the four terms state, actions, stores, and reducers. Finally, we'll have a short lesson about immutable state. So, in the next video we'll have a look at our scenario overview.

Scenario Overview
Let's discuss the scenario for our using Redux. I've chosen to invent a messenger service similar to the one you might use to communicate with coworkers at work. Here's the core functionality of the messenger service. Users can send messages to one another using an HTML form. They can also update their status using a drop-down. The user status affects whether or not they can send messages, but yet we don't want these components to be communicating with each other. Finally, the app will communicate with the server. In our example, we're just going to have a simulated backend, rather than a real one since that would be a lot of extra work. This presents a lot of unique challenges when we want to create the app using Redux. This is the application we'll be building in the next module, but for now let's ask the question, what is Redux?

What is Redux?
So what is Redux? Is Redux a library or an architecture like Flux? Well to start off, let's ask Redux what it is. According to its GitHub page, Redux is a predictable state container for JavaScript apps. Now in this statement you can look at the word state the same as the word model. It's the data backing your applications views. The keyword that I like to take away from this quote is predictable. If your application is in a particular state and the user interacts with it in a certain way, you'll be able to predict the result, there won't be a lot of guesswork. This is at the core of Redux. So what does Redux do? As we said before, Redux manages the state or the model of your app, it's the only part of the application that Redux is concerned with. Redux is often taught alongside React, and indeed, the teams that work on them are similar and related. However, it's inaccurate to say that Redux is an application architecture to be used only with React. In fact, it works with any view engine, and in our demonstration we're going to be using Vanilla JavaScript to demonstrate this. We saw in Flux that we could implement a reducer for our application's ReduceStore. However in Redux, reducers are mandatory. It's an integral part of how Redux manages your state, so you won't be able to get by without using reducers. Luckily since we learned how to use reducers in the previous modules, it should be easy to apply them now. Unlike Flux, Redux applications only have a single store and the dispatcher is built into it. This increases the simplicity of our application while at the same time requiring us to separate up our store's logic in some other way than using separate stores. Now that we understand a bit more about Redux, let's look closer at the relationship between Flux and Redux.

Understanding the Relationship Between Flux and Redux
Let's take a moment to have a look at the relationship between Flux and Redux. They have similar names, they do similar things, and this course teaches both of them, but clearly there must be another common vein between these libraries. Dan Abramov, the creator of Redux, had this to say, It is natural to conclude that Redux is just complicated. In a way it is, and by design so. To do anything in Redux you have to take a lot of formalized steps to do so. It's like a very formal version of Flux in a way, hence Abramov's remark that it's complicated. However, he notes that it's complicated by design. All the complications are there to improve your workflow one way or another, generally by forcing you to use correct practices so you have less debugging work later. So other than the fact that it's a more formal Flux, what else can we learn about these libraries? We know Flux is a precursor to Redux. We can tell from the ReduceStore that the developer of Redux was greatly inspired by Flux. A lot of stuff in Redux doesn't really make sense until you've learned what is in Flux first, like we did, and in many ways, Redux presents evolved versions of these ideas. Redux is suitable for projects that are advanced. In other words, it's good for projects where the level of complexity is so great that Flux doesn't really make sense. Flux does work with bigger projects of course, but you have to make a lot of effort to make sure that developers follow the correct practices. Everything about Redux is designed to work for big, complicated projects, so you might say its relationship to Flux is that for a simple, quick project, Flux makes sense, but for a big, complicated project, Redux does. In addition, Redux is more actively developed. As we noted, it has many more stars on GitHub than Flux does, even though Redux came along later. There's just a lot more activity with Redux, but the takeaway is that if you were to enter a random workplace, just basing it on the number of starts on GitHub, you'd be more likely to see them using Redux in that workplace than Flux. Now that we understand a bit more, let's have another quick look at this diagram. As you can see, Flux and Redux have more in common than they do differences. In fact, the major differences are mostly that the Redux library has a single store and that reducers are mandatory. Next we'll have a quick look at state, store, actions, and reducers; four terms that interlock and go together in any Redux application.

State, Store, Actions, and Reducers in Redux
We'll now learn about state, store, actions, and reducers, specifically relating to Redux. These terms are tricky to understand since it's really hard to define one of them without referring to one of the other three. However, you may recognize them from our learning of Flux. I find Flux makes it easier to understand what these concepts are. However, it's impossible to have a conversation about Redux or participate in a tutorial about it without really knowing what these terms mean, so let's have one more look at their significance. So the first word, state, holds our applications data. Almost every application has a state. The state is kept in the store and it's modified by actions. How the state changes in response to an action depends upon the reducer. Next we have actions. As we've learned, actions describe a change to a state. Actions tend to describe granular, small changes to state, but by applying a lot of them, we can turn a state from one thing into something completely different. Actions are processed by reducers. So reducers, which are generally managed by the store, process actions, then after processing the action they either return a new state if it's changed, or just the old state if nothing has changed in response to the action. Finally, the store is where you get the state if you're a component in the application. Actions are processed in the store by a reducer. So those are our four main terms. If you're at all unsure, I'd recommend that you watch the next two modules, and if you're still unsure, come back to this video and watch it again. Next we'll have a look at immutable state and its relationship to Redux.

Redux and Immutable State
Immutable and immutability are words that you hear often when you're trying to learn or use Redux. But what is immutable state and why is this concept so important when making a Redux application? Well, to find a definition for immutability, I went where every good developer goes when they have a question, Stack Overflow. According to Douglas Leeder, Once the constructor for an immutable object has completed execution that instance can't be altered. And since the constructor for anything happens right at the beginning of its lifecycle, it generally can't be altered for 99% of that object's life. Remember that the muta in immutability stands for mutate. You can't mutate an immutable object by changing it. So what is immutability? As we just remarked, immutable objects cannot be changed. Once they exist in memory, they are stuck that way. This is, for lack of a better word, good because it makes the app more predictable. If you are referencing and object in one part of the application and that object changes in some dramatic way at an unexpected time, not only will your application stop working, but you may have a very hard time figuring out what's gone wrong. With immutable objects this concern is long gone. Sure, when it comes time to actually change an object or rather create a copy of that object that's changed, there's a bit more work to do, but once you have an object you can predict that it's going to be the same as it was before, very useful. Immutable data objects must be modified via a copy, so if I have a string that's immutable and let's say that string contains the word JavaScript, and I want to make that string into the word TypeScript, I have to create a copy of the string and then as that copy is being constructed I can change the first four letters from Java to type. Any objects or components referencing the string will still have the string JavaScript, since they'll have to get the new, the copied string, to see that string TypeScript. The example I just gave is actually very valid since in JavaScript strings are one of the immutable data types. To change a string, you have to make a copy of it. That means anything referencing the previous copy will be unchanged. The same is true for Booleans, numbers, and a few other special words, null, undefined, and NaN, or not a number. Once an object has a reference to any of these data, that value won't change even if where the object got the reference to that data changes. However, the caveat is that there are several data structures in JavaScript that are not immutable. These include arrays, functions, and most importantly, objects. The fact that functions are not immutable in JavaScript is just puzzling and can lead to all sorts of trickiness down the road. But what we're really concerned with is objects. Why? Because the state of a Flux or Redux application is often represented with an object. Arrays usually make a definite appearance too, but this presents a problem, since we like our data in Redux to be immutable, but our choice of storing the data structure, an object, is not immutable. So unless we're really careful, we'll end up mutating the object. Is there any way to avoid this? Turns out there is. You can simulate immutability by doing a thing called combining reducers, which we'll actually be trying in the next module. So, when you're combining reducers, you take a mutable data structure, the object, and you break it into immutable parts. So in our previous module we had an object and one of its properties was the showComplete property. The object is mutable but showComplete is immutable, so if you pass something only showComplete, it can't really change the object. So in a good Redux application you have many reducers that operate on only one property of the state object. The data that's passed to these reducers is usually immutable, so it doesn't matter if the person on the other side tries to edit the data, it simply won't affect the core state. Reducers just don't have access to the state object when you combine reducers. They only get little parts of the application, which in addition to being easy to conceptualize, prevents us from mutating the main state. So that's a lot to take in, but in the next module we'll be applying all of this, so try to keep it in mind and we'll be reinforcing it very soon. So, that's about it for understanding Redux. In the next clip, we'll wrap up.

Module Review
It's been a pretty dense module. Let's wrap up by reviewing what we've learned. We learned that while it does have its differences, Redux is more similar to Flux than it is different. A lot of what Redux does can be understood simply in the context of a more sophisticated or formal version of what we do with Flux. In Redux you have to use reducers in your application, even the name Redux strongly implies you have to reduce things with reducers. Redux however is more sophisticated than Flux and therefore it's more suitable for projects that are more complex. The ideas of actions, state, reducers, and stores are all completely central to an application. You must understand all four of these things and their interactions to really understand Redux. Finally, we've learned that a good Redux application never mutates the state through the principle of immutability. In the next two modules, we'll be developing our very own Redux application. So get your id open and get ready to code along at home as we build and application with Redux.

Building Applications with Redux
Introduction / Application Preview
Hello and welcome to this module entitled Building Applications with Redux. In this module, we'll be constructing a message board component to our application. The message board will use Redux to manage its state, so it should be a great opportunity to learn Redux and how it works. Here's what we'll be covering in this module. First, we'll go over the procedure for scaffolding the application, then after we've installed Redux, we'll implement a Redux store for our application to hold its state. We'll create a reducer for our store that updates our application state in response to actions. And finally, we'll combine multiple reducers into a single reducer to increase simplicity and reduce the chance of object mutation. First, let's preview the messenger service. If you're coding along at home, just click out the branch redux-start for the messenger service stub that we're going to start with. Here we are at the Message Board that we'll be building in the next two modules. As you can see, it displays a list of messages that users have posted. I can type a new message, and submit it. Notice there's a slight delay between when I submit it and when it appears. This is the asynchronous component we'll be adding in the next module. If I update the status, to Offline, I can no longer interact with this input component, so these two components are going to have to share data in some way. If I choose a different status, then the message input returns to normal. So, that's the Message Board. In the next clip, we'll get started on the scaffolding.

Scaffolding the Messenger Service
Before we can create the messenger service, we have to scaffold the necessary files to actually hold the code. Now in the interest of time I've already updated the code base to include the necessary scaffolding. I want to focus all our coding time on actually learning Redux, but we'll be going over what's changed in this video. The webpack configuration has been updated to allow a new page. Two new files, message-board. js and message-board. html were created, and the HTML, mostly the forms, is created. So here we are back in WebStorm. Now to get the scaffolding I highly recommend you just check out the branch, redux-start, however it is an option to copy it down yourself if you really want the full hands-on experience. Let's look at what's changed. First, in index. html we've added a new link to the message board. Just some basic HTML here. We've added a message-board. html with a similar boilerplate at the top as the other pages. Here in our body, we have a section that holds our messages repeater. We have one form with an input and a button to accept new messages that the user creates, and another form with the select and options to specify the user status. Next, in the src directory I've added an empty message-board. js file. This will hold the code we'll begin to write in the next clip. Finally, if we have a look at webpack, I've added a new entry point that serves our message-board. html and also our message-board. js. In the next clip, we'll begin to implement Redux.

Implementing a Redux Store
In this clip, we'll implement a Redux store. This store will be the backbone of our application and will hold not only a lot of the logic, but the state itself. In this clip, we'll be doing the following: first, we'll install Redux using npm, then we'll create a Redux store using the tools provided by the Redux library. We'll define a default state for our application so that it shows something when it starts, then we'll render the application which updates what the user sees and will have the effect of putting our list on the page. So with no further ado, let's get started. So, here I am inside WebStorm. First things first, if you have webpack running since the last module, go ahead and stop it and start it again, which will give it access to the message-board. html and js files. First we need to install Redux. So I've got my terminal open right inside WebStorm this time, and I'll type npm install --save redux. With Redux installed, we can now begin to implement it, so let's go to message-board. js. First, to create a store, we're going to need to import the createStore method from the Redux library. Now we'll define a default state for our application. This is the data from which the application gets what to show the view from before the user has interacted with it at all. Our state object will have two properties, a messages property, and a userStatus property. We'll implement the userStatus in the next clip, but let's create some messages. Each message has three properties, a date, a postedBy, which is the users name, and content, or what the message shows. We're going to want at least three messages that look like this, so I'm going to add a few messages that fit this format and you do so as well. If you want to change the postedBy or the content, then that's totally fine. Now our defaultState is defined. Next, let's create our store. We'll say const store, so we'll call createStore, now this is where the reducer would go but since we don't have a reducer we'll just make a very simple one that returns the default state. It'll take and argument and if no argument is passed, it will default to defaultState, and it just returns the state. Finally, let's add a render function. The render function will update the page whenever the store changes. First though, let's just update userStatus here to the string ONLINE. That looks a bit better. Now inside render, first we'll get the store's state. We'll use some object destructuring here. So we'll update the document's element called messaged, and we'll make that equal to the messages property of the store, and we'll sort it by date. Then we'll map the messages to a message component similar to what we did in the previous module, but we're just going to inline the component this time. And just a bit of template strings there. Finally, we'll join this map so it becomes HTML, and that'll be sufficient for now. Finally, we'll call the render function at the bottom of the page. Now let's take a look at our application. As you can see, the render function is getting the state from the store and updating the page. The other form elements don't work of course because we haven't set them up, but in the next video we'll be adding a reducer that will actually update the state in a predictable way.

Creating a Reducer
In this clip, we'll be creating a reducer. Since we already created reducers in our Learning About Flux, this should be fairly straightforward. In this demo, we'll do the following: we'll define our constants, and create a reducer that works on the whole state, since we're not combining reducers in this clip. We'll update the store to use a real reducer instead of our placeholder, and we'll create an action for updating the user status. We'll also hook into the form to dispatch and action when the form is submitted. First, we'll define our constants. I'll create a constant for online, away, busy, and offline, our four statuses, and one more const for the actual action, which we'll call UPDATE_STATUS. Next, we'll update our defaultState to use the const online instead of just the string online. Next, let's create a reducer. As we know, reducers take two arguments, a state and an action. I'll give state the default property of defaultState, and I'll destructure the action into its two component parts, type and value. Inside the reducer we'll switch based on the type. If the type is our updateStatus action, we'll return a copy of the state where the userStatus is the value of the action, and we'll break, and remember a reducer must always return a state, even if it's unchanged. So at that bottom we'll call a return state. Now here in createStore, instead of this phony reducer we put in, let's add the real reducer. Now let's update the render function so that it actually changes how the app looks based on the userStatus. There's just one thing that happens. If the userStatus is offline, then the input for the message is disabled. We're almost there now, now we just need to hook into the forms on the page so the reducer actually runs when appropriate. So we'll add a change listener to our selectStatus form. So when the form is changed, we want to dispatch a user status change action. First though, let's create that action generator. I'll define a basic action creator just like we did in the previous videos. So there you go, it just takes a value and creates an UPDATE_STATUS action with that value. If we wanted to make it more sophisticated, we could have it thrown an error if the value didn't match one of the approved user statuses, but for now this is more than sufficient. So we'll go back to our EventListener, so we'll call store. dispatch. As you'll recall, in a Redux application the dispatcher and the store are all in one thing, but otherwise not much has changed. So rather than creating a dispatcher then calling dispatch, we can just call dispatch straight from the store, and just like in Flux, all we do is pass it an action. So I'll invoke our statusUpdate action function, and for the value we'll just say whatever the target of the event is, we want that value. Lastly, we need to subscribe to the store. So this is just like dispatcher. register, whatever function we pass to store. describe will be run whenever the store is updated. As you can imagine, we want to run render every time this occurs. So that should be all good, let's have a look at our application. Our app looks mostly the same, but with one key difference. If we set the status to Offline, this form becomes disabled. Of course, the form doesn't do anything yet because we haven't implemented that, we will in the next clip, but this is a great boilerplate Redux application, so I encourage you to take a few minutes to review what you've created before moving onto the next clip where we'll be combining reducers.

Combining Reducers
In this clip, we'll be combining reducers, which means taking two or more reducers and turning them into a single one. In this clip, we'll be creating separate reducers to operate on each part of the state. We'll create a reducer, constants, and an action for our new creating messages functionality. At the end of this all, the application should be fully functional, minus the asynchronisity. So, let's do it. Here we are at message-board. js, first, to combine reducers, for combining reducers Redux provides a handy utility called, you guessed it, combineReducers. So let's import that from Redux. Next we'll create a new constant for the create message action, we'll call it CREATE_NEW_MESSAGE. Next we'll create a new message action creator, so we'll call it newMessageAction. Unlike the previous one, it will take two arguments, content, which is what the messages hold, and postedBy, who the message was posted by. We also want to know the date but since this is going to be the same whether the user enters it or not, we'll just define it here in the action. We'll say const date is a new date. Then we'll return our action, and our action will have all of the properties, type, value, postedBy, and date, and now we have our new message action. Now we'll combine reducers. As you'll recall, I have my existing reducer here, but we don't want a reducer that operates on the whole state, we want something that operates just on one property. So let's create a new const called userStatusReducer. So this is just like our existing reducer, but instead of worrying about mutating the whole object, we just have to operate on the userStatus. So the first argument is the state, but it's not going to be equal to defaultState, but rather defaultState. userStatus, and the second argument, the action, will destructure for its type and value again. So now from our existing reducer we'll just copy this switch statement, but here for this line we don't want to return a whole object, which is the state, we just need to return the value, and this should be a comma here in between type and value, and then at the bottom we can return state if the switch hasn't occurred. And we don't need this reducer anymore. So as you can see, the userStatusReducer is like a simplified version of our previous reducer, it never gets the whole object, just the part of the state called userStatus. Next, let's make another reducer for messages. We'll define a messageReducer, and it will take a state whose default is to the defaultState. messages, and an action which will destructure to the values type, value, postedBy, and date. So just like in most reducers, we'll add a switch based on the type. If the case is CREATE_NEW_MESSAGE, we'll do the following. Now as you'll recall, messages is an array and arrays are actually a mutable data type, so even though we're using combine reducers, we still want to be careful and make a copy of our array and not mutate it. So we'll create a newState, and it'll be an array since messages in an array, and the first entry in that array will be a new object with a date, a postedBy, and a content property. Then we'll use the array spread operator to add whatever elements were in the previous state to this one, so now it's just like the previous state copied with one new element. Then we'll return that newState. Great! So we've created a reducer that just works on messages, but we have two reducers and the store only takes one, we're going to need to combine the reducers. So I'll create a new constant called combineReducer, and we'll call the combineReducer's method. So combineReducers has kind of a weird syntax, it takes and object as an argument. The keys of the object is the name of the property in the state, and the values is the reducer it uses to reduce those. So we have a property userStatus, and we want our userStatusReducer. And we want messages, so we'll use our messagesReducer. This is actually all the procedure that's necessary to combine reducers. Now back down at our store, we'll pass it the combinedReducer. If we take a quick peek back at our app, we can see it's still functional, it's not throwing any errors. Our combinedReducer is working just like our previous reducer, all we have to do now is update this form, so let's go back into WebStorm. So I'll add a submitlistener to the document form called newMessage. First we'll call e. preventDefault, so the page doesn't reload when we submit the form. Then we'll get the value of the field by getting the target's newMessage. value. We'll get the username, now since we're storing the user's custom name in local storage, we can try to use that and if that doesn't work then we'll just get the default username like Jim. So it just parts the local storage or returns the default. Just some presentational stuff there. Finally, the interesting part, we'll call store. dispatch, we'll create a newMessageAction, the first argument will be the text of the message, and the second one will be the user's name. Finally, we'll add one thing to render. When it renders we're going to clear the value of the newMessage form. Alright, so everything should be working. Let's go back to our application. Now you shouldn't have any errors here on the right, if you do you may want to consider checking out the branch, redux-midpoint, which brings us exactly to this point. As you can see, if we type a new message, it shows up right at the top. You can do this as many times as you'd like. If we update our status, we can no longer type messages because an offline person can't send messages. So that's our application. The only problem is everything is synchronous and a real message board would definitely have some asynchronous functionality, so we're going to learn how to resolve adding that to Redux in the next module.

Module Review
Let's review what we've learned in this module. So by applying a Redux store we see that it really does have all the functionality of a dispatcher and a Flux store rolled into one. We've seen combined reducers in action and noted that they only get one part of the state, not the whole thing. However, we saw that when we pass a mutable object to a combined reducers like our array, we still have to make a copy of it because otherwise we risk mutating that array. Finally, you probably noticed that this works very similarly to a Flux application. A few things have been reorganized, and some additional utilities are at our beck and call, but otherwise it works the exact same way. As we've learned, Redux provides a more formalized experience than Flux. It's good if you have a big team and don't have time to show them all how you like to do your Flux particularly, if they use Redux they're kind of going to be shoehorned into building an application just like the one we just did. But our study of Redux is not done because in the next module we're going to implement some asynchronisity, it's going to be great, so stick around.

Implementing Asynchronous Redux
Introduction / Scenario
Welcome. In this module entitled Implementing Asynchronous Redux, we'll be completing our Redux application by adding an asynchronous endpoint to it. This will let our application simulate the asynchronous functionality that many modern web apps must have. Here's what we'll be covering in this course. First, we'll take an overview of the scenario and look at why it's necessary to implement Redux asynchronously. We'll create a virtual endpoint which will allow us to make asynchronous calls, we'll learn to understand and apply Redux Middleware, which is a tool for adding functionality to your existing Redux application. We'll learn to debug Redux applications by using specific kinds of Middleware, and lastly, we'll implement an asynchronous action creator which will create a special kind of action that works asynchronously. Let's have a look at the scenario for this module. You need asynchronous code to communicate with the server. Sometimes communications with servers can take a few seconds or even a few minutes depending on the distance from you to the server and the kind of information that's being exchanged. If this code were synchronous, that means all the other code on your page would stop while the server communication was happening. In other words, the whole website would probably freeze and the user would likely leave for a different website. The reason for this is that JavaScript itself is asynchronous language. There are only one or two constructs that allow for asynchronisity, whereas there's hundreds of constructs that are synchronous in the language. So to get this asynchronous code to work with the server, we have to implement some special JavaScript code. However, there's yet another caveat. As we learned, a function is only idempotent if it does the same thing every time with the same arguments. Obviously, a function which communicates with the server and requests some kind of information, like whether the users logged on or not, won't return the same results given the same arguments every time. So how can we implement asynchronous code but yet keep our reducers idempotent? Here's a possible solution. First you can create asynchronous actions, note this is actions and not reducers. Asynchronous actions sometimes dispatch numerous actions via a dispatcher, as they do a different thing like communicate with the server asynchronously. However, the reducers still respond to these actions in an idempotent way. So a typical asynchronous action would communicate with the store once to let it know that the action has begun, and then again, letting the store know whatever the result was of the action. By doing so we can create a different idempotent reducer for each step of the communication process. In the next clip, we'll be created a virtual asynchronous endpoint for our application to use as a makeshift server.

Creating a Virtual Asynchronous Endpoint
In this clip, we'll be creating an asynchronous endpoint for our application to communicate with. We're calling it virtual because instead of communicating with a database or another remote server, it's just returning a hard-coded response. Here's what we'll be doing. First, we'll create a basic mock of the HTTP module, but one that's designed for just a simple response to a simple request. We'll simulate an asynchronous delay by using a timeout inside the get method, and then we'll attempt a communication with the mock server from our application. So, let's go to our id and get started. So here I am in my text editor. If you want to start from this point, check out the branch redux-midpoint, or use the starting course files from this module. So inside our src folder I'll create a New Folder called http. Now I'll create a New File inside it called index. js. As you'll recall from a previous module, naming a file index. js allows us to use a special syntax when importing dependencies. In this file, we're not really going to do anything fancy. First we'll import shortid, to create something for our endpoint to return. Now we'll define our module's export, we'll call it get. get will take two arguments, the url to get, and a callback function to call when the communication is done. We're not actually going to use the url for anything, it's just for parody with the original http module. Next, we'll define an amount of time for our endpoint to simulate a wait. I like 500ms, but you can choose whatever time you want. Now, inside of get, we'll call setTimeout, and the set timeout will wait as long as the asyncAwaitTime. At the end of the timeout we'll call the callback, and pass it a new id, and that's all we're going to need for our endpoint. Now let's go inside message-board. js to test it. So first we'll import our new module, we'll call import, then we'll import get from the http folder. Now all we need to do is make sure it's working, so at the bottom of the page let's add a call to get. We'll say get and we'll just pass in any url, and a callback function to execute when the get call is finished, and we're just going to have a console. log statement there. Now let's just add another log before the get so we can see the asynchronisity. That's all looking good, now let's have a look at our application. So here we are in our application. You can see on the right we have our console logs. If you refresh the page, you'll notice first Making request appears, then about 500ms later it receives the callback. Now that we have an endpoint that simulates asynchronisity, we can build the tools into our application to deal with it. In the next clip, we'll talk about Redux middleware.

Understanding Redux Middleware
Before we go ahead with implementing Redux middleware, I thought it would be good to take a few minutes to learn to understand it. Redux middleware can be used to accomplish almost anything, though it tends to fall into a few main categories of common things that developers need done. So what does Redux middleware do? Redux middleware can respond to actions in a unique way. Basically, your middleware is inserted in the store, and is run whenever an action is received. Often middleware will run right before or right after your reducers have run to change the state. In some cases, like with the debugger middleware that we'll be using, it does both. Middleware makes it easier to debug by allowing you to do custom things when actions come in. For example, you can call debugger in response to a specific affected action, or you can simply log all the going ons of your application to make sure that everything is working properly. The alternative to this is rewriting our actions and our reducers to export tons of information to the console regarding their state. Obviously we want our reducers and our actions to be clean, so using middleware is a better solution. Middleware can teach your store completely new things. For example, a middleware exists to allow actions, instead of returning an object, to return a promise. The promise middleware teaches Redux how to receive a promise and then do the appropriate actions both when it's received and when it's resolved. And lastly, another popular use for the middleware is adding analytics. Since actions describe every possible change to your websites state, this is a great place to put in the hooks that communicate with your analytic server. There's no change you'll miss an important event like the user clicking the submit button or adding a new product to their wish list, if you insert your analytics at this point in the application. As you can see, Redux middleware has many uses, from the practical to the esoteric. Probably the most useful feature though is the ability to debug, since no one likes spending excess time debugging applications. So in the next clip, we'll be debugging our Redux application.

Debugging Redux Applications with Middleware
In this clip, we'll be applying what we learned in the previous clip by installing middleware in our Redux application. This one will give our app added functionality, without the need for us to modify our reducers or our actions. In this clip, we'll take the following actions: we'll install Redux Logger from npm, then we'll use the applyMiddleware method provided by Redux to implement the logger in our application. After this we'll see we have detailed information about what's going on in our application. So, let's jump into our text editor. So here I am in my editor, first in the terminal I'll install redux logger, and after a few seconds this should be complete. Now inside our message-board. js, first we'll import our new module. At the top we'll say import logger from redux-logger. Next we need applyMiddleware, which is the third of three main methods exported from the Redux library. So at the top import statement next to combineReducers, we'll add applyMiddleware. Generally speaking, middleware is added to your store at the moment it's created. The first argument for createStore is the reducer that the store will use. However, the second one is for middleware that we'd like to include. So we'll call the applyMiddleware method, and as the argument we'll invoke the logger. And let's just clean that up a little bit. So with middleware implemented, let's go back to our application and see what's changed. So here we are in the application, and everything looks the same until we try dispatching an action. So go ahead and give that a try. You'll notice we get this awesome debug statement on the right, indicating three things, the previous state, what the application was before, userStatus ONLINE, the action, what changed it, and the next state where the userStatus is AWAY. This debugging functionality is awesome as it allows us to very easily see if there's a problem with our reducer and once we've established that all our reducers work correctly, we can say we have an application that's basically totally functional. Try engaging some more actions and watch the logger give you information on your app's state. (Working) Now that we have the logger implemented, we can implement our asynchronous functionality with confidence knowing that if there's any problems we can quickly debug them; and so that is what we will do in the next clip.

Implementing an Asynchronous Action Creator
In this, the final demonstration in this course, we'll be implementing an asynchronous action creator. This action creator will replace our existing action creator and give our app access to the asynchronous functionality that all apps need on the web. We'll be doing the following things: first we'll create constants and a special reducer just for the communication status with the API. By having the communication status as part of our app's state, we can prevent components from cross communicating with each other. We'll take our existing action creator and modify it to add an asynchronous call, and then we'll update the render functionality to keep the user appraised of what the communication status is. So, let's head to our IDE. Here I am in message-board. js. First I'll create three new constants. The new constants are as follows: a READY API communication status constant for indicating that the application is not waiting for the server, and a WAITING status to indicate that it is waiting. Finally a constant to indicate that a new message has been accepted by the server and the application can continue running. Next in our defaultState, let's add an API communication status. (Working) Next we'll create a reducer for the API communication status, this reducer will closely resemble our userStatus reducer. So the communication status reducer listens for two different types of action, a CREATE_NEW_MESSAGE, and a NEW_MESSAGE_SERVER_ACCEPTED. Whenever it hears CREATE_NEW_MESSAGE, it will change the communication status to WAITING, because it hasn't received a response from the API yet. When it does, the status of apiCommunicationStatus will again become READY. Next, let's update our combinedReducer to include this reducer. (Working) Next we'll update our NewMessageAction. We'll add a call to get at the top and pass in any URL, but we'll just call it api/create. Since we just made our endpoint and note will it succeed all the time, we don't have to worry about preparing for failure here. All we know is that when the get response comes back, we know that the newMessage has been accepted. So we'll call store. dispatch, and we'll make the type NEW_MESSAGE_SERVER_ACCEPTED. So when this action runs, first it'll dispatch CREATE_NEW_MESSAGE, then later it will dispatch NEW_MESSAGE_SERVER_ACCEPTED. We can try it out here in our application. Try creating a new message, you can see that actions happen twice, once for CREATE_NEW_MESSAGE, and once for NEW_MESSAGE_SERVER_ACCEPTED. Finally, we'll update our render function. Here at the bottom of render, we'll update this to say that the new message field is disabled if the user's offline, or if we're waiting in the communication status. And you'll note we're requiring apiCommunicationStatus here at the top from store. getState. And so the application is complete. Let's have a look. Now if we create a new message, you'll notice that the input turns gray for some time. We now have asynchronous functionality in our application, but all our reducers are still idempotent. This is at the heart of making an asynchronous Redux application. In the next clip, we're going to spend a minute learning about some tools that let us do more advanced asynchronisity.

Understanding Redux Thunk and Redux Saga
In this clip, we'll spend a few minutes discussing Redux Thunk and Redux Saga. Both of these are tools that allow us to do more advanced asynchronous functionality. We won't actually be implementing them in this course since that's beyond the scope of what we're trying to cover, but I know that at some point you're going to encounter at least one of these libraries in your day to day work, and it's best that you're not completely surprised when you do. So what are Redux Thunk and Redux Saga? Fundamentally they're both pieces of middleware and they're available on NPM. As we've learned, middleware is applied to our Redux application at the same time as we create the store, and it can do almost anything. Both of these middleware's do something specific though, and that's they support a chain of asynchronous events. In our application, we had a very short chain, just of two things, first the communication status went out, then it came back in. However, in real applications there may be multiple things that are happening, you may first communicate with your authorization server before communicating with your user status server and so on. So in addition to any schemes you could devise yourself for making this more simple and easy to debug, the Redux Thunk and Redux Saga libraries both solve this a different way. So Redux Thunk allows you to make action creators that instead of returning actions they return thunks. So what is a thunk? A thunk is a method that delays the evaluation of code until a later time. Usually it takes the form of a normal function. The ES6 arrow syntax is necessary for making thunks, as otherwise just using the word function, they would quickly become unwieldy and not be useful. Redux Thunk was developed by Dan Abramov, the creator of Redux, so you can use it with confidence knowing that it was created by someone who really understands the library well. Here are two basic examples of thunks. If they look a bit dense, that's okay, thunks can be a bit confusing at first. The first one is a method that takes no arguments, and returns 1 + 2. Even though this is idempotent and the answer is always 3, this is a thunk because 1 + 2 isn't evaluated until you call the function. Maybe you're on some sort of system where adding 1 + 2 takes a huge amount of processing power and you only want to do it at that specific time. In the second argument, we can actually see that the first stage of the thunk returns another thunk, and that thunk remembers what the argument was that was passed in when it was created. If you find this interesting, I encourage you to do more research on thunks after the end of this course. Next, let's take a minute to discuss Redux Saga. So the principle behind Redux Saga is a little bit different, it looks at each series of related events as a chain, and this chain has its own thread, which means that it can be conceptualized apart from any other chains of events. For this to be possible it uses an ES7 feature called async function generators. These function generators are one of the most complicated parts of JavaScript, which makes Redux Saga a little bit challenging to use. It uses the yield keyword, so if you're coming from a language like C#, which has asynchronous functionality, you'll find that it's implemented in much the same way and you might be quite comfortable using Redux Saga. Now I know I've just scratched the surface of these two libraries, but in the interest of time, it was as deep as I could go. However, I do encourage you to learn some more about these libraries if they're something you want to implement for your application. More information on Redux Thunk is available at this URL, github. com/gaearon/redux-thunk, and more information on Redux Saga is available at github. com/yelouafi/redux-saga. In the next clip, we'll review what we've learned in this module.

Module Review
Let's review what we've learned in this chapter. So this chapter dealt with the most advanced topics of all the chapters in this course. We added asynchronous functionality to our application. This makes it a lot more on par with a real world Redux application in what it can do. We learned middleware can give our app functionality such as a asynchronisity or just basic debugging. Finally, we demonstrated in this module that reducers must be idempotent in a Redux application, but actions don't have to be. An action can break down to a number of different actions, all of these which can be interpreted idempotently at the reducer stage, but when they're still actions, anything can happen. In the next module, we'll conclude everything that we learned in this course. We'll review what we've learned and provide some ideas to continue your learning.

Conclusion
Introduction / Review the Completed Application
Welcome to the final module in this course. In this module, titled Conclusion, we're going to wrap up everything we've learned in the course. Here's what we'll be covering in this module. First, we'll review all aspects of the completed application, and also review what it is we applied and learned at each phase. We'll review what we learned about Flux, and review what we learned about Redux. Finally, I have some suggestions for your continued learning on this topic. First off though, let's review the completed application. Over the course of our learning we've done a few things, we implemented Flux to create a control panel, then we used Flux's ReduceStore to make a tasks page. We used the ReduceStore's functionality to keep track of and even undo actions that the user had made. Lastly, we used Redux to create a message board complete with asynchronous functionality. So let's review our application. By this point you should have an application that looks just like this. If you don't, you can always check out the Redux complete branch of the course, or look at the complete course files from the previous module. So our Control Panel had two different kind of actions and did not use any reducers. We had an action for updating the username, and an action for updating the font size. This was a really basic implementation using Flux, and while it was enlightening to implement, we learned moving on that there are much better, more sophisticated ways of doing things. We learned this when we made the Tasks page. The Tasks page literally extended our implementation of Flux at a ReduceStore, taking a lot of the best stuff of Flux and adding in a lot of certainty that was otherwise lacking. In our Tasks page, we created not only a reliable application that's easy to debug, but we also created something where users can undo their actions. This is a great little app and in my opinion and outstanding show piece. As long as you wrote most of the code yourself, you can definitely use this part of the app and application, and as something to show potential interviewers. Of course I do recommend that you're honest and say that you made this with the help of a course, but if you wrote the code, at least some of it yourself, and if you take a few minutes to change some of the styles and maybe update the items in the todo list, I strongly recommend you using this. Yes and to make it all possible we used the ReduceStore, and we learned that the ReduceStore is a bridge between Flux and Redux. Lastly we made the Message Board, the most sophisticated part of our productivity app. The message board used Redux through and through, even adding middleware and asynchronous functionality. We implemented a repeater using Vanilla JavaScript, just to prove that Redux does work without React. And that's the application. In the next clip, we'll review what we learned about Flux.

Flux Review
In this clip, we'll review some of the most key things we learned about Flux specifically. Of course, we learned tons, too much to summarize fully in just a few minutes, but here are the most key points. First, we saw that Flux is easy to implement on your own. We didn't use any Flux library but rather we wrote the entire library ourselves in just a few small JavaScript files. We learned that all Flux applications are based on unidirectional data flow. All actions go directly up to the dispatcher, which is then dispatched to various stores for interpretation. We learned that almost nothing in a Flux app can happen without going through the dispatcher, and also since there's only one dispatcher per Flux app, we can really say it's the core of our Flux app. Lastly we learned about ReduceStores. ReduceStore works like a normal store, but instead of having basically whatever implemented as the logic for dealing with actions, you have to implement the logic in a specific way, using reducers. We saw later that reducers are used heavily in Redux and the ReduceStore makes a great bridge between Flux and Redux. In the next clip, we'll review what we learned about Redux.

Redux Review
Not only did we learn about Flux in this course, we took our learning of Flux and translated it into understanding Redux. Overall, I'm very happy with how the learning process worked out. By learning about Flux and its ReduceStore first, we were really well positioned to understand Redux and learn that it's in fact not a complicated library at all, rather a simple and effective one. So let's review some key points about Redux. Unlike Flux, which has many stores, Redux has only one store per app. To get our functionality broken up into different functions or files, we have to combine our reducers before we pass them to the store. We found that Redux is a lot more rigid than Flux and you can't just go around doing whatever you want, but we also saw that it's very reliable, especially with the debugging middleware implemented. From this we can infer that Redux is a great tool to use if you have a large team and you need more sophisticated ways of making sure they're all following best practices. We saw that the functionality of Redux really does work like the Flux ReduceStore. If we can understand what's going on with the ReduceStore and understand why it exists, we can basically infer a large amount of design decisions that were made during the creation of Redux. Next we learned the nature of combined reducers, and that it's required not only to separate our logic into different files, we learned that combining reducers also prevents mutation. In our application when we combine reducers we saw that each reducer was only receiving a small immutable part of the state, and since they never got access to the whole state, they couldn't mutate it. We learned a lot about idempotence, and we learned that reducers must be pure. We learned all about the side effects of potential functions and that all of them must be avoided to create a truly idempotent function. Finally, we established beyond a shadow of a doubt that React is totally optional for both a Flux and a Redux app. Of course, don't get me wrong, I love React, I think it's a great library and that it adds dozens of hours of productivity to any developer's day. However, I would contend that the only way to be prepared to use Redux and Flux properly with React, is to first learn them without React. Now that you have, you're totally able and encouraged to implement React as part of your next Redux application. And that's all we've learned. In the clip following this one, we'll discuss some means of continuing your learning.

Continued Learning
Alright, well we've come to the end of this course, but that does not mean that your learning has to stop here. As Patrick Rothfuss once said, I only know one story, but oftentimes small pieces seem to be stories themselves. In other words, the big story is Flux and Redux. This course, as well as the pieces of learning I'm going to suggest, are all things that have their own lessons to teach you. Only by getting every perspective can we really say we've mastered Flux and Redux. First I'd like to suggest that you get a subscription to JavaScript Weekly, at javascriptweekly. com. So JavaScript Weekly is, as it suggests, a weekly email roundup of JavaScript news. What makes it relevant is this tends to be the place to get the very freshest, very newest things, the only way to get something newer is to actually read all the conversation that happens on a particular GitHub repo. So to subscribe, you can enter your email address here. However, if you'd rather just pop in and read it you can check out the latest issue here. Now obviously, a lot of this stuff here is worth watching, I do recommend you read every article you find interesting. However, if you're specifically interested in Redux of Flux news, you can almost always find some every week in JavaScript weekly. If we search for Redux, we can see that they have an article here at the bottom for a React-Redux grid, this is definitely a very advanced topic and I certainly suggest that you take your time to learn about it if you feel that's interesting. JavaScript Weekly is great because it doesn't just make you better, it makes you cutting edge. If you read something on JavaScript Weekly, then come into the office and tell your coworkers about it, odds are they won't have heard it yet unless they're also avid JavaScript Weekly readers. Next in your continued learning, Dan Abramov himself, the developer of Redux, has made several videos and video courses to teach you Redux. Now I've found that his teachings tend to be very advanced, and he uses a lot of advanced techniques very quickly in succession, but now that you've watched this course, you're ready to understand the teaching directly from the creator. So here on YouTube is Dan Abramov's The Redux Journey at react-europe. Clearly this is an extremely worthwhile video to watch. The link is there at the top of the screen if you'd like to copy it, or just Google the title of the talk. In addition, Dan Abramov has a course on Redux on egghead. io, which is free to watch and which is very good, if a little bit advanced. So this course is called Getting Started with Redux. This course deals with some advanced stuff indeed, including using the React Redux library to generate containers. Currently, this course does not have any cost, so I recommend that you watch it and learn what you can directly from Dan Abramov. What you've learned in this course will prepare you to understand all these concepts without convoluting them with other ideas such as React and JSX. Finally, on Pluralsight, Cory House has an excellent course on React and Redux ES6, so if you're already a Pluralsight member, this course should be free for you to watch. This course naturally follows the course you just watched. Mr. House takes us through a full app building process. Unlike this course, he emphasizes React heavily, and since I do think that learning to use React with Redux is practical, I'd recommend you check out his course. There is the link there on the top. It's rather long and the coding along segments are very involved, but being prepared with this existing knowledge of Flux and Redux, you should be all set to take care of it. Well, that wraps up this last video. In the next clip, we'll take a moment to say thanks.

Thank You
Well, it's been quite a course. I'm personally very proud of this course. I feel that it strikes the perfect balance between being thorough, entertaining, and really focusing on the practical skills that you need to know, but of course none of this would be possible without you. Now if you've made it to this video, that means you've watched this entire course, and if you haven't, go back and watch it now. I'll wait. But if you have watched the whole thing, that means you've already shown more persistence and determination than 95% of other developers I've met. Most people just like to try something and see if it's easy, they're looking for the quick way out. Very few people are willing to put in the necessary time and work to understand the materials, but I know that you are among those hard-working people, so I want to extend a very special thank you to you for watching this course. Have fun on the continued education and be sure to check out my other courses. If there's something that you thought could need improvement, please chime in on the discussions and let me know what you would have done to improve this course. I'm Daniel Stern, the code whisperer, happy coding.
