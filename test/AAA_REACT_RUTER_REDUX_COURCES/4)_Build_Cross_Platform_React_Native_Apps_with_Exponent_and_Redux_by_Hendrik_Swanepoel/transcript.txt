In this course, you'll learn how to use your existing JavaScript skills to build native apps for iOS and Android. You don't even need to be a React expert to follow along! You'll learn how to get going with React Native with minimum development setup as we'll be using Exponent to help us get going very quickly. After building most of the app through Exponent, we'll move into a full-blown environment where you'll learn how to do platform targeting: building special features specifically for a specific platform while trying to achieve as much code reuse as possible. We also introduce Redux to the mix to help us encapsulate our state management in a very elegant manner. This course (and React Native) relies heavily on JavaScript 2015 features!

Course Overview
Course Overview
Hi everyone, my name is Hendrick Swanepoel, and welcome to my course: Build Cross Platform React Native Apps with Exponent and Redux. I'm a full stack developer and the technical lead at 227, a Fintech company in Cape Town, South Africa. There's no denying it anymore, React is here to say, so it just makes so much sense to use the same technology to target the web, iOS, and Android using the same skillset. In this course, we're going to cover using Exponent to get started quickly. We'll also cover how to use various React Native components. I'll show you how to do platform targeting. We'll also do state management with Redux. By the end of this course, you'll be able to build a cross platform React Native app, building specific features for specific platforms, while achieving as much code reuse as possible. Before beginning this course, you should be familiar with JavaScript, a little bit of experience in React would also be very helpful. I hope you'll join me on this journey to learn React Native with the bold cross platform React Native apps with Exponent and Redux course at Pluralsight.

Get Started
Why Use React Native?
So you decided to take a look at React Native, good for you. I'm Hendrik Swanepoel, and I'm very excited to show you how to build cross platform apps with React Native. Before we start delving into the details, why would you want to use React Native, what will you get from working through this course? Well it's got a very friendly workflow, very familiar too if you've done any sort of web development. What I like about it is that out of the box, you've got ES6 compilation and all that sort of stuff, you don't need to go and set anything up. The React Native packager takes care of all that for you. It's got a massive community. React Native uses React itself, so all the information that you get from the React community also applies to the React Native community, but there are a lot of people interested in React Native itself. I'll show you some resources throughout this course to point you to good places to go and meet up with them. The other benefit of using React Native, since they've released Android support, is that you get a massive amount of code reuse between your different platforms. That said, you can still differentiate between how your app looks on iOS and how it looks on Android. I'll show you how to target specific platforms later on in this course. As I've mentioned earlier, with the React Native packager, you get JavaScript 2015 and JavaScript 2016 features out of the box, and you won't even need to set up something with Babel, and Grunt, and all that sort of stuff, it's all part of the React Native packager. The React Native packager uses Babel under the hood, but you don't need to go and configure it, you just get to enjoy the results. If you've got a rudimentary understanding of React already, then React Native will be a breeze for you. But don't worry, if you don't know React well or haven't even seen it, it's very easy to learn and understand. It's one of those technologies where you can do 80% of what you want to do with 20% of the knowledge. React native has also proven in the wild. It was used by Facebook to develop their ad manager app and also their groups app. This scored a very popular chat platform for gamers with a massive amount of users, also develop their app using React Native. So if you know JavaScript already and maybe a bit of React, you can get started building very rich, mobile apps very quickly for both iOS and Android with maximum code reuse.

This Is What We'll Build
Let's have a look at what we'll build during this course. We're going to build a todo app, maybe not the most exciting example project in the whole world, but do you know what, React Native is exciting enough to keep you hooked, I'm sure of it. As you can see, I've got the iOS simulator open here on the left, and the Android emulator open here on the right. The app looks slightly different between the two. As you can see here, it's got a checkmark on the todo items inside of the Android app, and it doesn't have it inside of the iOS app. Let's add one here in the iOS app. Let's call it A new todo. Okay, now it's showing two todos here. Let's do the same in the Android app. As you can see, React Native out of the box gives you very specific styling for your components between iOS and Android. A textbox looks like an iOS textbox on the iOS platform, but like an Android textbox on the Android platform. This is actually very cool, you don't want your components to look generic on both platforms. That's called the uncanny valley effect, where stuff doesn't look quite right. Let's add a new one in here. As you've might've noticed, it's got really nice transitions from the one scene to the next, and as you'll see later on in this course, you don't even need to do fancy coding to get this right, it's all baked in. In our app, you can also mark todos as done. Let's go and mark a todo done in the iOS app, and we do this by sliding our row to the left, exposing this Done button over here. When I click that, the todo disappears. This is an example of the way we do platform targeting. On the iOS app, you slide the row to the left, and you've got a button, and you mark it as done, as you just saw, but on the Android app we've got this checkmark, when we press that the row disappears. We also have this switch component here where you can toggle between showing pending todos and done todos. Before we start, I just quickly want to show you how much reuse we get out of our code base. We've got an Android file and an iOS file that have got exactly the same little bit of code in it. It's because we can reuse this component between iOS and Android. We don't need to go and split off, and have two different code bases, one for iOS and Android. We can split on component level, and even get a lot of reuse in a component where we split. This is an example of where we did platform targeting for a specific component. You can see that we've got two render files. The one contains the view for the Android platform, and the one the view for the iOS platform, but we still have a lot of code reuse on the component level where we do stuff like handle events and mutate state.

React Native Overview
Let's do a quick overview of our React Native works. I have released another course earlier on React Native on Pluralsight, so go and check that out for more detail on how React Native works. That course was built before React Native supported Android, but there's more detail in there on how styling works, and how the compilation process works. So if you want to have a more in depth understanding of React Native, go and do that course, and come back here. This course's purpose is to show you how to build cross platform React Native apps, so we're going to be using some tuning in this course, which wasn't available when I did the previous course. But the previous course goes into a bit more detail on how React Native works. So you might be wondering, how can I use JavaScript and React to build Native apps, that doesn't make sense, how can it be Native and be running React? Are you worried that it's maybe running something in a web view, and building stuff up to HTML, and displaying that to users? That won't be Native, right? Well don't worry, that's not the case. The UI that your user will interact with will be full Native components. It will look and behave exactly like components that you build with Objective C or Java. So this is how it works, you code up your React code using J6 and all that sort of stuff, define components, and then it goes through a build process. So the React Native packager, a terminal app, hangs around in the background, and monitors your project for file changes. It then compiles those files into a package. So in the meanwhile, you've installed your app on iOS or an Android in the simulator or on the actual device. Now this app talks to your React Native packager, gets notified that there's new code, that there's a new bundle, and downloads it, and loads it into a JavaScript engine, where it executes it. In JavaScript Core, it calls your components render, and it pulls up a tree of components, and commands, and stuff. It then talks through a bridge with the Native app, and what it does is it programmatically lays out your view using Native components. So imagine you're an iOS developer, and you don't use any graphical layout tools. You go and build up all your views programmatically. Well this is basically what React Native does. It goes and uses React code, and it compiles it to instructions that it runs over a bridge to programmatically go and layout your view and components, and it does the same on both Android and iOS. So in a nutshell, that's how React Native manages to do its magic.

React Overview
I'm going to give you the quickest primer on React ever. There are a lot of courses on React on Pluralsight. If you're unfamiliar with React, you can go and check them out, no worries, come back to this course. But if you're in a hurry, and you really want to check out this mobile developing thing using JavaScript, and you're not that familiar with React, maybe stick around, and see if you can work through it. It's very, very easy. We're not going to use a lot of advanced React features in this course, and I'm going to expose you to the nuts and bolts of React step by step. Let's have a quick look. So this is using ES6 classes, and I'm importing the component from React. This component contains all the lifecycle sort of events and all that stuff that a React component needs to run. We then create a new class, and extend from this component. Very importantly, all React components need to define a render function, and in this function you can see that we've got this weird syntax. We return, and then we've got what, it looks HTML in here. Well that's call JSX. Obviously this JavaScript will need to go through a compilation process before it can run in a browser. Now I'm saying browser because we're going through a React primer. We are obviously going to build mobile apps in this course with React Native, so there won't be any browsers involved, but I'm just trying to explain to you how React works. Anyway, so we're returning this HTML in here, and you can see that we've got one element, so you should always return one element from this render function, one root element. It can have nested stuff, nested content inside of it, but I can't return two sibling p tags here. I need to return one root element. In here I've got this brace syntax, which looks very familiar is you've done any sort of data binding inside of web development, perhaps using Angular, and here I say that I want the prop called name to be rendered. So this component expects a name attribute to be set on it. Lastly, we export this component so that it can be used in another component. Let's have a look at this other component, which uses our newly-defined Cat component from the previous slide. Okay, so we import Component again, that's just so that we can use it here to define our main component, but also we import the Cat component from it relative location. So obviously, you need some sort of build tool that can handle this syntax, this ES6 module syntax. Mostly, you'll probably just use Babel and something like Webpack. If you want to learn more about this stuff, go and check out my other course on Building Real-time React apps with Firebase and Webpack. Anyway, so we go and define our main Component, extend from Component, and here we've got our render function. Now in here you can see we return a root element again, but this time we go and render our Cat element. So this is the magic of JSX shining here because it will figure out oh, this Cat here is this component that you've referenced in, so it will go and slot in our Cat component in there, and it will go and wire up this name attribute that we specify with hendrik. Lastly we export this object so that we can use it either as a root component to our app, or inside of yet another component. So that's what we mean when we say that React uses components.

Versions and Conventions
So let's have a look at some very important versions and conventions for this course. Well right off the bat, I just want to make it clear, React Native is open source, and we do depend in this course, even though I tried my best to keep it to its minimum on other open source dependencies. That means we're very susceptible to versions changing. I always feel that even though open source moves along very quickly and changes quite often, that you can learn the underlying concepts in older versions, and apply it in newer versions when you go and use it. So don't think for a second that if you're doing this course six months after it was released, and React Native's gone on with a couple of versions, that you won't be able to derive benefit from this course. Try and use the same versions as used in this course, work through the content, and then you're guaranteed that you won't have any breaking changes in any libraries that we use, including React Native. The way to do this is to go and use the package. json file that I'm sharing on this screen at the moment. You can also find this package. json file inside of the source code on Pluralsight for this module, but if you can't grab it from there, go and grab it from this link on GitHub. The way to use this file is go and then plunk it into your folder, and run NPM install. That will make sure that you've got exactly the same versions that I used during this course. Another important thing to get out of the way is that I'm using ES6 classes throughout this course when defining React components. It's one of those things that developers get very polarized about, should you be using this sort of syntax to go and define React components, or should you be using some other sort of syntax, the React. create class and something which I'll show you soon enough. I've opted to use ES6 classes because from all the examples that I could see, this is what most people favor and can understand, especially if you're coming from something like Java or. NET. It helps to work with familiar sort of constructs like classes, but that's it. Even though I favor using classes, I thought I'd at least mention that since a recent version of React, you can use stateless functional components. They're so elegant, I absolutely love them. This here is the same component as the previous slide, let me go back there quickly. This is the ES6 class, look at this code, look at the boilerplate, and this is the same component defined in a stateless functional component. You can see why I'm so excited about this, and why a lot of the community members are so excited about this. It's just more in line with the larger movement of using functional programming concepts while building React apps. So just keep it in mind, be aware of it. Even though we use ES6 classes throughout this course, this is very exciting. So for React Native, we use version 0. 19. 1 throughout this course. You can always try and use the latest version, in fact I'd recommend it. Go and try, and see if you've got breaking changes. If you do, and you want to follow along line by line throughout this course, go and get the package. json that I shared earlier, and go and install this version of React that I can vouch for, for this course. React Native and React are both very popular open source frameworks, so they take care to go and evolve the API, and try to minimize breaking changes. So you should actually be fine with the latest version when you do this course. I'm just letting you know this is the version that if you run into problems, you can revert back to, and follow along line by line. Similarly, I used 7. 2. 1 of Xcode. In fact, always go and ensure that you've got the latest version of Xcode installed. But if stuff looks a bit weird, and your Xcode looks a bit different than mine, this might be why. This course was one on 7. 2. 1, and you might be on a later version already.

Configure Atom with ESLint
Now if you're like me, and you've done a lot of. NET and Java programming in your past, basically having IDEs, and type safety, and all that sort of stuff, then you might enjoy setting up linting for your favorite text editor. I used Atom throughout this course, but you could also use something like Visual Studio code, or Sublime. Let me show you pretty quickly what linting gives you. I'm opening up some code in the final product of what we'll be building in this course. Going into this render function, and I'm going to write a bit of bad code. It doesn't actually look that bad, so I'm just saying if a == 1, then go in console. log testing 123. See, it doesn't look too bad does it? When we save that out, my linter setup kicks in, and it starts giving me errors. Let's work through the errors so that you can get a sort of feeling of that this linter setup will give you. So when I click on that, it tells me that the keyword if must be followed by a whitespace. Hmm, I didn't think of that. So let's add a little bit of space after the if keyword. Now it goes onto the next error, and it tells me that a is not defined. Hmm, okay, it's a bit difficult to get around that error now, let's make it 1 == 1. Now it's telling us that we expected to see a tipple equal sign instead of double equal to do strict equality checking. Okay, so let's fix that. Now it's telling us that it picked up an Unexpected constant condition, 1 will always be 1. See how clever this linter is? Okay, so I'm going to get rid of this if statement, and add something a bit more specific in here, something that we'll actually be doing inside of React. So I say if this. props, so this is how you access the properties that was set on your component, if the name prop === hendrick, now it gives us a warning, and it says name is missing is the prop validation. So this is app's specific linter issues kicking in here. We'll do this many times in this course, but I just want to scroll down and show you quickly, it's referring to these prop types down here. Whenever you expect to use a prop, you need to go and add a rule in here to go and say what type of value you're expecting and whether it's required. Let's go back up to our code. Okay, so I'm just changing this to an existing prop so that we can get rid of that warning. Let's see what the next error is. Oh, it also wants some space after this if condition. Okay, and let's fix that. Then lastly, it tells us that strings must be single quotes, I used double quotes here. Oh we still have one error left, I've forgot the semicolon. So that piece of code that I put in there, that looked not too bad, just when we typed it, when it saved it up, it adds so many issues with it. So using this will result in code with less bugs, and when you work in a team, your code will be very consistent, and everybody's code will be format similarly, and using the same sort of rules. So this is a massive benefit. I love how quickly you get realtime feedback as you type the code. So how did we get this setup? Well it all relies on ESLint, which is the base linter package out there at the moment for JavaScript. You can go to their website on eslint. org. Importantly, you can click on here, and go and have a look at the Integrations. Here you can see that you can use Sublime Text, Atom like I just showed you. You can also use it in Visual Studio code, which is pretty cool, and if you're a JetBrains fan, you can also use it in all of their products. Also pretty cool, as you can see down here, you can use it in Build Systems like Grunt and Gulp, so that you can go and run it as part of your continuous integration when you push code through to your repo. So for all the specific nitpicky sort of rules that you saw about if statements needing some space after the if and the condition, all that sort of stuff that I just showed you, that is actually not part of ESLint, but a plug-in to ESLint. Those rules are all part of this, the Airbnb JavaScript Style Guide. I'd advise you, if you haven't yet, to go and have a quick scan through this content. It's really informative to go and scan through this, and to understand the thinking behind all the different rules. This is a very popular style guide favored by a lot of development teams. The cool thing is that there's an ESLint plug-in that allows you to conform to this style guide. And the React specific stuff that you saw when I used a prop, and it told me that I didn't have prop validation, well that's all part of this React plug-in for ESLint. This is also a very popular plug-in, and it's got very good documentation, explaining each separate rule to you in a lot of detail. If you want the same setup as I've got, then in Atom go and install some packages. I've already installed it, so I'm just going to show you here in my installed packager when I type linter, you've got to enable this default linter package in here, and you need to install the linter-eslint package with Atom. So instead of going to Packages here, just go to Install on your machine to go and install these packages. So that's all you really need to go and do in Atom. The bulk of the config is actually done in code. As you can see here in my package. json file, I've got babel-eslint, eslint, eslint-config-airbnb, that's the style guide, and eslint-plugin-React, that contains all the React rules like the property validation that I showed to you earlier. So just go and ensure that you've got these packages installed, then to go and configure ESLint, you add an eslintrc. file inside of the root of your project, so that's. eslintrc. This file is available on this location, and GitHub if you need to go and get it from there, or you can just go and get it from the source code for this module on Pluralsight. I don't want to go too deep into this subject. You can go and get the config from there, it's all just very self explanatory. You can also install the NPM packages that you need for your linting setup from terminal by typing this npm I, and then followed by all the packages that I showed to you. But it might seem like a bit of a schlip to go and do this work before starting the course, but I'd advise you to go through the trouble to go and get this set up. I'm going to refer to linting quite a lot during this course because it helps us to code the most beautiful consistent code possible, and it does teach us a lot about JavaScript and React on the way. Let's get started with some React Native code as soon as possible, and we're going to using Exponent to set up a project, so we won't be doing a lot of complicated environment setups. We're going to use it to get you started on coding React Native as soon as possible. I'm sure you're going to enjoy it.

An Introduction to Exponent
What Is Exponent?
In this module we'll start building our relatively simple mobile app in a cross-platform way. At the end we'll end up with what you see here, a todo list app that allows you to add todos, and mark them as done. This app can run on both iOS and on Android, and we won't even need to do a lot of environment set up to get this app working. We're going to use a tool called Exponent to help us get going very quickly with the basics before we start setting up proper development environments later in this course. At the end of this module, you'll know a bit more about Exponent. You know how to download and install it. I'll show you how to generate a new React Native project with it. Then you'll see how to attach the Google debug tools to your code, and you'll see how the basic app takes shape with React Native, learning important concepts along the way like React best standards, data flow, and how some of the cross-platform components work. But why Exponent? The reason I make such a big hurrah about development environments is because what often scares people away from mobile development is the daunting prospect of setting up environments for the platform they want to target. You might also have experienced this, I know I have. I think it's still easier to learn React Native then jump in and start coding in Objective-C or Swift against a UIKit API, but the environment setup can be quite a pain when you just want to dip into a technology, and perhaps evaluate its viability for your next project. And since React Native started supporting Android, if you want to target both platforms, iOS and Android, you'll need to set up the development environment for iOS and Android. Once you buy into React Native though, this feels negligible as you'll understand what it gives you and your team. But before that, it might prevent some people from checking it out and starting building something with it. So this is where exponent comes in. This technology allows you to get going with React Native development with minimum environment set up. Exponent's got a Native app release to both platforms, iOS and Android. So if you've got an iPhone, you install the Exponent app from the iTunes Store. And if you have an Android phone, you install the Exponent app from the Playstore. Then you download what they call the Exponent XDE app for OS X, which the app allows you to serve up with ngrok. Ngrok is a service that allows you to make a service on your developer machine to listen publicly on the internet. This is great because it means that your phone doesn't even need to be on the same network as the computer running your packager. Then you open up the Exponent app on your phone that you downloaded from the iTunes or Google Playstores. You then plug-in the URL for your project, and the app loads on your phone. So it's a Native app that allows you to load React Native apps. They even have a repo of published apps that you can run in here, and the Exponent community is quite excited about it. If this floats your boat, go check it out. As for me, I'm more excited to get a chance to show you cross platform React Native development without needing you to set up your development environment first. When you open this XDE app, you can see that you can set up a new project with this button over here. Let's create our project. First select the folder you want to create the project in. In our case, I want it to be called PluralTodo. Okay, now it loads up the options for the project that it's generated for us. I do, in fact, have Xcode already installed, which gives me access to the simulator of the _____. It's obviously easier for me to show you how everything works with the simulator because it's easier to record my screen this way. That said, I'll show you how it runs on my phones soon enough. When you want to run your exponent project on the iOS simulator, you need to install the Exponent app on the simulator, so that you can load your app bundle in the app exactly like you would do if you were running the Exponent app from your phone. Luckily this is super easy to do. All you need to do is click this button over here, which says Install Exponent on Simulator, 10 out of 10 for descriptive button labels for these guys, and there's the app. Now we can click this button that says Open Project in Exponent on this Simulator. The very first time that you do this, iOS on the simulator will ask you if you're happy to do this. We are, so we click Open. Now that the exponent app was launched with the URL pointing to the packager running in here, the first time you run the Exponent app, it will give you the option to subscribe to their Slack group. We're going to skip over this for now, but I do encourage you to sign up. The people over there are super friendly and helpful. Okay, let's skip that. You can see by this log here that the bundle was requested from iOS, and that it's running the app that we generated with the exponent XDE. So what have we done so far? We installed the Exponent XDE, generated a new project, installed the Exponent app on the iOS simulator, and got the app up and running on the simulator.

Running Exponent on Your Phone
Next we're going to take a look at running your app on the actual iPhone, and if you have an Android phone, it's just as easy. I have an iPhone though, so I'll show you the app running in an iPhone quickly. I've used special software to record my actual iPhone display. It basically allows me to _____ play from my iPhone to my laptop and then record it from there. So what you see here is my real iPhone, scout's honor. Okay, so I'm opening the App Store, and searching for Exponent, and I touch the install button, and we wait a bit for it to install. So it installed, and I open it up. Now it talks to a central Exponent server to load up the views to welcome you to the app, giving you the same option to subscribe to the Slack community, as it did on the simulator. When we cancel that, we are greeted with a default Exponent app that tells you how to get started. To load up other apps, you need to press this Exponent logo at the bottom-right corner. As I've mentioned before, they have an app repository, and anyone can publish to it. Let's open up this HackerNews one, for example. It looks pretty cool. Okay, now we need to get this app to open up our project, and we need to get the correct URL for that. It's a pain to go and type this whole URL over here into my phone. That's why they've built this button over here on the XDE that allows you to send the link to your phone. I just played around with http and localhost over here. Let's set it back to LAN because my phone needs to load it over the network, and let's set the link protocol back to exp. This basically means that it will send exp links when you press this button, and that the operating system will send the request for that URL onto the exponent app, which I've registered for that URL scheme. Now that we're back on the recommended settings, we click this Send Link for Phone button. On my phone, I receive a new email containing a link. See, its protocol is exp, and when I touch this, iOS knows that the Exponent app cares about links that use this protocol, so it opens up our app in Exponent. Let's open up the code for this project. I just want to change something quickly to show you that it does actually work. So I'm changing this text over here to something different. Now when we reload this app on my phone, it's updated the text. So theoretically, you can get started with React Native development with just Exponent and your phone. So what have we done so far? We installed the Exponent app from the App Store onto our phone. I did it on my iPhone, but you can do it on Android if that's what you've got. I then ensured that my settings for the packager made it available to my phone over the LAN, and emailed myself the link, and then opened up this link on my phone, and it launched the app. If you've ever struggled with getting app provisioning and all that nonsense set up for iOS, you'll know that this is a much nicer experience.

A Clean Exponent App
What we're going to do in the next few minutes is simplified so that we have a basic component that renders some simple text. To start with, I'm just removing the sample files that the XDE app generated for us. We're going to keep main. js, but we need to clean it out a bit. Let's change the destructuring call here to pull in only the AppRegistry and Component objects from the React Native package. Let's remove this kind from here too. Because we pulled in Component reference, we don't need to say Reacted component here. Let's rename our component to PluralTodo, and we don't want this state over here. We're going to add some state later on, so let's at least leave the state assignment over here. There render function we clean out completely. We delete these two functions, we don't need them. For now, let's also remove the style code. Okay, so we've got a pretty clean file now, but with an empty render. As I said, we want to render some text to the view here to make sure everything is working. So I need to pull in the text component up here. Now we can render a text element with a simple hello message in it. So I open up a text element, type some text in here, and close it up again. Oh, I see that I did an updated statement _____ _____ used to create component time. Let's change that to PluralTodo, it should match this over here. Let me show you the app here in the simulator. We reload it, and cool, it's rendering our label over here. We need to add some padding to get it to show in the correct place, but we just wanted to check whether it's working, and it is. That was fun. Let's do it again. We update our text again, and this time I use the simulator shortcut to simulate the device being shaped. Cmd+Ctrl+Z, and this brings up the developer menu where I just click on the Reload button. Cool, it loaded the updated text. You might've noticed that there were a bunch of options in the list, let's check it out again. In some scenarios, it can be very useful to auto-reload your application on a change. Let's check that out. I click to enable it, and then change the text again. Now when I save, it reloads the app, and it shows me the latest content in here. I'm disabling auto-reload for now because it's a bit difficult sometimes to record a cause with auto-reload, especially because it's got such an itchy save finger. So we've cleaned out our code base, and got it running and reloading when we wanted to. How did we get here? We cleaned up the generated project by removing all the files we don't want. We opened up main. js and cleaned it out, leaving just an empty render method. We also renamed the component class in main to PluralTodo. Correct naming helps when you need to look at stack traces, so that's kind of important.

Defining a Basic Project Structure
We're ready to start coding up some serious React Native code, and run it in Exponent. In the next few minutes, we're going to change the app to look like this, a very simple list of todos. We're also going to split out a component that lists these todos. Inside of the component, we'll be using React Native's ListView component. We'll be passing state from the main component on a property to the component, which will be calling TaskList. The TaskList will build a dataSource containing the todos, which will result in the ListView being rendered with a row for each todo. In React, we don't want a bunch of different components setting state all over the place. The community has started to draw a distinction between components that handles state permutation and components that are done, just views that render and covers input. Components that handles state permutation we call container components. Then we've got components that just present state and gathers input, which it bubbles up the container component. These are called presentation components. They receive their state through props. They also receive event handlers through props, which they call when they want to bubble up events, which could affect state. What sometimes gets challenging is when you have deeply-nested component hierarchies, and you have components that have to be aware and pass these props down all the way. For that we can use context to make it a bit more implicit. With context, you can make something available from a component that sits very high up in the hierarchy, to a component that sits very low down in the hierarchy implicitly, without the components in the middle being aware of this piece of data. For the rest of this module though, we're just going to pass it all the way down very explicitly through each component. Our app is quite simple, so we don't need to introduce context variables just yet. So what we want to do now is set up our PluralTodo component in main. js to maintain a list of todos in its state because it's going to be our one end only container component. We're also going to add our first presentation component called TaskList, which will eventually list all of our todos. Remember, it's a good idea to have as few as possible container components in your app, meaning components that make changes to state. This will keep your app easier to understand and maintain. That's why TaskList will be a presentation component, meaning it only gets state via its props. We'll pull in the TaskList component into the PluralTodo component, so that it gets rendered. We'll also style the TaskList component a bit, nothing serious, but enough so that you can get an idea of how to do styling in React Native. In the constructor, I just add an attribute onto the state object called Todos, and set that to an array. We're making each todo an object literal with an attribute called task containing the description of the todo. The first one we just call Learn React Native, and we need to fix all the linting warnings quickly. Okay, now that we've got some state, let's start defining our TaskList component. So I just create a new file called TaskList. js, and here we need to define our new component. The very first thing we do is require React Native by importing it into a variable called React. Next up, we pull in everything we'll be using from React Native using object destructuring. For now, I'll just pull in the text component because I just want to test that our new component is wired up before I start fleshing it out. So to start off with, I'll just be showing a label. Now we define the component using a class, and we call it TaskList. When using classes, we extend the component object from the React module. I'm just going to make this component the files default export before I forget to do it later on. Now that we have the basic structure in place, we can focus on providing a render function on this component. So I just add a render function on it, and in here just return a text element wrapped in parentheses. For the text body, I just type a simple message, something like this is a TaskList. Let's go and pull in this component now. To do that, I'm just going to open up the simulator next to Atom first. And in the main file, in the PluralTodo component, we need to import the TaskList component at the top. So import TaskList from, and then the relative location of the TaskList file. We don't need to add the js extension, it'll do that for us. Now that we've referenced the component, we go down to the render function, and replace this with a JSX node to pull in our TaskList component. Now when I reload in the simulator, you can see that our new component was pulled in, and it's rendered. You know what, let's go add some basic styling for the TaskList because I don't like that the message is still scrunched up here. To do that I declare a constant of styles, and assign that to the result of calling React. StylesSheet. create, which expects an object containing the style rules. Let's define a rule called container, and for this rule, we specify a top padding value of 40. Now let's wrap this text element over here with a view, and we specify that it uses the container style by adding a style attribute set to the container attribute from styles. I just need to close that off. Ah, the editor is warning us that we need to pull in the view component, so let's do that quickly. Linting makes our environment so much richer. When I reload that, you can see that it pushed down the message, so our style is working pretty well. So what have we done so far? We added some initial stay to our PluralTodo component, a list of todos. We'll bind to those soon. We've defined a new component called TaskList, and rendered some text in it, just so that we could make it easy to test whether it's wired up correctly. I like to get the structure in the hierarchy sorted out before fleshing out the details of a component. That way I can easily see it take shape when I save changes to the component, especially when I've enabled automatic reloading. We imported the new TaskList component into PluralTodo using a simple import statement and the relative path to the TaskList. js file. We rendered the TaskList, and then I introduced you to styling components with React Native, which you'll do quite often in this course and in real life.

Creating a List of Todos
Now we're going to flesh out the TaskList, and make it expect an array of todos on a prop called todos. We're not just going to trust that it gets set though, but add prop validation for the prop using React's prop types. You've got to do this in your projects. It ensures that component hierarchies are set up properly, and that components get their expected props, which they need to function correctly. We're also going to work with a ListView component now, and we're going to use it to show a text label for each todo that it finds in the list. To do this, we're going to have to create unpopulated datasource, which the ListView can bind to. There is quite a bit involved in this. By providing a render of function, which tells the ListView what to render for each row, as well as providing the datasource with a function that tells it how to differentiate items in the list from each other. So I just referenced the ListView component up here. We need to add a constructor now because we want to build up a datasource that we can bind the ListView component to. So we add the constructor with two parameters, props and context. Remember, I mentioned that you can pass data to components in two different ways, through props and context. Well when you add a custom constructor to your component, you need to ensure that you take these two as parameters to your constructor, props and context. And the very first thing you need to do in your constructor is pass these onto the super class, which is the React component class. This class will know what to do with the props and context, then you don't need to worry about it. Okay, we're going to build up our datasource, and make it available on the component state very soon, but I would like to show you where we'll be using it first. In the render function, we replace this text instance here with a ListView instance. And ListView needs a datasource for it work, and we assign this prop to a state variable, which we'll create soon, called dataSource. A ListView also needs to know how to render items from its dataSource, so we need to provide this ListView with a renderRow property, and assign that to a render or function, which we still need to define. When working with ES6 Grasp-based React components, you need to ensure that you bind the function to this using the bind function. Before we start dealing with the complexity of datasource creation, I want to show you something else that is really useful. I'm going to add a bogus property onto this ListView called key, and set its value to a todos property that I expect to be on this component. This is just a bogus property, but I want to show you what happens when the linter detects that you are using a prop. It's giving me a warning that todos is not specified in props validation. I was quite naughty with props validation until I started using the React linter, and now it actually enjoy it. Prop validations give us warnings in the developer console when a control is used with the incorrect props. In another version of React Native, which I'm going to show you in an upcoming module on this course, you can see that the warnings pop up from the bottom. Property validation is very useful, and I strongly recommend you to use it in your own project. It's also complaining about the sort order of these properties, it wants me to sort it alphabetically. Happy to oblige, dear Linter overlord. Although key is a bogus property here, and I just wanted to show you how linting helps us with props we rely on in the component. I do actually expect a todos prop on this object, so let me add some property validation. At the bottom I add a static value on TaskList. There is ES7 syntax to do this, but there has been some issues in configuring React Native with Babel, since Babel 6 was released. So I'm doing it by setting up property on the class, instead of using the static keyword. The properties name is propTypes, and it should be an object literal. We want to validate that the todos prop is set, and it contains the correct value, so we add a todos rule. Now I specified that I want it to be a React. propType of type array, but I do know what I want in the array, so I go and use arrayOf, which expects more information about what the array should contain. In here I specify that the array contains objects, and I set the isRequired on the todos rule. Let format this a bit better. Okay, that's good enough, at least for the props validation linter message to disappear. Now we're going to set up this dataSource, which the ListView component expects on its state. So we define a const called ds to a new ListView. DataSource, which we pass an object literal containing some setup config. I need to tell it how to differentiate between values that we populated with, which expects a function. In my function, I just do a reference check, and if it's an object with a different reference, I want it to be deemed a different object. Pretty simple, but you can obviously do way more advanced stuff here. Now we set up the dataSource onState by calling cloneWithRows on the DataSource, and passing in the todos value, which we expect to be available on this components props. That's how our datasource is populated with data, by calling cloneWithRows on it. Oh, the linter has warned me that I did not use a stricter quality checking on my reference checking. Very naughty of me. Now we need to provide this render function, which the ListView wants to call for each item in the datasource. So I just add a new function called renderRow, which takes an argument called todo. The ListView will pass the value from its datasource to the renderer function. In here we return a text element with the todo task attribute as its text. We close this off over here. Okay, this file looks good. Let's go to main, and pass the TaskList component the correct state that it needs on its props. The TaskList component needs a prop called todos, so we just set it, and pass it the value directly from state. Let's heed the linter warning here, and remove the text reference up here. We're not using it anymore. Okay, let's reload the simulator now. It's rendering our one todo in main where we have our state. Let's duplicate this todo, and change its task to Redux, and reload this again. It's adding a row for each item we have onState. What have we done so far? We ensure that the TaskList gets an array of objects on its todos prop by using React's propTypes validation. What was nice is that that the linters we configured advised us to do this as soon as we started using a prop, and it even guided us to do it in a more useful way by not accepting just the requirement for an array, but also telling us that we need to specify what the array should contain. We're going to go even further in subsequent modules, and specify prop validation for shapes, meaning we'll tell React exactly what attributes we expect on the objects passing a new prop. We set a datasource onState, and we ensure that we clone it from the prop, which we expected to be set, containing the todos. To clone it with data, we had to call the cloneWithRows function on it, which is how you always populate a ListView datasource with data. We also had to provide the data source with a rowHasChanged prop, which expects a function. This function is used by the datasource to differentiate items in the datasource from each other, helping React Native to update the least amount of the view in an attempt to minimize unnecessary rendering. We rendered the text element containing the task attribute of each todo, and we did this by specifying a function for the renderRow prop of the ListView. As you surely know, mobile apps have a lot of lists, so make sure that you understand everything in this last part if you're serious about using React Native.

Creating and Styling the Todo Rows
At the moment, we've got our row layout embedded directly inside of the renderRow function. It's good practice to break down your components a bit more granular than this. Keeping that in mind, we're going to add a new component called TaskRow into the mix. We'll expect a property called todo to be passed to this object, so we'll also define some prop validation for that prop. We'll then add some styling for our rows, so that they're bit easier on the eye. Let's create a file called TaskRow. js. In this file I start fleshing out a React component. I pull in React from React Native, so import React from React-native. Now we pull in the components that we want to use in the TaskRow component. Text for the label, and View for the container layout. We create a class called TaskRow, and then extend that from React. Component. This should be really familiar to you by this stage. We need to ensure that we export the TaskRow component as the default export before we forget. Now let's flesh out its render function. We return a text instance as the root component. And for the contents of this text instance, we use the task attribute of an object called todo, which we expect on the props of this component. Immediately you can see that our linter kicked in and warned us of prop usage that's not validated. So let's remedy that. We add an attribute called propTypes directly on the class definition, meaning it's the same for all instances of this class, and set that to an object literal. We specify that we want to validate a prop called todo. This prop we want to be a shape propType, which you pass another literal, where you can define the shape that you expect. So we're not just saying that we expect an object, we're also informing React of which attributes we expect on that object. We say that we want a property called task on the object that was passed on the todo prop, and we go further by saying that we want it to be a string value, and that it should be required, meaning we don't allow undefined or null. We end this off by saying that we want a todo prop itself also to be required. Let's honor the lint a warning down here now, and also remove this unused view reference at the top here. Let me use this component from the TaskList component now. To use it, we first need to ensure that we've imported it, so import TaskRow from its relative location, and down here in renderRow, we've written an instance of it. So we return a TaskRow, and we need to remember to set the todo prop on it. This todo is already being passed into the function over here via the renderRow prop on the ListView from down here. Now that we're not using the text element anymore, we can go and remove the text reference from up here. The linter is happy with that. We reload the app, and it looks exactly the same as it used to, which is a good thing because it means we successfully extracted the component, and go it rendered correctly. Let's just add something different in this control to make 100% sure that it's our new control in action. I'm just adding two periods over here, cool, it's definitively our new TaskRow component rendering in the simulator. Let's make it a bit easier on the eye now. To do this, we construct a new React Native style sheet, which we assign to a styles constant. In here we define a container rule again, being careful not to confuse this container rule with a concept of container components. This is just a convention most React Native developers use with their style sheets, where they define a rule for a container, and wrap all the contents in render with a view, which uses that rule. This just allows for style like padding, borders, and margins around your component. I'm just going to power through the style rules quickly, and then assign this style to a rapid view we'll introduce in render. We want to have a white background, and we want a border with of say, 1. For the borderColor, let's go with E7E7E7, which is a gray color. For padding, we want about 20. We also want it to be a flex component, that's very important. And it's flexDirection should be, you guessed it, row, because we want it to be laid out horizontally. We want its content to be justified with as much space between it as possible. This will make sense later when we add another control to this component. We want a bottom margin of 20 just for some space between the rows, and let's also do that for the left, and now for the right, just so that it doesn't go all the way up to the edges of the screen. Now in render, we add a View, and we add a style attribute. Now we set the style attribute to this container style, which we just defined. We close off that view, and make it wrap the text element over here. Oh, again our linter comes to the rescue. We need to reference the view component from React. Let me quickly add it here at the top, supple in view from React Native please. Okay, so we've defined some style and restructured the JSX to make use of this style. I think we can test this now. Reload that in the simulator. Great, it worked. Let's style that label too, it doesn't look great at the moment. To do this, I add another rule in the style over here called label. We're going to assign this to the text element in the JSX down here. I want a bit of a bigger size font, so let's change fontSize to right about 20, and fontWeight to 300. Let's save that. Oh no, we got an error, and it crashed the whole Exponent app. Exponent is obviously a work in progress, so I think we should understand that it can't handle every single error gracefully, and give us feedback on each one. Luckily, it's easy to go and find out what went wrong. Let's have a look in the simulator's console by pressing Cmd and forward slash. Now we scroll up until we see something that looks like an error. Ah-ha, it errored because it expected a string value for fontWeight, and I passed in a numeric value. Let's fix that quickly by wrapping the 300 in quotes here. And now I'm re-launching the exponent app, and selecting our app from here, and the error is gone. The style is still the same though because we still need to use the style on the text instance in render. Let me do that quickly. So a style attribute that points to the label rule. Let's reload that. Okay, that looks better, but it's still a bit difficult to see that these are rows. It needs a bit more contrast. At the moment, they've got the same background color as the background behind the rows. To add some contrast, we'll need to make some style changes in the TaskList control. Remember we also used the same pattern in the TaskList component as we just used in the TaskRow component. We created a wrapper view, and assign it a container style rule. That enables us to change the background color of this component. I like that contrast between the rows in the background, but I want the background to take up all this space, not only up here. To do that, I need to change this container to be a flexbox by setting flex equal to 1. If you're unclear on how flexbox works, go check out my earlier course on React Native right here on Pluralsight. In there I go through how flexbox works in quite a bit more depth. Now that we've made it a flexbox, we need to tell it how to lay out its children. We want it to start at the top, and lay it out from there. So I specify flex-start as the value. We'll basically get what we had before, but now when we reload, this container takes up the whole screen, giving us the background from top to bottom. It's looking good. How did we get here? We created a file and component called TaskRow, which simplifies our code a lot. We added prop validation for a todo prop to be set on it using the shape prototype to even specify what properties the object on our todo prop should have when set. In the TaskList component we used the TaskRow for each todo that needs to be rendered in the ListView, we bind to our state. We even defined some styling for the row, and made it look much better, for which we used flexbox. Get to know flexbox well, it makes styling with React Native a truly pleasant experience. Remember to go check out my earlier React Native course if you want to understand flexbox a bit better.

Creating the Add Button
Now we're going to build a button, which will stick to the bottom of the TaskList component. We'll wire up this button to communicate all the way up to the main container component, the PluralTodo component. As mentioned earlier in this course, we have container controls and presentation controls. Presentation controls should as much as possible not attempt to change the state of the application, or have direct access to it. They should get their data through props, and communicate up the hierarchy to the closest container control via event handlers, that it expects to be passed through on its own props. I'm telling you this because this is the first time that we're going to communicate from the presentational components to the container component. We're going to build this button using the TouchableHighlight component inside of our presentation component we've got at the moment, the TaskList component. We're also going to attach the Chrome debug tools for the first time, so that we can log a message out to the console. Obviously it's tremendously useful to be able to step through your code and inspect variables, so I think the ability to attach the Chrome debug tools is a big boom to React Native development. Let's start with just laying out the bottom on the TaskList component view. First we need to reference the TouchableHighlight component where we destructure the React Native import. We also need to reference text because we'll have a label on the button. In the render function, we create a TouchableHighlight node, and close that on. To add some text for our button, we add a text node inside of the TouchableHighlight node. For the labels text, we specify Add one. Let's reload the screen to see what we've got thus far. Not a very exciting button, but it's there. Now we need to style it a bit. In the style sheet rules object, I add two new rules, which we'll wire up soon enough. First the button rule, which we'll apply to TouchableHighlight, and then buttonText, which we'll wire up to the text node with in TouchableHighlight. Okay, now let's go and wire up the style rules. On TouchableHighlight we add a style prop and point it to the button rule we just created. So styles. button, and we do the same with the text node, but this time we wire up the style prop with a button text rule. Let's reload just to test that everything is still cool. Or even better, let's just enable live reload. And now we set the height to 60 on the button. Save that out, and you can see that the button height it updating. Next I give it a border color of this code, which is a bright blue color. Let's give it a nice solid border width of 2, and for the background color, a nice dark color, 333. And I don't like that there's no space around the button, it doesn't look touchable at all. Let's add a margin of 20, and we want the text to be aligned in the vertical center, so justifyContent of center. And the text to be aligned in the horizontal center. AlignItems set to center. For the button text, let's specify a font color of an offish-white color. Now reset our fontSize of 20 to make the font a bit bigger, and to bold the font, we set a fontWeight equal to 600. Now we want to notify the parent control through a callback specified on the TaskList components props when the button is pressed. A TouchableHighlight allows you to specify an onPress event handler. So we just pass on a prop called onAddStarted to it as the TaskList expects an event handler to be passed through on this prop. The linter correctly warns us that we haven't done prop validation on this property yet, so let's go do that. I'm adding a prop rule for the onAddStarted prop, and setting it as a func PropType, meaning we expect a function to be passed through on this prop. We also want it to be a required prop, meaning we won't allow null and undefined to be passed through. Now that we've validated our property, we can safely assume that this control will receive a function on this property, and that we can just wire it up to this components onPress handler directly. Let's jump back to the PluralTodo component quickly. Here we provide the TaskList component with a function on the OnAddStarted prop. You know what, let's create a function called OnAddStarted first. We're just creating a new function on this components class. Now we can wire this prop up to the newly created function so this. onAddstarted. bind this. When you use ES6 classes for React components, and you want to bind class methods onto event handlers, you have to use bind to ensure that this still translates to the component instance when this function is executed. To test that our event is wired up correctly, let's do a console. log on add started. Let's hope that the chrome debug tools log this out when we place the button. To launch the Chrome debug tools, we press Ctrl+Cmd+Z in the simulator to launch the developer menu, and on here we click the Debug in Chrome option. As you can see it launches the Chrome instance now. We can use the debug tools in here to debug code running inside of the app at the moment. If this seems at all strange to you, please consider watching my earlier React Native course on Pluralsight. So we've launched the Chrome debug tools by pressing Alt+Cmd+I in Chrome. So now we have the console open here. Let me just clear it out quickly so that we don't miss the message coming through. When I press this button, ah, the message is being logged to the console. How did we get here? We referenced the text and TouchableHighlight components from React Native in the TaskList component. We introduced some style for the TouchableHighlight and the text to style the charcoal button with a bright blue border. We bound the TouchableHighlights onPress prop to an event handler that we expected to be passed through on the TaskList props. When our linter picked up that we were using a new prop, it prompted us to do a prop validation, which we did by using propTypes and setting the onAddStarted propType to expect a function to be set. We then set this prop on the TaskList instance inside of the PluralTodo component to a function, logging out a message to the console when this function is called. Remember, when you want to debug code by logging to the console or inspecting code by setting breakpoints, just launch the debug menu inside of the simulator by pressing Ctrl+Cmd+Z and launching the Chrome debug tools.

Introducing the Navigator Component
In React Native, we use the navigator control when we want to add the switch between different views. The navigator control is a cross-platform control, meaning it works on both iOS and Android with the same code. We're going to configure the navigator component with routes, which controls which views are displayed with which props. We'll wire up our add button in the TaskList component to bring up a new view by calling the push function on the navigator. You'll also see how to use the configure scene prop on the navigator to configure how it transitions between different views. So let's pull in the navigator component from React Native, and because we're going to show some placeholder text again to test our navigator logic, I'm also referencing the text component again. We need to specify a function that takes a route identifier, and returns the corresponding view for that route. Let's create a function called renderScene, and this function has two arguments, a route and a nav. The first is the route being requested, and the second the navigator calling this function. Inside of this function, we're going to code up a good old switch statement, and switch on the routes name attribute. The route. name is just a string that identifies which route should be rendered. Okay, now a bit later we're going to use the navigator to add a form that enables you to add a new todo, so let's add a case for TaskForm. For now let's just return a text element for this route containing some placeholder text, Add form comes here. Later on, we'll add a new component in here, but I just want to show you how the navigator works first. That one's done for now. Let's add a default route, and for this one we want to render what we used to render in the render function over here. So let's copy all that over, and paste it into the switch statement here. Now that we've got our route set up, we can render the navigator, and provide it with this function, renderScene to resolve its routes. I'm adding a navigator instance, and now I'm going to tell it which route it should render first. You do this by using the navigator's initialRoute prop, which takes an object. In this object we specify the name of the route, and for completeness sake, we specify an index of 0. Now let's look up the function we defined onto a prop called renderScene. So I'm just setting up renderScene to point to our renderScene function, ensuring that we've got it bound to this. Oh, our linter picked up an issue with a JSX for the TaskForm. Let's see, I think I need to wrap it in some parentheses like I did with the TaskList. Ah, linter seems happy now. From time to time, we want to refer back to objects that we create declaratively in JSX, so that we can interact with them programmatically. I want to tell the nav to push the TaskForm route onto the navigator when the add button is pressed, so I need a reference to it. To do this, we use JSX refs. A ref prop takes a function, which expects an instance of the object created by JSX. This function should store a reference to this instance somewhere so that you can use it later. I'm just going to plunk in an arrow function in here. In this arrow function, we take the navigator instance that React created, and store it on the component, so that we can refer to it on our onAddStarted function. Because it's an arrow function, we don't need to bind it, it's already done for us. I'm just going to wrap it in parentheses and make the linter happy by adding a space before this arrow. Okay, so when React passed the JSX and created this component, it's going to call back on this ref function, and we're going to store it so that we can interact with it programmatically. Now in onAddStarted, we can call the push function on the nav that we stored. This expects a new route to be passed. For this route we want the TaskForm to be rendered. See, this name that we're passing to push should correspond to this value in the switch statement over here. Let's see if that worked. When I press this button, cool, our view gets replaced by JSX we had for the route. Just for kicks, I'm just going to push down this text element by adding some padding. And you know what, I'm going to do it with inline style. I know it's very naughty of me, but we're going to throw this JSX away very soon. So paddingTop, set to 20, save that out, press the button. Okay, we can see the label better now. I also don't like that the view comes in from the right when you press the button. Because the button is at the bottom of the view, I think it makes more sense that it pops up from the bottom. Luckily this is quite easy to do. Let's add a configureScene prop on the navigator instance. This prop expects a function, and this function should return a configuration for how the scene should work when creating a function, which I just specified on the prop. From here I just return a config that comes with a navigator component. SceneConfigs. FloatFromBottom, let's give that a try. Cool, it came up from the bottom. So how did we get here? We introduced a navigator component to add the capability to flow between different views in our app. The navigator component is cross platform, so try to use this component opposed to platform-specific navigation components like the navigator iOS component. We created a renderScene function and specified it on the renderScene prop of the navigator. In here we did a switch on the route name, retaining a text element when the route name is TaskForm, and the TaskList component as default. So remember, the function that you bind to the renderScene prop of the navigator is where you define the routes and the flow of your app. We also had a look at refs, which we use when we want to reference to an object that gets created through JSX. In this case, we use it for the navigator, so that we can use it programmatically. We then pushed a new route onto the navigator inside of the code that executed when the button was pressed, causing the view to be replaced with our text message. We also overrode how the navigator transitions from one view to the next, opting for it to slide out from the bottom, instead of from the right. This is done using the configureScene prop on the navigator component.

Creating a Form Component
Now we're quickly going to create and style the TaskForm component, which we'll slot in with the navigator when the user presses the add button. You'll learn a way to do this that shortens the feedback cycle between making a code change, and seeing the results on the screen. The TaskForm will have a text input, a cancel button, and an add button. This means we're going to work with the TextInput component in addition to the TouchableHighlight, and the text components we used earlier to create a button. This time you'll be introduced to no concepts on the fly, so we're going to go a bit faster. The benefit of this is you'll see how to approach React Native boilerplate when laying out a new component in the real world. Let's create a file for our new component called TaskForm. js. In here, the first thing that we need to do is reference React Native. So import React from react-native. Now we reference all the components we'll be needing from React Native. We'll be using Text for our labels, TextInput for the todo's task description, and we'll use View for layout, and the TouchableHighlight component for our buttons. We're obviously destructuring these components from the React module we imported earlier. Now I'm going to code up the boilerplate for the TaskForm component. I'm defining a class called TaskForm, and extending that from React. Component. Now I'm defining a constructor because I'm going to set up some default state later on. When we define a constructor, we always need to remember to take props on context. I tend to forget to export my components, maybe you do too, so I'm going to do it now, export default TaskForm. Back in the constructor I'm calling super with the props and context. When you provide a custom constructor to your React components, you always need to ensure to call super with these arguments. Now we're going to set up some default state. State is just an object, so I'm setting it to an object with a task as an empty string. Now I'm going to flesh out the render function. This time I'm going to add all the components that I want to use to compose the view, and then proceed to starting them all in one go. We want a rapid view, which is always a good idea when you want to control stuff like padding and background, we've used it before. The first thing to add in here is a text input. We're closing off the components in this manner because we're going to add some props to it soon. Now let's create the Add button by adding a TouchableHighlight component. You might remember that we also used TouchableHighlight earlier on when we created the button on the TaskList. In this TouchableHighlight we want a text label to display, so we're going to add a Text instance, and set the label to Add. Now we can close off this TouchableHighlight. Just ignore all the linting errors for now. It's going to go away as soon as we plug in the rest of the code. We duplicate this line in order to use it for the cancel button, and just change the text to Cancel. Okay, those are our components, let's style them. Let's create a new StyleSheet here, as we've done a few times before. This time around, we're just going to add placeholder styles, which we'll wire up to the great components soon enough. We'll then bold the styles out while we've got a simulator auto-reloading for quick feedback. The first one is a container, which we'll use in our ____ view. Then we've got input, which I'll wire up to the text input component. Next we've got buttonText, which we'll wire up to the text labels inside of the TouchableHighlights we'll be using for our buttons. Button, which will wire up to both TouchableHighlights to style buttons. And lastly, cancelButton, which will merge with the default button style on the cancelButtons TouchableHighlight. Let's wire up the JSX elements to these styles now. The rapid view gets a style assigned to the container rule, so we add a style attribute, and bind that to styles. container. The TextInput we want to style with a row called input. Both of the TouchableHighlights will use the button style, so I'm adding it to the first one, both of the text elements will use a buttonText style. The cancelButton TouchableHighlight will use a combination of the button style and the cancelButton style. When you want to merge rules like this, you specify an array, and add the rules you want to combine to this array. When there are conflicting rules in the style definitions, the merging will always override from the right-hand side, meaning if I had a font color in both these rules, blue in the rule on the left, and red on the rule on the right, the font color will be red in the end. And we shouldn't forget to style the label for the cancel button by giving this text element the buttonText style. So we've laid it out, we've added placeholder styles to all the elements, but we still don't have this view visible, so we won't be able to see what we're doing. Let's wire this view in so that we can see what we're doing while we flesh out the style rules. We're going to show this TaskForm in the navigator, and the rules for the navigator is here in the PluralTodo component. We need to import this component that we just created, so I just duplicate this here, and adapt it to import the TaskForm component instead. And down here where I displaced all the text component, I'll get rid of that, and add a TaskForm instance instead. Let me save that out, and it auto-reloads, so I need to press the button again. It doesn't look like much here does it? That's going to change pretty quickly. What's very important to get right now is to allow us to make changes, and see their fit as quickly as possible on the screen. As you can see when I save, it jumps back to the TaskList again because our whole app reloads, and the TaskList has been configured as the default view in our navigator. So let's go to where we set it as the default view, and just swap it around. So change this to taskform instead. Now when I save it again, it shows us the taskform, meaning we can style it with quick freedback now. So let's style it. We want the container to be a flexbox so that we can easily control the layout of the children. We want the children to be laid out from the top, so we're using the flex-start value here. Flexbox lays out vertically by default. This value just says start at the top, and layout from there, instead of from the center or the bottom. We added generous amounts of padding to the top, and set it's backgroundColor to this code, which is an off-white color, which we've also used in an earlier component. Let's move on to the input rule now. I think the input should have a nice thin border, and the borderColor should be a light gray. The text box should be about 50 high. Let's remove it from the edges to make it stand out a bit more by adding margin on the left, and also the same on the right, also like having some padding and input elements. Let's give it a rounded corner look just for kicks. That looks pretty good. For the button we specify a height of around 45. Just to be safe, I'm adding an alignSelf value of stretch because I want to ensure that it takes up the whole width. Maybe this one isn't necessary, I'll keep it here for now. For the backgroundColor, let's go with a blue color, which I've made a note of. Okay, I'd also like some space between these buttons here. So I'm going to set a marginTop, marginLeft, and let's also add a marginRight. Hmm, that looks better, okay, and I'd like this text centered here. For that I need to use alignItems, and set it to center, and don't you think we should have the same for the vertical axis? For this we use justifyContent. Now for the labels, we want to specify a bigger fontSize, maybe about 18 should be enough. But we also want to make it a big bolder, so fontWeight we set to 600. This time we remember it's a string value. For the color we specify the same off-white color that we used before. We've also go the Cancel button, don't we? The Cancel button rule we merged on the bottom rule for the Cancel button down here. What we want to do in here is override the backgroundColor to a dark gray to color to differentiate this button from the other one. That looks pretty good. How did we get here? We defined a new component called TaskForm and wired that into the navigator. We also made it the default route for the navigator, so that we get quicker feedback while working on our style rules. It's worthwhile to always try this when you're laying out a new component. We laid out all of our component structure and assigned style rules to all our components. Once we did that, we could quickly make style changes, and immediately see the effect on the screen. This is a super powerful way of building Native applications because we don't need to wait for a long compilation step every time we want to make a little styling change.

Adding a New Todo
So far we haven't defined any behavior for this component yet, we just laid it out, and styled the various components within it. In the next few minutes though, we're going to wire up the TaskForm component so that it also adds a todo to the list. We've already handled our component should use call back _____ through on props to communicate up the component hierarchy to the closest container component, which knows other change should affect state. We're going to use the same pattern here. First we're going to wire up the Cancel button so that the main component can pop the TaskForm from the navigator. Then we're going to wire up the Add button, which will pass the description for the todo to the PluralTodo component, which is our container component, so that it can be added to the list of todos instead. Because we'll add the todo and call setState inside of the PluralTodo component, the app will be re-rendered, and the new todo should be shown in the TaskList component. In both the add and cancel callbacks, the PluralTodo component will need to pop the TaskForm from the navigator, so that we see the list again. This time around, we're going to do prop validation first for the callbacks that we want to receive on the TaskForms props. Previously we just started using props, and then added the prop validation when the linter told us to do so. This time around, I thought it might be nice to add it before we define the functions. To set up the prop validation, I set up propTypes object on the component. First we add a rule that we want onCancel to be a func, and that we want this prop to be required. We do the same for onAdd, also a function, also required. We need a semicolon over here, thanks linter. So now when we open up the dev tools, you can see that we've got two warnings here in the console. It tells us that we've got unset props on the TaskForm. Do you see now why prop validation is so useful? You'll know quickly when your component isn't be used correctly in the app. Okay, let's satisfy one of these props, onCancel. In the PluralTodo component where we use the TaskForm component, I add a new function onCancel. For now I'll just log a message out to the console, cancelled. Now on TaskForm, I set the onCanceled prop, and bind it to the new onCancel function. Let's also fix this issue that the linter's picked up. We don't have placeholder text anymore, so this isn't being used anywhere. Let's remove it. In TaskForm I need to handle the press of the cancel TouchableHighlight. So I'm adding a simple onPress prop here and just binding it directly to the delegate that we expect to be passed through on props. We can do this because we don't want to do anything when this button is pressed before calling this callback, so we don't need another event handler in the TaskForm component itself. Let's test that out. Great, it logged the message to the console. We don't need the TaskForm as the default view anymore. So I want to change the code so that the TaskList executes as the default route again. In the PluralTodo component in main. js, I just change this TaskForm over here to TaskList, causing the initial route to be TaskList again, as we want it to be when I save that out, and the TaskList displays by default again. Remember, when we press this Add button, the TaskForm is displayed, and what we want to happen now is when we press this Cancel button, the TaskForm gets hidden, and the TaskList displays again. To do that, we need to go into onCancel over here, and tell the navigator component to pop the current view from the stack. Because we used a ref earlier down here to keep track of the navigator, we can expect a nav variable to be on this component, so this. nav. pop. Pop is what tells to navigate it to hide the current view that is displayed, and revert back to the previous view that was displayed before that. Now when I press Add, and then press Cancel, the TaskForm transitions away, and the TaskList is displayed again. Pretty nifty. Now let's wire up the Add button so that it stores a new todo when you press Add. Just a reminder, I added prop validation for the onAdd function on the TaskForm component earlier, as you can see by the warning in the console when I open the TaskForm by pressing Add. Let's satisfy this warning first by setting a function on the TaskForm from the PluralTodo form. I need to create a function to wire up first though, and it needs to have one parameter, the task. For now, I'll just log it out to the console. Let's log something like a task was added, and then append the task onto the message. And as we did with the onCancel event, we want to pop the TaskForm of the route route stack, and display the list again. Let's specify the prop on the TaskForm now, binding our newly minted function to it. In the TaskForm, this time we don't just wire up the onAdd function we got via the onAdd prop directly to the Add button's onPress event, we need to first gather input from the TextInput, and then when the button is pressed, take the gathered value, and send it along to the callback. I'm creating a new function in the TaskForm component, which gets the updated value every time the textInput's value changes. When it changes, I'm just storing it on an instance variable. I originally intended to store it onState, but that's not required. Let's remove the state setup code from the constructor. Now on the TextInput component in render, I'm adding an onChangedText prop, which I'm binding to our new onChange function, which will store the value on the component instance. Now that we're retaining the value from the TextInput component, let's wire up the button press event, and send the value on to the onAdd callback that was set on the TaskForm by the props from the PluralTodo component. I'm going to do this in yet another function, which I'm going to call onAddPressed. In this function, we need to call the onAdd function on props, taking care to pass in the task, which we gathered as a result of the onChange function, keeping track of this TextInput. Now that we've got a function to bind to, let's bind the Add button's onPress prop to the onAddPressed function. Let's check that in the console. Let me just clear out this first. So I type Use react native, and press the Add button. See, it's displaying our message in the console. Now let's actually do something with the task that's been bubbled up through callbacks, all the way up to the PluralTodo component in main. js, which is our container component. Because it's a container component, it's allowed to update a state, causing the components depending on the state to re-render. Just after logging to the console, I'm going to try and handle the change in state based on the task being added by the TaskForm component. I'm going to push a new todo with a task description to the todos onState, and then call set state to cause this component and its dependents to re-render. Let's scroll up to look at the structure of todos instead. As you can see, each todo has a task attribute. This keeps us open to perhaps storing a status for each todo later on. So let's use that structure for the new todo. I'm pushing an object literal with a task attribute set the task augment. Remember, this task is passed from the TaskForm component and is a string that was harvested of the TextInput in the TaskForm component. Okay, now that it's pushed to the array, we need to call setState so that our components know it's been updated. Have a look at this linter warning, it doesn't really like us setting state. Weird, eh? In most React examples, you'll see a set state or two, but this warning does have merit. We definitely don't want to call setState unnecessarily because it might cause a lot of performance issues if your components have to re-render without cause. The whole React community is also embracing Flux frameworks and libraries like Redux, which should result in you using setState way less. Later in this course, we're going to refractor our app to use Redux to get rid of this issue. Because the attribute name is the same as the variable name, we can also use this ES6 object literals shorthand, and now it can go in the same line. That's much easier on the eye. It's not going to work at the moment, but it's very tempting to test it out now right, and expect it to work, isn't it? We're updating state, and all the other objects should just get values through the props in re-render. So if we add a new item now, it should be visible in the list, no? Not quite, let me show you. See, when I add a new item, nothing happens, why is that? Is it because the state isn't updated correctly, or the new todo goes missing somewhere along the line? Well no, let me show you. I'm setting a breakpoint at the line where we push the new todo into the array. Let's add a new one. When I press the button, our breakpoint hits. Have a look. When I inspect this variable, we can see we've got the new item at the end of the array. And we don't get an error when call setState, so what's going on here? The issue is with how the ListView component works, which we are using inside of the TaskList component. See, the ListView is just a component like any other component, but what makes it a bit tricky to work with is that you have to build a dataSource for it programmatically, and bind the ListView to that dataSource. That means if the programmatic calculation of the dataSource doesn't kick off when the data changes, then the ListView's dataSource property will become stale, and it won't bind to the new data. Initially we calculate that the dataSource, which the ListView binds to here in the constructor. We need to somehow hook into when the todos prop is updated so that we can recalculate the dataSource, and cause the ListView to re-render with the new data. Luckily this is quite easy. React will look for a function called componentWillReceiveProps on your component, and call it when it's updating your components props. That gives us a nice hook point where we can recalculate the dataSource with the latest data. So I'm adding this function, componentWillReceiveProps. The props it's going to set is the first argument to this function. Let's call it mixedProps. Let's do what we did up here using the dataSource onState to clone a new one. And because our linter will be unhappy if we don't, we'll use a constant to assign it to. So this. state. dataSource gives us the existing dataSource onState, and now we can call cloneWithRows, passing in the todos of the new props. Now we can call setState on our component for the updated dataSource using the ES6 literal syntax again because the field has the same name as the variable we've chosen. Again we get a setState warning, but this is a valid use of setState, so let's ignore that. Let's test! I'm adding a new item, Use react native. Okay, moment of truth, it hits our breakpoint, let's just resume that, nice, our new todo was rendered here in the list. So how did we get here? We set up prop validation rules for both our onAdd and onCancel callbacks that we expected on the props on the TaskForm component. It's nice doing this upfront because it makes you think about the interaction between different components before you start implementing the details. It's also nice because then you can just keep on providing props needed until the validation warnings just go away. In the PluralTodo component, we wired up the TaskForm's onCancel prop on the TaskForm component instance, and in the function we wired up, we used the. pop function on the navigator we stored with ref. The pop function closes the current open route on the navigator stack, reverting back to the previous route, which in our case is the TaskList. We created a function in TaskForm, which we wired up to the TextInput's onChange prop, so that we can store a local instance variable containing the text value of the TextInput every time the value changes. We proceeded to wiring up the onPress function in the TaskForm, calling the onAdd function it got through its props from the PluralTodo component, taking care to send along the value we stored from the TextInput component. In the PluralTodo component, we stored a new todo in the component's state, and then we noticed that the TaskList component didn't update. To remedy that, we created a componentWillReceiveProps function in the TaskList component so that we could hook into new props being set on the TaskList, and recreate the DataSource that its ListView is bound to. This made the new items reflect in the TaskList, which was the whole point of the exercise, wasn't it?

Deleting a Todo
Now we're going to add a button to each todo record, allowing us to mark it as done. We're going to bubble up the undone event from the TaskRow, a presentation component through the TaskList, another presentation component, all the way up to the PluralTodo component, which is our container component that's allowed to change app state. In the PluralTodo component, we'll remove the affected todo from the array onState, and call setState to re-render the TaskList without the removed item. Let's push through, we're almost done with this module. In the TaskRow component's render function, we add a TouchableHighlight. Remember that's how we do buttons in React Native. Inside of this TouchableHighlight, we create a new text element. And inside of this text element, we add the text we want on the button. Let's save that out, and see what it looks like in the simulator. Cool, it looks like it's displaying. It doesn't look like a button yet though, let's fix that. We're going to add some style here on the TouchableHighlight to make it look like a button. You know what, let's go and define this style rule first, then come back here to wire it up. Here in the style definition, I'm creating a new rule called doneButton. Let's start fleshing out this rule. Rounded corners look quite cool on buttons, I'll say about 5. Okay, bad idea to wire it up after starting to define it because we'd like to see the affect of our style changes as soon as we save it. Let's wire it up here on the TouchableHighlight quickly. We add a style attribute, and set that to the new rule that we just created, doneButton. Okay, now we can go back to the rule, and start fleshing out the style while seeing the affect as soon as possible in the simulator. In the rule, we specify a background color of a code that looks suspiciously like a donkey's brain translated to X notation, but it's in fact a light gray color. The most important value for a button other than background, yes, padding. Let's give it 5. Now let's wire up some logic to this button, so that we can bubble up the event all the way to our PluralTodo component, where it can remove this item from the state. So down here in the PropTypes declaration, we add another field called onDone. We'll expect a function to be passed through on this prop, so we specify that it should be a func, and that it should be required. The TaskRows is rendered from within the TaskList component, and it'll communicate through the TaskList, so we need to add the same prop validation inside of the TaskList component. We'll use the same prop name, onDone, and add the same validation rules, function that's required. Inside of the PluralTodo component now, we add a new function called onDone. In here for now, we log out to the console that a task was completed. Now we can bind this function down here on the TaskList. So onDone=this. onDone. bind to this. Have a look in the console here. We used to get two warning about onDone props. Here's the warning from the TaskList component, but because we set it on the TaskList now, there's only one warning left, which is for the TaskRow. So we need to go to the TaskList, and in here pass along the prop value to the TaskRow, which we do here in the renderRow function. Remember, the renderRow function will be called for each todo in our list. So the function we received once on the TaskList component will be passed on to each of the TaskRow instances. Now that we've done that, and we've saved it out, let's open up the console, and have a look in here. Yep, all the warnings are gone now. Even when I reload, yep, still gone. Let's jump into the TaskRow, and use the onDone prop that is being set on it. On the button's TouchableHighlight, we add a prop onPress, and bind that to the onDone prop we can expect to be set. Let's check it out in the simulator. When I press this Done button, cool, it logged out our message with the event, which was passed through. Wait, what? Don't they want the actual todo here? Oh, you know what, it's because I just wired up the onPress with the onDone prop, so we're never sending along the todo to the onDone function in the PluralTodo component, which is logging out this message. This means I'll need to create a function here in the TaskRow component, which still has access to the todo, which was clicked on, so that we can send the todo along up the chain. So let's call it onDonePressed, and close that off. And yeah, we call the onDone function, which this component received via its props, and we pass in the todo, which we also got via this component's props, the same one we're using to bind the row to inside of render. Then we quickly switch out the function here with onDonePressed. So we're just adding a function inside of this component where we still know exactly which todo we're working with, so that we can bubble that up through the props to the container component. Let's open it up in the simulator again so that we can have a look in the console. Press Done, aha, this time it's logging out the todo now. Oh, on that point, let's rename the variables to todo here in the PluralTodo component. I actually regret naming the description of the todo. task, as well as to todo-related components. I realize now that it's not consistent, but it's unfortunately a bit late to fix that now. Okay, so now we need to update our state so that the todo gets removed from the TaskList when the user presses the Done button. Here in the PluralTodo's onDone handler, we've got the todo being passed through, so we can use this reference to filter the todo out of the array, and update the state so that the TaskList component re-renders without the todo in it. I'm just assigning a new const here called filteredTodos, which I'm going to say to the existing todo array, but with a one todo passed into this function filtered out of that array. I'm calling the Native ES5 filter function on the todos array onState. We need to pass a callback in here. An arrow function will do quite nicely for this purpose. Okay, now in here I want to say that only items that are not equal to the todo passed into the onDone function should stay in their array, and now we need to remember to call setState to update the todos on state to equal this filtered array we just calculated. Oops, the linter is angry at us again. The setState is fine, this is a totally legitimate setState call because we're in a container component, which is allowed to call setState. Ah, very naughty of me, I need to make this a strict check over here. Okey dokey, let's test. When I press Done, the item gets removed from the list. Let's do it again, gone. So how did we get here? We created a button in the TaskRow component, which we styled. We created prop validation for a prop called onAdd, expecting a function in both the TaskRow and TaskList components. We had to add it to both because the TaskRow contains the button we created, but the TaskRow is rendered from the TaskList component, so it needs to go from the main component which is interested in the event, through the TaskList component, which passes it on to the TaskRow component. We could also have used the context for this, but I opted to show you how painful and repetitive it can get when we use explicit props all the time. We then wired up onPress on the TouchableHighlight for our Done button in the TaskRow component, and yeah, we still have access to the todo that was passed to the TaskRow through its props, so we could pass it up all the way to the PluralTodo component, our container component, which is allowed to change state. In the PluralTodo component, we filtered out the todo from the list of todos onState, and reset it onState, causing the TaskList to re-render without the removed todo.

Summary
We've gone quite far building our todo app using Exponent, without ever even touching Xcode or Android Studio. The Exponent approach is immensely useful if you want to get started with React Native very quickly without getting marred in the details of setting up development environments for the platform you want to target. During this module, we've repeatedly used prop validation to ensure that our components get all the props that they need to function correctly. Prop validation is especially useful in combination with a good linter setup because it will remind you to create your prop validators, and even guide you towards doing better validation rules. Although we've used quite a lot of components in this module, I think the navigator warrants a special mention. We used a navigator component wherever we want to replace a view in an app with another one. You'll have to do this in most apps, so get to know this component really well. Another thing that I mentioned a few times, try and contain state changes to only container components. State permutation is where bugs breed, so we want to limit it to a few select components that are clever enough to do so. Container components also implies that there are components that are not clever enough to make changes to state. These we call presentation components. These components should only work with callbacks and data that they get through their props, which also makes them much easier to test. In the next module, we're going to start using platform-specific components, and code up platform-specific code, so that your app can look and behave differently on iOS and Android. You don't want your Android app to look like an iOS app, or your iOS app to look like an Android app. To do this, we'll have to set up our full-blown development environments. Another thing we'll do in the next module, is use the very popular Redux library to manage our state for us, and we're not just doing this because I'm freaked out by those linter errors that tell me I shouldn't call setState, we're doing it because most React apps these days use some sort of library to help them manage state.

Platform Targeting
What Is Platform Targeting?
Platform Targeting. Well if you haven't been living in a cave for the last years, and you've seen both iOS and Android phones, you'll know that the same app often looks and behaves quite differently between the two platforms. That's because Android users expect a certain experience and certain components, while iOS users expect a different experience and different components. Most apps following this strategy have a lot of cross over between the different platforms, but they do differentiate. There's been a whole bunch of mobile frameworks that promise write once, run anywhere. This basically means that you use the same code, and you transpile it, or compile it, or run it inside of a web view on the different mobile platforms, and give exactly the same experience on all the platforms that you target. This has got a downside though called the uncanny valley effect. Basically it means that if you're on iOS, the app doesn't quite look like an iOS app, and if you're on Android, the app doesn't quite look like an Android app. Now a whole bunch of obstructions have been dreamed up to still try and achieve this dream of write once, run anywhere, where you reuse components, and it attempts to give you the most optimized look for the specific platform. But people have since realized that this is a bit of a pipedream, especially the React Native team. The React Native team has a totally different objective, learn once, write anywhere. This means that you get to know your framework well, the way it works, the components that it contains, but then start differentiating for each platform to give that really Native feel for each platform. But you might be wondering, how is this better than writing an iOS app in Objective-C and an Android app in Java? Well what React Native gives you, other than learning concepts, which you can apply for Android and iOS, is a lot of cross-platform components and a lot of reusable code. You would usually develop your app with cross-platform components, get it functional, and then start differentiating for Android and iOS, giving that specific feel for each platform. It's the best of both worlds. It's not trying to be this generic thing that gives you the uncanny valley effect, apps that don't quite look right on each platform. It does look right, and you get a lot of code reuse. This is what I'm going to show you in this module, how to get this right, how to differentiate for different platforms, which I call platform targeting. So far, to get started very quickly, we've been using Exponent. This was so that we don't need to go and set up full-development environments. We're going to move away from this strategy now, and set up a full React Native project, and we're going to move our code from the Exponent project structure, into this full React Native project structure, so that we can go and do stuff like target specific platforms, and test it in the iOS simulator and in the Android emulator, so we're going to set up a full Android development environment as well.

Full-blown Environment Configuration
I sincerely wish that there was a way that I can take you step-by-step through setting up your environment for iOS and Android development, showing each gotcha and guiding you through the process. Unfortunately each computer is different, it's got different stuff installed, it's got different OS versions. There's no fool-proof way of guiding you through this, and making sure that you don't run into issues. Fortunately, React Native's documentation site has got quite nice documentation guiding you through the process. It's open source, so people have contributed to it, people who have ran into weird issues, have gone onto it, made pull requests, and it's now part of the documentation. I can't promise you that everything that you'll run into will be solved by the site, but this is the place to go to if you do run into an issue that we don't cover in this module. To get to this site, go to facebook. github. io/react-native. When I click on this link here, you can see it's got its Getting Started documentation here. Other than just getting your environment set up, come back here often to come and have a look at components, guides, and the rest of the APIs documentation. You've already got an OJS installed, we've been using it quite a lot, and we've been using NPM to install a bunch of packages before. To get your iOS setup up and running is extremely simple. Unfortunately you need a Mac though. If you've got Windows, you can't do an iOS development. You can do Android development though, and this guide takes you through that. Let's start with an iOS setup. Very, very simple, as I promised, all you need to do is install Xcode, the latest version from the App Store. I've you've already got it installed, just go and make sure that you've got the latest version. The minimum required Xcode version for React Native is 7. My system previously had Xcode version 7. something on, I can't remember the exact version, but the interesting thing was I ran into all sorts of problems with React Native. In the end, it turned out all I had to do was go and upgrade my Xcode version to the latest version in the App Store. So please, go and check in the App Store whether you've got the latest version installed. You might save yourself a lot of time. So it's like I said, the iOS set up for React Native is a breeze. It basically just depends on you installing the correct version of Xcode. Now let's move on to the more challenging part, setting up for Android. It starts by telling you to install Git. Now if you've installed Xcode previously, or you just followed along, and installed Xcode just now, you should have Git already on your system. Next it tells you to install the Android SDK. Now the Android SDK also depends on the latest Java Developer Kit, so you need to go and install that. To install the Java Development Kit, click on this link, go and find your operating system, go look for OSX here, here it is, download that DMG file, open it up, and go and install it from the installer in there. It's pretty straightforward, I promise you. After you've installed the Java developer Kit, you can proceed to installing the Android SDK. Now it says here that if you're on a Mac, you can use Homebrew to install it. If you've got Homebrew already installed, go and type this command in terminal and run it. Otherwise you can also click on this link, which is what I've done. We don't need to install Android Studio, we actually just want the standalone SDK tools. When we click on that, you can see it already picked up that we're on OSX, and it gives us the instructions to go and install the SDK tools on OSX. So we just download this file, wait for it to complete, and then unzip it somewhere on the file system. Just remember where you unzip it to. Back on the React Native guide, now that we've got it downloaded, we need to go and make sure that we add the ANDROID_HOME environment variable into our environment. So if you're on a Mac like I am, you have to edit either your. bashrc file or your. bash_profile file, and go and add this line in there. Now you can either start the terminal after you've done that like they advise you to, or you can just run source, and then the path to the. file that you use to run your environment settings. If neither of these files exist yet, run touch, then with the path, and then go and open up the file in Atom or something similar, and then go and add the slide, and afterwards restart your terminal. You can safely skip over this part of configuring the gradle daemon, and still have a fully-functional Android setup. I did this when I first checked it out, but later on I clicked on this link and followed the instruction to install the Daemon, and it did speed up the build process quite a bit. Now in a terminal instance, go and run the Android command. Because we've added that Android SDK to our environment using. files, this Android command should be working by now. When this command runs, it brings up this GUI tool, that allows us to select packages that we want to install. Follow the instructions in this image on the Android setup guide to go and install all the required packages. Make sure to go through this guide because something might have changed by the time that you do this course. So when I first checked out developing Android apps with React Native, I went with this route, install the stock Google emulator. I thought it sounded more advanced and more professional to install this stock standard stuff. Turns out I should have gone Genymotion as the site recommends you to. It's much, much easier to get it started, and it's also much faster. So I would really recommend that you go and install Genymotion. And yes you need to sign up and confirm your email, but I must say I haven't received any spam from them, and I've been using it for a few months now. Once you've installed it, provided that you've also got VirtualBox installed, you'll be met with this interface, where you can go and add a new virtual machine, and specify which Android version, and what device to emulate. If I were you, I would just go with the latest version, and go and choose a device to your liking. I would go with a Google Nexus 5. Press Next here, and give it a label. You don't really need to do this part, and press Next. Now it will take a while to go and download this image before it will set it up. I'm just going to cancel this, I've already set up a device previously. Once your virtual device set up is completed, you can go and press start here, and once that finishes launching, you can see that you've got a virtual machine here running the Android operating system. This is where we're going to test the Android version of our app, and that folks is unfortunately as much help I can give you in setting up the environment. Like I said before, if you get stuck, go and wade through this documentation. Alternatively, go and hit me up on the discussion forums of this course, and I'll see if I can help you out. If I can't, maybe somebody else that did the course will be able to help you out. After we've done Xcode, the Android SDK, Genymotion, all that stuff, we've got to go and install the react-native-cli, and we can install this with a -g option to install it globally. Then we go and generate a new project, and start working on it. I'll take you through that now.

Migrating from Exponent into a Full-blown Project
So now that we've got our environment set up, we can start using it. We're going to generate a new React Native project without using Exponent. This will give us a run of a mill, full-blown React Native project structure, which we can build on. Just to show you what a fresh project looks like, we're going to start the project in both the iOS simulator and in the Android emulator we set up with Genymotion. Generating this project will result in a very empty structure. What we want to do is copy our existing structure that we worked so hard on in Exponent into this full-blown project structure, so that we can make use of the full-blown environment, and do some advanced stuff, but not lose all the progress we made while working with Exponent. Once we've copied the files from the Exponent project into our new structure, we're going to hook up the files so that this app runs our app that we build in Exponent. And the great thing is, you're going to see how it runs in iOS and in Android. I think you're going to be pleasantly surprised to see how easy it is to get this app running on iOS and on Android because we were using exclusively cross-platform components while we were working in Exponent. So we installed React Native earlier using NPM. This made the React Native command available in the terminal, and we can use this command to generate a new project. To do this we type react-native init, and give it a project name. The project name we used in Exponent was called PluralTodo, so I'm going to call this one FullPluralTodo. I just sometimes come up with the most creative names for stuff, don't you think? And now let's run that. This might take awhile to finish on your machine. Before it generates your project structure, it downloads a bunch of stuff. Just give it awhile, and it should finish in the end. Okay, so it finished installing, and it gives us some nice instructions on what to do next. To run the app in iOS, just run this command, react-native run-ios. You can also do it the manual way by opening finder and opening this file. We're obviously going to use the nice way, which is by running this command. The interesting thing to note here is that this app can also run on the Android emulator, and to do this, we run react-native run-android. Pretty simple, but first we need to cd into this folder. So cd FullPluralTodo. Let's start by running the app in the iOS simulator. React-native run-ios. This start launching the simulator, and it starts building the project. So you can see a bunch of Objective-C stuff being built here. This is all the stuff that we weren't exposed to while using Exponent. During this process, it also launches the packager. While we were using Exponent, Exponent was housing the packager. Using the full-blown way to run a React Native project, it will spawn a packager like this, which it runs in its own console. Here you can see that the React packager is now ready. It's now watching the files of our project, so when we make changes, it will repackage this, and make it available for the app to reload, so let's go back to the main terminal where we kicked off the command, and see how far it's progressed. It seems like it's still doing some advanced stuff here. So it's saying BUILD SUCCEEDED, and it's launching the app in the simulator. Let me just bring the simulator to the front here. Nice, our new app is running in the simulator. It's pretty boring, but this is a default React Native app. What's nice about this piece of text here is that it tells you what command to use to reload your app, and also how to bring up the developer menu. So let's make this app a bit less boring, and get our code, which we built in the Exponent project into this project. In terminal, I'm just going to copy the files from the location of our Exponent project, so copy, then the relative location to the folder containing the Exponent project, and I'm just saying I want all the JS files, and I want them to be copied right to this folder. Let me list that out for you. Here you can see that it copied over our TaskForm, TaskList, TaskRow, and the main. js files. We're opting to keep the same node modules, and the package. json, and all this stuff that was generated when we called React Native in it. Let's open up this code in Atom quickly and see what we've got. Here you can see that we've got an iOS and an Android folder. When I open up the iOS folder, you can see that it's got some Xcode projects in here, stuff like that. If you want to do some advanced stuff, you might end up opening this project with Xcode, but luckily we don't need to do that just yet. We just want this app to look like the one that we created while using Exponent. See these two files down here, index. ios. js and index. android. js. This notation here, ios. js and. android. js, tells React Native which file to use for while platform. So if it's running on iOS, it's going to use the index. ios. js file. If it's running on Android, it's going to use the index. android. js file. Let's get it running in the iOS simulator first. This means I need to go into index. ios. js. As you can see, at the moment it's got all the code that it required to show its default splash screen. What we want to do now is replace this with a structure that we had in our Exponent project. Now you might remember, the root of our exponent project was defined here in main. js, but now our root files are these index files, one for iOS and one for Android. So we don't need to call this main. js anymore, we can rename it to something a bit more descriptive. The main file just basically contains the PluralTodo component, so let's rename it to PluralTodo. Now that we've got a proper name for that, let's cut this index file, import the PluralTodo component, and get it rendered. So basically this whole component definition and all the style stuff we select, and get rid of it. Get rid of a bit of extra spacing. Now even all these imports, all we're going to require is AppRegistry, so let's get rid of the rest. I don't even like this boilerplate up here, let's get rid of it. Now that it's pretty clean, let's start importing the PluralTodo component from this file that we renamed. So import, PluralTodo from the relative location, to this PluralTodo file, and now we just style React Native to make this the root component for our app, by replacing this FullPluralTodo with this PluralTodo reference. There's a little gotcha with this PluralTodo file though, let me open it up and show you. When you scroll down to the bottom here, you can see that this used to be registered and the main component. What we want to do instead is export this class. We're setting up the root component for this app in the index files, so we shouldn't do it here. So let's replace this line with export default PluralTodo. Okay, let's go and check that out in the simulator. When I press Cmd+R, it reloads, great, our app is already ported to iOS, just with a few copy commands and some simple code that just wires it in. I guess this is the benefit of using components. Let's just make sure that everything still works. Let's press this Add button, and add a new item. Already working, great, the item's added to the list, and we can also mark the items as done. So we ported the app from the Exponent project structure into our full-blow project structure, and just wired it up, and it's already working in iOS. Let's go do the same for Android now. On terminal, instead of running react-native run-ios, we run, you guessed it react-native run-Android. And this also builds a bunch of stuff, and then in the end launches the app in the Android emulator. Now remember, when we set up our emulator using Genymotion, we get Genymotion running. You always need to ensure that this is running when you run this command, otherwise you'll just get an error. It looks very simulator to the default-generated app that we saw in iOS. Now let's go and do the same that we did with iOS, and get our app from Exponent running in here. We're actually going to run exactly the same code as we're running on iOS, so let's just go into the index. ios. js file, and get all this code on the clipboard, and go into the Android file, and replace all of this with what we copied from the iOS file. Now in the Android emulator, we press this button over here. What this button does is it launches the dev menu. Let's press reload, great, our app is already running on Android too. Let's make sure that everything works here in Android. Click on Add, and add a new item, adding one on Android. Click this Add button over here, great, the item's added to the list, and we can also mark them as done. So we've got our app ported from Exponent, and it's running on both iOS and Android already inside of a full-blown environment where we've got advanced capabilities like using custom Native models and embedded images. So how did we get here? We used the react-native package, which we installed earlier, and generated a new project, which we called FullPluralTodo. I then showed you how to run it in the iOS simulator by using react-native run-ios. This basically compiles the Xcode project, launches the packager, and gets your app running in the simulator for you. It's very similar to get the app running inside of an Android emulator, instead of running react-native run-ios, you just run react-native run-android. It's very simple. The one thing to take care of here is to make sure that you've got your Android emulator already running. We then had a look at how easy it is to copy from an exponent project into a full blown React Native project, and get your app running there. Luckily in our Exponent project, we were using cross-platform components all the way, which just made this step so much easier.

How to Split a Component to Render Differently in iOS and Android
When we moved our project over from the Exponent structure into the full-blown React Native project structure, I forgot to take over the linter files to enable linting in our project. We're going to fix that before we move on to some more advanced stuff. And the advanced stuff we're going to do is we're going to refactor the TaskRow component to get its render logic from platform-specific files. What does that mean? Well that means we'll be able to render a TaskRow differently on iOS then on Android. This is a pattern that you're going to use quite often when developing apps for Android and iOS, where you need to differentiate between the different platforms. Okay, so let's start by re-enabling linting in our project. Let's just open up the code for the project we were working on in Exponent. Let's open up the package. json file, and in here just select all the linting-related packages. Now we go back to our new project, and in this package. json file, paste these modules in here. Okay, now in terminal we just run npm i, which is shorthand for npm install, to ensure that it installs all the modules that we've got in package. json. What for that to install, okay, it's done. We also need to copy over that esLintrc file from the previous project structure into our new project. You might recall that this contains all the rules that we've configured our linter with. So let's start refactoring TaskRow so that we can differentiate how it looks between the Android and iOS platforms. Just to reacquaint us with TaskRow, let's have a look, it's pretty basic. It's got some style, it's got its render function with some very JSX, and then it's got its event handlers down here. What we want to do is move the render logic into separate files so that it can go through the platform-specific loading logic. The TaskRow component will be defined across multiple files, so that's why we're creating a new folder to contain all these files, and now we can just move the TaskRow. js file into this newly created folder. When following this pattern, I like to rename this file to componet. js. The reason why I like to rename it to component. js is because when I follow this pattern, I always know to look for the component. js file inside of the Components folder. Okay, so now that we've got our component file inside of the TaskRow folder, we're going to select everything that we've got here in render, and move it to a different file, so let's cut it from here. And now we create a file called render. ios. js inside of the TaskRow folder. This file will contain the rendering logic for the iOS platform, and we paste the render function, which we cut from the TaskRows component file. We basically want to export this function so that we can import it from the component file, but going through platform-specific loading logic. So we export this function as the default function of this file. Cool, so our linter's picked up a few things that we need to fix to get this working. It's mostly components from React that we need to import, but it's also this styles variable, which used to be defined inside of the TaskRow component, which is obviously not available to this file. Let's start with the components. First we need to import React Native onto the React variable, so import React from react-native. Now inside of this render function we're using view, text, and TouchableHighlight, so we assign these components to constants using the ES6 destructuring syntax. Now that we've got the correct components available on scope, the linter's happy with that. The only outstanding issue that I can see here is that the styles variable is not available here. Let's make this an argument to this render function so that we can pass it in here from the component. Okay, now that we've added that argument, the linter seems fine with all the dependencies here. Let's go back to the component so that we can pull in the logic defined inside of this function, and use that as the render logic for the component. So we're going to import this render logic using the standard import statement. So import, Render from, and the relative location to the file. Now you might be tempted to add. ios on here because we've got. ios defined on the file, but remember this file name syntax is a special syntax. React Native looks for. ios. js files when it's loading files on the iOS platform, and it looks for. android. js files when it's loading files on the Android platform. So instead of saying render. ios here, we just say render, and trust that React Native will find the correct file for the platform. Because I moved the render logic away form this component, it's not using any of these components anymore, so we can safely remove that. The linter's still warning us that this styles isn't being used, but we'll use that soon enough. Let's scroll down to the component definition, and add a render function again. So we just add an empty render function over here, and because we imported the render logic from the render file, we've got it available on a variable called render. So we say Render. and we need to bind this render function to this component's scope, so we say Render. bind to this, and then pass it styles. Let's go back to this render file so that I can show you how this works. See, we added the styles argument on here because we're using it a lot in our JSX over here, and we bound render to the component's state because we're using this all over the place. If we wanted a PF function, we could've made these arguments as well, but you know what, I'm a bit lazy, let's keep it like this. So let's reload the simulator and see what's happening. Ooh, we've got an error, and I think I know what it means. Let's go to the TaskList component quickly. See here in the TaskList component where we import TaskRow, we're still importing it from its old location. We need to update this import statement now that the files moved. Let's reload it in the simulator again to see if that fixed everything. Whoops, now it's telling us that a valid ReactComponent must be returned from render. Hmm, I think I know what's causing this issue. Inside of the render function, which we created inside of the component, I'm not returning the result of calling this render function over here. Remember, render should always return JSX. Now when we reload it in this simulator, great, it works. But we did all this so that we can differentiate between Android and iOS, didn't we? So let's go into the iOS render logic, and in here inside of this text element, let's add iOS, that way when we define the rendering logic for Android, we can see that this was iOS, and that Android's was Android's. Let's go define the rendering logic for the Android platform now. We duplicate this render. ios to js file, and in here we add and, so we expect to see iOS on the iOS simulator, and and on the Android emulator. Let me just bring the simulator and the emulator to the front. Great, as you can see, we've got iOS on the iOS simulator and and on the Android emulator. So it's definitely using the correct render logic for each platform. So how did we get here? We installed linter modules for our new project to get the linter working again, and it was really useful wasn't it? It helped us a lot to refactor our cold, and told us which components to remove, and which components to add. It also picked up that we had to add a styles attribute to make it available to the rendering logic. We moved the TaskRow. js file to a TaskRow folder and renamed it to Comopnent. js. We then proceeded to extract the render function from this component to platform-specific files, Render. ios. js and render. android. js. We then imported this render logic from the Component. js file by just saying import Render with the relative location, trusting that React Native will import the correct render file for the specific platform using the. ios. js and. android. js convention. So this is how we differentiate rendering per platform.

Add a Swipe-out Effect on the TaskRow for the iOS Platform
So we just went over how to differentiate between iOS and Android on the view layer. Now we're going to make use of that newfound knowledge, and add a swipeout effect on the TaskRow component in iOS. When we're done pulling in the component, we're also going to style it a bit. We're going to reuse as much as possible of the style from the base component, but we're also going to override it with some custom style for the iOS platform. So basically you'll also see how to reuse styles when you want to differentiate between Android and iOS platforms inside of the same component. Let's have a look at the component we'll be using to add this swipeout effect. It's called react-native-swipeout. If you've got an iPhone, this should look very familiar to you. You basically swipe the row from one side to the other, which reveals some buttons, which you can choose to press. If I scroll down a bit, you can see that it's quite easy to install, just up here, npm install, and here's the code to get started. You define an array of Buttons with text and some other attributes I'll show you soon, and then you wrap the content that you want in your row in a Swipeout component. So let's start by installing this NPM package. Npm i react-native-swipeout. I'm choosing to save it to the package. json file, and this is another option, save-exact, which basically means that I want this component to be pegged to this specific version in the package. json file. Once it's done installing, we're met with this error. I have tested this, and it did actually work even with this error, so we're just going to ignore that for now, and keep on using this component. I did mention in an earlier module that it is really advisable to use the exact same versions that I used in the development of this course to follow along. It's been a few months since this course was developed, and react-native has moved on with a few versions. Unfortunately, the latest version of this module react-native-swipeout is not compatible with the latest version react-native. There are a few requests to remedy the problem, and it might have even been merged back into the repo by the time that you have reached this point. If not you might run into this error after you have installed this module. If that's the case, then go and install this module by using this command instead. This command will install it from a ___ that I have created on my github profile, and which I'll keep around. So it's basically just npm i git+ and the Url to this repo on my github profile. Unfortunately, this is opensource we are using and it's bound to happen. Okay, so remember we want to use this swipeout effect in iOS only, so we open up the render. ios. js file, and in here we install this newly imported module. So import Swipeout from react-native-swipeout. Let's go back to this documentation example again. So we need to define these buttons, and we need to wrap our content inside of a swipeout instance, seems easy enough. So let's start by defining the buttons. So I'm defining a new const and calling it buttons. Just me and my creative naming at play there again. Buttons should be an array, and it should contain an object for each button that we want to be available. In our case, we just want one button. First we define some text for this button by using the text attribute, which we want to be Done. Next we define backgroundColor, for which we specify an off-white color. Next up, we've got underlayColor, underlay is the color that you see behind the row when you swipe it out, the part that will be the background of the buttons behind the row. For that we want a grayish sort of color. Now to wire up the functionality of this button, we use onPress, and then let me just scroll down here a bit. See this is the event handler that we used on our traditional button over here, so let's use this same function. This. onDonePressed, and we bind it to this. Let's just close that off to keep the linter happy. Okay, so we've just go two warnings, Swipeout isn't being used anywhere, and this button constant is also not being used. So in render, we add an instance of this Swipeout component, and let's also close it off immediately before we forget. Now let's select all this content over here, and put it inside of the Swipeout component, and also add some indentation just to make clear that it's a child component of Swipeout. So let's also add some attributes onto swipeout itself. We want it to have a backgroundColor of pure white. And we specify that on the right-hand side, we want these buttons to display. This obviously gives you some flexibility as to which side the button should display on your row. Okay, let's go and reload that in the simulator. It doesn't look great at the moment, but we'll fix that with styling soon. Let's have a look, and see whether it works. When I drag this over, great, our button is being displayed, and we can also drag it closed. This can make it a bit easier on the eye. It doesn't look great at the moment. Oh, another thing, we don't need this Done button over here anymore, we'll rely solely on this swipeout effect for the done functionality. So we delete this TouchableHighlight over here, and now because we've done that, our linter gives us a warning. Let's click on that, it's because we're not using this TouchableHighlight reference here anymore. Let's remove it. Okay, linter is happy again, and the Done button is gone when we reload our app. Let's see it still works, great, still works. Okay, so now we're going to style it. Remember we've got some existing style here in the component. js file. See, we've got all this style that we used to use in our rows. Some of this style doesn't apply anymore, so our aim here is to reuse as much of style as possible, but then merge it with some iOS-specific styling that will make this row look proper. Now that we're going to define our style in two places, we definitely don't want to get confused as to where our styling comes from, so let's be more clear, and rename this styles variable to baseStyle. I've selected all the occurrences of this variable, and I'm now renaming it to baseStyle. Let's test that still works, great, everything is still working, we can go on. So let's define some new style rules. I'm using a new const called loccalStyle and assigning that to React. StyleSheet. create. You might remember that this takes an object literal for its argument, containing all the rules that you want to define. So let's create a new rule called row, and here what we want to do is get rid of this margin that we've got around our component here. We want to change it so that this is flush against the sides, but with a margin in between. This used to work for us, but now that we've introduced swipeout to the mix, it doesn't anymore. So we change marginBottom to 0, marginLeft to 0, marginRight to 0. For this view instance, we're going to combine this existing style baseStyle. container with this newly created rule, and we do that by giving this style attribute an array containing the different rules that it should merge. And remember, style rules are merged from the right to the left. We wanted to keep all the values that we defined on the rule on the right, and override any existing values on the style on the left. So we're basically saying give us the existing container style, but just change the marginLeft, marginBottom, and marginRight values to 0. Let's reload that and see what it looks like. It looks much better now, but we still need to have a bit of margin in between. Unfortunately this Swipeout component itself doesn't take full-blown style rules, so I can't just go and set the margin on that. What I'll do though is wrap it in another view, and go and set the margin on that. So we wrap it in a view. Okay, now we can go and add a new rule onto this view. So I create a new rule called container, and in here I go and set a value for marginBottom of 20, and now that we've got that defined, let's go and use it. So style = localStyle. container. Let's have a look, I reload this, great, that looks much better, and it's much clearer that those are rows. Pretty sweet, and if I open up the Android emulator, and reload it over here, you can see that we've got the old look on the rows in Android, but a totally new behavior and look for the rows in iOS. Now we can see how useful this strategy is when you need to provide a different look and feel in an iOS app then in Android, but still reuse as much as possible code. So how did we get here? We installed the react-native-swipeout module for the swipeout effect. We then proceeded to configure some buttons for this swipeout component, and linking the button up to the existing event handler, which we already had defined. Our component didn't look so great at this point, so we combined the style from the base component with some local iOS-specific style that we created. That's the aim of the game, reuse as much as possible code between the different platforms, but then go and target specifically for that platform, to make it as user friendly as possible.

Add an Image on the TaskRow for the Android Platform
Let's go differentiate on the Android platform now by doing something simple. We're going to add an image to the TaskRow component, which targets only the Android platform. So inside of the file that contains the rendering logic for Android for the TaskRow, we go and add a new reference, Image. This is the React Native component that we use when we want to bring images into our app. Before we can use this image component in any meaningful way, we need to add a real image to this project structure. Luckily that's quite easy. All we need to do is add an image inside of a folder, and go and reference from a relative location. So let's create a new folder called Images, and I've got an image already on my clipboard, I'm just pasting it in here. Okay, now that we've got an image, let's go and add an image element inside of our JSX here in Render. And on this image element, we add a source attribute, and inside of this source attribute, we use the normal require keyword, and to that we pass the relative path from this file to the image that we want to display here. So this is actually pretty cool. We're using require as we would do with a JavaScript file, but we're actually pulling in an image. So React Native is hooking into require, and figuring out that we're trying to pull in an image, and doing all the right stuff for us. Let's close off this image element, save it out, and reload our Android app in here. Great, our image is already displaying. The cool thing is that even with this little code change, it's still working correctly when I press this button. The button doesn't look great at the moment, let's go and style it to look a bit better. So as we did when we wanted to style the iOS-specific side of the TaskRow component, we're creating new style inside of this Android file, which we'll use inside here only. So I'm defining a new const called localStyle and assigning that to a new React Native StyleSheet. This we get by calling React. StyleSheet. create. We add a new rule called doneButton, and here we set nothing but the borderRadius of 5 and a padding value, also of 5. When we save that out, it tells us this style's not being used. That's fine, we'll fix that now. So down here in the TouchableHighlight, we don't use this styles. doneButton rule that we got through arguments here, we just replace it by this newly created doneButton rule. Okay, so that looks better. There's still an issue though, let me show you. When I press down on this button, it shows us this ugly black background. What we want to do is make that a bit lighter. Interestingly enough, this is not done through style, this is an attribute on the TouchableHighlight component called underlayColor. So let's set that to a light gray color. Now when I reload the app, press this button, hmm, that looks better. So what did we learn in this lesson? We used a standard require keyword to pull in an image from a relative path. This is actually pretty cool if you think about it. React Native is hooking into the require keyword, picking up that we're requiring an image, and sorting out the rest for us magically, pretty cool. Then we made all the changes inside of the Render. android. js file, this means that we targeted the Android platform exclusively without affecting the TaskRow component on the iOS platform.

Animate the TaskRow Component
Now we're going to use animation to add an effect to when the todo is marked as done, and we're going to add this only for Android, so we're going to leave the iOS implementation as it is at the moment. Animation is very useful when you want to communicate something to the user, so I think it's important that we at least have a look at this concept. To do animation in React Native, you have to reference the animated object form the React Native module. This is a bit of weird syntax. The node in JSX that we want to target with animation, we're going to prefix with this object, Animated. View. This actually means that it's using a special view that's enabled for animation. With React animation, you need to go and create an animation object, which will contain all the state necessary to keep track of the animation, and to control it. This we do by creating a new constant, I'm calling it doneAnimation, and we set that to Animated, and I'm going to use valueXY. Now exactly like with all things coding related, there are a gazillion ways to do the same thing. We could do this animation that we want to do now in several different ways. This is just one way to do it. To link a specific animation up to an element, we use style. So I'm just creating a new style in here called row, and we're setting a transform attribute. This transform attribute we set to the doneAnimation, which we just created, and say getTranslateTransform. Now as soon as I save here, you can see that the linter complains, and it says I don't know about this doneAnimation object, it's not on scope. So let's just move it down here inside of the render function, below where we defined doneAnimation, to make it available to this style code. Now when we save, the linter is happy, and perhaps more importantly, the app is happy. Okay, so no animation will happen at this point. We need to tell it when to start, and we need to tell it how to animate. At the moment this button is just wired up to call the onDonePressed event. What we want to do is add another event handler function, call that to kick off the animation, and then afterwards call this onDonePressed event handler. So I'm creating a new function called animatedPress, and inside of this function we say we want Animated. spring, which is a specific sort of animation, which looks like cool, to happen, and to this spring we pass our arguments. We say that we're using this doneAnimation to keep track of the state, and now we're going to specify some variables to control how this spring animation happens. We're setting a tension variable of 2, which is the speed that it will animate away, and friction of 3. This controls acceleration and deceleration for this animation. Now we're setting a toValue, we're telling it where to animate it to. Because we want to animate these rows away, we're going to set a negative X value of -500. We want it to navigate away to the left. And because we used an XY animation, we're just saying Y equals 0. Don't do anything on the Y axis. And then we also need to tell it to start this animation. Now our button is still hooked up to the old event handler. Let's hook it up to the animatedPress function instead. Save that out, oh, you know what, I used this. animatedPress, but it's actually just a function on here. It's not an instance function like the onDonePressed function. So let's remove this. Okay, now when I save, at least it's loading again, so we're not calling the onDonePressed, which we removed anywhere anymore, it should just animate at this moment. We still have some work to go. As you can see when I click here, it's not doing anything. This is because we haven't hooked up this view with a newly created style rule, which associates it with this animation. So again we're using this array syntax where we combine styles. So we're saying use this style. container, but also use the localStyle. row, which contains the style rules for the animation. Now when we save that out, and press this button, great, it animates away to the left. We're still not done though because this object's not being removed from state. Let me show you what I mean. When I click here to add a new item, and add one called test, you can see that it's got a gap in here. That's because although this item's style now puts it all the way over to the left, it's still available on state, so it's still being rendered, even though we don't see it here. So let's just do the easiest thing first, and call the onDonePressed function inside of this function. It's not going to work perfectly, but I want to show you what it does. Now when we press it, it just disappears exactly like it always used to, it's not animating anymore. That's because while this animation's being kicked off, we're also removing it from state, and this control gets re-rendered without this todo. So we never get a chance to see the animation. Now you can actually add an event handler to animations, to go and see when it's done, so that you can go and do some extra logic afterwards. I've used this, and I must say I wasn't impressed with the results. I had inconsistent behavior, maybe I was doing it wrong, but you know what, let's just get it working in the easiest way that we can think of, and that is a setTimeout. So I'm using setTimeout, and providing it with an arrow function. Inside of this arrow function, I call this. onDonePressed, and I'm delaying this code by a 1000ms. Hopefully this will animate the row away, and then go and remove it from state. Let's test that out. So I click this button over here, and the item animates away. But remember, it also did that previously, but then it wasn't removed from state. Let's go and add one to test. So I add one, called test. Okay, so it doesn't have that odd gap there in between these two rows anymore. That means that the item that we marked as done a bit earlier, was actually removed from state. So we ended up with the animation being shown and the item being removed from state, which is good enough for me. Animation is a very deep subject on any platform, and React Native is no exception. I could probably do a whole course on React Native animations, but if you're interested in checking it out a bit further, go and have a look at the official documentation. There's quite a lot of examples here and quite a lot of background on how it works. So how did we get here? We referenced the React. Animated object to set up the animation. We used that weird syntax to prefix the view with animated in the JSX in the render call to allow it to be targeted by animation. We then proceeded to create a new animation using Animated. ValueXY. Now if you go through the documentation on the React site, you'll probably find various different ways to go and do the same animation, which we set up now. I chose to use the Animated. ValueXY because it's something that I could understand, and something that I could get working. We then created a style rule, which we associated to this animated. View instance in JSX, and this we linked up to the animation that we set up. That's how you associate animations with JSX elements in React Native, through style rules. Then we told this animation what to do. We used Animated. spring to start the animation with some configuration variables. As I've mentioned before, animation in React Native is a very deep subject. If you want to play around with it more, go and have a look at the official documentation on React Native's website.

Recap
Let's do a quick recap of what we learned in this module. Instead of write once, run anywhere, the React Native approach is to learn once, write anywhere. This basically means that you get to understand one framework, one language, and then use it on multiple platforms, but not always necessarily with just the one code base. You can definitely differentiate for each platform. I think the best balance is to try and get as much as possible code reuse, and then differentiate where you need it for each platform. In order to do selective platform targeting, React Native provides us with a convention that we can use. This is how we do platform targeting with React Native. We use ios. js files, where we want our iOS logic to live, and we use android. js files where we want our Android code to live. Then when we use require, passing it a file name, React Native will look into that, and see is there an iOS to JS file, and am I on iOS? Then use that file. Conversely, if I'm on Android, and there's an android. js file, it will prefer that one. So we don't split our whole code base into two, one for iOS and one for Android, we can even have components with all the component logic embedded inside of one file, and then extract only the rendering logic to. ios. js files and android. js files. This is what I showed you in this module, how to do that, and we did that on the TaskRow component. So the TaskRow component still had all the event handling and bubbling up of these events to the container components, but then we differentiated with style and the JSX inside of two files, render. ios to js and render. android. js. We then pulled in these files, and called it from the components render function. This approach can obviously be used not only for rendering, but for example, if your whole component's the same even with JSX, but you want to include different style for those nodes, you can also use this mechanism. And that's it for this Platform Targeting module. Next up we're going to look at pulling in the very popular Redux library to help us manage our state a bit better.

State Management with Redux
A Quick Overview of Redux
In this module we're going to have a look at doing State Management with Redux. It feels like nowadays you can't read anything about React without something like Redux being mentioned, and this is with good reason because state management is very complex. Your component might need to change one bit of state, but then changing that one bit of state has effects on other bits of state, which needs to be recomputed, and other components are interested in that change. That's why the people at Facebook came up with a flux pattern, to help you manage this complexity. Turns out with this standard flux pattern, without a bunch of libraries, you end up writing a lot of boilerplate, a lot of repetitive code, and that's also an opportunity to introduce bugs. Redux is actually very, very simple, and it achieves this simplicity by relying on pure functional concepts. I did a bit of Googling to try and find the best explanation of pure functions, and I think this one on SitePoint does the job quite well. A pure function is a function where the return value is only determined by its input values without observable side effects. This means that when you call a pure function, the function should not get any external data. It should receive all the data that it needs to perform its calculation on its arguments, and the part about the observable side effects, it just means that when you go and call this function, it doesn't change anything. You can call this function as many times you want with the same input values, and it should always return the same value. Let's have a look at how Redux uses pure functions to achieve its simplicity. At the core of Redux, you'll find reducers. Now this sounded very technical to me when I first looked at Redux. It sounded very computer-sciencey to me, it sort of scared me off in the beginning. When you go and have a look at it, you see it's very, very simple, and it's nothing to be afraid of. So a Redux reducer is just a plain old function. This function takes the current state as its first parameter, and the action that's being dispatched. An action is sort of like an event, and can contain a description and maybe some data on it. For example, a todo has been added, and here is the todo. The reducer then and goes and have a look at the type of the action, and then mutates the state from the old state, into a new object that it returns. I suspect you're actually going to get tired of me reiterating mutating state and not changing state, but basically it means that you don't affect the state being passed in here at all. That's a side effect, and you shouldn't have side effects in pure functions. So what I mean with mutating this state is that you create a copy, you pull over the stuff that you want from the old state onto this new object, and then go and make the changes on the new object according to the action that was passed in here. Then you return this new state. This should leave the old state that was being passed in here unaffected. That is a pure function. So once you've set up your pure function, which is your reducer, you just pass that into the createStore function on Redux, which gives you a store on which you can go and dispatch actions. Interestingly enough, you can also have multiple reducers. This can obviously help a lot in big apps where your state becomes quite complex, where you just want reducers focused on specific actions. But a very important concept that might be surprising to you is that in a Redux store, you always have just one object for state. Now that object will probably have a lot of properties, and properties with arrays, and in those arrays other objects, but at its root, it's just one object. So introducing more than one reducer doesn't mean that you'll have more than one state object. These reducers will all be passed the same state object, and they'll all mutate a certain part of it based on the action. So sometimes a reducer will be called, and because you've set up this reducer for a specific action, it might ignore the action being passed into it. So this is the overall flow. Let's say we've got two components, and component A dispatches an action to the Redux store. The Redux store starts recalculating its state by passing in the current state to all the reducers that it's been set up. So the Redux store passes the current state and the action that was dispatched on it into the first reducer. This reducer goes and figures out, am I interested in this action, and if it is, it mutates the state and returns the mutated state. If it's not interested in this action, it just returns the same state. Then the Redux store takes the state as it was calculated by the first reducer and passes it into the second reducer, which does the same. It goes and checks is it interested in this action, if it is, it mutates the state and returns it. If it's not, it just returns the state unchanged. Then the Redux store takes the updated state and passes it in to the last reducer, which does the same as the first and second reducer. Then the Redux store goes and haves a look at all the components that subscribe to it for changes, and it notifies them that the state's been recalculated. The components then just asks the Redux store for the latest state, and then re-renders. So let's get going, let's start installing it, and let's refactor our app to use Redux for state management.

Introducing Redux to the Project
So let's start using Redux now. We're going to install it first, then we're going to create a Redux store. We're going to implement a few actions during this module, but we're going to start off first by adding an action to add a new todo. Then I'll show you how to sync the PluralTodo components state with the Redux store state with the result of our app re-rendering with the new todo in the list after triggering the action to add a new todo. So let's open the command line, and install Redux by using npm i redux -- save, and it installs pretty quickly. That's what's so nice about Redux, it's got such a small footprint. Open up the source code to go and have a look, it's really, really simple and small. You can see it doesn't even have dependencies to other modules. Okay, so I've opened up the iOS simulator containing our app here on the right, and now we're going to integrate Redux here on the left, keeping track of the changes in this simulator with auto-reload. So here in our container component, which is the PluralTodo component, we've got a bunch of warnings where we call setState. I kept it around and didn't disable these warnings to remind ourselves that we need to use a state management library like Redux. So let's create our Redux store. We just click here to add a new file, and call this todoStore. js. Okay, the first thing that we need to do in this file is import the createStore function from Redux, and our store is going to be a pure function that takes input and provides output. So we create a new function called todoStore, and this function takes a parameter called state. We want the default value for this parameter containing the default state for this store. So let's create a new constant up here called defaultState, and this should be an object. This object has got an attribute called todos, which is an array, and in this array let's just add one task todo, and if you recall, the way we modeled todo was an object with a task attribute. Let's set this task attribute to Initial todo in store. Let's just add our dangling comas and our semicolon over here. Okay great, now we've got our default state, which we can assign as the default for this parameter. So our Redux store takes two parameters, the state for which you need to provide a default value, and the action that's being fired on this store. This action is used to figure out how we need to mutate the state. Let's go and export our store. At the moment we've only got this function. We need to create a store from this function, so we export default, and we use this createStore function that we got from Redux, and we pass in our function in there. So that's our store exported. We're not mutating any state though, and that's the whole reason for using Redux, so let's go and implement the mutation on state when an action gets fired to add a new todo. We're going to handle a bunch of different actions inside of this one store, so to make sure that we can handle a bunch of actions, we use a switch statement, and we switch over the type attribute of the action. We want to handle adding of a new todo, so we go and add case, and ADD_TODO. This is just a string that if you pass in an action with the same string, it will hit this part of the switch statement. You can use constants for this, but that's actually a bit of overkill in smaller projects like this one, so let's just use a string in here. So when an action is fired on our store with a type of ADD_TODO, what we want to do is go and mutate this state so that the new todo is added to this state, but here's the weird and wonderful part of Redux, it uses pure functions, so we can't just go and override this state, we need to mutate the state in a non-destructive manner that keeps the old stater out, and we create a new copy of this state with a new todo added to that. To do this, we use Object. assign. Now Object. assign works very similar to how we merge styles in React Native. It's also similar to Lodash's extend functoin. This is something that's been added to the JavaScript language. So we use object. assign, and we pass in an empty object. What's important here is that we don't go and override this state. We need to return a new object reference, that's why we specify an empty object here. Then we go and say take all the attributes that we've got on state currently, and copy them over to this new object reference, and only then do we say cool, now I'll go and mutate the todos property on this object over here without changing it on this object over here, so we're working from right, preferring all the properties from those objects, and then working to the left, resulting in a new object containing the properties from these objects as we pass it in from the right. For this todos property, we say that we want the current todos on state, and we use concat on this array to go and say cool, go and append this array to that array, and return that as a new array. So even the old todos array that we had, without this new todo, doesn't get touched. We create a new array containing this new object. So people often feel that Redux is a bit complicated, and they don't understand it. It's just because we need to use these non-destructive ways of mutating state instead of overriding state as we're used to. And to this we say that we want an array with one object, which is our new todo, with a task property set to this task attribute on the action being passed in. All this is strategies from functional programming, and it's with good reason. There are even dev tools that have been built for Redux that allows you to time travel. This means that you slide a little slider backwards and forwards, and it uses the state as it was in that point in time for your app. If you change the state in a destructive manner, it obviously couldn't do that. That's the benefit that you get from mutating state, no side effects. Phew, I know that's complicated, and I know it's a bit daunting, but that's the thing about Redux, it's actually very, very, very simple. The thing to grasp is this mutating state in a non-destructive manner. Once you've grasped that concept, working with Redux is going to be very simple. And you know what, these are really good practices to get use to. Even in a world without Redux, you're going to use it quite a lot. So when we save that out, our linter is telling us that we've got a switch statement without a default rule. So let's add one, and all we do from here is return the default state, so our store always return state. If we pass in an action that it doesn't recognize, it's just going to return the same state that was passed into it. Okay, so let's go and use our store. Inside of the PluralTodo component, we import this store from its relative location. So import store from todoStore. Now here where we've set up our default state in PluralTodo, we can get rid of this assignment. What we're going to do instead is call store. getState. When we save that out you can see that it's now rendering the todo that we set up in the default state in todoStore. Now here in the onAdd handler, we're going to get rid of this, and fire an action on our newly created todoStore instead. So I'm just going to comment this out so that you can keep an eye on this when we replace it with the Redux logic. So what we need to do here is go and call store. dispatch. This is how we tell it to go and fire an action on the store. And we pass this an object, so this is the action that we expect in the store. We specify type attribute, and we use the same string as we used in the todoStore when we switch over the action type, and we pass it the task using the ES6 literal syntax. It's complaining about a semicolon here, so this isn't going to work, but I want to show it to you in any case. We click on Add a new item, call it Test, click on Add, see our item isn't reflected here in the TaskList. Why is that? Well that's because we bound to state initially in the constructor, but when state is mutated in the store, we don't know about it in this component, meaning we're bound to an old copy of state, so we need to subscribe to when state is mutated, so that we can update our state in this component. To do that, we call the subscribe function on the store, which expects a callback. I'm just going to add an arrow function in here, and inside of this function we call this. setState, and we callgetState on store again to get the latest copy of the state. Now when I save that out, the linter complains that we shouldn't use setState, but this is a totally valid usage of setState because we're getting the state from a Redux store, which we use to manage state. We're going to fix that linting issue now, but let's just go and test whether this worked. Click on Add again, add an item called Test, great, our TaskList re-rendered containing this new item. So we're mutating state inside of a Redux store, and we're subscribing to that mutation inside of our container component, which is the PluralTodo component, and updating its copy of the state to the latest state. This causes the TaskList to re-render, containing the new todo. So seeing that this is a totally valid usage of setState, I'm going to ignore this warning using ESLint's mechanism to disable warnings on a specific line. To do that, we type comment on this line, and then say eslint-disable-line, and now we need to specify the name of the rule that it needs to disable on this line. If I click here to get the warning again, we need to use this, react/no-set-state. When I save that out, you can see that the warning goes away, so my advice is keep the setState warnings around while you're coding it up so that you're aware of it, and then when you're 100% sure that this setState should be used still, go and disable it like this. So how did we get here? We installed Redux through NPM. We then created a Redux store with some initial state. Your Redux store should always have initial state, even if that initial state is just an empty object. We then implemented a switch statement to target a specific action, in this case the ADD_TODO action. We then mutated the state. We didn't override any state, using object. assign to mutate objects, and for arrays, we used a concat function. This resulted in a totally different array, keeping the old array of todos intact. This is where the complex part of this lesson was, and if you feel like this part of the demo was a bit complex, you're totally right. It takes a little time to wrap your head around mutating objects instead of just overriding the values. But like I mentioned before, once you get the hang of it, it's totally worth it. You'll be able to use Redux like a master, but also it's good overall for your JavaScript development. So then we tested our new action, and the item didn't reflect in the list. That's because we had to go and use store. subscribe to go and update the container state when the state was mutated in the store.

Adding an Action for Marking a Todo as Done
Cool, in this lesson we're going to mark a todo as done using Redux. This we're going to do by adding a new action handler to our Redux store, and we're going to use Object. assign again to mutate our state, we're not going to override it. We've got a todo array, and we're going to filter out the todo that's marked as done from this array. This results in a new array, so we won't be overriding anything from our old state. We're also going to dispatch this newly-created action to the todoStore when the user marks the item as done. So what's interesting is that currently when you mark an item as done, it still gets removed from this list. So we've got our desired behavior already. What we don't have is this logic handled by Redux. We're currently being a bit naughty, and affecting the changes to state right here inside of our container component. We'd like to do all state mutations through the Redux store and contain it in there. Let's go and set up the new action inside of our todoStore to go and remove this item from the array. So remember to identify which action we're handling here, we switch over the actions type attribute. So for this one, we're going to look for DONE_TODO, and when we hit this action we're going to want to filter the affected todo from the array. So we say return Object. assign, with an empty object. This is going to be our new state object, and then we say cool, we want a new todos property, and this new todos property should be an array without the affected todo. To get this new array without the todo, let's just say state. todos. filter, and then we use an arrow function to go and say when this todo doesn't equal the deleted todo, keep it in the array. So we're basically saying keep all the items except the todo that was removed. This will result in a totally new array without the affected todo. Okay, so let's go and fire this action from the PluralTodo component. So instead of making the changes directly to state here in a destructive manner, we're going to dispatch this newly created action here. So I remove all this, and we can say store. dispatch, and we pass in the type of DONE_TODO, and we pass in the affected todo. This todo we pass in here is used to go and do a reference check to filter it out from the array. Okay, let's go and test that. When I mark this todo as Done, it gets removed from the list through the Redux store logic, so our logic in our todoStore is working. To get to this point, we added a new action in the todoStore called DONE_TODO. In the todoStore, we used Object. assign to mutate the state again instead of overriding it. To get a new array without the todo that was marked as done, we used the filter function on the array. This results in a new array, which is cool because we don't want to affect the array, we want to keep it around and create a new array. We always want to mutate state, keeping the old state intact. We also ripped out the old code inside of the PluralTodo component, which was changing state directly, and wired it up to dispatch an action instead, allowing the todoStore to mutate state.

Adding an Action to Switch Between Pending and Done Todos
So we've replaced our existing state permutations with Redux, but now we're going to do something new with it. We're going to add more complex state mutation to our app, and use Redux to help us fight complexity. To do this, we're going to add some functionality to the list, that allows the user to toggle between seeing pending todos and done todos. We'll introduce a filer state variable in the todoStore. This will keep track of which items to show in the list. Then we're going to add a new action to toggle the filter state variable between pending and done states. We'll use a switch component to allow the user to toggle the filter. In the end, we'll mutate state to filter the todos based on the state variable. So first things first, here in the default state, we add a new variable called filter, and we set this to the default value that we want, pending. I'm going to use strings wherever I want to refer to a particular state, but in your app maybe consider using constants. I want to keep it simple for you to follow along, so I don't want to add complexity, but it's a good idea to use constants wherever you want strings like this. So let's add an action handler for when the user toggles the state between done and pending. So we need to switch here on action type, and I'm adding a case for TOGGLE_STATE. What we want to do in here is flip the filter state, so if it's pending we want it to be done, and if it's done we want it set it to pending. So I'm creating a new constant here called filter. Now I'm saying that if the filter equals pending, set it to done, otherwise set it to pending. There are further ramifications to our state when this action gets dispatched, but for now we're just going to record this filter onto our state. Remember we mutate state, we don't override it, so we're using the same pattern as we did in the ADD_TODO and DONE_TODO action handlers. We return an Object. assign with a new object. We take over all the properties from the existing state variable, and then we say that we want the filter value to be updated to this value that we just calculated here. Now we're going to build a little switch that allows the user to toggle this filter variable instead. Inside of the TaskList, we reference the switch component from React. Now we scroll down here to the render function. I want to add this switch with a label next to it on top of the items in our list, so I'm going to have a View wrap both the switch and a text element, so let's create that view, and close it off. Now let's add this switch element, so open up Switch. You need to tell the switch whether it's on or not, this you do through the value attribute. For this value, we say that we want it to be in the on position when the prop called filter has a value that's anything other than pending. Remember, pending is the default value that we set on state. And now we want to insert some text next to this switch, so I open up a text instance, and close it off. Inside here, we add some text. We say we're Showing, and then we say the length of the todos that we get on props, and we say this. props. filter, so we want it to say something like Showing three pending todos. Okay, when we save that out, well we get a few warnings here. Let's click on them. Oh, it's just a filter prop that's not being validated. Let's go fix that quickly. Down here in our prop validation rules, we add a prop called filter, and we say that we want it to be a React. PropTypes. string, and we want it to be Required. Okay, let's save that out. That's a bit better. We've got a warning down here in the simulator telling us that we're not setting the filter prop on the TaskList component. Let's dismiss that, and let's go fix it. Inside of the PluralTodo component, down here where we render the TaskList, we need to specify a filter prop. So we add a filter prop, and we give this a value from state, so this. state. filter. Remember, this gets set in our todoStore. When we save that out now, our warning is gone. This is not how I want these components to look. Let's go and style them quickly. So inside of the TaskList component again, let's add some style attributes to each of these components, and then go and style them. So on the wrapper view we specify a style of toggleRow, and on the Switch we specify a style of styles. switch, and on this text instance here, we add a style attribute, and set that to toggleText. Now the first thing that I think we should do here is to go and render this text item next to the switch. To do that, we need to specify the flexDirection on a toggleRow rule in here, and we want this flexDirection to be a row. Let's also give it some padding, I think 10 should be enough. And now let's set up a rule for toggleText. I want it to have a bit of bigger font size, let's make it 20, and I've done this before, so I know exactly what values to give here. PaddingLeft, let's give it 10, and paddingTop, let's give it 3. Okay, that looks much better. So it's got our switch with a nice label next to it. When I try and tap this switch, it goes to the off position automatically. I can't get it into the on position. That's because our state never changes, and React checks and sees, oh this state's still pending, so it takes it back to the off position. So we need to go and add an event to this switch so that we can dispatch an action to our todoStore so that it can update the state because all our interaction with the Redux todoStore is done from the PluralTodo component, which is our container component. We need a way to let the PluralTodo component know that this switch has been interacted with, all the way from the TaskList. So on the TaskList, we say that we want a function to be passed through on a prop called onToggle. This we do by saying React. PropTypes, and we specify that we want a func, and that's it's Required. As soon as we save that out, you can see that we get a warning because this onToggle prop is not being set. In the PluralTodo component, we specify onToggle where we add the TaskList, and we bind it to a this. onToggle. We don't have this function yet, but we'll define it soon enough. And just because we've done it with all the other functions, we bind it to this component's instance. This isn't strictly necessary in this case because we're not going to interact with this instance in this handler, we're just going to dispatch an action on the store, but I think for consistency sake, let's keep it the same as all the other event handlers, and bind it to this component's instance. So let's define it on this component. We add an onToggle function, and all we do in here is call store. dispatch, and we need to specify a type for this action, which you might recall is TOGGLE_STATE. Again, you might opt to use constants, which you export from a file, which you can refer all over the show, but this is a very small app, so I'm trying to keep it simple by not using constants. In any production app, I'd advise you to try and pull in constants as soon as you've got more than three action handlers, and we don't need to dispatch any data to this action handler. It's got everything that it needs to go and calculate where to flip the filter to. Okay, so our TaskList component has got an onToggle prop, and we're binding a function onto this TaskList prop from the PluralTodo, but we're never actually using this prop from inside the TaskList component. What we want to do is when the user toggles the switch, is to call this function so that it dispatches the action to the todoStore. On the switch, we use the onValueChange prop, and this we bind directly to the onToggle function that was set on props. We don't need to hook into it, and do some intermediary logic. It's fine just to call it directly. Now when we toggle this switch, you can see that our label updates, and it says in the on position. So that's all cool and everything, but it doesn't change the list down here. We need to go and change our app so that it filters this list based on this switch. Up to now, it would've been fine for these todos just to be strings, wouldn't it, but now I'm sure glad that we opted to use objects instead of strings. Now we can set extra parameters on todos, and we want to do that to keep track of which todos are done, and which todos are pending. What we're also going to do is change our state here in the store to have two arrays, todos, which contains the filtered list of todos, and then allTodos, which contains all the todos regularless of their state. When we start out, I want the default state to have the same array for the todos attribute and for the allTodos attribute. So let's extract this todos that we set up here to a variable called defaultTodos. And we can add a new attribute called allTodos, and also set that to defaultTodos. So at this point our default state has got two attributes pointing to the same array, and we're going to keep this todos attribute to contain the filtered list of todos, depending on this filter value here. When this value is pending, we're only going to have pending todos in this array, and when it's done, we're only going to have done todos in this array, but the allTodos will have a mixture between pending and done. Let's just save that out, great, it reloads, so I haven't broken it yet. Now done here in TOGGLE_STATE, we go and specify that we want the todos to be recalculated. We want it to be the old todos value, but filtered, and in here we pass an arrow function, and we specify that we only want todos that match this filter attribute, which we've just toggled, to be in the todos list. Let's test that out in the simulator. I don't expect this to work, but I want to show you. So it loads up showing our todo, but when I toggle this switch here, I guess we expect this, we don't have any done todos, but now let's switch back, and now our pending todo is gone. Where did it go? Let me show you. Here where we set up the default todos, this task doesn't have a state, and because we only falter once we tap the switch, the item displayed initially is only when we _____ that it filtered out, and it couldn't find any todos in a done or pending state. So we need to set the state on this default todo to pending. Okay, let's try that out in the simulator again. Switch it do done, 0 todos, that's expected. Now let's switch it back. Cool, it's displaying our pending todo, great. Okay, so I add a new todo called Test, and we do the same test done earlier. We toggle this, we expect 0 dones, and we toggle back. Our new todo is gone. That's because when we add todos, we don't set a state currently. So here in the ADD_TODO action handler, let's set a state of pending. Okay, let's test that out again. I add a new one called Test again, toggle this to done, that's expected, toggle back, and our new todo still disappears. That's because this ADD_TODO action handler added the item directly to the todos array. Because we've now go two arrays on state, todos, and ALL_TODOS, we should always add the item to ALL_TODOS first, and then go and call the filter afterwards. Remember todos contains only the filtered todos. ALL_TODOS is what contains all the todos. So I change this props name to ALL_TODOS because we want to add it in here, but that actually won't work because if I go and assign it to ALL_TODOS here, how can I calculate the todos array from this property where it's being set in line? We'll need to split this statement out, and create an array outside of this Object. assign statement containing the ALL_TODOS array, including the new item that was added to the list. So const allTodos, and we cut and paste this statement over here. So now we've got an array containing the todos with an added todo that was passed through on the action. And now we can say that we want the allTodos to be set on state, and that we want the todos attribute on state to be calculated from the allTodos by filtering it and saying that we want only the todos that match the current filter state. So the idea is we always affect the todos on the allTodos array first, and then go and reply our filter for the todos attribute. And at this point, we need to actually go and get the filter variable from state. Down here, we calculated a new filter variable because it was toggleState action handler, and that's why we have this constant called filter available, but here we just want to go and say use the current value for filter on state. Okay, let's go test it out. We add a new item again called Test, and it gets displayed here in the list. We need to do something similar in this doneTodo action handler. Currently it still makes the changes directly on the todos array. We want to make the changes on the allTodos array, and then go reapply the filter on the todos array. Previously in this DONE_TODO action handler, we just filtered out the todo on this action from the todos array. Now what we want to do is go and set the state on the todo to done, but we can't just override it on this todo, we need to mutate the state, and go and create a new todo with the correct state. This we do by calling Object. assign, saying we want a new object, getting all the attributes from the todo on the action, and then overriding the state with done. Now we need to mutate the allTodos array to contain this todo with the updated state, and we do this by creating a constant called updatedAllTodos, and we go and map over the allTodos array that we've got on state. Inside of this map, we specify that if the todo is the todo passed through on the action, we want it to be replaced with a doneTodo, otherwise we just want to leave it alone. So this results in a new array with all the same todos except the todo that's been marked as done gets replaced with a new todo with an updated state. We go and set the allTodos on our new state to this updatedAllTodos variable, and we go and copy this statement up here so that we can reapply the filter that we've got on state to our todos array. Okay, let's test that out. Toggle it to done, that's expected, no todos are done yet, and we add a new todo. Now when we set this todo to done, and toggle this switch over here, it shows that we've got one done todo, so we've mutated the state correctly in the done todo action handler. Go back to pending, and it's still displaying only one item in the pending list. Looking at this code, I can actually see that there's a bug in there, let me show you. When I add another one, let's call it Add another one, it gets shown in the pending list, that's what we expected, but now when we switch to done, the previous item that we marked as done is gone. Go back to pending, it's only got our new items in there, so one of the todos has gone missing. That's because here in the ADD_TODO action handler, I made a mistake, I mutated the allTodos attribute from the wrong array. We actually needed to mutate the allTodos on state. So instead of using todos here to calculate allTodos, remember todos in the filtered array, we need to use the allTodos variable on state. So let's do that same test again. I add a new item, call it The first one, let's mark that item as Done. It filters it out from this pending list, so far so good. When we toggle this switch, it shows that item. We go back to the pending list. This is where it broke earlier when we added another item. So let's add another item. Okay, so it's showing our initial one, and this one in pending. Now for the big test. When we toggle this switch, it's still go the first one in here. Let's switch back, and it's showing all the items that it should in pending. Just for good measure, let's also mark this one as done. Great, it's still showing both these items when I switch over to done, and when I switch back, only the one pending item displays there. So we're not losing todos anymore. So how did we get here? We toggled between showing a list of pending and done todos by introducing a filter state variable in the todoStore. We added a new action to the todoStore, and all this action did is toggle the filter state variable to pending when it was done, and to done when it was pending. We then wired up the switch component to bubble up an event to the PluralTodo component, which is our container component. This component dispatched an action to the todos store, which updated the filter state variable. In all three of our action handlers, we then mutated state to recalculate the todos array based on the latest filter on the state variable.

Thanks
You've worked your way through this whole course, and I really want to thank you for that, and commend you. It was a lot of work, it was a lot of concepts and set up that we had to go through to get to this point. I really hope you're at a point now where you can see the benefit of React Native, and see how you can build cross-platform React Native apps, targeting specific functionality on specific platforms while still squeezing a lot of reuse out of your code base. Thanks a lot, and if you've got any questions for me, go into the discussions panel on this course on Pluralsight, and pop me a message.
