Do you feel a little bit overwhelmed by all of the other technology you need to decide on and learn in order to get your React app in production? You need to build JSX, and you probably want to use ES6 and ES7 too. How about flux, how does that work, and what library should you use to implement it? This course will show you what issues need to be addressed when you build React apps, what technology to address it, and how the technologies fit together.

Introduction
Welcome
Welcome. I'm Hendrik Swanepoel. Don't worry, I won't expect you to learn how to pronounce it. More importantly, I want to show you a cool stack for developing React apps. In this course you'll learn a lot about React, in case you don't already know it, and learn a lot about how to _____ it with other technologies to address issues like builds, flux architecture, material design, client side routing, and event hooking it up with a realtime backend. This course makes heavy use of E7 features, which I'll at least point out to you and oftentimes explain in more detail. Why would you want to learn all this stuff though? Well React is a library, it's not a full comprehensive framework where you color between the lines. React developers need to understand that they find themselves in an ever changing ecosystem where certain libraries lose favor to others as the community support reaches a sort of transient equilibrium.

The Demo App
In this course I'll take you through a stack with React at its core. The aim of the stack is to alleviate real world concerns and show you how everything fits together. I'll introduce the stack to you through building out this realtime chatter. As you can see, it looks pretty nifty with a material design. Have a look at when I click on one of these channels over here. See that click effect? And it's also realtime. Let's add a new message. Almost immediate. You can also see that it employs client side routing up here. I'll also take you through doing a logging screen with authentication using our stack, because that's always the first thing that I try to figure out when I have to build an app with new technology. This stack addresses these issues, builds and packaging, which we use webpack for, nothing else, yep. No Bower, Grunt, or Gulp required. Not even Ruby for Sass. It enables you to build amazing looking apps in conformance to Google's material design. We get this by using a library called Material-UI. We'll also implement the flux architecture in order to keep our code nice and clean. This we do by using the popular alt library, which removes a bunch of boilerplate. We also hook up a realtime backend service, Firebase, in order to show off the realtime nature of React.

A Breakdown of the Stack
Let me introduce you to the different components of the stack quickly, so you can see for yourself. If you've done any serious front end coding in the last 2 years, you'll know how important it is to get a build tool in place. You can opt to use Grunt or Gulp. You can even get a bit weird and use Browserify or you can get even weirder and use webpack, that's what we're going to use in this course. I just love this piece of technology, I love it. This is their description of what it does, which doesn't really do it justice. But rest assured, it's popular and it's not going to fade away into obscurity anytime soon. Well, we all know how volatile build tools for front end devs are, as we've seen with Grunt and Gulp, so don't hold me to that, but still it's got a pretty solid following on GitHub. And it's what it does that really rocks my boat. Or maybe it's this cool animating logo on their website that gets me excited. It's not called webpack for nothing. Using the concept of loaders, it can package up npm packages, JavaScript, images, and CSS into modules that can run in the browser. And not only currently supported js, but all the popular languages that compile to js, like CoffeeScript. In our case though we'll use the Babel webpack loader to transpile from ES7 to ES5. This course is very heavy on the ES7 concepts, as I've mentioned before. ES7 really makes a difference to your code. I'm sure you'll enjoy it if you haven't checked it out yet. Just a little bit of extra information to show you how popular webpack is with the React community in particular. Have you heard of this guy, Pete Hunt? He's one of the original engineers that started React at Facebook. As you can see from the comments that he contributed to the project before leaving in 2014. He's gone through the efforts of coming up with a little open source how to on using webpack, which by itself became quite popular. He obviously thinks it's worth using. He's thrown his weight behind it in other ways too. He even gave a talk on it at Oscon in 2014. Even the people in the Reactiflux Slack group embrace it. As you can see, by the 883 people who joined the channel dedicated to it. So that's my very scientific reasoning behind choosing webpack. It's all just a darn popularity contest. Yes, yes it is. What's the point of coding apps that look awful? Lots of time we don't have access to designers, especially when we code up prototypes or minimum viable products for launch day. I'm a big fan of Google Material Design, so for our stack we're going to use Material-UI to give us a bunch of components conforming to the material design spec. Again with the popularity contest, it's got 10, 984 stars on GitHub and it's well supported. Don't believe me? Check it out. I'm so impressed by this library. The components look amazing and are so easy to work with. And we've got a whole bunch of them, each one with a lot of flexibility and styling options. You can also customize it in the form of specifying theme rules and color palettes. You really have to see this for yourself, check out their beautiful website. I especially love the section where you can see all their components with their various options in action, with code samples right next to it. Just have a look at all these components. And as you can see, it's got some really nice material design interaction to it as well. Because our chat app that we're going to build out in this course is of a realtime nature, we'll be using Firebase for our backend. We don't want to be building the backend ourselves in this particular course. Here's a good reason to use Firebase, it was acquired by Google, that speaks volumes about the technology itself. It's so easy to consume. It's been positioned as a backend server for mobile apps and they cater for all levels of developers. So they go through painstaking effort to relentlessly document the service. The end result is the best documentation that I've ever experienced for anything. No exaggeration there. I'm actually serious. These guys set a new standard with their docs and guides. In the Firebase module of this course I'm going to mention it again, but just have a look at their site, per platform documentation and each platform is very well documented. When we select web here, you can see that they have Quickstart, Guides, Recipes, basically everything that you can want. Let's select the Quickstart. Step by step instructions on how to get started with it. Let's select Guide over here, step by step interactive documentation with examples to show you how to do everything with the service, amazing. We are going to make use of the flux architecture in this course and we're going to use a library called alt to do that. Alt is semi-popular on GitHub. It's not the most popular library for implementing the flux architecture anymore, but it's super user friendly and easy to learn and it's got a decent community around it with solid documentation and patterns. It gets rid of so much boilerplate, it's totally worth it. It uses conventions instead of explicitly configuring everything with loads of code, which is something that we first appreciated in Ruby on Rails. To help get rid of boilerplate it adds a bunch of ES7 decorators you can use to build out your flux app with meta programming techniques, making your code more declarative and easier to read and maintain. We're also going to add client side routing to our app, as I showed you earlier when I selected a channel. For this we'll use React-Router, which is embraced by the React community as the defector routing library. But more importantly, I'm going to show you how to use React routing with a _____ fast stack, specifically the flux code we'll implement with alt, as that can get quite challenging to get right.

Recap
To recap, in this course we're going to take a look at a real world React stack that gives us builds through webpack without needing to pull in Gulp or Grunt. We can package a bunch of different types of content into downloadable packages that can be executed by standard web browsers. Most importantly we're going to use a lot of ES6 and ES7 features and we'll use Babel and webpack to transpile it ES5 for us. We're going to pull in Material-UI to give us a bunch of React components conforming to Google Material's Design spec. For our backend, we're going to use the Firebase service and I'm also going to show you how to use it to authenticate someone using their Google account. We're going to pull in alt to implement the flux pattern in our app. And I believe that you'll be impressed with the amount of boilerplate that it removes in the process. I'm so excited to show you the ES7 decorators that it gives us to make our code very expressive and declarative. It's not just a nifty feature, it really does make a world of difference. Lastly, we're going to pull in React-Router onto our stack and make it play nice with the flux implementation using alt, just to put a nice little bow around our pretty little stack. A very important thing to note before we get into it, this course relies heavily on popular npm packages and open source moves quickly. By the time that this course was ready to publish there were already a few breaking changes in some of the packages used, in particular Material-UI. I'm sure you understand that it's not feasible to go and redevelop the whole course every time this happens and that's why I'm warning this early on in this course. To remedy this, individual published a final code for the sample app on the GitHub repo. Load it up at GitHub. com/hendrikswan/react-stack. If nothing else, use this package JSON file. I picked all the dependencies to exactly the same versions I used while creating this course. So if you plan to follow along with this course on your machine, which is always a good idea, copy this package JSON file into your project folder and run npm install. That will ensure that you're using exactly the same versions that I used throughout this course. Once you feel that you understand the concepts that I introduce to you, you can always upgrade to the latest versions then. Otherwise it might just be too much to handle at the same time. If you still get stuck, please feel free to chat with me on this course's discussion panel. I usually answer quite promptly and would love connecting with you. In fact, even if you aren't stuck drop me a message, I would love to chat. Let's get going on the stack already.

Environment and Tools
Introduction
In this module we are going to take a look at setting up an awesome environment for working with React. We're going to rely heavily on webpack throughout this course and this module quickly introduces you to it. We then configure it to transpile our JavaScript files using Babel, giving us access to a whole bunch of cool ES6 and even ES7 features. We add some React code to the mix, this is a React course after all, and I show you how to get your JSX compiled correctly. Webpack has loads of benefits, but the most mind blowing is the fact that you can hot swap your React components without reloading the whole page. I'll show you how to configure webpack to get this behavior for React apps. Another impressive thing about webpack is that it's not only for JavaScript, you can also pull CSS and SASS code into your bundle, just as you would JavaScript. I'll show you how to do this as well.

Webpack Basics
Let's get the basic structure for our project in place. We do this by simply creating a new directory, which I call react-stack, and then cd'ing into it. We're going to use npm to install our dependencies, even libraries that we plan to use only on the front end. We're not going to use Bower at all, only npm. So let's just run npm init so that we've got a package JSON file. I'm just accepting all the defaults. We're not going to publish this as a package, so it doesn't really matter. Okay, now I can install webpack, passing the save option to ensure that the dependency gets recorded in the package JSON file. Now that we're got webpack installed, let's open our directory with atom. You can use any text editor you like or IDE, whatever you prefer. Let's create two script files here in the route folder. The first one I call script1. js, then I create another one and call it, you guessed it, script2. js. Expand that. In script1 we use common js to make the default export of this file a string, something simple, hi there from module 1. This is important, we're using common js in code that I plan to send to the browser. That's what webpack gives us, a packaging system based on modules. We got to script2 and create a message variable. To this variable we assign the result of requiring script1. Now that we have the message available, let's just write it onto the document, document. write(message). Okay, in order to package this code for consumption by a browser we need to tell webpack that we want to create a bundle that includes these files. We do this by creating a webpack configuration file. The default file it looks for is called webpack. config. js. Webpack expects this file to export an update containing the packing config. So we make a default export by typing module. exports and assigning an empty object literal to that. The first attribute we specify is called entry. Entry contains all the inputs for your packages. Each package you want to produce should have an attribute on entry. We're going to create a main package and we use an array to specify that this package should include script1. js and then script2. js. We use relative paths _____ because it needs to know where these files live in relation to the app route folder, which is where we run webpack from. Now that we've defined our inputs on the entry module, we move onto the output definition by adding an output attribute. You can be more explicit here, but we're opting to use a convention that takes the name of the bundle in entry as the file name for the output. This we do by specifying the variable name surrounded with square brackets over here. Okay, so that's the simplest webpack config ever. Let's go to the command line. Here we run the webpack command and you can see that it took script1 and script2 and emitted public/main. js, which is exactly what we wanted. Let's open up this generated file quickly, just for interests sake. It looks like _____, doesn't it? Okay, let's use this file and see what happens. In the route we create an index. html file and in here I just create a stock standard HTML document. Just before the body close I add a script element and set the source to our generated file at public/main. js, close that script tag off. We're going to look at setting up a dev server later on in this module, but for now let's just host it using python's web server module. To do this we type python -m SimpleHTTPServer. Now that we've got that running, let's head it up in the browser. Ah, it seems to be working. This looks boring, I know, but a lot is happening under the hood. We're using common js module syntax and it's generating browser friendly code for us in the form of one file. What this means is that we really don't need Bower anymore. We can rely purely on npm.

ESNext with Webpack and Babel
We're also going to rely heavily on ES6 and even ES7 features throughout this course, so we need a way to transpile to ES5 to ensure that we can run our code in a browser. Luckily, this is quite easy to set up with Babel and webpack. Babel is the best js transpiler out there and it's super easy to configure. Let's get it up and running quickly. To make Babel work with webpack we're going to install the Babel loader module. The webpack loader is sort of like a pipeline component, which you can string together in serial to transform content from the one format to the other. Don't worry, you'll see what I mean soon enough. So in terminal we install Babel loader. I'm always passing this --save flag in here to ensure that we save the dependency to the package JSON file. Now that we've got the Babel loader package installed, we open the webpack. config file in atom to set it up. To set up our transformation pipelines you need to add a module attribute to the config. On the module we add a loaders attribute and set that to an array. Each transformation pipeline will have an object in this array. To configure out Babel transpilation pipeline, we first create a test attribute, which is what webpack uses to figure out whether the file, that's required through common js module syntax, should go through this pipeline. As its value, we provide a regex pattern that matches the file name. In our case, we want it to execute for any file with a. js extension. Next up, we add an exclude attribute and specify a regex value for node_modules. We need to do this to ensure that this pipeline doesn't execute for all the modules we'll require from there. We want it to be used only on our custom code. Lastly, we specify that we want the Babel loader to act when we require files that get passed our test and exclusion rules. To test this out, let's go and add some ES6 code to one of our scripts. In script2 I'm just changing this document right over here to user string template. So let's wrap that with a special quote characters and add a message in front here. This will be formatted with ES6. And then we use the dollar brace syntax to interpolate the message variable at this spot. Okay, now we need to run webpack again to compile our bundle. Let's see if that worked in the browser. Yes it did work.

Using React with Webpack
Now we get add React to the mix. This is a React course after all. On terminal we install React using npm. See what I mean with no Bower? Because webpack supports common js we can easily use npm packages in our browser based apps. Now that we've got that installed, let's add some structure to our app. I'm creating a source folder where we'll put everything that needs to go through webpack. All our js and SASS files will live in here. Now I'm creating a components folder. This will house all of our React components. And in here I create a file called App. jsx. This will contain our first React component. Because we've configured the Babel loader in our app, we can use ES6 module syntax to pull in React. We do this by stating that we want to import onto a variable called React the default export from the React module. This will look for a React package in the node modules directory. There are two distinct ways to create React components when you have ES6 available to you. The one is the more old school way, which is to call the createClass function on the React module and pass in object literal to that. The other is what we'll use, which is to define an ES6 class and extending from react. component. When we use ES6 classes for defining React components, we need to always make sure that we provide a constructor that calls the super constructor first thing. Usually I would also add a props argument, which I would pass onto the super constructor, but I know this going to be my route component, so I'm not doing that for this one. Another thing that's important to do in the constructor is setting up the default state for the component. We do that by just setting a variable called state onto the component instance and specifying the state variables in there. For now, let's just add a state variable called messages, which we assign to array. In this array we just add some strings for messages, the first one we set as something like, hi there how are you? And another one to something like, I am fine, how are you? As if anyone would talk complete sentences in a chat app these days. Cool. Now we've got the constructor out of the way. Let's add a render method to this component. Let's create an element for each message on our state. To do this in React, you create an array of elements, which you can reference later on. We declared a variable called messageNodes. To give this a value, we start mapping over the messages variable on state. Note that I'm using an ES6 arrow function for the callback to map. I can do this confidently because we're using Babel. We want to generate an element for each item in this array. So in our callback function we type return and add some parenthesis for our markup. I like doing this because it makes it clearer to me where the jsx markup begins and where it ends. For each message we want to return a div with a message as its inner text. We close off that div. Now that we've got an array of message div elements, we can build up and return the root element which we want to return from render. For that we specify another div and its children we specify that we want the messageNodes. Render should always return only one element, that's why we're wrapping message nodes in another div before returning it. Now we use the export keyword to make this component the default export of this file. Okay so we've created a React component. We still need to instantiate that component and add it to the DOM _____. We create a fill called main. js and in this file, like we did before, let's import React from the React module. This time we'll say import the App component from App. jsx, which we just created. Now we call React. render and pass it some markup to render, in this case an instance of our App component. We also pass a DOM element where we want the marker to be added to. In this case we use the getElementById method to get a div with an Id of container. We need to create that div though, and this we do in the index HTML file. Let's add it as the first element in body, so just a div with an id of container. Let's close that off. Now we define our App component in a file called App. jsx, so with the jsx extension, which I guess I could have done for the main. js file too because it also contains jsx. But I wanted to illustrate how we can adapt the webpack config to target both types of files with the same loader. Down here in the test regex for the Babel loader, we just add an x to the end here in order to match jsx files. Another thing we should do in the config is to remove these inputs over here and replace that with main. js in the source folder. Oh, wait a minute, that regex won't work. We actually need to add a question mark after the x to match both jsx and js files. In order to enable the features in Babel, we quickly create a babelrc. file and in here we specify that we want stage to be 0. Like I said, this just enables all features in Babel giving us all that nice ES7 sugar. Okay, back in the terminal we quickly run the webpack command to rebuild our bundle. Now when we refresh our page, cool it worked. We've got our React component rendering using webpack as the packager and compiler.

Debugging and Reloading
We've got all sorts of magic happening here, jsx, ES6, and even ES7 features. You might be wondering though, how would that look when it's synced to the browser? Let's take a quick look. I'll put a breakpoint in the render function over here and save the file. Now let's refresh in the browser and take a look. As you can see, this looks pretty dodgy. We definitely wouldn't want to debug this. Luckily we can quickly enable source maps. This is quite easy to do. At the route of our webpack config we add a property called devtool. Yeah, I know, it's a bit of a generic attribute name, but this is what we use to configure how webpack bundles and executes the code sent to the browser. The option we're looking for is eval-source-map. This option is quite fast and has the added benefit of generating source maps, which allows you to better debug the code in the browser. Okay let's hit that up in the browser now that we can expect source maps. That's much better. This allows us to step through the code that we wrote and understood. And to show you that it's useful, let's step over this and down here in the console we type messageNodes to see what that returns. An array of React elements. So cool, we can step through our own code and inspect variables. We've come to expect auto reload from most web frameworks, so let's set that up. Luckily we can install the webpack-dev-server module, which will sort this problem out for us. So we're not even going to be using Grunt or Gulp, just webpack. To install we use npm again. This time with a -g flag to install it globally. Wait for that to install. Okay cool. Before we'll use webpack-dev-server to serve our code, we also install another module for auto reloading, which will configure soon. This module is called react-hot-loader, which allows us to do something called hot module replacement, which is even better than just _____ loading the whole app on a change. I'll show you how to configure it soon enough. First we just run the webpack-dev-server and see what it gives us. I'm passing it a progress flag and also colors to make their output a bit easier to read. Now we see a percentage of the packaging process and in the end it shows us that bundle is valid. Okay cool. Now let's make a change to our jsx file by just adding some text to this first message. This would have usually required us to run the webpack command again to recompile the package. And now that we refresh in the browser, you can see that it's always recompiled the file for us without us needing to run the command and it's showing us the new message. Now we're going to do some more advanced webpack config, but with a good goal, auto reloading of the app when we make changes, and not just any type of reloading, hot reloading. You'll see what I mean soon enough. At the top of the file we require the path module to enable us to work properly with relative parts in our packaging environment. Remember the code in this file won't be seen to the client. This is used purely for our bold and would typically run only on the development machine and bold server. Now we require the webpack module and get that onto a local variable called webpack. This part you should follow along with exactly. Make one mistake and your auto reload probably won't work properly. I must admit I found the documentation a bit anemic when I first had to figure this out. Once I got it working I was still a bit unsure of why everything is required. I'm hoping that down the line webpack configuration becomes a bit clearer and beta documented, but for now just follow along carefully and hopefully your setup will work like mine in the end. If you run into issues, remember you can always download the associated source files for this module and use that as a base for you own config. For auto reloading to work, we also need to send some additional code down in the bundle. First we add the webpack-dev-server client folder in here, parameterized with the URL it needs to talk to the server, which in our case is the webpack-dev-server default, localized on port 8080. We also need to add another one, webpack/hot/only-dev-server. See I told you that it's a bit obscure and difficult to figure out, but it does work well in the end and it's totally worth its pain. Okay, another thing I found I had to do to get it working is add a path variable to the output config. Here we use the path module to get the path to the current directory and public combined. We also need to specify a publicPath attribute. This is the relative path that these files will be hosted on in the web server, so you can have the path where the web server will host at be different than the actual path on the file system, which seems very useful to me. To get hot reloading working, we need to add a plugin section and in here add an instance of the HotModuleReplacementPlugin, and also an instance of the NoErrorsPlugin, which just ensures that no packages are sent to the browser that had errors while being compiled. We don't want to confuse the hot reloader to reload when we add compilation issues. Another thing in the config, let's change our matching rules on the jsx Babel pipeline to work with an include rather than just excluding node modules. We use path. join again to say that we only want to match files in our source folder with a Babel loader. We also add to the pipeline now. We don't want to run it only through Babel, but also through the react-hot loader, this adds some code to the compile jsx code, which hooks into changes on the server and hot swaps the component to the new definition. Webpack loaders executes from right to left when delimited using an exclamation mark. So it'll first compile the code with Babel, then include the hot reloading logic afterwards for the result. The only example that I could get working on my machine also used a node file to host it and called it into the webpack-dev-server module for hot reloading, and we'll do the same for now. We create a file called server. js. In here we require webpack again, and now we also require webpack-dev-server. And to get a hold of the config we configured just a few seconds ago, we require that config onto a variable called, you guessed it, config. Now we instantiate a new web server passing it a webpack instance configured without config. We add an object literal for our additional config. Again we're faced with a bit weirdness here. We need to copy the public path from the config onto this literal. I would have expected it to use the value we've already got in config and passed to the webpack constructor, but like I said, let's hope for improvements in configuration over time. We specify that we want hot to be true, meaning hot reloading, we also need to sit historyFallback to true. Lastly we tell this to listen on port 8080. Whew, from almost no config for full ES6 and ES7 support, React jsx compilation and packaging to a bunch of weird config entries for hot reloading. Well, is it worth it? Let's take a look. In the shell we first need to link the webpack-dev-server we installed globally and make it available in our local node modules. Now we can run the command node server to host our app with webpack-dev-server and hot reloading. Oh man, I see I've made a mistake in the webpack config. Luckily it gives us good feedback. Let's go check it out quickly. Yeah, I missed an l over here in the main entry, let me fix that quickly. Okay let's run it again. Cool. It's up and running. You still have to restart this process when you make changes to the webpack config file. We'll have hot reloading for anything in the source folder though. Okay, the moment of truth. Can we make a change to the app component and have it reload in the browser? Let's see. We add a style attribute onto the devs we used for each message and oh, it seems like I've made a mistake somewhere. I've looked around in the meanwhile and found the issue. In the webpack config I specify an output path but duplicate it in the file name, so I need to remove public over here. Now when we go back to the browser and resume this breakpoint, it seems like it's worked, but let's try it again. This time we change it to green and save. Oh it's definitely worked. But was introducing all that config weirdness worth just that? Well there's something happening here, which I haven't illustrated well yet, and that's that the modules are hot swapped. Let me show you what I mean. I'm changing the DOM with debug tools to add an attribute onto this element over here. Cool. Now we've got a test equals true attribute onto this dev element, which was generated by our React component. Okay, so let's go back to the code again and change this color again. And back in the browser, you can see that the text is now blue, but even more impressive, the attribute we added with dev tools is still there. That means that it changed just the color selectively. Meaning all the state and everything remained. That's pretty impressive and in my opinion it's totally worth the configuration _____ we had to go through to get it working.

SASS Compilation
We've got a really cool setup so far, but webpack is about more than just compiling JavaScript, you can also use it to make CSS part of your bundle and not only _____ CSS, but also stuff like SASS. Although we won't be using it a lot in the rest of this course, I quickly want to show you how we can pull in SASS. I just think it's so darn impressive that it works that it would be a shame to now show you how cool it is. Previously we installed the Babel loader, now we install all the loaders we'll need to do a full SASS load, including node-sass. No dependencies to Ruby SASS for us. Okay so all our loaders in node-sass installed successfully. Now it's time to configure the SASS loader so that we can pull SASS files into our bundle. In the loader section we add a new object, for its test we specify that we want to match files with scss extensions. We also say that we want only this to execute for SASS files in our source folder and now we use the exclamation delimiter syntax to specify that we want the style loader to execute last. Before that, the CSS loader, and even before that, the sass loader. To test our new loader setup, we create an scss file in the source folder called main. scss. In here we declare a variable called color and set it to red and we add a rule that sets the color of font in the body to the color variable. But how will our app know to pull in this SASS? Do we pull it in in index HTML? No. We require it here in our main js file. Webpack will see that we're requiring a file that it's been configured for and send that file through the correct sequence of loaders. This results in JavaScript that it adds to the bundle. So yes, your CSS will be going down inside of JavaScript. I found this a bit weird in the beginning, sending CSS down with JavaScript, but I must say I got used to it very quickly. And I'm starting to prefer it actually. Let's reload in the browser. The text seems pretty red to me. Now let's change this color to blue over here and check the browser again. Yep, blue.

Recap
Let's do a quick recap. With webpack we can just use the required keyword and it builds up a package for us that we can run in the browser. This not only works for JavaScript files, but we can even require CSS code. This leaves us with one file to include in the browser and the ability to componentized our code way better. Because a component can even require its own CSS, which doesn't need to be pulled in somewhere else, like an HTML file. With webpack we used loaders that we install with npm and string them together in pipelines to process files according to their type. I'm sure you'll agree that the hot reloading is a huge boost to productivity. The shorter the feedback loop, the better for your flow, and you can't really get a shorter feedback loop than this. A very important part of this module was to show you how easily we could configure full support for ES6 and even ES7 features by using Babel in concert with webpack. The code throughout the rest of this course will rely heavily on this aspect.

Styling with Material-UI
Introduction
We've set up a pretty impressive stack for working with React. Now we're going to focus on making our app look impressive too. And what better way of sprucing up our app than using a material design framework. Material design is a visual language created and maintained by Google. It's quite popular and has spawned many community driven libraries that support it. There are even a few different ones out there to support React itself. The one we are going to use is material-UI. Material-UI is quite mature as a rich component library, supports themes, and has excellent documentation and examples. Just have a look at this excellent documentation site of theirs. As you can see, it's got examples with code samples right next to it. In this module we're going to take our sample chat app, which at the end of the previous module looked like this, some ugly blue text, and make it look like this, which I'm sure you'll agree looks much, much better. To achieve this, we'll chop up what we've done so far into components. This is always a good idea when working with React. We don't want to keep on building out our whole app in just one component, we'll install material-UI and start integrating it with our code. We'll also set up a theme using its theme manager. As soon as we've got material-UI integrated, we're going to style our existing message list to use material-UI components. We'll define some new components to introduce a channel list and we'll style that with the UI material, followed by a message box component, also styled with material-UI. After this module you'll know how to get material-UI installed and how to define and implement awesome looking React components with it.

Better Components
Before we can go on doing anything else, we need to break our app into better components. Currently we have everything in one component. This is not a good idea. It's all in one file. It's basically what you see on the left here. With React, it's good practice to structure your app in granular components. What we're going to do now is practice _____ to components like you see on the right here. We're still going to have our root app component, but we're also going to add a message list component and a message component, which will repeat inside of the message list. In atom I add a new file in components and call it MessageList. jsx. First thing we do in here is to import React using the ES6 module syntax by typing import React from react. Now let's move on to defining a class called MessageList. We let this class extend from React. Component. The first thing we always do when defining a React. Component is to add a constructor, and add a props argument to this constructor, we call this super constructor, passing props through that. Usually after doing this we want to set up the default state for the component. For the MessageList, we've already got data, don't we? We go to the app. jsx file and cut it from there, pasting it into the MessageList component's constructor instead. That's our constructor for now. We move onto defining the render method for this component. We've also got the code for this already defined. We go back to the app. jsx file and copy the code from this random method over here and paste it into the MessageList component's render function. Lastly, we export the MessageList component class as the default for this module. Cool, we are back to the app file. And here I quickly clear out the render method. We want to render the newly created MessageList component we just defined and before we can do that, we need to pull it in first. This we do by importing it here at the top of the file by typing import MessageList from and then providing the relative path to our MessageList component. Now we can use the MessageList in our render method. In fact, we're just going to return it as the root component for now. Let's check this out in the browser to see what it looks like. It looks like we didn't break anything and our components are rendering as we planned. Cool. Let's create a component that we'll use for each message. I'm creating a message. jsx file here in the components folder. First thing we do in here is import React again. And now we start defining a new React component by creating a class called Message and extending from the React. Component class. As you know by now, I always like to create the constructor first with the props argument and we need to call the super constructor with that. We add a render method and from here we want to return a div and this div should contain the message attribute that we get on this. props. This is set on this instance by passing props to this super constructor over here. This is it. Let's export this component as the default for this module. Okey-dokey, now we go back to the message list component to use this component for each message in the list. At the top we import the message component, exactly like we did earlier in the app root component when we pulled in the MessageList. In the render function we want to use the message component instead of the div here, so we remove this div and return a message instance instead, making sure to set a message prop on it to which we pass the current message in the map. And as you can see, when we have a look in the browser, it's still working and looking as it should. We're getting ready to add material-UI to the mix and before we do that, I just want to get rid of this ugly looking blue text we defined earlier when we showcased webpack's SASS integration. Okay cool. We've got components now and we're ready to pull in material-UI.

Install and Configure Material-UI
Installing material-UI is super easy. As with all our other dependencies, we install it using npm. So we go to the command line, type npm i material-UI and passing the save flag as usual. Now that we've got the module installed, let's put it into our code. We're going to set it up in the root component of our app in app. jsx. Up here we import it onto a variable called mui from the material-UI module. We want to set up a theme a bit later on, so we declare a variable called ThemeManager and assign that to a new ThemeManager object from the material-UI module. In order to specify colors for our theme, we assign a variable called colors to the material-UI's color object. In the constructor, we use the ThemeManager to define our color palette. By calling the setPalette method on it. This method takes an object literal. Here we can specify different colors for our various labels of primary colors. The first one is called primary1Color, which we set to a hue of blue. We duplicate that and start specifying more primarily colors for this theme. We can choose any mixture of colors here, but let's stick to different hues of blue. As you can see here on material-UI site in the customization section, we've got quite a variety of colors to choose from with easy to understand color codes. We can also specify different accent colors, but we'll define only one for now, a nice and bright pink. Okay to make this theme available to all the components in this app, we need to use the React. Component's context and add the theme to it. To declare which variables are available on the context, we add a static property to this component. This is ES7 code and we can do this because we configured Babel in the previous module. Basically, we need to specify a property on this for each variable we want to make available on the context. In our case, we want the theme variable on the context and we specify that it's an object. This just declares that we are sticking this on the childContext. We're not actually setting it on the context yet. We set it on the context by adding a method to this component called getChildContext. From here we return an object with the same attribute as we declared earlier and set that to the result of calling the getCurrentTheme method on the ThemeManager. Okay, now that we've integrated material-UI into our code and configured a theme, we can start referencing it's components. Up here we create a variable called AppBar and assign that to the AppBar component from the material-UI module. Now let's use this component in the render method. Because our structure is getting a bit more complicated than just a MessageList, we need to add a container div. Remember, in a React component we can only return one root element from the render method. In this root div we specify that we want an instance of the AppBar component and we want it to have the title of Awesome Chat App. We close that off and also move the MessageList component into the root element. Let's check that out in the browser. Cool, it's looking good. I don't like this margin over here though, let's fix that. We go to the main SASS file and for the body specify a margin of 0. Check that out. Cool. Looks like the annoying margin is gone. Our nav bar is taking up all the space without white space around it.

Styling the Message List
Now we're going to make our MessageList look a bit more respectable by using material-UI components and adding some style to it. In the MessageList component, we import the material-UI module at the top here. Now we make use of object destructuring to pull in the card and list components from the material-UI module. And down here in render, we add a Card instance and inside of this Card we specify that we want a List instance. Inside of this List we specify that we want to render the messageNodes. Okay, what does that look like in the browser? Let's take a look. Looks like we've got a card here, as you can see by the shadow over here. Okay because we've specified that we want a list and specified that we want it populated with a bunch of message elements, we need to modify the message component to use the create material-UI components too. We open the message component and here we import the material-UI module again. Again we use destructuring, but this time we pull in only the ListItem component from the material-UI module. You might be thinking that it looks a bit weird to use destructuring with only one variable, but we're going to use some more later on. Down here in render, we add a ListItem instance and populate it with the binding to the message on props, close that off. Let's see what it looks like in the browser. That looks much better. The list should look better with avatars on the left each message though. Let's go and hard code my avatar in there, so that you can get a feeling of how powerful the UI material framework is. We change this line too, also pulling the avatar component, and down here in render we adapt this ListItem instance by adding a leftAvatar property. We use braces here in order to specify and Avatar instance and I'm pasting my Google profile pic, which I conveniently put on the clipboard earlier. Now I just close up this tag over here. Okay, so we're specifying that we want a ListItem and on that we specify leftAvatar property, which we pass an instance of material-UI's avatar component. See it's pretty cool to compose your UI with components. It's starting to take shape quite nicely, don't you think?

The Channel List
Let's elaborate on the app structure by adding a list of chat channels to the UI. As you can see here in the finished step we're working towards, the chat channels will be used to group messages in our app. This we do by adding a new file to the components folder called ChannelList. jsx. The ChannelList is very similar to the MessageList, so let's copy the contents from here in the MessageList component and place that into the ChannelList file. I'll come back to this file soon. First we create another file in the components folder called Channel. jsx. This file we model from the message component. So we open that, copy the contents over here, and paste it into Channel. jsx. To change this to our new component we'll have to make sure that we reference the correct components. We need to change the class name and specify the updated definition in its render method. First we update the reference here, we won't be using an avatar, so we remove that. We change the class name to Channel up here and down here. We get rid of this avatar over here. Now that we've got a clean list item, we bind it to a property called channel. In the ChannelList component we need to do a few things. We want to change the component class name, change the default state of container list of channels instead, and import the channel component instead of the message component. We want to bind to the channel component here in the loop. First we change the class name to ChannelList up here and down here at the export. Up here we import the channel component instead. We move on to changing the state of container channels value and change these messages to really mind blowing original channel names, Dogs and Cats. In render we rename this collection of elements to channelNodes. We change this map statement to map over the channels variable and change the iterator parameter to channel. Now we return a channel instance from here and set a channel property on it, which we get from the map iterator functions parameter. Down here in the list we bind the channelNodes variable instead. Oh I see I made a mistake here at the top. I neglected to rename this variable here to channel. Now we can pull our ChannelList component into the app. We open up the App component and duplicate this line where we imported the MessageList. We adapt it to pull in the ChannelList component we just defined. Now we can use it down here in the render method, right below MessageList we add a ChannelList instance. Okay let's check that out in the browser. Looking good. Well, at least it's working. Let's go and fix the layout so that these items are rendered next to each other horizontally. In the App component we add a style attribute onto the root element over here. We want to make this element display as a flex box so that we can specify that we want it's _____ to be laid out horizontally. And now we specify that we want the flexFlow to be a row. Also want this container to be constrained to 1200 pixels and I specify a width of 100% to ensure that it takes up all the space up to the desired max. Now I'm using a margin alter rule to specify that I want 30 pixels at the top and bottom, but I have the div auto centered horizontally. We don't want the AppBar to be included in this row, so we move it out to the top. But now we don't have the root container anymore, which we need to return from render. So I add a wrapper div around all of this, _____ to keep it nice and clean. Let's have a look in the browser. Hmm, it looks a bit weird. See, it's all squished up on the left here and we actually want it to be spread out over 1200 pixels. To fix this, we need to add flexGrow rules on the message and ChannelList components. In the ChannelList we add a style attribute on the Card instance and here we specify that we want a flexGrow value of 1. In the MessageList component we do the same. We add a style attribute, but this time we specify that we want the flexGrow to have a value of 2. Basically we want double the flexGrow value of the ChannelList. It works with relative ratios. So this tells it that we want the MessageList to take up twice the space of the ChannelList. Let's check that out in the browser. Looks better, doesn't it? But I'd like some space over here between the two lists. To get this, I add a marginLeft on the message list. That looks pretty good.

The Message Box
We've got one more component to define. We need to add the ability to the UI to allow a user to type a new chat message. We add a new file to the components folder and call this one MessageBox. jsx. We're going to model it off the Channel component we created earlier. So we open the Channel component, copy its contents, and paste it here in the MessageBox file. We change the class name to MessageBox and pull in the Card component from the material-UI module. Here in render we add a Card instance. Now we close that off. Inside of the Card we add a good old textarea instance and close that. Before we style that any further, let's build a MessageBox component into the app first. In the app file we duplicate this reference over here and adapt it to pulling the MessageBox component instead. I need to add the MessageBox component below this flexBox over here. Let's have a look at that. It looks horrible. Okay, time to start on the MessageBox component. I add a style attribute on here. Firstly let's add a maxWidth on here of 1200 pixels and give it the same margin rule as we did earlier for the container of the message and ChannelLists. We'll also give it a generous amount of padding. Okay that looks better. Now for the textarea styling. I give it a width of 100% and I want it to have a lighter border. For this I specify a border color rule with a gray color code. I don't want those ugly _____, so we specify a resize none rule. We give it some rounded corners, I think about 3 pixels should do it. Let's give it a bit of height with a minHeight value of 50. When using inline style like this, we can specify integer values and defaults at 2 pixels for us. I want a lighter color for the text, a grayish color is fine for this. Give it a fontSize of 14. Enough with this weird little rule to prevent the ugly highlight when you tap into the field. Outline: Auto 0px. Let's check that out. Looking pretty good. As you can see, this looks a bit better than when we started out with this module and we didn't even have to do much to get this polished look.

Recap
Let's do a quick recap shall we? In this module we pulled in material-UI to give our app a polished Google Material look, material-UIs mature are quite popular. We found that it's quite nice working with material-UI as it's totally component based. We didn't need to pull in a whole bunch of different style files and such, we used it just as we would use our own React components. Material-UI is extremely well documented and comes with a ton of examples. Material-UI also has a bunch of components, most with flexible configuration options. You'll be able to code most of your apps using only the default components. Where to looking at setting up a theme, which material-UI provides excellent support for. Even having a whole list of predefined colors which are documented on its site. We styled our material-UI instances with inline styles in this module and I would advise you to do the same on your project. I've tried styling it using a separate style sheet, but in the end settled for inline styles instead, it resulted in way less issues and fits better with a component style of coding with React. In the next module we're going to change our app to get dynamic data from the awesome Firebase servers, after which I'll show you how to take your app to the next level by implementing the flex pattern.

Using Firebase
Introduction
Hi. In this module we're going to start adding some dynamic data to our app. Sounds boring? No way, because we're going to use the amazing Firebase service as the data store. I'll give you a bit of introduction to the Firebase. We're going to upload some test data and I'll show you how to get this test data loaded into our app. We'll enrich our messageBox component and send a new message to Firebase when the user presses Enter. I'll show you a better way later on in this module to work with our Firebase data, a way that enables your app to add a new message to the UI as it's added to the data store. Lastly, I'll quickly show you how easy it is to remove a message from the MessageList component in our app as soon as it's removed from the Firebase database. Let me introduce you to Firebase quickly. The company launched the first version of the product in the end of 2011 and was acquired by Google in October 2014. They've got really impressive numbers. In terms of developers on the platform, in mid of August 2015 they were hovering around 230, 000. That's impressive. I didn't know there were so many of us developers out there. They say on their blog that they had a celebration moment in 2014 when they reached 1 million concurrent connections on their platform. Wow. I guess getting 1 million concurrents on their platform isn't even such a big deal a year later on. But what is Firebase and why should we care? Well, Firebase is a realtime data service. It's not just a database, nor is it just an API. Think of it as a publish subscribe implementation, pubsub for short, in the cloud. Gone are the days that you need to build a back end for each and every project. There will be certain projects that won't work on Firebase. But I find that Firebase is a good place to start when you want to build a proof of concept and it's a great _____ to stay on if your app is of a realtime nature and you expect a lot of concurrent users. You can also use a mixture where you use Firebase only for the realtime event aspect, together with your own bespoke API that gives you more control and server side processing. But what do I mean with realtime? Let's say you've got your app and you've decided to use Firebase for your realtime backend API. Your app subscribes to a location in the Firebase db, this is called a Firebase reference, and it uses web sockets to let your app know of changes. When a new document gets inserted, updated, or deleted at the location you subscribe to, your app receives a push through the WebSocket channel containing the change, allowing your app to respond in nearly realtime. A Firebase app status store is actually one huge document. There are no collections or even tables. It's a bit weird, but I'll talk a bit more about this decision soon. Each Firebase app has a URL, which you can specify parts of when you set up the app. I'm going to show you how to set up an app a bit later on in this module. You use the Firebase API client to subscribe to a location in the apps data tree. In this case we point at the reference to the messages node. This is called a Firebase reference, a WebSocket based event listener that receives events when something changes at the location you subscribe to. Remember that I said that there are no collections or tables? Well, it gets even weirder. It doesn't use arrays either. This is something that I've struggled with in the past. When unbounded states, which we usually want to store in arrays are stored in the form of an object with each item in the set having a key and a value. I struggled with it because intuitively I want to work with arrays. Over time though I have started to buy into it more and more, and I think I'm almost ready to say that I'm converted. Meaning, I think it's almost always a good idea to store your sets with key value pairs where the keys are unique, like with JavaScript objects. That's enough blabbing for now. Let's look at some code and make our chat app work with Firebase data.

Installation and Configuration
Before we can code against Firebase we need to create a Firebase app. Don't worry, it's free. You'll only start paying when you reach higher concurrent connections or require more storage or want a custom domain name. To create that, you need to register a Firebase account at Firebase. com. They have a really cool developer free new website with insanely useful quickstart guides for various platforms, easy access to libraries, a bunch of examples, and recipes for common scenarios. I've already registered my account and I just logged in. You can see I've got an existing app over here, but I want to create a new one for our app, so I fill in these fields over here. For the app name I specify react-stack and it uses that to come up with the URL too. Pretty nifty. Okay, now that it's created the app, we click on Manage App over here. This meets us with a very useful view of our database, which we'll use a bit more later on. You can add, edit, and delete documents in here as well as import and export data. I've prepared the file with some test data. This is the file we're going to import. It's, as you can see, an object and it's got a messages property, which is another object. For each message, we have a key value pair. You can see that I used 0 and 1 for the keys as an array would. I did this for a reason that you'll see later on. So in the Firebase console where we just created our new app, I click on the Import Data button to import the test data I've just showed you. I select this file and it uploads it to Firebase. Now we can see our test data here in the nifty tree view. Great. It's got all our data correctly imported. To use Firebase from our app, we install the Firebase node package by typing npm i firebase. Now that we've installed that we quickly install lodash too. We're going to need it a bit later on. If you haven't worked with lodash before, you should. Anybody working with any form of JavaScript can benefit from using a library like lodash, which gives you a bunch of higher order functions to work with all kinds of structures and data in JavaScript. It also helps us to convert objects into an array format quite easily, which we'll do often throughout this course. One last npm package we want to install is called trim. This we'll use a bit later on when we want to trim our messages from leading and trailing whitespace before sending it to Firebase. In our code, we open up the MessageList file and at the top here ensure that we import Firebase from the Firebase module. Later on we'll also be using the lodash module, so let's import that. Now here in the constructor where we've hard coded our messages, we set this to an empty array. You might be wondering why I'm setting it to an array after going on for so long about how much better objects are for storing sets. I just wanted to show you something nifty quickly. When we specify our object with keys that could be converted into zero based sequence of numbers, like we've got in our sample data that I uploaded earlier, Firebase will convert it to an array for you. We're going to work with objects soon after that, but I just wanted to take this opportunity to show you this option first. Now that we've got our default state defined, let's define a Firebase reference and store it on our component. We specify a URL to the node in the database that we are interested in. In our case, the URL is react-stack. firebaseio. com/messages. And on this reference, we use the once keyword to tell it that we are interested in receiving this data only once and not again when it changes. I want to show you the simplest interaction first before we start making it a bit more realtime. So to this once, we say that we are interested in the whole value for this node we specified here and we pass it a callback function, which will get called once the data is brought back from Firebase. In this callback we start assigning a variable called messages and to get the value we need to call the. val function on the dataSnapshot, as the dataSnapshot contains other information about the event and not only the data itself. Now that we've got the messages we just do the usual React thing by calling setState on the React component. We can use this here and trust that it will resolve to the component itself even though we are in a callback function. That's because we are using ES6 error functions, which automatically ties the function app with the classes scope. And that's it. That's all that's required to get the data from Firebase and render it in our app. Let's have a look in the browser. It's looking good.

Working with Objects Instead of Arrays
Now remember that I said that Firebase doesn't really support arrays? Even though we're using an array over here and setting it directly from the val call on the data snapshot, that's because Firebase looks at the keys and then converts it to an array when it can. We don't really want to stick to that though. In fact, in Firebase documentation they advise you to use their generated IDs and to steer clear from arrays. I want to show you quickly what will happen when we add a property to our messagesNode that doesn't conform to an array index. This will also give me a chance to show you how easy it is to edit data through the tree view in the Firebase dashboard. To add a new node, we just click on this plus icon here on the messagesNode. Now we get to specify a property name over here. I'll just choose new_msg and instead of specifying a value as a string or number, we click on this add button over here, which tells it that we want to specify a child name, here we type message as the property name and for its value we specify a string. Hi there, this is a new message. Okay let's open up our app in the browser with dev tools open so that we can see what it brings back from the server. I've set up a breakpoint on the line where we've already pulled the message variable from the data snapshot. We hover over messages here. As you can see, this is not an array anymore, it's now an object. This is because Firebase found that it contained a key that it can't use as an index to an array, so it passed it to an object instead. Resume that even though, yes, we got an error, because our code expected an array, as you can see by this error over here. Let's fix that. Let's make our code expect an object instead and bind the list against the object. So what we're going to do is use lodash to pull out each value from this object and create any array containing each value in this same sequence that it was found on the object. We start by renaming messages here to messagesVal, which now contains the object we saw earlier in the Chrome dev tool. We declare a new messages variable and assign that to the result of wrapping lodash around the messages object. This syntax of lodash immediately starts a chain allowing us to continue adding lodash functions to the chain until we call value. Sort of like when you work with link and C#. The first thing we add to the chain is the keys function, which will result in an array of all the keys in the object. Next we add map, which is used to project an object for each item in a collection. It's similar to select in link. Map expects a callback function, which we specify using the arrow syntax. It's good practice in functional programming to treat data as immutable. So instead of changing the object directly we create a variable called cloned and then using lodash to clone the item found on the messagesVal object with a current key in the keys array. The reason I'm going this route of working through keys first and creating a clone from each of the values through the keys is that I want access to the key for each object so that I can do this, set a key property on the cloned object to equal the key that was used on the object itself. When working with collections and binding in React, it's always advised to specify unique keys for the items and because we know the keys are unique on the objects coming back from Firebase, we can use these keys for that. Now we just return the clone. So we're following good functional practice and good React practice. Remember when we use this lodash syntax where we wrap an item immediately and then start chaining on functions, we need to call the value function in the end to tell it to start evaluating the chain. Let's test that out in the browser. Great, it worked.

Writing Data
Now I'm going to show you how to add a new child node to the Firebase reference. We're going to do this by adding functionality to our app that makes this message box functional, gather a message, and call the Firebase API with that message. So a nice mix between React and Firebase. In this messageBox component we're going to set up some default states, sync the text area with that default state by using the onChange event of the textarea and hook into when the user presses Enter, then send the message to Firebase. We specify some default state in the messageBox component's constructor. Just an object called state with message property set to an empty string. Okay, now on this textarea down here, we want to know when the field changes so that we can update our state variable to the value of the textarea. We add an onChange event on this textarea and bind it to a function called onChange. We need to use the bind keyword to bind it to this as we always need to do with React components defined with ES6 classes. We define this new function on the class called onChange, which takes an event parameter. We call the setState function and specify that we want to set the message state variable with a value which we get from the event through the target. value property. On the textarea again, we also specify that we want the value of this textarea to be equal to the message state variable. So essentially we're setting up two way data binding here. It's not really required, but I want to show you how to do it nonetheless. Next order of business is hooking into the onKeyUp event so that we know when the user presses Enter and then saving the new message to our Firebase database. We add the onKeyUp event, similar to onChange, using bind to bind the handler to the React component's _____. And now we add the function here, specifying an event parameter like we did earlier for the onChange function too. Before we code _____ this event handler, we go to the beginning of this file and pull in the trim package we installed earlier with npm on the command line because we want to use it now to trim leading and trailing whitespace from what the user typed into the message box. Okay, back in the onKeyUp handler, we use an if statement to check whether the key code on the event equals 13, which is the key code for the return key and whether the trim value is not just an empty string. If it passes our checks, we specify that we want to prevent the default action on this event, which is the correct way to stop event bubbling. Now we call setState and set the message property to an empty string to clear out the text area. This is possible now because we bound a text area value property to the message state variable a bit earlier on. And now we just log out this value on the console. So console. log, sent a new message, and we have pinned the value on the event. We close that off and check it out in the browser. I've got the console open here at the bottom. So we type test into the box over here and press Enter. Sweet. You can see that we've got the message being logged here. Let's test again (Typing). I'm so original with these test messages, aren't I? Okay so that's the React part of it. Now we want to start sending this new message through to Firebase, don't we? At the top of the messageBox component we import Firebase from the Firebase module. Now we go down to the constructor and yeah we want to set up a Firebase reference, just like we did in the messageList component earlier on. So we create a FirebaseRef instance variable and assign it to a Firebase reference, which we get by passing it the same URL we used earlier in the messageList. I've got it on the clipboard already, so I just pasted it in here. Now that we've got the reference set up, we want to use it to add messages to the messagesNode when the user presses the Enter key, and of course, we need to do this here in the onKeyUp method we created earlier. To add a new document to the location in the Firebase database where are reference points to, in our case the messagesNode, we need to call the push function on it and to this push function we want to pass a new object. Remember, we've got objects for each message in our database as we want metadata associated to each message, like the person who sent the message, the data, and so forth. We're not going to set this extra data for this particular message as we don't use it yet. We're just setting a message property and then message value that we've already got instead. Okay so let's test that out in the browser. I'm going to come up with the most original message ever, something like this is the first real message. I'm just so creative, don't you think? I should have been a copyrighter. Anyways, let's see, when I press Enter it seems like it does nothing, but that's fine, I expected that. We first need to reload the page. Okay, we've got our new message over here coming back from Firebase. It's not at the end of the list because Firebase generated an ID for this document and this ID caused this document to get positioned before the one where we created an ID manually earlier on, but we'll clean out the database a bit later on and have only items with IDs generated by Firebase. Just for kicks, we add another message, another message that would have won awards for test data if there awards for it. Press Enter, reload. Nice, it's coming back from Firebase.

Real-time Data
Firebase is realtime isn't it? We don't want to be reloading the page every time in order to see new messages, do we? Well this is ridiculously easy to fix. All we have to do is go to the messageList component. Here where we used the once function to subscribe to the Firebase data, meaning we want a snapshot after data only once and not again, we use the on keyword, which will give all the message every time there is a change, allowing us to rebind. Let's test that in the browser. We type another message, test again, and press Enter, and yes, immediately we've got the message displayed in the list here. Let's do another one. Wow! So we've got one component publishing a message to Firebase and another subscribing to the changes to the messages and rebinding when a new message comes in. These components in our app our blissfully unaware of each other, but it's still working like a charm. You can see why Firebase is so popular. But using this way, we get all the messages every time that the messages change. That's not very efficient, is it? It's a lot of unnecessary data to pass back and forth for each message. Luckily we can do it in a better way. Currently we're still morphing the object coming back from Firebase and storing it as an array on state. Let's change it to an object on state _____ there because it'll help us with the logic we're going to code up now. Now let's clear out the body of this function. On this Firebase reference, we can use a different event here. We use the child_added event. This'll get called every time our messages node in the database gets a new child node added to it. Now let's handle the scenario. The first thing we need to do is to ensure that we don't already have a message in our state with the same key. This is just a bit of defensive programming. So if our message's object on state already contains a message where this message is key, we just want to exit quickly and not handle this message. Okay, cool, now we declare a variable called msgVal and set that to the value of the message parameter to this callback. You might remember when we were still using the onValue root and expecting all the messages in this callback, we also have to call val on it to get the actual object containing all the messages, that's because there are a bunch of metadata around the event. Now that we've got this msgVal variable containing the actual message object, we set a new property on that called key. Remember, React needs every object that it binds to in a list to have a key, which helps it to do intelligent updates to the DOM. Great, now we add this object to our messages object on state using its key as the key. And because we've updated the messages variable, we quickly call setState to update the messages value. This is how React knows that it should check for possible updates to the DOM. Okay, let's close that off. Now that our messages are in an object on state instead of an array, we need to look through it differently here in render. Luckily lodash makes that super easy. What we need to do is use lodash's values function to give us all the values in the object as an array, as easy as that. So let's test that in the browser. Okay it seems our initial binding still worked fine. This means that a trigger child added for each item it already has, but more importantly when a new message gets added to the list, Firebase only passes us the new message and not the whole list, making our chat app much more efficient. Firebase has a bunch of events you can subscribe to on a reference. In this course we're only really going to be using child_added, but I thought it might be useful to show you how easy it is to handle different events using React. Let's have a look at having child_removed, meaning when items are deleted from the messages object, we use the on function again on the Firebase reference. This time though we specify that we are interested in child_removed event and specify an arrow function for the callback. We want to remove this item from our messages object on state, so we immediately get the key from the message that was deleted. Now that we've got that, we use the delete keyword, which is a standard JavaScript keyword to delete this item from our messages object. Now we call setState on our component to notify if that the message's variable has been updated and that should be it. Let's test this out in the browser. We add a new message quickly. Cool. As you can see it bound to that item in the list here, so let's delete it. We'll do this in the Firebase data console, which is terribly useful. Okay this one seems to be the right one. We click on this delete icon over here, confirm that, and go back to our app here and it's gone. So our app was notified of the removed item, it removed it from state, and rebound itself. Pretty cool. Don't believe me? Let's drag these browser windows next to each other. We've got the console on the left here and our app on the right. I add a new message through our app, going to delete this, delete it on the left here, gone. This stack is really fun to work with, I'm sure you'll agree.

Recap
Let's do a quick recap. Firebase is a realtime data service, best suited for doing pubsub type of apps. You can always use a mixture in your app where you use Firebase for the realtime part and something else where you need more control over what happens on the server. Firebase has impressive support for a huge variety of platforms, so you know it can play well not only with your reactor, but also with RS, Android, and a bunch of other web frameworks. In this module we looked at constructing a Firebase reference, which points to a specific node inside of your Firebase database. You use this reference to subscribe to events on the data at the specified node. These events include value, which will notify you of any change and provide you with all the nodes data every time something changes below it. We hooked up the child_added event, which sends you a copy of the new child object as soon as it's added. We also looked at child_removed, which sends you the object which was removed allowing you to handle it on your side. We didn't look at child _changed, but this is used to handle updates to children of the node your reference is subscribed to. A terribly important aspect of Firebase is that it does not play well with arrays and always stores objects, even when you ask it to store an array. I showed you how it converts objects to arrays when it figures out that you can expect an array, but how brittle this approach gets because you'll have to maintain all the IDs in order to keep it working as an array. My two cents, use objects, they're way better. Next up, we're going to get serious with our app now. Any app that gets a bit big needs more structure than we've got now and in the React world, that means you need to employ the flex pattern. I'm going to introduce you to the pattern, but we're going to look at a specific implementation library of the flex pattern soon afterwards called altFlex. We'll refactor what we've got to use this library, but we'll also flesh out our app a bit and implement the chat channels, which will fall to the messages based on what channel the user selected, using the altFlex library all the way.

Flux Architecture with Alt
Introduction
We're getting quite serious with our React stack. After this course you'll be in a position to build your own fully functional React app and release it into the wild. Keeping that in mind, we don't want your code to become a mess now do we? In the world of React this means we need to implement the flux architecture in our app. I'm going to give you a quick overview of the flux architecture. We're also going to have a look at a very popular implementation of this architecture, a library called Alt. We'll install Alt and get it hooked into the app we've been building over this course. At this moment our app does not need you to log on at all, so we'll do that using the Alt library. Then we'll refactor the existing components in our app, add the channel list and the message list components. If you've never heard about the flux architecture or don't know how it works, this module will be very useful to you as it introduces the architecture in a very practical way, without getting too stuck on theoretical gobbly gook. I even break some rules, which some of the flux purists may be unhappy about, but this is a real world course and I want to show you how to ship with flux and Alt, not blog about it. Facebook also realized that their apps were getting confused when it comes to storing state, handing changes to that state, and how the component knows when to update. To remedy this, they came up with the flux architecture, a very simple architecture that allows you to keep your app structured. Think about something like MVC or MVP, it's something along those lines. Let me introduce you to the basics quickly. This should be the most theoretical part of this module, so bear with me. In flux the first thing to care about are actions. Think of actions as events that get fired, events that can be fired with data. For example, in our app we have the ability to send a new message. In flux the component will trigger the action that was sent up for sending a new message. The action gets fired on the dispatcher. The dispatcher is like a switchboard where your events go through and where interested parties can register to be notified of certain events. You might have heard about event buses and event brokers, this is what a dispatcher is in the flux architecture. When the dispatcher gets notified of an action it looks for stores that are subscribed to that action and passes it onto them. And don't get confused here, it's not a store like MongoDB, SQL, or anything like that. It's a logical store. Even though you can use persisted stores like local storage, _____nxdb, or something like that, most of the stores you'll see out there will just be state that get managed in memory. That's the ultimate job of the store, to maintain the state, which the views, also called components, are bound to. When the view responds to certain user events it fires an action and the whole process starts again. Facebook did such a bang up job coming up with the architecture and libraries for it, why use this other library? In the end it's because it's just so much easier to develop flux apps with it. You have much less boilerplate to code up with Alt and it even provides us with some cool ES7 attributes we can decorate our code with. Let's have a look.

The Benefits of Using Alt
We're going to compare between code that was developed against a vanilla flux libraries and code that was developed against the Alt library. We're starting with actions. We'll have a look at stores and components soon afterwards. Let's imagine we've got a really simple app that has only two actions, say_hello and say_bye. This is what we'll have to do with a bare bones Facebook flux implementation. We've have to define constants to identify our actions by. When I implemented flux the first time and saw this I was like, surely you're joking? Well no, constants, unfortunately you'll need to define them if you don't want to rely on a library like Alt. So we've defined two constants, say_hello and say_bye. To define actions without a proper flux library, you'll have to do something like this. We pull in our dispatcher, which I'm sure you remember is the switchboard for the actions in our app. For each action that we want to trigger in our app, we add a method and pass it onto the AppDispatcher, with the action type set to the correct constant and the data that we want to pass onto the action, in this case message, as you can see here on both the say_hello and say_bye actions. I'm sure you've already come to the conclusion that this will get quite repetitive down the line when you might have hundreds of actions in your app. Now let's have a look at how we implement actions using Alt. In Alt we don't have to define constants to identify our action. This gets taken care of in the library. This file does exactly what we did with the two files I just showed you where we used a vanilla flux implementation. In fact, let's go back a bit. We defined constants and have all this repetitive code over here and here for each action. Whereas with Alt, we just call the generateActions function passing in a bunch of strings and it sets up simple pass through actions for each one of these strings. This is done here at the bottom when we call the createActions function on Alt and passing our class into that, much more elegant than without Alt. We already work with a dispatcher directly when we work with flux as it's just an event broker where the objects go to register themselves to be notified when a certain event occurs. So we don't need to compare versus vanilla flux and Alt in this area, so we can skip over this and look into implementing stores with vanilla versus the Alt library. There are quite a few things to remember when implementing a store without Alt or a similar library. You need a reference to the dispatcher. You need to pull in the node EventEmitter. We can do this because we're using webpack. If you're not using webpack, you'll have to use a port, which you can install using Bower or something similar. As always you'll have to pull in your constants, and we need to set up this ugly event constant here so that we can use that to notify components of changes to the store's state. In order to handle our events we need to extend our store from the EventEmitter. In our constructor, we need to register with the dispatcher and we need to set up default states. The logic we call from the constructor to register with the dispatcher entails registering for any action on the dispatcher and then, wait for it, do a switch statement to handle each event we're interested in. This means that you still will get notified of each and every event on the dispatcher and that you need to switch on the action type to only handle the events that you want to handle. This is a bit tedious. In this case we execute the say_hello function when the action is of type say_hello and the say_bye function when the action is of type say_bye. In both these functions we update the state of the store as we wanted and then need to remember to emit the change_event, which we created a constant for a bit earlier on. See what I mean wit boilerplate? If you forget to fire this event your components won't know about the change and they won't rerender and then for each store you implement, you'll have to add these two functions here, addChangeListener and removeChangeListener. I guess your subscribers can interact directly with the functions we get by extending from the EventEmitter, but as far as I can tell, the flux community prefers wrapping it with a more explicit function on the store in order to encapsulate the constant. So a lot of code gets rolled into a store like this and as you can imagine, you end up writing a lot of fragile, tedious, and repetitive code. In Alt all the code to do the store even fits on a screen at the same time. There is some magic happening here. I love how much elegant the code looks with ES7 decorators. This is way more declarative than what you'll get without the benefit of Alt. We have to import actions and also pull in some decorator functions from Alt. We're using object destructuring here to pull certain decorators in from this location onto our own variables. Now we get to use the decorate decorator on this class. What this does is look for bind attributes like this and this one and subscribe to the dispatcher for you ensuring that the function will be called when the corresponding action is triggered on the dispatcher. So much nicer than the old school switch statement we saw earlier. And have a look at what it does in these functions, it calls setState on the instance, just as we would do in components. So it's reusing an already familiar paradigm, which ensures that the component bound to this store gets notified of state changes. You don't need to think about firing events or anything like that, Alt takes care of this for you. Lastly, one little caveat before returning this class, we need to call the create store function from Alt on this class, which takes care of all the other explicit code that was required in the previous example. I love this. It's just so declarative and intuitive. Now let's have a look at the difference between components built with Babel and flux and components built with Alt. _____ areas implementing a store without a library, you'll also have to remember some tricky things when building flux components. In our constructor you need to call the addChangeListener function I showed you earlier in our bare bones store example. Let me bring that back up. I'm talking about this convenience function we created that allows for subscribing to the onChange event on the store. Okay so we need to subscribe to that and I don't know if I was just being superstitious, but I felt like I need to store the handler that was bound to this class's instance because we also need to remove it as a listener later on when the component gets un-mounted. And in the actual handler we call a function on the store, which we have to set up, which gives us the state we're interested in so that we can do something with it. In this case, we just sit it on the state of the component. Let's compare that with Alt. There's not much less code this time around, but it's way more declarative. We pull in a decorator called connectToStores from Alt and decorate our class with it. When you decorate a component with this, you need to provide these two static functions on your component class. We'll be doing this a lot in this module. You need to define getStores and getPropsFromStores. getStores returns an array of all the stores that this component wants to get data from. In our case, only one store. And getPropsFromStores gives you a hook point to pull state from these stores onto the component. I just love this. It's so much more declarative and elegant. And that's it. That's all you've got to do to bind stores to an Alt component.

Getting Started with the Alt Library
Let's get Alt installed and start using it. Before we start plugging in the Alt library, let's have a look at where we are at the moment. We have a MessageList component, which currently gets its data itself from Firebase. We're going to move this logic out here and rather load it in a more fluxy way, so that it ends up in a store and our component binds to that instead. We have this ChannelList component with some hard coded channels, which we don't really do anything with when you click on them. We'd like the app to fall to the messages based on the channel that you've selected in this component. Soon we're going to refactor this component so that it gets data from Firebase, but through a flux store. This component will also trigger a flux action, which communicates to the rest of the app that a channel has been selected through the flux architecture we'll implement using Alt. We also have a MessageBox components, which currently talks directly to Firebase to send it a new message. We're going to do this by triggering a flux action with a new message. Then we're got our app component, which pulls everything together for us. We're also going to make some changes here as we would want to conditionally show a login screen when the user is not logged on. That, of course, means we'll have to build the login component. Okay let's install Alt quickly. As usual, we do this from the command line using npm. Now that we've got that installed, we need to set up the basics for Alt in our code base. I'm going to stick to conventions that most people seem to be using when developing apps with Alt. But remember that this is not set in stone. You can have a totally different structure if you want. We create an Alt folder here in our source folder and in here we create a default file, index. js, allowing this folder to be importable. This leaves you open to add more files in here at a later stage. In our simple but realistic app, we are going to create one alt instance and reuse it. You may choose to have multiple alt instances as this will allow for less noisy dispatching of actions when a collection of actions might, for example, only affect one part of the app or something like that. All subscribers to a dispatcher will be notified of all actions going through the dispatcher, whether they're interested in all of them or not. It's up to the subscribers to decide whether they want to handle the action or not, so there is a real possibility that a large app will require multiple instances. Mostly though, it should be fine to do what we're doing here, create a singleton and reuse it. So all we did here was import it and export an instance of it. The rest of the app will always be working with a specific instance. Okay now let's use the same basic structure for our actions, a folder called actions containing an index. js file. First thing we do in here is to import the alt instance we created earlier. We create an ES6 class called Actions and before I forget to do it, I export it. But I don't export it as is, I first call alt. createActions on it. This is the magic that Alt gives us. These little functions that take care of all the boilerplate for us. If we didn't have Alt, all our functions would have been very robust, but using this one function call it will change our class definition and do all the magic for us. Okay let's get going on the meaty stuff already. Our first action we're going to code up will handle the login. And we're going to use Firebase authentication for that. So we import Firebase from the Firebase module here at the top. Now we add a normal function onto this class definition, which we call login. We make this function take a parameter called args. When you want an action with some behavior, you create a function with a name of the action, in our case login, and then immediately return a new function which takes a dispatch argument. This of course, can be called anything. As I've mentioned before, we're going to use Firebase for our authentication, so we construct a Firebase instance in here, passing the URL to our app instance to it, in our case react-stack. firebaseio. com. Now I'm going to blow your mind with how easily we're going to do authentication with Firebase. We just call the authWithOAuthPopup function. Now it needs to know which provider we want to use, and in our case I specify that we want to use Google authentication. To this function we need to pass a callback function with the first parameter any possible errors and the second parameter the user that logged on. Well usually we'd also want to handle errors gracefully and make it affect the data store, which in turn would allow our components to communicate an error state to the user. But in our case, we're just going to return early and keep it simple. If it was successful though, we call a dispatch with the user. This means that any subscribe stores can update their state with this user. For the upcoming actions, we're just going to generate pass through actions, which don't do anything except pass data on through the dispatcher to the subscribe stores. For this one though, we wanted some behavior and ended up with this, a function with a desired name of the action returning a function that takes a dispatch callback as a parameter, wherein we do some async work and call dispatch with the resulting data. At the moment we don't have anything subscribing to this event though, which means we need to create our store. We create a stores folder and in there a file called ChatStore. First thing we're doing here is import the singleton alt instance so that we can subscribe to actions on it. In order to know about the actions we import the actions component we set up earlier. Earlier in the module I showed you how Alt makes use of ES7 decorators to weave behavior into your app using introspection or reflection if you're a. NET coder. What this line does is make these specific decorators available on local variables. Now I'm creating a class for our store called ChatStore and before we do anything else we export it, calling alt. createStore, similar to when we created our actions. Because we're going with the ES7 decoration route to _____ our store to actions, we add this call here on the class level, @decorate, and then pass in the alt instance. This is a decorator with a very confusing name of decorate. It's needed in order for our further decorators we're going to use later on to be wired up correctly. Don't worry, it'll make sense soon enough. This might look a bit more familiar. In the constructor we set up some default state, like we usually do with React components. In our case we set up a user attribute with a null value. Okay now we add a login function, which takes a user and call this. setState, setting the user state variable to the value we got on the user parameter. I think it's quite nice that a store built with Alt follows this familiar paradigm to update state. Now I'm going to use a really cool decorator. I add a decorator onto this function called bind and specify that it should bind this function to the login action we set up earlier. You see? I don't have to go and write a bunch of imperative code to subscribe to the login action. Instead, I declaratively express my interest in the event and Alt makes sure that this function is called when the action gets fired. Pretty cool. Oh I see I have a typo down here. Okay so we have the ability to allow a user to login, but we still need to be able to trigger that action. So we need to create a login file so that we can add a logon component. Instead of building a new component from scratch, I've just pasted some code in here, which I coded up earlier. It's a simple component that has an onClick handler, renders a card, and has a button that calls the onClick handler when clicked. Now it's wiring the functionality that will kick off the login process. Basically call the action which we have just created and wired up to the store. To do this, we import the actions we created earlier and here in the onClick function, we just call the login function on the Actions object. That's how simple it is to trigger an action from a component. Nice and clean. But we still need to display this login component and we need to do this in the app component. This is the first time that I'll show you how a component will bind to a store, allowing it to use the state in the store to render itself accordingly. We import something called connectToStores from alt/utils, and now we import the ChatStore itself from its relative location to this file. One folder app, stores/ChatStore. Cool now we can use this connector stores decorator on this app component at the class level. As soon as you do that you need to specify two static functions on your component. Yep, static functions. ES7 is a game changer. The first static function you've got to define is called getStores and from this function you specify which stores this component is interested in. For each store that you return from this array, Alt will wire up this component to state changes on their stores. The next function you need to provide is getPropsFromStores. This function gets called when any of the stores you subscribe to experienced a change in state, allowing your component state to be recalculated. We're just going to store this state as is from the ChatStore on our component. We get this by calling the getState function that Alt generated on our store. Okay so our component is wired up to the flux store using some elegant ES7 code, but we still need to import the login component quickly, before we can use it in render. I'm doing this at the top here, okay now on render we can create a variable called view and set that to a login component instance and what we want to do now is reassign this view to what is currently shown in the app, but only if the user has been set on our props. As you might have deduced by this statement, Alt sets the state from the stores on your component's props and not on state as might have been _____. At least this is made clear by this function we specified just now called getPropsFromStores. Okay, so when they're logged in we want to reassign this view variable to a div, which we populate by going down here and copying this and placing it in here. Now we say that we want the view to be rendered over here. So basically if we have a user on our props, we render the app as we know it. If not, we render the login component instead. Okay, let's test it out in the browser. Cool. It's showing us the login component because we haven't logged on yet and when we click on the log in here we get a message from Firebase telling us that Goggle is not a supported authentication provider. Oh, I see. Let's fix that quickly. In our actions we need to change this from goggle to Google. Let's try again. Ah-hah, this time we get the message I expected. Firebase authentication is disabled and we need to go configure it for our Firebase app. I must say I'm very impressed with how much care the Firebase team took in showing these very descriptive messages. It's in plain English and spot on. Luckily doing this in Firebase is super easy. Firebase gives you a lot of information on setting up Google authentication, so if you want to follow along, I suggest that you go through this guide to understand how to create a Google app, which will give you credentials that you can use to configure your Firebase app with. I've already set up a Google application and configured it according to this guide, so now I can go to the login and auth section for the Firebase app and in here enable Google auth and paste in the keys that I got from Google. That gets auto-saved and now we can test it again in our app. This time when I press the log in button it gives me a Google login form. Let me type in my password quickly, click Sign In. Logged into the app, so that's our first _____ in flux interaction integrated into our app with a Firebase log in to boot.

Refactor the Channel List Component to Flux
Now we're going to change this hard coded channel list on the left here to get its data from Firebase through a flux store. Since we've last looked at the data we've uploaded to Firebase, I've changed it a bit. This is what we're got now. A new node containing channels with names. So let's get this into a flux store from Firebase and bind our ChannelList component to it. When doing async operations like getting data from Firebase, the Alt library has the ability for you to code up what is called a source and an _____ store with it so that it's got the ability to get the data and still publish actions to report on progress. We're going to code up a source for the channels, so let's create a file for that called ChannelSource in the sources folder. Okay so this shouldn't come as a surprise to you, we need to import our actions into this file as a matter of priority. So import Actions from that actions folder and because we're going to load our data from Firebase, we also load the Firebase module. Now that we've done that, let's set up a Firebase reference pointing to the channels node. So new Firebase, the URL to our Firebase app, and point that to the channels node I showed you a bit earlier. Now to code up a source we're going to create an old school literal object on which we'll just have various objects that are used to get data. But before we define these objects, I just want to export the ChannelSource _____long, so that I don't forget to do it later. Okay, nifty. Now for each async operation that you want to support, usually getting data or something similar, you need to add an attribute to this object. This attribute will be turned into a function later on when we bind the source to our store. Now, for each one that you define, you need to define a remote function. This is using ES6 and on's literal syntax, meaning this is actually an attribute called remote, which returns a function. Our remote function takes a parameter state, which is the state on the store that the source will be bound to at the moment that this call is made. From this function, you need to return a Promise so that it knows when the async operation is done. So we construct a new promise with a function containing a resolve and reject parameter. When our async operation is done, we'll call resolve with the results. And if we get an error, we could use reject to notify the store that something went wrong. If you're a bit confused, just bear with me. It's hopefully going to make some sense soon enough. In this function we use the Firebase references, once function to specify that we want to get the value of the channels node once. We provide a callback to that and here we get the value of the result and assign that to a variable called channels, which we then use to resolve this promise, allowing the Alt library to take over. But where does this data go then? Well we're going to tell the source which actions it should use to publish the data through the dispatcher, so that the stores can update themselves through the app. To do this, we need to set up some new actions first. In the Actions file I'm adding a constructor and in here I'm using an instance level function called generateActions, which this object has because we sent it through the alt. createActions function before returning it from this module. To this function we can add a bunch of strings. For each string that we specify it will create a pass through action for us, which we can call from any place in the app and which will then pass whatever we give it to the subscribers of the action through the dispatcher. Now back in the ChannelSource, we've defined the remote function, now we need to specify the actions that it should use when the promise that the remote function returned was resolved successfully or when it resulted in an error. We add a success action for when it was resolved, for that we want the ChannelsReceived action to be fired and when we experience an error, we want the channels failed action to be fired on the dispatcher. Okay, but where do we call the source from? Well as I've quickly mentioned before, we weave it into our store and we call it from there. In our store we first import the ChannelSource from the ChannelSource file. Earlier we imported the datasource decorator from the Alt library up here. So now we decorate our store with the data source, passing the ChannelSource to that. This will add functions to our store, which can be called to kick off the async logic we just created in the ChannelSource. Let's start using this now from the ChannelList, which depends on the source that we just set up in the same way that we connected our app component to the flux store a bit earlier on, we import the connectToStores decorator function from the Alt library and we also import the ChatStore from the ChatStore file. We're going to show some progress while the channels are loading. So let's also import the circular progress component from UI material, before I forget to do that later on. Okay now let's decorate this class with a connectorToStores decorator function and what did I tell you we should do when we bind the app component in this way? As soon as you decorate your component with connectToStores, you need to specify two static functions on the component, getStores and getPropsFromStores. We start with getStores and from here we return an array containing the ChatStore. Remember this is done so that Alt can wire up the data change events on the stores and sync your component properties with a state of the store when the store's state changes. Next we define a getPropsFromStores function where we get to pick how the states should be copied onto this component's properties, as we did with the app component, we just say that we want to copy everything over, but it's probably a good idea to be a bit more selective in a production app where you want to keep your memory usage low. Okay let's get rid of this hard coded state here in the constructor and instead we add a call to ChatStore. getChannels. You might be like, what? at the moment. I don't blame you. I'm unloading a bunch of stuff on you now. Where did this getChannels function come from all of the sudden? Well, see here in the source? We specified that we want the getChannels remote and because we used a data source decoration on this store, passing in this source, it actually created a function on our store called getChannels. Weird, eh? But also a bit wonderful. So remember that when we bind our components to a store, it'll actually set data on props, so we need to adapt this statement over here to get the channels from the props instead of state. We also wrap it with lodash because we used to have an array, but now we've got an object with a key for each channel. So first we call keys on the lodash chain, then we change this map part a bit. We change the parameter to k for key and get the channel from this channels property using that key. Okay I also mentioned a bit earlier that I wanted to show a progress indicator while we're loading data, so here at the top of the render function, let's add some code to handle that. If we don't have channels set on the props yet we return a card element and we set this card style with a flexGrow value of 1, same as we do when we return a channel card when we do have channels. In this card we add a circular progress element. We specify that we wanted to keep on spinning indefinitely by specifying a value of indeterminate on the mode attribute. We add some style here, close it off _____long, we want padding at the top of 20 pixels, the same at the bottom. We add a margin rule to center it in the card, set it to a block and specify some width on it. We did a lot here, so let's do a quick recap. We reference connectToStores and the ChatStore app here. We decorated the component with connectToSources, which meant we had to add these functions to the component in order for it to know to sync data from stores onto the component. We also added this call to the ChatStore. getChannels function to kick off the async functionality, the store gets from the source we created. We return a circular progress if we don't have any data yet. And we change this logic here to get the data from the properties instead of the state and to work with channels being an object instead of an array, but how does the result of the getMessages remote that we defined on the source get into our store? To let that happen we have to do one last thing in the ChatStore quickly. We add a function in here called receivedChannels. This can be called anything, but it's nice to make it something meaningful. This function takes one parameter, channels. This will be the value that we return from the getChannels remote we defined on our data source. Now we use the bind decorator to hook this function up to the channels received action we defined earlier on and which we hooked up to our source, by specifying it as the success action for the remote. I just flipped back to the source quickly, see, yeah we specified that the channelsReceived action should be triggered when the promise returned by the remote function is resolved. Okay, but before we do anything with the data that's been passed through on the action, we pull in lodash at the top here. Now we can use that to do some work on the channels here in the receivedChannels function. We wrap the channels with lodash and start the chain with a keys, which should pass on an array of keys to the next handler in the chain. On this we do an each and in here we set the key attribute of each channel to the key we get from looping through the keys array. When you work with set in React it's a good idea to provide a key attribute to each object you're binding to and because these keys are coming from object attributes, we can trust that they are unique. We also want to set the first channel to be selected, so if we're at the 0 index according to the index passed into the callback, we can set the selected attribute on this current channel to be true and assign the selectedChannel to this channel. Now we need to call value on the end of this lodash chain to tell it to resolve. We call setState on the store, setting a channel attribute to the channels variable and select the channel attribute equal to the selectedChannel. This is ES6 and on's literals. Where if you don't specify an attribute it just uses the variable name as the attribute. So basically to recap, we just added a receivedChannels function, use the bind decorator to hook it up to the channelsReceived action, and then proceeded to add a key to each channel. We then set some state to keep track of the selected channel. Lastly we called setState to update the stores state and fire events so that the interested components can rerender. Oh, I just notice a little issue here. I used the wrong variable name over here, let's change that to index instead of just i. Very naughty of me. Okay let's test this already. We log on and see a loader and bummer, it's getting data and binding, but something isn't right. I guess we added a bunch of new code, so something was bound to go wrong. I've dug around a bit in the background and found that it was something here in the channel component. Here where we set up this lodash chain, we didn't call value at the end, what a rooky mistake. Okay, now that's fixed, let's check it out. Cool it worked. We now have a list of channels here. Let's make the selected one look a bit different than the other channels. In the channel render function we add a style variable and set that to an empty object, so that we can do this conditionally if the channel is selected, add backgroundColor to the style object. Now we set the style of this ListItem equal to the styled object down here. And when we check it out in the browser, cool, it's styled differently now. That's it for the ChannelList component. Let's move on to getting our messages loaded into the flux store.

Refactor the Message List Component to Flux
Before we proceed, I want to show you what the latest data upload looks like now. This time around we've got the messages node, then we have its messages nested beneath channels. So instead of just having a messages node containing all the message directly, you now need to navigate through a channel first. This allows us to easily filter the messages according to the channel. I'm not saying this would be the best way to store this in real life, but what I'm trying to do is show you enough of a real world stack without getting stuck too much on the details. The first thing we're going to do to get our messages loading through flux is add the actions, just as we did for the channels. So messagesReceived and messagesFailed. And as we did with the channels, we're also going to add a source for the messages async functionality. You are familiar with a source that we defined earlier for channels, so let's reuse that. Let me copy and paste the contents quickly. Okay, so now we can quickly adapt this file. Let's quickly have a look at what we're going to do. We'll obviously rename it and we'll have to change this reference to get the messages for the correct channel, the channel that is selected according to the state that was passed in, which is the state currently on the store. And we'll also hook up the actions, which is defined up here. Cool. Let's begin with the easiest task, which is to rename it from ChannelSource to MessageSource. Next, I changed these actions quickly, this should be messagesReceived, and the error should be messagesFailed. Let's confirm that. Yes. messagesReceived and messagesFailed. Now because we don't know at this point what channel was selected on state, we can't build a meaningful Firebase reference here. We need to point it to the correct channel now that are messages are nested below channels in the Firebase DB as I showed you earlier, but we want to keep this variable at this scope for a reason that will soon become clear. So we just set it to null for now. We want the function that will be made available on the store to be getMessages, so we rename this field. Okay, now let's change this variable to messages and rename the reference to that. So basically each time this is called, we want to use the channel that is selected on state to get a Firebase reference to that location in the database. So we assign the FirebaseRef at this scope to point to the messages node and then we append the selected channel we found on the state to the end of it. Now if we leave it all like this, it's kind of dangerous because when the channel selection changes, it means we've got Firebase references hanging around. We're not disposing the reference that was set up for a different channel earlier, so we'll get some weird results when messages pops into the screen from a different channel. To handle this, we check if their reference has a value and if it does we just switch it off. I love the naming of that function. Okay, let's use our newly defined source now by binding it to the store. First we pull it up here with import, here where we bound the channel data source to the store we also pass in the messageSource. Done. Okay, well not quite. We also need to call the get messages function when we know that a channel is changed and set up some state. But I'm still quite impressed with these decorators in the Alt library. Let's also set up some default state for the messages. Just setting it up to null. As we did for channels here, we add a function called receivedMessages, taking in messages parameter and now we bind it to the messagesReceived action. Again similar to what we've done with the channels earlier, we use lodash to wrap this value and then start morphing it to what we want to be stored on the state itself. First in the chain we add a keys call to give us an array of keys for the object. Then we add each again, this time we don't care about the index. For each message we set the key attribute to equal the current key, as mentioned earlier it's good to add keys to all the other objects when you want to bind multiple of them. Then we remember to evaluate this chain by calling the value function. We don't want a repeat of what happened earlier. Now we set the messages on state using setState, which will notify all the components subscribed to this store and allow them to rerender. Talking about components updating, we need to go bind the MessageList component to the store because at the moment it's getting instated directly from Firebase, which is very naughty. I've done this a couple of times. You should know this by now. How do we bind a component to a store using alt? We need to import the connectToStores decorator and the store itself of course. There we go. Now we want to hook the store up by using the connectToStores decorator and then adding the getPropsFromStores and getStores functions, but we still have this old code hanging around here, which we've reimplemented in our messages source, so we get rid of that. Now we add the connectToStores up here and this means we have to define a getStores static function, which returns an array of stores this component is interested in, in our case just this one, the ChatStore, and now we can add a static function called getPropsFromStores and in here we just say that all the state from the store should be set on this component's props, as is. Again, you might want to be more selective here in your app to try and keep the memory footprint a bit lower. So our components should get the state from the store when it's updated, let's adapt our render function to work with a new data structure and also change the structure so that we can show a loader later on. Let's add a variable here called messageNodes and set that to null. Now we check whether the messages are on the props and if they are we assign messageNodes to the result of the statement here, which when we change this to props and not to state, will result in a list of message components. But nothing is calling this get messages function. Where should be put this call? Hmmm. Well remember at the start of this module I said I'm going to show you some hacks, which might make some flux architecture purists really uncomfortable? The time has come. I'm going to show you now. Let's open the store and in here we go to where we've just finished setting up the channels on state. This is the first time that we've selected a channel and therefore a very good trigger, in my mind, for loading the messages. But we can't because with pfFlux you should not fire an action as a result of another action being dispatched. In fact, it throws an error if you try this. I've agonized long and hard over this and how I'm going to show this to you, and in the end I decided to show you how I would have done it in the real world. So keep that in mind while I show you how to do it. We're going to do it in a timeout. So we type setTimeout, passing a reference to this getMessages function and make it run a few hundred milliseconds after this. See, I told you I'm going to show you a hack. Let's test that out though. The proof is in the pudding. Sweet. It only loaded the Firebase messages and the Firebase channel is selected here on the left.

Responding to a Channel Selection
That works fine for the initial load, but what about when a channel is selected? Let's go add that functionality quickly. We go to our action file and add a new action called channelOpened. We're going to trigger this action when a user clicks on a channel, allowing the store to respond by loading updated messages. Here in the channel component we want to trigger the action, that means we need to reference the actions and add a click handler to this list item down here and trigger the action from the handler. We start by importing the actions from the actions file, then we define a function called onClick and in here trigger the channelOpened action we just created and to that we pass the channel instance that this channel component is bound to. To trigger this action, we add an onClick attribute on the list item component and bind this to the onClick function using bind to ensure that it executes bound to the component state. Okay so we've set up an action and we've triggered the action. Now we need to handle it in the store. We add a channelOpened function on the store class, which takes a selectedChannel parameter and as we did before we use a bind decorator to bind it to the channelOpened action. Then we wrap the channels on state to start a lodash chain again. On here we add a values call and then an each. Values will return just a values of the object in an array format. In our each callback over here, we get the channel passed in so that we can do some work on it. A previous channel could have been selected so what we do is set the selected value to false, so essentially this sets every channel to unselected so that we've got a clean state. Now we just set the channel that was passed in on this action handler up here to be selected. And now to update the store state, we will set that passing in the updated selectedChannel and also update the channels property. We also want to make a call to the message source to go and load messages now that the selected channel has changed, but remember, unfortunately this is a bit hacky. The work we're doing in here is already happening as a result of an action being fired and when we call getMessages here it will fire actions of its own to tell the store when it's resolved the messages or experienced an error. So we have to trick the dispatcher again and do this work asynchronously. We're being so naughty. So I'm adding a setTimeout function and passing it the getMessages function with a miniscule timeout. Let's test that. Okay, when we select different channel it updates quite nicely. Let's try another one. Yep, it's definitely working. So our messages are loading as a result of a channel being selected but I don't like that there is no visual indicator that something is happening, so we're going to use flux and Alt to show a loader while the message source is loading messages from Firebase.

Showing Message Loading Progress
We're going to tell the store that messages are loading through firing an action through the dispatcher. So we need to set up an action in our actions file. Okay, now that we've got that, let's open our message source. We've looked up actions for when the messages have been loaded or when it experienced an error. There are other hooks we can subscribe to though. For example, when the remote is being called, meaning the promise has been started and it's waiting for data. To do this we set up another attribute, loading, and tell it that we want it to trigger the action we just created. Okay, now in our store we want a default value for our loader state, so you're in the constructor, we add a new state variable called messagesLoading and set that to true. And down here where we've loaded the messages on state, we also set the messagesLoading value to false. So that takes care of the default value and when the messages have loaded, but we also need to look into the messageLoading action in order to set the messagesLoading on the store stated to true. So we add a messagesLoading function onto this class and bind it to the messagesLoading action by using the bind decorator. And all we're doing here is set the messagesLoading variable to true. This will cause subscriber components of the store to react to this event and rerender. At the moment the components don't even use this value, so let's remedy that. In the MessageList component we want to show a loader while the messagesLoading variable on the state is true. To do that we need to reference the circular progress component from material-UI. Now we change this if statement over here to tell it to only render messages when the messagesLoading variable is false and when messagesLoading is true, meaning we want it to show the loader, we set the messageNodes variable to CircularProgress. On this component we set the mode to indeterminate, meaning it won't try to communicate progress, but just show that something is happening. We add some style, padding at the top, same at the bottom. We tell it to center itself by adding this margin rule, which also means we have to make a display as a block for that to work. We give it a width of 60. Okay, let's test that out. Logging on again, okay click on a channel here. There, see that? Let me slow it down. There, so that worked. The data is loading super quickly from Firebase though, so we don't get to see the loader for too long, but that's a good thing, right?

The Flux Way to Add a New Message
Okay so everything has been moved over to the flux architecture, except adding a new message. In fact, it's entirely broken at the moment, so we're going to fix it now and also move it over to the flux architecture. As we usually do when we want to add new behavior in flux, we start by adding actions to support the interaction. In this case, we add a new action called sendMessage. Then messageSendSuccess and then something like messageSendError in case we want to hook up error handling a bit later on. Okay let's adapt a messageBox to trigger this action. We remove this Firebase import here and replace that with an import for actions instead. This component won't be talking to Firebase directly anymore. We also remove this Firebase reference from the constructor over here and in the onKey app we remove this code that used to send a message to Firebase and call the sendMessage action instead, passing the message currently on state to it. Let's go and add the logic we just removed here to the message source. So we add a remote on here called sendMessage. We add its remote function, which will _____ more soon. Now we tell it which actions to call when it resolved the promise we're going to return from remote. For success, we pick the messageSendSuccess action and in case the promise gets rejected, we want the messageSendError action to be called. Okay, from remote we return a new promise, so we set up the promise here. If we don't have a Firebase reference, we just resolve it immediately and return because we don't know where to add the messages to. This is in case the source has not been used to load messages yet, meaning it won't know which channel to add the message to. If it does have a value, we push a new message to it, getting the message from state. For the date of the message, we just specify a new date and convert it to universal time format. For the author, we use the user that's on state and get the Google display name for that user. And let's also store the userId on it for good measure, which we get from the user object on state. For the profile pic attribute, we use the user's Google profile image, which we get on the Google object on the user. After doing that, we just resolve this remote. This would cause the success action here to be triggered. But nothing is trigging this async functionality on the store here. Nothing is responding to the sendMessage action and what do we do when we want to respond to an action? We go bind it to a store. Let's do that now. In our store we add a new function called sendMessage, taking a message parameter and here we set a message on the store state to equal the message passed in. This makes it available to the async functionality we just coded up in the message source. Now remember, if you want to call a function on your source to kick off async functionality, it'll result in firing up more actions through the dispatcher and this isn't possible because we're already in an action handler here. So we have to use a timeout again and this timeout tell the message source to send a message. I've explained this in greater detail a bit earlier on. If you dropped into the course at this point and you're a bit confused about the timeout, perhaps consider watching this module from the start. Okay so let's bind it up to the sendMessage action using the bind operator. Okey-dokey let's fire that up in the browser. Oops, got to log in again. We'll have to keep the user logged in a bit later on. Okay after logging in, we type a new message in here, something original like, I don't know, testing a new message to Firebase. How do I come up with this original stuff? Okay, did it save? Let's have a look at the Firebase console. If this seems a bit strange to you, you should consider watching the Firebase module of this course for a bit more context. Let's expand the Firebase node and this one with the Firebase generated ID. Cool it added our new message.

Adding a New Message to the Flux Store
But when we add a new message, it doesn't come up in our message list. That's because we used the once and value way of getting our messages once and not notify us of any changes. Let's adapt this and add another event handler for this reference once we've resolved this remote. On the reference we use the on function and tell it that we're interested in when a child gets added to the reference location to which we pass a handler function. And here I set a msgVal variable to the value of this message parameter. Next, I set the key attribute on it to equal the key for the object according to Firebase by calling the key function on it. Remember, all our messages that we have in the store has the Firebase key set on their key attributes so that we can identify them easily in our reactor. Now we can call the messageReceived action and pass the new message in there so that the store can add it to its state. Unfortunately we don't have this action yet, so we quickly go and create it in the actions file, just another pass through action called messageReceived. Okay let's handle this action in the store now. I add a function called messageReceived and bind it to the messageReceived action by using the bind decorator. We expect a message to be passed through on this action. Now we use the key that we set up on the message in the source and check whether it's already present in our store on the messages object. If it is, we just return early. Just a bit of definitive programming to ensure that we don't end up with duplicates being shown in our messageList. Now that we know when we need to add this message, we just add it to our messages object using the key on the object as the key. See how working with objects make logic like this much simpler? Imagine we were working with arrays, we'd end up with a bunch of folders to find the existing one, which would have been nasty. Okay now that we've updated the messages, let's call setState to update our components. Why don't we check this out in the browser, let's add a new message in here and see what happens. Cool, it immediately bound to the list. And another one (Typing). Cool. Just one bit of last minute housekeeping before wrapping up this module. At the moment our profile pics are still hard coded from when we initially created the message component and we need to fix that to get the profile pics from the documents coming back from Firebase. You can also see that we are expecting the message property to be a string containing the actual message that was typed in. This prevents us from getting access to all the other fields on the message. Where we bind the message component here in the messageList component, let's pass in the message object instead. When we check it out in the browser now, you can see that our message component will need to be adapted to bind correctly because it expects a string, but now it's getting an object with a bunch of properties. Okay, so all we do in here is change this code to use the message attribute on the message object. And now we can bind the source attribute of the Avatar component to the profile pic attribute on the message object. Okay, so that worked.

Recap
Let's do a bit of a recap for this lengthy module. Here are the important notes to keep in mind when working with a flux architecture and the Alt library. Actions are important. Every time you want to trigger any change in state, you will need to execute an action. Alt makes it ridiculously easy to set up actions, eliminating the need to write a bunch of repetitive boilerplate code every time you need to add a new one. With Alt you can just call the generate actions function and pass it a bunch of strings and it will create a new pass through action and make it available to the rest of your app, easy peasy. All your state will come from stores when you work with flux and, again, Alt saves us from the ugly fragile code by giving us ES7 decorators we can use to do stuff like mix in asynchronous functionality using the data source decorator and binding to actions in a declarative manner, using the bind decorator. Components bind to stores. In the flux architecture, stores notify components that they should refresh their data through publishing events. This can also get very fragile, buggy, and repetitive without using Alt. With Alt, you use the connectToStores decorator on your components and all you've got to do is bind your component to various stores is to provide two static functions, getStores, which should return an array of references to stores that the component is interested in, and getPropsFromStores, which copies data from the stores state to your component. Alt takes care of the rest and you get to focus on user benefit. And that's it for the flux architecture and the Alt library. Next up, we end off with making our application respond to URL changes, allowing you to cut up apps that can be navigated to a certain state through a URL. For this we'll be using the React Router library.

Routing in a Flux App with React Router
Introduction
In this module we're going to tie a nice bow around our stack by introducing routing. I can still remember the first time I understood how routing in the browser worked and I was blown away. And now years later I still think it's pretty darn cool. Let's have a look at what you'll learn in this module. You probably know this already, but it's worth a rehash. Why would we want to add routing to our app? And where does React Router fit into the picture? I'll show you how I pull React Router in on our sample app that we've been coding throughout this course. We'll have to change our app a bit to play well with React Router, so we'll start off with that. Even though React Router is quite simple and intuitive, we'll have to deal with a bit of complexity to make it play well with our current stack that uses Alt to follow the flux pattern and this can get quite tricky. Then we configure our app to load the logging component and the chat interface on two different routes. Then I'll show you how to look into routing changes, so that we can redirect our user to the login screen when they need to log in and to redirect the user to the app after successful login. We'll end off this module by lying channels to be selected in our app through changes in the URL. This means that deep linking would be supported to open up a channel through a URL. It also means that we'll be able to press back and next in our browsers to navigate through the previous channels we had selected, which I'm sure you'll agree is a pretty nifty feature. React Router is a very popular library that lends the ability to declaratively set up a structure for a reactor and allows the ability to respond to URL changes by rerendering different states. Most serious web app stacks have routers involved as it allows for deep linking to certain states in your app, like for example if you have a music app and you want to share a link to a particular song with a friend, you want the link to open the app at the song when your friends click on it. In fact, it's kind of expected from web apps these days and if you don't cater for it, you'll just end up frustrating your users when they press back and they end up in some other site, more often than not Google. There are other routing libraries for React out there, but React Router seems to have gone at the biggest following so I would say it's the safest bet to stick to it, at least for the time being. Let's have a look at an example of routing with React Router before we delve into the code itself. Let's say you have a React app with a structure like this. It looks very similar to our sample app we've been coding on in this course. We've got a main component and in this component we've got an element up here, for example, a nav bar. And an element on the left over here and we would like this area to change based on the URL that was used to load the app. Now let's say we've configured React Router to respond to a link for dogs and we've instructed it to load the dogs component. We've also set up our main component to render whatever React Router tells it in this area over here. When this URL is hit, our main component renders the dogs component because React Router has looked at its configuration and figured out from the URL that we want the dogs component to load. It's sort of like a master detail relationship where we have a master page or a template, if you will, and the detail wrapped into that. Now let's say that we've also configured a cat route in our React Router config and we've set it up to route to the cats component. So this is kind of interesting. React Router can pull state of the URL and pass it on to the props of our component. We're going to use this later on in this course when allow for switching between chat channels based on changes in the URL. So if we've set up a route in this example app for loading different types of cats, we could _____ it with the URL that passes in a variable value and that value is then passed on to our component through props. We're going to have some complexity to deal with in this module, but it's mostly due to our rich stack that we've laid down with flux and Alt and not because React Router itself is complex. For my amazing example of a cats and dogs application structure, this is what your routing configuration will look like. I've extrapolated the interesting bits, there would be more code around it, like the imports and such. This is just to give you an idea. We tell it that we want the main route to load our App component. This is the component that needs to take the component from the router and stick it somewhere into its own structure in its render function. Then we set up a default route, in this case the dogs component. We tell it that the route dogs should load the dogs component too and that the cats route should load the cats component. Pretty simple. I keep on saying that the App component will take the component that the route gives it and pull it into the structure in render. This is what it would look like. We would pull in the RouteHandler and somewhere in render tell it to render the component. It's as simple as that. Let's go use our routing knowledge now to add routing to our app.

Making Our App Router Friendly
First thing we've got to do, as usual, is to install the React Router module from the command line using npm. So npm i react-router, passing the save option. Now that we've got that out of the way, we can start focusing on changing our app structure so that it's easier to plug in React Router to drive it. Currently we have our App component as the Route component for our app. What we'd like to do is restructure this so that it can serve as a template which changes the one part of itself based on the component that React Router gives is to render, as we've discussed a few moments earlier. But when we scroll down here, you can see that it won't be easy to do that. At the moment, based on its own state, this component makes the decision whether to render the login component over here or if it doesn't find a user, to render all this component structure instead. So what we want to do is ensure that the two permutations we've got for this part over here, the login view being one and the chat interface being the other, are componentized so that we can use a React Router config to decide which components should be pulled in here and we can't do that as it stands now because the chat interface is composed within this App component itself. This is very naughty in the first place, it should have been a component to start off with. Okay, so let's fix that. Let's create a new component that contains the structure over here. We create a new component file and call it chat. Obviously this is a React component, so we import React from the react module. Now we import the components that we want this to be composed of, so we import the MessageList component from the MessageList file. The ChannelList component needs to be imported too. Okay, cool. Now for the MessageBox component and that should be the last component we'll pull in. Now let's code up a new component class called Chat, extend that from React. Component and close it off over here. Okay, let's remember to export this component before I forget again. Now this component should actually be quite simple. Its only purpose is to encapsulate these other more complex components and render them in the correct structure, so we need a render function of course, which I'm busying adding now. Let's head over to the App component and grab what we need from there. We basically want to move over this whole section here, this div and all of its contents, now we pass it in here, in the render method of those chat components. Okay, so now we can adapt the App component to use this Chat component instead. So we open up the App component, we won't be referencing these components anymore because they'll be encapsulated in the Chat component. So we remove them. And here we ensure that we've imported the Chat component by duplicating this import over here and adapting it. And here in render, we remove the stuff that was moved over to the Chat component and reference the Chat component instead. So this component is still deciding when to render the chat interface and when to render the login component based on its own props it got from the flux store. But we're going to change that soon by plugging in React Router. First we have to get the structure conducive to working with routes though, and we should be done with that now. Let's just see if this is still working, shall we? We open up the app and it asks us to log in. Let me do that quickly. Okay, and now it renders the chat interface. Cool. So it's still working as expected, but now with a much better component structure.

Defining Routes
So now we're getting to the juicy part. We're going to pull in the React Router now and get started on its configuration. Let's set up a new file for our routes. We follow the same convention as we've used before for actions and create a folder called routes, but with an index file in here. Now a route config is actually a component. Let me show you what I mean with that. We import React from the react module as we would do when we create a new component. And all the different parts we'll need to set up the hierarchy we need. We import App because it's going to be our template component, then we duplicate that so that we can adapt it to import the Chat component and also the Login component. Now we import the Router from the react-router module. And we assign some variables from that. First, we assign a Route variable to the Route component from the router module. Next we get the DefaultRoute component onto a variable called DefaultRoute. I guess we could have just used destructuring there to make this a bit nicer. Old habits die hard. Now we start fleshing out our route configuration and we do this using jsx. We declare a variable called routes and assign this to some jsx composed of the route and the DefaultRoute components we pulled in from the router module. Route components are nested and you need to create a main route, which will contain all the other routes and point that to your main component. In our case, the App component. So we set up a route instance, which should be activated when this URL is hit, just a route URL for our app. And then it should hand off to the App component, which is our App component we pulled in up here. In here we want to define what components should be pulled into the App component based on URLs. First we add a DefaultRoute and say that we want the Chat component to be used for that. I'm not too crazy about this being its own component. I think it's a bit weird, with little or no benefit. I think it would have been way better just to work with Route components and use a default attribute on it instead of doing this. Now we add another route. This time with a path of chat and again, we tell it to use the Chat component as the handler. This just means that if no specific route is passed through, it will render chat by default and if you pass the chat route through, it'll also render chat. So now we do the same for login. We add a route, a path, and specify login as the handler. Okay, so we've established our routes. So how does it get wired up? Well we're going to make this jsx we set up here our app. So instead of rendering our app component, we're going to render this instead. So we first initialize this router by calling run on it, specifying the hash location option, meaning we're fine with the Hashbang URL, and code up a function it will call back on with the Root component, allowing us to use the component and add it to the DOM. And yeah, we just take this Root component and call React Router, telling it to render the Root component in the container element, which we'll get by calling getElementById on the document. Great. So because we're doing this here, we quickly need to change our code here in the main file a bit, so that we don't render our app here anymore. So we remove this line and even all the stuff at the top here we can safely remove, and all we do now is require the routes file we just coded up. Remember that webpack will automatically hook into this require and ensure that the jsx we've got in there gets compiled in our pack. Now we need to change our app component. Because it's still making the decisions on when the chat interface should be rendered or when the Login component should be rendered, based on its own props. And it's not acting as a template, allowing React Router to tell it what component to render based on its URL state. This component should be blissfully ignorant of what component it's rendering because React Router is going to decide that. So it doesn't even need to be aware of the Login and Chat components anymore, we can safely remove that. Even the store logic won't be used anymore, so remove this connectToStores import and even this ChatStore import. What we do want to import is the route and the component from the React Router. This will get resolved to the correct component based on the state of the URL. Let's clean this code up a bit here, we don't need this connect stores decorator here and these static functions down here that we had to provide for connecting to the store, let's nuke that. And now we can remove this logic here. We're not going to use that anymore. And instead of rendering the view variable here we just pull in the route and the component. This will ensure that the correct component is slotted in here based on the rules you set up and the URL that is currently active. Let's have a look. We load up our app and sure enough it defaults to the chat interface, as we wanted it to. Check up here, you can see that it's redirected to the base client side URL by the hash in the URL over here. Pretty cool. Let's test it a bit. When I change this URL to login and press Enter, it takes us to the login. Let's change it back to Chat. Nice. So our URLs are definitely working.

Redirecting Routes
But there is a bit of a problem, it's a bit hard to notice here. We're rendering the chat interface, but we're not actually logged in. Let me show you. I've expanded the debugger tools and when I'm now trying to add a new message, it tells me that it can't read property Google of null. That's because we don't have a user on our store yet because we're not logged in. We want our app to redirect to the login URL if the chat interface is being loaded without a user being present. Let's do that now. In our actions file, here where we do our login logic, we want to redirect to the app URL after successful login. Otherwise, our app won't know to switch over to the chat interface component. But to do that, it'll need access to the router. For now, let's assume we'll find a way to make it available to this function and just make it a parameter to this action function. Now we can call this function on the router, transitionTo, which allows us to specify a different route to redirect to. In this case, the chat route. Now we need to ensure that we do in fact call this action with the router so that this logic will work. Turns out that React. Component is pulled in with the React router has the router available on context, so we quickly add a static field on our class, which sets up an expectation that we want the router, which is of type function, to be required. Now that we've done that, we can safely assume that it's been resolved, and we get to pass it onto the login action like this, this. context. router. Okay, so now this code over here in the actions file will actually work. Because we're passing in the router we got from the context to this action call from the login component. Okey-dokey, let's test that out. We load our login screen and then press on Log In. The suspense is killing me. Great, it redirected to the chat component after login. Don't believe me? Have a look here in the address bar. That's the code that we just added in action. Nifty. Let's do it again, but this time we step through the code in the debug tools. I change the URL back to login. Okay, now where should we put this breakpoint? Definitely in the login component. I would say here in the onClick handler is a good place. And maybe in the actions file too where we've got our login logic. This should be here at the bottom. Ah, okay, here where we transition. I click on Log In and I have a run router here. Cool. So it's got a value, doesn't it? Let's resume that, and wait for this familiar login popup to do its job. Okay, so now it's in the login success handler. In here we ask the router to redirect to this route and it obeys our wish. So we're redirecting to the chat route when we're successfully logged in, but we're still allowing the chat interface to be served without the user logging on. Meaning, we won't have the chat interface set up correctly for the person to chat. This isn't supposed to be secure, by the way, it's merely a way for me to show you how to enable a part of the interface based on state. Okay, in the Chat component we pull in the ChatStore, so I import the ChatStore from the ChatStore file, which we don't do the usual connectToStores thing. We will use the store a bit differently this time. Components that are rendered by React Router set up can provide static functions as hooks for React Router to call, allowing the components to act sort of as middleware for the routing layer. It's a tad strange, I must admit, but it does work. So the static function we want to define now is willTransitionTo. This'll get called by React Router when this component we're in is going to be rendered as a result of a route change. In here we get the state from the ChatStore and put that on a variable. And now we check to see whether we have a user on state. If we don't, we want to write the redirect to the login URL. And we do this by saying that this transition should redirect to the login route. Simple as that. Let's test that out. Let's force this chat route to execute again. And it should, yes, it redirected us back to the login route so that logic is working correctly, and just to make sure, when we click this Log In button to log in again, cool, now it renders a chat interface because we have a user in our store, and remember we couldn't add a new message earlier, let's test that out now. Let's select a different channel over here, it's still nice and clean this one, and add a message. Cool. No errors. And, yep, there's the new message. So we're re-implemented our whole auth flow using routing.

Route Parameters
Now we're going to get a bit fancy and allow a channel folder to be applied through the URL. So we open the route file over here and duplicate the chat route so that we can adapt it to serve a specific channel's messages. We specify that we want a channel parameter on this route by using this familiar convention to denote that we want whatever is passed in at the URL at this point to become a parameter and to be passed onto our component. We still want the Chat component to be rendered when this route is it, so leave that as the component for this route. Okay, now we're going to change the ChannelList component a bit. We want to hook into the props that we receive on this component so that we can get the channel that was passed in from the routes and then we want to use that channel to pass it onto our store, so that it can retain the select value. So we start by removing this call to get the channels over here. Now we try to hook into when this component is mounted so that we can get the channel passed through the route. To hook into this we define a componentDidMount function, which React will call when this component has been mounted for the first time. I'm going to store the channel on an instance variable because we'll need to refer to it later on. To get the channel parameter, we need to pull it from the props of this component on the params object. This is our React Route that passes route parameters onto the components. It sets it on the props of the component, on the params object. Okay and because we use the token channel in the URL, React Router sets the value on the params object using the same identifier. Now we've got the selected channels stored on the instance variable. We call the getChannels function on the ChatStore, passing in the selectedChannel, the selectedChannel will contain a string value, which will be the ID of the channel, so that handles the scenario where this component has been mounted for the first time, but what about when the URL changes and the component should be updated? Luckily this is quite easy to hook into. To do this, we need to specify another function, this time we specify componentWillReceiveProps. People at the office often tease me because I prefer using verbose naming and I must admit, it's kind of true. But just look at how useful and self explanatory this method naming is, componentWillReceiveProps. Anyways, I digress, this function will be passed to props that is about to be set on the component so that you can watch out for changes. In here we check whether the selectedChannel we've got stored on the instance variable we set up here is different than the one being passed through from the router. If it is, we want to ensure that our store is updated with the correct channel. First, we need to remember to keep track of our selected channel on the instance variable, so we overwrite the instance variable with a new value and now we call the ChatStore again to get the channels, but with the updated selected channel. Remember, the getChannels function is weaved onto our store. It's actual location is in the channel source and we need to update it to keep track of the selectedChannel in this way. So let's open up that channel source file. Now we add a parameter on here, selectChannelKey, and before we resolve this we set a default value for this parameter. If it's populated we use it, if not we assign it the first channels key and the value is returned by Firebase. Okay, now we can get the selected channel from the channelList based on this key. Only if it found the channel do we set that channel selected property to true. Remember, we're trusting the URL here to give us the ID, so the possibility exists that we've been given garbage. Now because we're doing this at this level we also need to update the store logic. Let me show you what I mean. Okay, down here we've got this receivedChannels function and this function hooks into the action that the channels have been received, because we've just adapted that code that fires this action to store the selected value on channels, we can assume that a channel will always be selected. So this code should be changed a bit. We change the statement quickly to rather execute in the current channel where it's writing through is selected. Previously we just set the first channel as selected, but because we can trust that the source took care of that for us, we can trust that we'll have a channel that is selected at this point. So obviously that means that we don't need to set it to selected, that it's already been done for us. We still want to assign the selectedChannel though because that gets set on the store here and allows all our components to be aware of the value. Now because we've made our app able to render different channels by setting the route parameters, we're going to change what happens when a channel is selected because now we're just going to navigate to a different URL rather instead of handing an onClick and talking directly to the objects. We replace that with a good old href, which we set with a string containing the base chat route on which we pave pinned the channels key, which is, as you might recall, what we've expected the whole time to be passed through on the route. Now this won't work, but I'm going to open it up in the browser to show you why not. I found it quite interesting when I first figured out how to do this. We log in and when it loads you can see that it's not loading the messages, we're getting an error in the code we just did for the channelList. It says that it's not able to get the route parameter from its props. That's because the routing config never constructs this component directly. Our React Router set up is only aware of three components, App, which is our template, Login and Chat. It will pass the routing parameter on these main components, but it's your own responsibility to ensure that these properties are passed on through to components which are descendents of these components. Let's do that quickly. So Chat contains the channelList, which needs this property. All we've got to do in here is set this property so that it's got access to it. We could probably do it the old school way, by saying something like the channel equals the channel value that we got from this component's props on the params object. But there is a way better way to pass on props to a child component when we have ES7 to our disposal, and we do have ES7, thanks to Babel. All we've got to do is use the spread operator and specify this component, the Chat component's props, on the ChannelList. All we've got to do is use the spread operator and specify that the Chat component's props should be set on the ChannelList. This will ensure that the props from this object is destructured and set onto this object using individual attributes, it's kind of like magic isn't it? Okay when we test that out now, it works. Let's click on a different channel here. As you can see, the URL changes. See our loader, it loads the updated messages. Seems to work well and now when we press back, it takes us to the previous channels that we had selected. And that's it for routing.

Recap
Let's do a quick recap, in order to facilitate state changes through URL changes, we pulled in the React Router module. What's interesting is that the routing config is done with JSX, pulling in components for each rule and each rule should have a path and a component that should handle that path. Let's have a look at that again. See, we pull in the components from the React Router module and then specify the routing rules by adding components to this jsx structure. And here you can see that each route has a path, which builds on the path from its parent. Routes can be nested and if it's hit, it returns which component should be used to handle it. It's actually very simple and elegant. Components that have subroutes, like in our case we had the app here as the main route, act as templates. So they need to listen to React Router and render the component in the correct place in their structure. Let me open the code I showed you right at the beginning of this module. Here we used a route and a component in our render function. React Router will let this reference be resolved to the component that should be rendered based on this current URL. So if the URL is dogs, the dogs component, and when it's cats, the cats component. We also had a look at specifying a route parameter by adding a URL parameter token. To specify a token like this, you just need to type a colon followed by the name for the token, and the router will ensure that your component is passed a value on the params object on its props using the same name for the token that you used in the URL. And that's it for this course. Thanks a bunch for taking the time to watch my course. React is such a fast-paced technology. By the time that I finished this course a few things have already changed and I'm hoping to get to them soon in following courses. I hope that you've at least learned something interesting in this course and at best that you feel that this is a pretty good stack to use in your next project. Thanks again.
