At the core of any successful web application is in-depth knowledge of how to properly track and update your application's state. In this course, Advanced Redux, you will learn how to implement Redux and its middlewares to create highly maintainable and performant data models. You will learn how to create middleware, how to implement immutable state, and how to use Redux Saga. When you're finished with this course, you will have advanced knowledge of Redux that will help increase your value in the workplace or greatly assist you in creating web applications on your own.

Course Overview
Course Overview
Redux, it's one of the most popular libraries on GitHub, with over 30, 000 stars. That's because Redux is easy to use, highly performant, and extremely reliable, but, the biggest productivity gains go to prepared developers who understand advanced Redux. I'm Daniel Stern, also known as the code whisperer, and I am thrilled to present my new course, Advanced Redux. This is a course that can bring any student from Redux zero to office hero in just a few days. We'll teach you about thunks, selectors, sagas, middleware, and much more, using a winning combination of short lectures and hands on demos. So, do you want to improve your productivity as a web developer? Do you want to maximize your opportunities in your programming career? Or are you just using Redux at the office and want to stand out by stepping up your game? No matter who you are, you will benefit professionally and economically from learning Redux, by watching this course. I strongly recommend watching the first video right now, it doesn't cost a cent to get started. I look forward to seeing you there.

Course Introduction
Introduction
Hello and thank you for joining us in Advanced Redux. I'm your instructor, Daniel Stern, and in this course we're going to be learning all about Redux, the advanced techniques you need to know to be on top of the web development game. If you'd like to get in touch with me, you can of course contact me at my Twitter, @danieljackstern, or my GitHub, github. com/danielstern. In this lesson, we'll be introducing the course and taking an overview of what it's about. So here are the topics we'll be covering during the introductory chapter. First, we'll ask the important question, why Redux? Are there compelling reasons for you to choose Redux over a competing library? It turns out there are, and we'll have a look at those in that video. We'll also be determining who this course is for. Do you have the necessary skills to get the most out of this course, or would you benefit more from taking another course first? Then we'll go over what this course will and won't cover. There are a lot of related topics to Redux, and we can't go into all of them in equal detail, so in this clip we'll determine what those things are that we'll be delving into the most. We'll also take a look at the prerequisite knowledge and technology you'll need to have to get the most out of this course. Then we'll look at what's coming up in the remaining modules in the course road map. After that, we'll have a look at the demo application. We're going to be building a really advanced Redux messenger program, so it's good to get a peak at it right at the beginning so we know what we'll be building. Lastly, we'll be discussing some techniques for troubleshooting the demo application. Since it is an advanced application, there are things that can go wrong, which may result in the application being difficult to run. We're going to be discussing the techniques to prevent that from happening, or if it does happen, the techniques to get your application back on track. In the next clip, we'll be asking the question why Redux?

Why Redux?
So, why Redux? It's not the only option out there, but is it the best choice for you? Here are some compelling reasons why it might be. Now as far as GitHub is concerned, Redux is the most popular JavaScript library for managing state. As you can see, Redux has over 1, 000 watchers, almost 6, 000 forks, and so, so close to 30, 000 stars on GitHub. This indicates there's a lot of interest in the library and it's probably well supported by the community. So compared to competitors like Flux or Relay, it has more stars on GitHub. As we'll discover, it also has more features arguably that you'll find useful for your application. Finally, it's easy to introduce Redux to large scale projects. Redux is a popular library, and odds are developers on your team will already be at least partially familiar with it. In addition, the conventions that Redux forces you to use generally lend themselves well to harmony between large teams of developers. In the next video, we'll discuss who this course is for.

Who This Course Is For
Who is this course for? Let's find out. So if you're a senior developer and you're looking to greatly increase your Redux skills, then this course is for you. We're going to be assuming that all students have a decent knowledge of simple concepts like React, Flux, ES6, WebPack, etc., and if you don't, while you can still complete this course, you may not get the most out of it. Now if you're not already fairly knowledgeable with Redux, there's no need to worry, this course is actually the second of a series of courses on the topic of Flux and Redux that I've made. The previous course, Mastering Flux and Redux, is suitable for beginners and preps you for this course. And here we are at the webpage for the course Mastering Flux and Redux. Now of course if you have a Pluralsight membership, then you can already access this course. So if you don't already consider yourself knowledgeable in Redux and an expert on Flux, then you'll want to watch this course before you watch the course Advanced Redux. Now if you're not sure, if you already know all the concepts in Mastering Flux and Redux, just have a look at the contents of the course on the right. IF you're already familiar with all these ideas, then there's no need to watch Mastering Flux and Redux, and you're probably ready to get started right away with Advanced Redux. There's no shame in thoroughly preparing yourself for an advanced challenge, so make sure that you're up to the task before proceeding for the rest of this course.

What This Course Will / Wonâ€™t Be Covering
So before we go any further, I'll be honest with you, this course does not cover everything. There are some topics that we just didn't have time for, and others that we needed to trim down in order to focus on the more important stuff. So in this video we'll get all our expectations clear and go over what we will and won't be covering. First up, the good stuff. Here's what you can feel confident in you'll learn by the end of this course. We're going to discuss using React together with Redux, to basically create entire applications. We're going to do Redux server-side rendering, which is very exciting since server-side rendering improves the performance experience for your end users, and its' just a very cool trick to show off. We're really going to dive into immutability, especially using the library Immutable. js. We'll be implementing and creating Middleware. Middleware is an important and more confusing part of using Redux, but by learning this course, you'll know everything you need to create and use Middleware. We'll be learning about combining reducers, not just doing so the standard way but creating our own custom function to combine reducers in whatever way we want. We'll be covering thunks. If you don't know what a thunk is, don't worry because we'll cover that too, but our application will use thunks to, among other things, generate a bit of asynchronous functionality. We'll also be covering sagas. This is very exciting since as far as I know no other course goes into detail this deep about using Sagas and Redux Saga as this course. But as tempting as it is, don't just skip to the end to the part on Sagas, because all the information before that is good too. So, what will we not cover? This is what we won't cover. So we're not going to be talking about advanced React concepts, we'll be covering Advanced Redux, but I'm already going to assume that you understand React, so if you don't know too much about React, watch this course first, Building Applications with React and Redux in ES6. I've watched this course, and this is a very good course, and it leads up very nicely to the course Advanced Redux, and Cory House tells you everything you need to know about React, and then many useful concepts about Redux, like immutability, server-side rendering, etc., but in terms of details about React, Cory Houses course is the best, so watch this course first if you're at all unsure about React. We won't be covering testing Redux applications. This is already covered thoroughly in Cory House's course above. We won't be covering Flux, as Flux is discussed thoroughly in my previous course, which I discussed in a previous video. We won't be talking too much about Advanced ES6 regenerators, now ES6 regenerators are what we're going to use to use Redux Saga, and while we will implement them, we won't be going into the details of how they work. If this is a topic you'd like me to discuss more of, please let me know in the discussions or send a message to my Twitter about how you'd like to see a course that delves deep into ES6 and regenerators, and I'll know that this is something that people are interested in. We won't be covering databases, as databases are a whole deep topic that aren't related too intimately to Redux. We'll just be simulating a database using Node and Express. In addition, we won't be covering authentication in this course. We'll once again be simulating authentication, so that we can focus just on Redux. In the next clip, we'll go over the prerequisite skills you need to have to succeed in this course.

Course Prerequisites
So, what do you need to know and have before we get started on this course. You're going to need to have a solid understanding of ES6, Node, and JavaScript. These are all technologies we'll be using a lot to get our application on track. You'll need to have a good knowledge of React, like as we discussed, you can gain by watching Cory House's course on React applications, and you need to have a basic understanding of Flux and Redux, which you can get from watching my course on Flux and Redux. In addition, you need to have the following technologies set up on your computer. First, you'll need to have Node. js, and if you don't already have that we'll discuss installing it in a upcoming video. You'll also need to have Git installed on your computer to take advantage of the course files. If you don't have Git, just visit the URL that you see at the top of the screen and follow the instructions to install it properly for your operating system. And you'll need to have WebStorm or an equivalent text editor. I recommend WebStorm because it's the one I use, and it's pretty great, even though it costs a bit of money. There's a free trial so if you're interested grab WebStorm, or otherwise just go with Adam Sublime, or your text editor of choice. In the next video, we'll be covering the courses roadmap.

Course Roadmap
So now that we're sure that everyone who is still watching is of the appropriate level of skill for this course, let's go over what we'll be discussing in order. First we'll learn about and then implement advanced immutability, so we'll be using immutable. js to make our Redux state a mutable map instead of a mutable object. After that we're going to implement a custom con7ombined reducers function, and learn all about that and the advantages of doing so. Afterwards, we'll create a series of view using React and Redux. We'll also use the Reselect library to gain access to our state in the middle of our application. We'll add asynchronous functionality using thunks and sagas, and finally, we'll install dev tools and explore how to troubleshoot with those. All in all, it's going to be a very exciting course, so I hope you stick with us until the end.

Overview of the Demo Application
In this clip, we're going to have a look at the demo application, this is the application we'll be building throughout the course of this course. I personally am very happy and excited to bring this demo application to you. I've put a lot of work into the demo application, and I feel it encompasses all the best practices that a Redux application should have. It has a lot of useful features, it's functional, but yet it's clean enough for to repurpose it for whatever you want. So we're going to be having a look at, in a minute, at the application, and here's what the application has to offer. It's a single page messaging application, so it's similar to HipChat if you've use it or maybe Slack. It's what you'd call a static application, so we're not loading new pages to load different views of the application. It has four main components, a list of channels, or conversations that the user can enter, whatever is the content of the currently open channel, the status of the user who is logged in, and a list of the user's contacts. There's no direct cross-component communication, so even though you'll see there's a lot of interactivity to this application, we're not sending messages directly from the channel list to the user status, we're using Redux to do all of that, and changes are also persisted to a central server, thanks to the Middleware which we'll be implementing. And behind it all Immutable. js is representing the state, making it easier on the development side to not make mistakes. So here I am at the application, we'll be discussing how to install this application and get it started in the next clip, but for now, let's have a look at it. On the left, we have a list of channels. If I click a channel, then the Channels content loads up. Notice how there's a bit of a delay, we're using sagas to load the data we need in right at the last minute, so that the initial load is smooth. Also, if we refresh this page, you'll notice all the content loads right away, because we're generating the Redux state on the server. Here at the bottom of the screen, the user can type something in, and if the page is refreshed, the message persists. We're using sagas and web sockets to save these changes to the server as soon as they're made. On the right here you can change your status, and if you put Offline status, it'll affect the conversation view in the middle, this is despite the fact that the status change isn't communicating directly with that view, but rather just communicating with the dispatcher in the Redux application. Finally, we can create a new chat with, for example this individual here. This also persists the new chat to the server. As you can see there are tons of great features to this application. So that's the application. In the next clip, we'll be discussing some strategies for making sure it works on your computer.

Troubleshooting the Demo Application
In this clip, we'll just be discussing some strategies for troubleshooting the demo application. We'll be getting the demo application running in the next module, but if you have any trouble, you'll want to go back to this video and have another look. The first thing you'll want to do at any sign of trouble is visit the GitHub repository. You can clone the application in it's correct state from this place, and if there's any changes that happen to any supporting libraries or anything that might break the application, the GitHub repo will be updated, so you know it always works. So always try cloning the GitHub repo and installing dependencies, as this is the most consistent way to get the application working. So what are some common errors that could occur? So you may have insufficient user permissions to use some of the dependencies, this happens mostly on Macintosh, and if this is the case, you're going to want to use Brew to install Node with Mac. You might also have an Incorrect Node version. I made this course with version 7. 2. 0, so you'll want to make sure yours either is that version, or is a compatible version. Finally, there's a problem that can occur sometimes on Windows, which cannot be solved by running npm install, which is that dev dependencies may be expected on the global scope, but they're only available locally. To fix this we have to explicitly install all the global dependencies. The command for doing so is here in front of you. You can type it in if you're, you know very attention to detail oriented, but I recommend just going to the link below, the GitHub repo, there is a text sample you can copy and paste available at the repo. Also, keep in mind this should only be necessary if you're having problems, usually with the babble that is cause by this. Alright, so that was the introduction, in the next module we'll be discussing advanced immutability.

Advanced Immutability
Introduction
Hello and welcome to module 2, entitled Advanced Immutability. In this clip, we're going to go over what we'll be covering in this module. First, we'll be having a quick recap of immutability. In this clip we'll take a few minutes to recap what we learned about immutability in Flux/Redux, and also go over some key points relating to all discussions about immutability. We'll take a bit of time to understand Immutable. js, which is the library we'll be using this time to manage our immutable state. We'll look at the advantages as well as the disadvantages of using immutability in your application. We'll set up the development environment that we'll be using for the rest of this course to make the application. After that, we'll discuss normalizing state shape, an important idea that relates to any Redux application, and interacts especially well with immutability. Finally we'll implement our applications default state, using an immutable object. In the next clip, we'll be doing an immutability recap.

Immutability Recap
Let's review a few important points about immutability. First of all, and from this point on, when we talk about immutability we'll be referring to JavaScript. in JavaScript objects and arrays are not immutable by default, that means that once an object or an array exists, it can be changed after the fact. Objects that have a reference to that object or array, need to do something to figure out when that object has even changed, or an error is almost certain to occur. In contrast in JavaScript, strings and numbers are immutable, so there are a lot of problems you avoid when using this, but they're also a lot less powerful than arrays or objects. The second key point is that in an application, Redux or otherwise, State is almost always represented as an object, but since objects are usually immutable and that leads to some challenging situations, we need a more sophisticated way of handling this. Now in the past, we've used the Spread operator to copy an object to a new object, effectively leaving the old one unchanged, or simulating immutability. And while this is great, it's cumbersome to use every time, and also can be less performant than our alternatives. In the next clip, we'll be learning about the industry standard solution for solving these immutability woes. Immutable. js.

Immutable.js
Luckily for us, a solution exists to the immutability question, using the library Immutable. js. So what do we need to understand about this library. Basically Immutable. js wraps the familiar mutable object in an immutable thing called a map. Now, unlike objects where you use a. syntax, maps have their own API for changing data. This changes the way in which we interact with the object, but restricts the changes that can be made to it. Generally a good thing. For arrays, Immutable. js also has a map like wrapper, called a list. So the Immutable. js wrappers essentially protect the internal object or array from being mutated. The underlying object is never mutated, instead copied, and the copy changed to match the requested change. And if you like the simplicity of just using the spread operator instead of creating immutable objects, indeed it is convenient, but Immutable. js also improves the performance of creating copies of large objects and arrays, therefore it's agreed to be the most performant way of introducing immutability into your application. Let's have a look at an example. So in this example, the constant a is an array containing the letters a, b, and c. Now we'll create another constant, b, which is a list that wraps a. The list comes from Immutable. js. Now a third variable is defined, c, in c, the second value of b has been set through the letter d, so the array b would read a, d, c. So we've created a new list that changes an element in the list b. IF we get the second element of this list, we can see it's been changed to d. But what has happened to constant b? Well if we look at the second element of that, we can see it's still b, because the original list, b, was never changed. We could change c, and that would also remain constant, all that we'd have done is created a copy and assigned it to a new variable. In the next clip, we'll discuss advantages and disadvantages to using this dynamic library.

Advantages and Disadvantages
There's no question about it, Immutable. js is a great choice for any Redux application where you want to implement immutability, but it's not all advantages, there are disadvantages to using this methodology, which you have to weigh against the advantages before you know if it's the right approach for your application. So, let's start by looking at some of the advantages. First of all, since you're always copying your objects and arrays, and never changing them, your history states are implicitly preserved. To look at your history you just have to find the object that represented your application at that point in time. Since it's immutable, nothing will have changed it. As we've mentioned, the performance when working with large arrays or objects is faster when using Immutable. js, versus using a homegrown immutability solution. When you're using Immutable. js, everything is very clear, you have to use specific commands to make any changes to an object, just a simple. notation won't do. In other words, you always know when you or another developer intended to make a change to an object or array. Since these objects and arrays are immutable, it prevents a common error case when an object referred to by one service is changed by another. These errors may be difficult to detect and may lie dormant for a long time. Immutable. js prevents this by preventing references to an object that one service has, from being changed by another. Finally, Immutable. js is a fast growing and actively contributed library. That means you have community support if you have a question, or if a new feature needs to be introduced. Now what are the disadvantages of Immutable. js? First, making changes in Immutable. js, if you do them wrong, are prone to silent failure. IN other words, if you try to change an immutable object using the. notation, you won't get an error, the change simply won't occur, so you need to be extra careful about that. Nested objects, as in objects within arrays within objects, are challenged to modify, but keep in mind though they are simple enough to modify an immutable object, it's very, very difficult to keep your references to the objects straight. To modify nested objects properly, you'll need to learn some techniques we'll be covering in some later modules. The syntax, that of getting and setting immutable objects, may be unfamiliar to certain developers. Everyone knows the. syntax but get and set can be new, and you need to take time with your junior developers to show them how to use this technology if you expect its implementation to be successful. Immutable objects often don't work for services that are expecting just a regular object. For example the combineReducers utility that we'll be modifying in a later modules, expects just a regular object, and will throw an error on an immutable one. Finally, depending on the version of Immutable. js and ES6 that you're using, spread or rest operators may not work with these immutable objects. This is a small limitation but it's good to be thorough about what we're working with. In the next clip, our first hands on clip, we'll be setting up the development environment.

Setting up the Dev Environment
In this clip we'll be setting up the development environment, the node scaffold on which we'll be building our Redux application. In this demo we'll be doing the following things. We're going to clone or download the application from the link mentioned there, and don't worry we'll be revisiting this in the upcoming clip, we'll install our dependencies, and we'll review the Webpack Express architecture, which is going to form the basis of our application. Alright, let's jump into it. So here I am in my IDE, WebStorm, and once again your IDE can be the one you choose to use. Now I'm going to want to grab the repository, so I'll do so by going to the GitHub Repo. Here I am at the repository for Advanced Redux. The URL is there at the top. I'll click this green Clone or download button, and I'll copy this link. Now back in my editor I'll type git clone, followed by the URL I copied, and optionally, the name of the directory in which it should be copied to, and that should copy the files to the system like this. Now of course if I just run npm start, we naturally get an error because we haven't installed any dependencies.. So let's do that, but first let's check out the appropriate branch for where we'll be. So we'll do git checkout immutability-start, now we'll install our dependencies with npm install. And that should have gone smoothly. Now one more step, as I mentioned early, we're going to want to install some of the global dependencies, specifically using the -g flag to remove some potential errors. So if I go back to the repository, if I take a look at the read me, right at the bottom there's a copy and paste link for some code to install the global packages. SO I'm just going to copy that, and paste it right into my terminal. And that should have all of our dependencies installed. Now if we run npm start, we should be able to visit our application on port 9000. Here it is, it's nothing too fancy yet because we haven't implemented React, Redux, or anything like that, but this is what you should see. Now if you've run into any errors and you've already tried grabbing the project files and going from there, please let me know in the discussion. It's possible that your computer may introduce a unique case that I was unable to determine on my Windows based setup, so letting me know will really help me fix the course files for everyone. So let's review some of the applications architecture. For this application I've prepared the server and the webpack files in advance. We're not going to be working with these too much, because we're focusing just on Redux, but we'll go over what's happening. So in webpack, the babel-loader plugin is loading all our JSX and transforming it from ES 2015 and React, into ES5. We're using the babel-regenerator-runtime, which is going to give us access later to asynchronous functions, or generator functions. Webpack is bundling all of our files into a file that belongs in assets, called index. bundle. js. Inside the server, we have a basic express application. The server is using webpackDevMiddleware, so when the server loads, the JavaScript is automatically compiled by webpack and made available through Express. The HotMiddleware allows webpack to reload automatically when a change has been made. Calling initializeDB initializes our database into a default state, just with some random values. Here we've introduced a delay in the server, this allows us to more clearly see our asynchronous functionality. Here we have a root that creates a new channel when it's called by the API. This route sets the active channel for a user, and this route gets the user's information. Here in the database, we have a channels model, which is just an array, a user's model, which is just an array, and here we have this method that just fills these two arrays with various semi-random pieces of text. So feel free to have a look at this more closely if you want to see how the initialization works, but this is just a presentational element to ensure that the application looks good and presentable when you're viewing it or showing it to others. In the next clip we'll learn about normalizing state shape.

Normalizing State Shape
In this clip, we'll be discussing normalizing state shape. Now we all know that Redux applications have a state, but did you know that there are two main ways in which that state can be shaped, or in which its properties can be structured? So what are these two ways? The first way, the one that may be familiar is normalized. So a normalized database is basically like an SQL database, if you're familiar with it. The data is broken up into many smaller tables that are all linked by an index. Units of data are very rarely repeated anywhere inside the database. The other kind are de-normalized states. In this case, there sometimes is only one table, and each entry in the table contains all the references it needs right inside it. We often see this kind of de-normalized state in databases like MongoDB, which don't require us to use many tables. Now, JavaScript's objects and arrays lends themselves well to de-normalized state shape, however there are numerous key advantages to normalizing the shape of the state. Firstly, if you have one piece of data repeated at multiple places in the state, when it updates for example in your Redux application, it'll be harder and harder, depending on how many times the data is repeated, and if you thought that it gets even harder when using something like Immutable. js as well, you're absolutely right. In addition, sometimes an update will occur and change a nested object deep within one of our main display components states. Since the component doesn't know if what's changed is significant or not, it will probably just have to redraw anyways, so updates can trigger unnecessary redraws if your state shape is not normalized. Finally, reducers tend to be too complex if they need to change multiple things every time, and they repeat themselves, in other words, they're not dry. So as you can see when we use Redux, several problems with de-normalized state float to the surface, and advantages of normalized state become more clear. Let's look at one or two examples. As you can see, each message has its owner inside it. If two messages with a different content were to have the same owner, the name John and the status ONLINE would be repeated every time. Now, here's a normalized state. The user's is within its own array, or you can look at that almost as a sub table, and the message doesn't have the user object, but instead refers to the user's ID. In the next clip, we'll be creating an immutable default state.

Creating Normalized Default State
In this clip, we'll be creating the default Redux state. We'll be using Immutable. js to make that into a map, and then we'll be couching on this map for the rest of this course. So first we're going to look at an implementation of a normalized state shape, then we're going to convert the plain JavaScript state object into a map with the fromJS utility. You'll notice the preprepared getStore file contains no default state so far. Luckily in our server we already have a file that makes a default state. You pass it the current user, the user that is viewing the application, and it forms a normalized state based on that. The channels array holds the information for all the relevant channels. The current user object holds a reference to the channel that's currently opened, but not any of the actual objects. The rest of this method just randomly populates these fields. So in getStore, first we'll import users from the database, then we'll import getDefaultState, and lastly we'll import the initializeDB method. First we'll call initializeDB so it has entries in it when we're using it right now. We'll choose a user to be the user that the client is registered as. I just chose the first one, but you can choose a random one or do that however you like. Then we'll create our defaultState, and we'll just call get defaultState and pass it the current user. Now let's log our default state. If we pay our application a visit, you can see here our default stat is indeed being logged. It's a map, and you'll notice that maps appear rather opaque from the console perspective. If we want to see what's actually in this map in our console, we can right-click it, and say Store as a global variable. Now it's called temp1, so we can say temp1. toJS, and it removes the wrapper and turns it into our state, so you can say here's our deformalized state, it's an array of users, and array of channels. You can see here the participants property of each channel is just an ID that refers to the user, the data is never repeated because it's a normalized state. So we know this is working, let's finish it up. We'll pass a default state to createStore, and that's all we'll be doing for this module. We'll need to add quite a few more moving parts before it looks like the dynamic application we saw in the demo. In the next clip we'll wrap up this module.

Module Summary
Let's summarize this challenging and knowledge filled module. So we learned that immutability is performant and reliable, it does have its flaws, but these two things we can count on. We found that maps and list are like immutable objects and arrays, but you can't really change them. When you think you're changing an immutable object, you're really just making a copy of it. The original will still exist somewhere, especially if you have a reference to it. When we're working with immutable objects, the conventions for changing them are different. We won't be changing any immutable objects until an upcoming chapter where we write our reducers, but this is how they work, and finally we saw that if our state shape is normalized, it doesn't repeat any key information anywhere, and this is the style that we want to have throughout our whole Redux application. In the next module, we're going to delve deep into the advanced world of combining Reducers.

Advanced Combining Reducers
Introduction
Hello, and welcome to this module entitled Advanced Combining Reducers. Let's have a look at what we'll be covering in this module. So as we know, Redux comes with a combineReducers utility, we'll have a look at that utility and discuss the reasons why you might want to make your own. Relating to that we'll learn to understand the process for implementing our own combineReducers function. Finally, we'll implement this in our application in a way that's friendly to the Immutable. js library, which we've implemented. In the next clip, we'll look at limitations and advantages.

Limitations and Advantages of Built-in CombineReducers Functionality
In this clip, we'll discuss the limitations, as well as the advantages of the built-in combineReducers function. As the Redux documentation says, once you go past the core use case for combineReducers, it's time to use more 'custom' reducer logic. As we can see from this quote, the documentation is advising us to create our own combineReducers utility any time that the core use case for the existing utility isn't enough for what we need. Of course the question for going past the core use case depends on your application, so you have to be the judge, but you can use these advantages and disadvantages to help you make a decision. So, what are the advantages of the built-in combineReducers functionality? Even though it's somewhat rudimentary, the built-in combineReducers functionality does have a few cool features. One is that if you make a mistake with your reducer like forgetting to return a value, it'll throw an error. You can of course put these in your own combineReducers function, but this all takes time, and you may not remember to enforce something that the built-in functionality enforces. The built-in utility is simple and easy to use. Most developers grasp almost immediately how to use combineReducers after just looking at one quick tutorial. In contrast, your utility may be much more complicated. If you're working as part of a big team, you have to take this complication into account and know that your developers will have to take some time to learn this methodology you've created. On that note, the existing functionality is already familiar to most developers, if you're using a built-in combineReducers function, you won't need to explain anything to the developers at all. So ultimately, we can say that if your project is a demo or a basic prototype, or something simple, then you don't really need to go beyond it and combineReducers will do the job just fine, but what are the disadvantages to this utility? First of all, using the built-in functionality when you write a reducer, it can only work on one property of the state, however, in practice, many times a reducer will need to access multiple parts of the state. For example, a user status reducer that also wants to update the users fetch status. Next if you've chosen any kind of element to represent your state that isn't an object, be it an array or a map, then the built-in functionality won't work and you'll need to update it in some way. On that note, if like in this application using Immutable. js, the built-in functionality won't work, so this is a great reason to make our own. So ultimately, the built-in functionality is not great for very large projects, as you're going to want to have that added control and maybe even enforce more best practices than the original utility. In the next clip, we'll ask how is combineReducers implemented?

How Is CombineReducers Implemented?
In this clip, we'll discuss how combineReducers is implemented. So in order to implement our own combineReducers method, let's look at what combineReducers does. At its heart, it's a method that returns a reducer. When you call it, what you get back is something that takes the state and an action and returns a new state. How this reducer behaves is based on how you configure it in the arguments of the method. So anything that takes arguments and then returns a reducer is technically like a combineReducers function. Which brings us to our question, how is combineReducers implemented? So combineReducers can take a configuration object, as in the case of the built-in utility. That object often associates simpler reducers that only work on one part of the state with a name of a property for the state. On the other hand, the configuration object might not contain any names of properties or reducers, you might decide to program those right into your combineReducers utility. We'll look at an example of that in the next slide. As we discussed, what is returned consists of a method taking a state and action, and whatever method is returned, always has to return the state, or else the store will throw an error. Here's an example of a combineReducers which takes no configuration, it just returns a reducer that already has hard coded into it, the reducers that we've prepared previously. This actually looks a lot like the basic combineReducers utility. We can also see that for the message property, the messageReducer is actually passed two properties, messages and users, so by doing it this way we can pass whatever arguments we want to our different reducers. Now we won't be hardcoding it for our application, but I thought this would be good to see. In the next clip, we'll actually be implementing combineReducers.

Implementing CombineReducers
In this demo, we'll be implementing combineReducers. If you're coding along at home, check out the branch combine0reducers-start, if you'd like to start from where I'm starting, and to jump to the end, check out combine-reducers-complete. In this demo, we'll create a custom combineReducers that's going to work with our Immutable. js implementation. We won't be worried about the configuration object that we're using right now, since until we write our reducers in a later module, we won't need to be configuring it, but in this clip, we'll be creating it. Finally, after the utility is implemented, we'll replace the existing combineReducers. So without further ado, let's jump into our text editor. So here I am in WebStorm, and I've checked out the branch combine-reducers-start. As you can see I've created a stub for combine reducers here in the src directory. It's a method which takes a config, but right now it doesn't return anything. As we know, the combineReducers has to return a reducer, so let's return a method that takes state and action as arguments. So whenever this method is called, we'll reduce the state, so we'll take the keys of the config, and we'll call reduce, with a method as the first argument, and state as the second, so for every argument in the config, it will do something and modify the state in some way. We'll pass state and key as the arguments to this internal reducer. Now in this case our config is going to be an object where every property is a reducer, so the reducer for this step would be equivalent to config, and then the property of that represented by key. Next, we'll figure out what the previous state was by looking at the key value for the existing state, and as we know to get our new value, we simply call the reducer passing it the previous state and the action. Next, we'll try and create a bit of the existing functionality, at this point we'll throw an error if there is no new value. This is very similar to how the existing utility works, and you are advised to add in these little safety checks to your combineReducers utility, especially if you'll be working with a large team. So we'll just throw an error here. Finally, we need to return the new value, so we'll say state. set, and this will create a copy of a state with the following change, for whatever the key value is, it's new value is the newValue, and we'll return this, and also we'll return Object. keys up here. Finally, we'll now go to reducer/index. All we have to do to make this work is change where our combineReducers is imported from. We don't need it from Redux anymore, so let's import the one from our combineReducers method. Finally, let's make sure everything is functionally. Run npm start in your Terminal. (Working) So, if you look at localhost-9000, you should see no errors and the basic shell of the application should be running. In the next clip, we'll sum up what we've learned.

Summary
Let's review what we've learned in this module. We've learned that the basic combineReducers functionality is certainly good, it implements a lot of best practices, but it doesn't work for corner-cases. Now whatever those corner-cases are for your application, the simplest solution is simply to implement your own combineReducers that answers those. We've also learned that combineReducers returns a reducer. Any method that takes some kind of configuration and returns a reducer, can be looked at as a combination of reducers. Finally, we've learned that when making our own custom combineReducers functionality, values can be hard coded as we see fit. Alright, in the next module we'll be creating Redux middleware.

Creating Redux Middleware
Module Introduction
In this module, we'll be learning about Redux middleware. Redux middleware is a powerful tool that is useful in almost all Redux applications. But what will we be covering in this module? First, we'll discuss the features of middleware, as well as the reasons why you might want to use it in your application. After that, we'll discuss middleware structure. Middleware all conforms to one overall structure, and we'll have a look at what that is. We'll also look at examples of popular middleware that's already available in repositories such as GitHub. We'll take an overview of the middleware we'll be building, which is a WebSockets based middleware for Redux. And finally, we'll implement that middleware in the application. In the next clip, we'll have an introduction to Redux Middleware.

Introduction to Redux Middleware
Before we implement it in our application, it's important to understand what exactly Redux middleware is. So at their heart, they're a tool that lets us program our application beyond actions and reducers. These two things, actions and reducers, are the core tools of any Redux application, but in many situations, they're just not quite enough. Unlike Reducers, middleware does not have to be idempotent, it can create side effects or do slightly different things even though you've called it with the same parameters. This lets us put functionality into our middleware that we might have wanted to put into reducers but cannot, because reducers must be idempotent. Two libraries that we'll be having a look at later, Redux Saga, and Redux Thunk, are both popular examples of middleware, and in the case of Redux Saga, and other middlewares that are like it, middleware is useful for managing side effects, or updates to your server. The main alternative, which is putting Ajax calls in your actions, is fine for very simple applications, but for more complicated ones you need middleware. In the next clip, we'll discuss the reasons why you should use middleware.

Why Use Middleware?
So we know what middleware can do, but why would we use it in our application? Aren't actions just fine for dealing with side effects? The first reason why you might want to use middleware is that it provides functionality that's sort of between an action and a reducer. An action is dispatched, and before it's reduced, middleware can take action. This is what happens in Redux Thunk as we'll see in a later module. As we mentioned previously, middleware lets you organize all your changes to the database via Ajax calls, into one place. Middleware allows you to preprocess actions, so you can check them for correct syntax, make sure they conform to your standards, or edit them in some way, like wrapping them in a function. In addition, due to its unique position in between actions and reducers, middleware is perfect for debugging an application, or, you can use it to track things such as Google Analytics, or other tools that you might be using. Middleware allows us to keep our actions clean, so we'll need less boilerplate and less tests in our actions to make sure they're working correctly. In that same vein, we know that all our API communications are going to be happening through our middleware, so if there's a problem with them, that's where we can look first. Overall, middleware has may useful purposes that make it a much needed addition to almost every Redux application. In the next clip, we'll be looking at the structure of middleware.

Middleware Structure
In this clip, we'll discuss the unique structure of Redux middleware. So at the top of the screen is an example of a valid but very simple Redux middleware I've just called consoleLogMiddleware. The first thing you'll notice is the weird structure of the function. It consists of three thunks, or three functions all within the other. The top-level function receives store as an argument, then the function below it receives next, and the function below it receives action. Now next is a special method. When you call next and pass it any action, it will return the state of the application after applying that action. However, until you return it, the state isn't actually changed, so you can call next using the action to get the state, then make sure the new state is correct, or you might just want to log it and then pass the existing state on. The store argument is optional. It can be used for the getState property to view other properties of the state, or to dispatch new actions if that's what you wish. However, a lot of the time you'll just be dealing with next, action, and your side effects. In the next clip, we'll look at some existing Redux middlewares that are already quite popular.

Popular Redux Middleware
Whenever you encounter a situation in your application that can't be resolved with just actions or reducers, you might feel compelled to rush out and create your own middleware without any further hesitation, and while this initiative is good, it's important that we first consider the existing middlewares that are available on repositories like GitHub. Some of these problems have already been solved, and due to their large amount of community support, they've probably been solved better than you could solve them in just a short amount of time. So let's look at some popular middlewares and how they might be used. SO the first most common middleware is Redux Thunk, this is the middleware you'll probably see included in most Redux applications. Redux Thunk, as we'll be learning about in the module on Redux Thunk, allows methods to be passed to the dispatcher. Most of the time the dispatcher can only take objects that represent actions, but by passing methods you can do many interesting things including chain them. Next, is Redux Saga, which also receives its own module in this course. Redux Saga manages side effects, or runs asynchronous processes. So it basically listens to the actions that are going on and then communicates with your database or any other third part component without interrupting the flow of your application. Redux promises another popular middleware, this allows promises to be passed to the dispatcher. You can then do interesting things like call. then or catch errors in your application. Next is a middleware you've probably already seen, Redux Logger. All Redux Logger does is log actions to the console, it doesn't actually change the way your application runs in any way. Similar to Redux Logger, we have Redux Reporter. Redux Reporter is a general purpose tool that can be used to report activity to different third parties, for example Google Analytics can receive messages from Redux Reporter, that lets it know if your particular goals have been reached. Finally, there's a Redux Undo. If you watch the course, Mastering Flux and Redux, you'll know that Redux applications lend themselves well to having their states reversed, or rewinded in time, and while this functionality isn't available in default by Redux, the Redux Undo middleware lets us do just that. In the next clip, we'll be taking an overview of the middleware we'll be making for our application.

Overview of WebSocket Middleware
In this clip, we'll take an overview of the WebSocket middleware that we'll be implementing. So our application has a need to communicate via WebSockets. The server's going to be communicating real-time changes to our application using WebSocket, so we don't always have to be pulling using Ajax. To make this middleware more multipurpose, we'll be using a configuration object that maps actions to certain messages that come from sockets. The values could, as always, just be hard coded, but by using a config object we can reuse our middleware in later applications. The end result of this is that we'll be keeping the side effects out of our action creators, rather than sending a message to WebSockets every time and creating cumbersome set timer loops, this will all just be managed with our middleware. In the next clip, we'll be implementing it in our editor.

Implementing WebSocket Middleware
In this demonstration based clip, we'll be implementing the WebSocket middleware that we've been discussing so far. Specifically, we'll be taking the following action. We'll be starting from the branch, middleware-start, and by the end it'll be the branch, middleware-complete. This time I've also included a URL that includes all of the changes I'll be making in this clip. As you can see, GitHub gives us a div indicating all the changes that have been made. So you can visit this URL to easily see or copy and paste the changes I've made. So in this clip we'll actually be authoring the WebSocket middleware that makes our application communicate in real-time. We'll be configuring the WebSocket component on our server, and then we'll add the middleware to the application's store, which will make it interact with the server every time something happens in our application, and vice versa. So, let's open up our text editor and get started. First, let's add the socket component to our server. We'll start by importing socket. IO. Then we'll create a new instance of socket. io. We'll call socket. IO and pass it our server, this will create our IO interface. Now we're going to make a change to the createMessage method in the same file. This message is called whenever a service or the server itself creates a new message, and we're going to want to notify any connected components. So we'll call io. emit, and we'll start with a string that represents the kind of action this is, we'll just call it NEW_MESSAGE. Then as additional information, we'll pass the ID of the channel, as well as the contents of the message. Next, we'll create the method that simulates activity on the server. This is just for testing and lets us view our application as though lots of people were interacting with it. I'll just check the file out from the application repository. So I'll say git checkout, followed by the branch middleware-complete, followed by the file, server/simulateActivity. js. (Working) So all simulateActivity does is it creates a timeout, and then every time it triggers, it just creates a random message, and then it calls the createMessage method in our server, and as you'll note this calls the socket. IO when it happens. Let's also import a file to do some random changes. So we'll import the file chance. js, from utility, and we'll also get the index from utility. Now if we have a peak at these files, it just creates a new instance of chance, and the index file just makes it accessible more easily using an import state. Now, let's get back to adding the Redux component of our application. First, we'll add a connection to socket. IO in our index file. So we'll add a script tag right here. It connects to this socket. io URL, which is automatically created when socket. IO is added to our server. If you run npm start and look at the application at this point, you shouldn't see any errors, but we won't see the updates just yet either. First, we'll create a new constant to represent this change that's coming from the server. We'll call it RECEIVE_MESSAGE. Now, let's create the socket middleware itself. So inside src, I'll create a new file and call it socketMiddleware. We'll start by exporting a constant, called createSocketMiddleware. Now you'll notice that createSocketMiddleware is a function that creates our middleware, which means we'll call it to get our middleware. We'll pass it the configuration, so as an argument we'll say io, as in the socket interface that we're going to use for the communication, and we'll also in another thunk pass it its configuration. So we'll create a socket by invoking io, then we'll return our middleware. Remember middleware has the pattern store, next, action, so in this it'll look at every key of its configuration, and if the type of the action is equal to the config's key, emit the action to the socket that has been configured for that purpose. Then calculate the result and return it as normal. Now let's add the middleware to our store. We'll go to getStore. js. First, we'll bring in compose from our Redux imports. Compose lets you take multiple middlewares and turn them into one. Now, let's import our createSocketMiddleware method, and we'll import the action that we created at the beginning. We'll get a reference to the Io by accessing it from window. IO, since we can only get it in our index. html. Now let's write some configuration for our sockets. First, we'll write the configuration that happens when something happens in our application and the data goes out, so the name of the key will be UPDATE_STATUS, and it's essentially an action creator that takes a data parameter and returns an action in the shape that the server is expecting. Now we can create our middleware. So we'll call createSocketMiddleware, and pass it io, then in new brackets pass it our config. Now we're going to rearrange this applyMiddleware block into an enhancer. An enhancer is just a convenient way of grouping multiple middlewares. So we'll take this createLogger statement and turn it into its own line. Now we'll create an enhancer by calling compose. Into compose we'll pass a call to applyMiddleware, and now we can put any number of middlewares in here and they'll be combined. So first we'll pass it our socketMiddleware, and then the logger, so we can see what's actually happening. Now instead of this applyMiddleware call, we can just pass the enhancer. Finally, we'll add a line of code to listen for events that come in from the server. So we'll say for each key in the socketConfigIn, now let's define a socketConfigIn, and we'll create a key called NEW_MESSAGE, and it'll basically convert that into an action with the type RECEIVE_MESSAGE. Also, we'll create a new socket for listening to server events. We'll just say const socket = io. Now for each key we'll just say socket. on, and we'll just have the store dispatch what happens when you call the config's property in that key with the data. And we'll get rid of this console. log statement here. And last but not least, let's call simulateActivity in the server, and we'll import it from the associated file. Alright, so now if you run npm start and look at the application, you can see our application is receiving updates in real-time from the server. It's not actually sending anything out, because we haven't added the interface for the user to change their status yet, but you can see we are receiving data and the data that's coming from the socket is being converted 1 to 1 into actions. That was our goal and we can say our application is now a lot more powerful. In the next clip, we'll wrap up what we've learned.

Summary
In this clip, we'll summarize what we've learned in the past module. So we've learned that middleware keeps side effects out of action creators by letting us organize the logic somewhere else. The structure of middleware is a little unusual, but it consists of three nested thunks, or three nested functions. If you need to do some communication with an outside API, odd are you want to use middleware, and you want to avoid putting your login inside individual actions. Finally, we've learned that for many purposes, middleware has already been authored. You should only write your own middleware if it doesn't exist or you want more control. But of course, the improved understanding of middleware that we gained in this module, will prove valuable in using and understanding all middlewares create by third parties. In the next module, we'll enter a very exciting phase in our application where we'll add the visual components using React Redux.

React-redux
Module Introduction
Welcome back. In this module, we'll be learning about and implementing React-Redux. React-Redux is a very powerful tool for adding views to our existing Redux application. Let's review what we'll be learning in this chapter. First, we'll ask the question, why use React-Redux in the first place, and look at some reasons why. We'll look at the relationship between React, Redux, and React-Redux. We'll analyze the two methods that are often associated with the React-Redux application, mapStateToProps, and mapDispatchToProps, then we'll take a moment to implement React-Redux in our application. We'll also discuss container and display components, which are part of the React-Redux family. After that, we'll discuss server-side rendering and find out how it can be done with Redux. Then lastly, we'll implement this server-side, or isomorphic functionality in our application. In the next clip, we'll discuss why we should use React-Redux.

Why Use React-redux?
In this clip, we'll discuss why we should use React-Redux in our application. So, first, let's look at what React and Redux do. Redux is basically a way of representing the state of an application with an object, this object, or map, if you will, is a collection of props, whereas React, React components are given props, a and they turn it into something visual, as in an HTML layout of some kind. So it's almost like they were designed to work together from the very beginning, one organizes props, and the other turns props into visual displays. But of course, we could just take all our props manually from the store and put them on our normal React components. So why should we use React-Redux? First of all, React-Redux reduces the boilerplate in the application. It has helper functions for connecting React to the Redux state that reduce the amount of code necessary to create live updates and interactivity. Additionally, React-Redux forces developers to use best practices. There are numerous means in which React-Redux does this, including providing different pipelines for creating the props and dispatching actions, which we'll discuss in an upcoming clip, but generally, the design of React-Redux is such that it encourages the proper way of coding any given part of the application. On top of that, React-Redux is designed to optimize performance. It watches your state behind the scenes, and cleverly determines which display components need to be updated and when. It always ensures that the minimum amount of HTML on the page changes to accommodate the underlying change in the state. As we know, changes to HTML in real-time are slow, so the fewer of those the better the performance. Finally, as we'll learn in the next clip, React-Redux introduces display components. Display components are agnostic of the environment they're in, and therefore, can be ported from one application to another. Once you start writing display components in the way we'll demonstrate, you can easily move them from one application to a completely different one, as long as they're both built in the React-Redux style. So, in the next clip, we'll be discussing these display and container components.

Display and Container Components
In this clip, we'll discuss display and container components, the two kind of components that almost every React-Redux application is composed of. Let's begin our discussion with display components. Now there are a few rules surrounding display components, and the most important is that they have no state. As you might know, React components have both state and props, well display components aren't allowed to use the state, in other words, it only uses props to determine the HTML. In a sense, it's idempotent, just like our Redux application. So given a certain set of props, you know how a React display component will react, there's no uncertainty. As we mentioned before, display components just don't care what component is enclosing them. They expect a particular set of props, and if those props come in then the display component is happy. This opens the door for us to reuse our display components in many different applications. Finally, the props that are passed down can comprise not just properties as in a name or a color, but methods as well. These methods can be callbacks, which means that part of the display component can make a callback back to the container component. This is critical since the container component is the only part of the application which can actually communicate with the Redux store. So here's a very simple display component. As you'll note, it has no state, only props. The content argument here is a property of the state somewhere, it's being passed in by the container. OpenContent on the other hand is a callback coming from the container. You'll notice how we're passing content as an argument to openContent. This is a best practice wherein in any React display component we specifically say which properties we're passing back to the callback. Other than that, you'll notice that it's quite simple, and it should be. Display components are meant to be simple and easy to understand. Now let's discuss the other side of this proverbial coin, by talking a bit about container components. Now every display component is going to need to be inside a container component, but what are the special properties relating to these components? First, unlike display components which we initialize just like a regular React component with JSX, container components are created by calling the connect method, which is a method that's included in the React-Redux package. Unlike display components, container components can access the store. It can get the state of the store, allowing it to pass properties to the contained React-Redux display components, but it also has access to dispatch, which means when a callback is received from one of these display components, it can dispatch changes back to the store. The container component is the part of the application that determines what these props for the display component are. Most of the time it will get these props from a particular place in the store, which it has access to. This means that if you take a display component and put it inside a different container, as long as the props have the same name and basically the same type, there's no reason why the display component won't work inside the new container. Finally, containers have no display logic. If you were to try and render a container without a display component inside it, it would just look like an empty block of no HTML, therefore, we can conclude that all our display object has to go inside the aptly name display component. In the next clip, we'll talk about the process of connecting container components to display components.

Connecting Components
In this clip, we'll review the process of connecting components. So here is basically all the code required to connect a React-Redux component. At the top, we define mapStateToProps, this method takes state and returns an object representing what the props of the React component are. Below it, mapDispatchToProps works similarly. Instead of state, it gets dispatch, and it passes an object which also becomes props, but all these props are methods, and they're meant to call dispatch somewhere inside them. We'll be discussing mapStateToProps, and mapDispatchToProps, in the upcoming clip. Finally, we create the actual container. We call connect, and pass it first mapStateToProps, and then mapDispatchToProps. By the way, as you may have noticed, these methods could technically be called anything here. We call them what we do, simply for consistency and clarity. The connect method is then invoked on our display component. This creates the container. If this still feels a bit advanced, we'll be connecting several components in our application in the next demo. In the next clip, we'll learn to understand mapStateToProps, and mapDispatchToProps, better.

Understanding mapStateToProps and mapDispatchToProps
Let's take a moment to solidify our understanding of mapStateToProps and mapDispatchToProps. So mapStateToProps is a method which is passed state and returns an object. The object is usually composed of immutable properties. Usually this doesn't mean maps in list, but rather you should break all the data down to strings, numbers, and Booleans before passing them down to the display component. This eliminates the possibility of the display component accidentally changing the data. Now if you were to take a method and try to pass it into the state in mapStateToProps, calling that method would never cause the page to be redrawn. This is the reason why mapDispatchToProps exists, and why methods should always go in the mapDispatchToProps object. However, when the state receives a change, this method is called automatically again to get new values from the updated state. Now, to talk about mapDispatchToProps, it's a method which is passed dispatch and returns an object, similar to mapStateToProps, but this is where the similarities end. The object is usually composed of all methods, and when any of these methods is called, a redraw may be executed. React-Redux will do the challenging work and figure out whether it's necessary to update any of the display components. Finally, there's no way to access state in mapDispatchToProps. If you want a part of the state to be passed along to whatever action you're calling when the callback is invoked, you need to pass it along with the callback. In other words, you just can't access properties in this method, you're only supposed to access the properties of the state in mapStateToProps. Alright, in the next clip we'll go about implementing React-Redux.

Implementing React-redux
In this first demo clip of this module, we'll be implementing React-Redux in our application. This is a very exciting clip since after the application will have a sharp visual display. First, if you're coding along at home, the start branch is react-redux-start, and the complete branch is react-redux-complete. There's also step by step changes available for this like the previous module, at the URL shown here. So in this demo we're going to create the display components for the application. These will be basically complete at the end of this demo. We'll then take these display components and wrap them in React-Redux to connect them to our existing Redux state. We'll add some handlers to take care of the component interactions, and we'll use mapDispatchToProps to pass these along. So, without further ado, let's get right to it. Here I am in my text editor and I'm on the branch react-redux-start. We'll start by installing React-Redux. Now let's create our first display component. Inside the src directory, I'll create a new folder called components. I'll create an index. js file, and I'll create a folder for our first component, the current user component. Now rather than type out all five or six components that we'll be including, I'm just going to spend time typing the first one in detail. The others I might use a bit of copy and paste, so be sure to pay attention closely while I implement this component by hand. We'll create a new file for the display component, and we'll call it CurrentUser. Some developers like to call their display component files CurrentUserDisplay for example, and others still like to put the display component and the container component in the same file. Those are both fine conventions, and there is no reason why those are better or worse than the ones we'll be using now. So this component will simply display the current users name, and provide an interface for them to change their status. First, let's import React from react. Next, we'll make an import from action. We'll import the three constants we made for editing a user's state, ONLINE, OFFLINE, and AWAY. In addition, keeping the constants in the action folder is another convention which not everyone uses. Some people prefer to keep them in their own files, or just wherever they're first created. Now we'll define our display components class, this takes the form of a basic function invocation. Now this format we have here is just the normal form of the most basic React component, the component which does not have any internal state, so here in the arguments we have to pass all of the properties that this component is going to need. We're going to need name, status, ID, and a method for updating the status. So we'll use some round brackets and then put a div tag inside of this method. First, we'll add a header that greets the user by name. There we go, that's friendly, now we'll add a select to let the user update their status. We'll give the select three options, with values corresponding to our three constants we imported. Now we need to hook the select component up to the props and the dispatch, so we'll make the value equal to status, which is a property being passed in by the container. Whenever the user status changes in any part of the application, it should update here. Now whenever it's changed we'll call updateStatus, and we'll just give it a className of form-control for Bootstrap, and for now we won't use the ID property, since as you can see the container will be able to access the target value of this object. Now let's create the CurrentUserContainer. I'll create a new file in the CurrentUser folder and call it CurrentUserContainer. First, we'll import connect from react-redux, then we'll import current user, which is the component we'll need to be containing. So as most container components are made, we'll start by creating shells for mapStateToProps, and mapDispatchToProps. (Working) So with these two shells made, we can actually go ahead and create our connect component without worrying yet what the actual props will be. We'll create a new constanct and export it, called CurrentUserContainer, and then we'll invoke the connect method to get the container. The first argument is mapStateToProps, the second is mapDispatchToProps, and we'll invoke what's returned from connect on our current user component. Now let's fill in mapStateToProps. In this method, we're allowed to do whatever logic or functions we want, to get the data from our state, it's okay to have a bit of code in here. So I'll get the current UserProperty from state. Now I could pass the whole thing to my display component and let it worry about the details, but as we discussed, it's a better practice to pass in only immutable objects, preferably strings, floats, and Booleans to our display component. So we'll pass it the current users name, and the status, and their ID. We're including ID here in case it's required for further functionality. Now for mapDispatchToProps we only had one method that we were passing to our display component, called updateStatus. Now updateStatus we pass the original event, this even has a target property and we're interested in the target. value, and finally we haven't implemented out actions yet, so a console. log will do for now. Great, everything's looking good so far. Now let's update our index to include our new component. I'll export only the container from the container file. We don't need to export the display component because usually only the container is interested in that component. Now, let's update our App. jsx. We'll import our new component from the components folder, so I'll add a row and a column for Bootstrap purposes, and now I'll pass my CurrentUserContainer. Now if this doesn't look complete to you, if it looks like something is missing, you'd be correct. If we try to run this application we get an error, it can't find the store. Well of course, we never passed store to it in the first place, but do we really need to pass store to all of our connected components? We do not. Let's visit our main. jsx to see. So React-Redux provides a provider component, which automatically injects store into any child container components. So we'll import provider from React-Redux, we'll get rid of this welcome message, then we'll create the provider inside its own div tag, and here is the only place where we ever pass in the store, and then inside of the provider we'll include App. Alright, so let's have a peak at our application. Our first component is working, if we make a change, you can see the callback being called not in the display component, but in the container component. It's getting this online/offline property, as well as a name, from the state, using the provider component. Of course, it can't be changed yet, because we haven't set up the action. Now, let's set up the additional components. Now I'll be adding the rest of the components. These components are similar to the first one, so for the most part I'll be copying and pasting them from samples I prepared earlier, and then explaining what's there. Most of the time it should look very familiar as React-Redux components all operate with a refreshing amount of consistency. First let's create a component to show the content of the current channel. We'll call it ChannelContent. We'll create a ChannelContent. js file, as well as a ChannelContentContainer. So, let's add the ChannelContent, and then I'll explain it. Here at the top we're importing three things from our actions, we still have to add fetched and fetching. Then, we're importing a MessageContainer which we'll also create shortly. The ChannelContent notifies the user if they're offline, then maps the messages to message objects like we'll be creating. Let's add those actions. Alright, FETCHED and FETCHING have been added, now let's add a container. So this container is very simple, in mapStateToProps it collects channels, activeChannel, and channel from the state, then it assembles those into the props for our display components. In mapDispatchToProps, nothing's been included, this is not an interactive component. Now, let's add the nested message component. Now rather than creating the files, I'm just going to check the message file out of the appropriate branch. So I'll say git checkout react-redux-complete src/components/message. Now we have this new Message folder, inside let's look at first our display component. Our display component is very simple, it just takes an owner property and a text property. Here inside MessageContainer, everything should look pretty familiar, except the second argument to mapStateToProps, this is own props, so this indicates the props that are received by the message container, since it's actually getting its own ID from a component above it, the ChannelContent display, it needs to access its own props, but luckily it can. Now let's update our index to export our ChannelContent, and let's update our App. jsx to show it. Alright so that's been added. Now if we look at the application, you can see here's the contents of the current channel. The user's names are still displayed as IDs, that's because we won't actually show their names until we've finished the chapter on thunks and sagas. That's all looking good, let's add the final components. Let's add the channel list, I'll Import it by using git checkout, like I did for message. We'll just change message to ChannelList. So here in ChannelListContainer, we're just getting channels and activeChannel from the state, and creating a setActiveChannel method in the props. The enclosed list just maps the list of channels to a child component, a ChannelListItem, and the ChannelListItem shows the contents of the channel. Notice how we're passing the setActiveChannel callback down two levels, from ChannelListContainer, to ChannelList, to ChannelListItem. Let's take a moment here to install classNames. ClassNames, as we're using here, lets us use an object to define a React name for a class. This is more a React tool than a Redux tool, so we don't need to discuss it too much. Next, let's add a list of contents. I'll check it out from the main repository, ContactList, so the ContactListContainer gets contact and name from state. Here we've just omitted mapDispatchToProps, since this does not dispatch anything. The enclosing list takes the contacts and maps them to a number of ContactListItem containers. Here in the item, we'll be using a selector to actually get the proper name from the ID, but for now we've included a placeholder, and the ContactListItem simply displays a media group with an existing contact. Calling openChannel will be invoked if the button relating to the user is clicked. Finally, let's check out the CurrentChannelTextInput container from the main repo. So the CurrentChannelTextInput container is a container, it's gets activeChannel and text and fetchStatus from the state, and to create the updateText and submitMessage callbacks for the component, then it creates the container as normal. The actual component is just an input that updates if the input text of the state is updated, and calls updateText, or submitMessage, when something changes. So, those are all our components, now let's import the index from the main repo, and this just gives us all five of our export statements that we need, and we need to add the remaining ones to App. We'll just do that by checking it out of the main repo. Now, all five components are imported. A nav bar has been added at the top, just for style. Then here's our ChannelListContainer, our ChannelContent, our TextInput, our CurrentUser, and our ContactList. And if we run npm start and open up our browser to localhost-9000, here's the application. As you can see, some parts of it look pretty good, the style is certainly there, but none of these buttons do anything yet. (Working) You'll notice that they all call console logs, because those are our placeholders for the actual actions that we'll be adding in the next module. In the next clip, we'll discuss server-side rendering.

Server-side Rendering with React and Redux
In this clip, we'll discuss server-side rendering with React and Redux. Server-side rendering, which improves performance, especially on mobile, is considered the holy grail of web development, but it is often eschewed by many developers due to its complexity in implementing. However, and I'm only exaggerating a little here, server-side rendering, when you're already working with React-Redux, pretty much implements itself. So how does server-side rendering with React and Redux work? Well as we witnessed in the previous demo, the provider component from React-Redux, injects a store into all child components. The store itself is created at the same time the provider is created. Relating to this is that React has utilities for rendering an app on the server to a DOM, which means that the server can get a provider, get a store of its own development, wrap your application in it, and render it using the DOM utilities all on the server. This just works out of the box because of the way that React-Redux forces you to build application. In the next clip, we'll be adding this isomorphic functionality.

Adding Isomorphic Functionality
In this clip, we'll be adding isomorphic functionality to our application. First, we'll add server-side rendering functionality to express by adding a special middleware to one of its roots. Then we'll move getDefaultState from the client to the server. We'll also be updating index. html. Let's jump to it. So here I am in the application and I want to create new middleware for my server to use to render the application. So I'll create a new file called serverRenderMiddleware, inside server. Now this is actually an express middleware, both Redux and Express use the word middleware to describe their own plugins. So first let's import a few things. First, we need to import createStore from redux, then we'll import Provider from react-redux. We'll go ahead and install a react-dom/server, and we'll import it, and we'll get the renderToString method, which we'll use to create an HTML string from our React application. Let's also install lodash for our templating, and we'll import template from lodash/template. We'll also import filesystem from filesystem. Lastly, we'll import the stuff from our own application we need, the App, and the reducer. So we'll add a method called readModuleFile, which will open a file for us. We'll use this to open up our index. html and then serve it. So readModuleFile will just open a file and if there's any error it will call the callback with that error. Now, let's create the handleRender method. So handle res is passed getState, and it returns a handler for an express route, you can tell because of that req, res signature there. So we'll get a state for our application by calling getState, then we'll create a store right here in our server using the same syntax we would use on the frontend. Now we'll actually write the HTML string that will become our application. We'll say const html, then we'll call the renderToString of react-dom, and we'll pass it our App wrapped in a provider. Now, we'll load the index. html file with readModuleFile. Now the index argument is the actual HTML content of our file, let's take a moment to update that right now. So we'll go to public, index. html. So here is our HTML, first inside our div for our App container, we're going to put another div. Now this is a bit tricky if you've never done this before, because whatever's in the App container will be overwritten as soon as Redux loads. However, until it loads, it will show whatever's inside. If the server renders the entire App and puts it there, not only will it display, but React will be smart enough to graft itself to the existing HTML when it loads. So here, we'll put in a template denoter, with less than, percentage, percentage, greater than, and in the middle we'll put =html. We're going to create this HTML property in just a minute in our other file. Then here, above our two scripts, we're going to do the same thing. We're going to take the window, and add a property to it called PRELOADED_STATE. We're using the window so we can access this later anywhere in our application, and we'll make that equal to a template of of something called preloadedState, which we'll define in a minute. So our new template needs a preloaded state and HTML, so let's go back to serverRenderMiddleware and create it. So we'll create a const called template, and we'll call template on index. The HTML will be the string that react-dom created, and we'll define a preloaded state property by calling the store. getState, and then turning it into normal JavaScript, and then for the preloaded state, we'll just JSON. stringify the existing one. This replace statement here at the end is used to prevent unsafe DOM injection. And let's just call this constant templated, so there's no confusion over the two things, and then we'll just say res. send(template). Now in server. js. here at the top we'll import handleRender from our new middleware. Now we'll get rid of this line that serves the static directory public, rather we'll say app. use, and for the root, just forward slash, we'll call handleRender, and we need to pass it a state, so we'll import getDefaultState from the associated file, and handleRender will be invoked with the DefaultState for the currentUser. Finally, we need to add some code on the front end, so Redux can grab the preloaded state that we've created and turn it into its own state. So inside src we'll create a new file called getPreloadedState. First, we'll import fromJS from immutable, then we'll use fromJS to convert window. PRELOADED_STATE into an immutable preloaded state. We won't need PRELOADED_STATE anymore, so we can delete it, and then we'll export a method which returns the preloaded state. Now, let's go to getStore. Here at the top we'll import getPreloadedState. Now here, instead of using the defaultState, we can use our preloadedState, and back in serverRenderMiddleware, it looks like we forgot to import React, and this template in the import should not be an object import, it should just be a basic import. Alright, and the application now renders from the server, very cool. In the next clip, we'll wrap up this module.

Summary
In this clip, we'll summarize the chapter on React-Redux. So React-Redux builds on the strengths of React and Redux. It's a union of the excellent organization of a state offered by Redux, with the consistent display of React. We learned that container components, which connect React to Redux, are created with the connect method. Display components don't communicate directly with the store, in fact they only have a reference to the methods that their container passed them. In addition, display components don't really know what kind of container they're in, all they know is the properties that have been passed in by that container, and we also learned that the provider component injects store into all child container components. That makes it very easy to render the application on the server side. In the next module, we'll be adding actions and using Redux Thunk.

Redux Thunk
Module Introduction
Hello and welcome to this module entitled Redux Thunk. In this module, we begin the first of two, dedicated entirely to exploring individual Redux middlewares. In this clip we'll be discussing what we'll be learning in this module. We'll be covering the following things. First, we'll be answering the question, what is a thunk? Then we'll learn about the plugin Redux Thunk and how it connects the ideas of thunks and Redux. We'll learn about dispatch and getState, which are the two arguments passed to any thunk in a Redux Thunk application. Then, to solidify all of that, we'll be implementing Redux Thunk in our application. In this module, we'll also be learning to understand selectors. Selectors are a powerful tool that we'll be learning about that integrates closely with Redux Thunk. On that note, we'll take a moment to explore how exactly selectors and Redux Thunk work together. And lastly, we'll also be implementing selectors in our application.

What Is a Thunk?
In this clip, we'll be demystifying Thunks. What are Thunks, and how do we use them? The New Hackers Dictionary has an interesting quote, it reads as follows, I am rather accurately modeled by a Thunk - I frequently need to be forced to completion. This is a pretty funny joke about the overall laziness of whoever it is that made the quote, but it also tells us quite a bit about thunks. So a thunk is a function, commonly in modern JavaScript applications it's an arrow function, though this isn't really a special property of thunks, arrow functions just seem to be taking over all JavaScript applications lately, and this is where the forced to completion line from the previous slide comes in. Simply writing a function, or a thunk, doesn't do anything, it has to be invoked for whatever's inside it to be evaluated. As such, you can say a thunk delays the evaluation of code. At the time that it's written, whatever's inside it might not make any sense, the values may not yet be assigned, but since it's a thunk, whatever's inside is only evaluated at the time you decide that it's ready to be evaluated. One thunk can be put inside another thunk, can be put inside another thunk, with little or no limitations. In fact, when we were writing middleware, we noticed the technique of three thunks being nested inside each other. Due to the way that arrow functions work in JavaScript, three thunks can take up basically the same amount of space in a file as just one. Finally, a thunk really does mean just a general purpose function, there's no special requirements as to what parameters must be passed in, or what values must be returned. So let's look at a simple example of a thunk. The thunk is declared as usual, just as you would declare any method. Inside, we see an example of code being delayed. The console. log statement isn't evaluated until the thunk is called. Maybe in the application you are running, console isn't defined until sometime into the application's lifecycle, but since console. log is in a thunk, this would only throw an error when the thunk is invoked. Additionally, the statement a+1 is not evaluated either, until the thunk in invoked. So in other words, the thunk delays the evaluation of a+1 until such a time as a is ready. Here are some more examples. This function, which takes no arguments and returns no arguments, is technically a thunk, although the code that is delayed is nothing. This function, which takes a variable and returns that same variable, also called an identity function, is also a thunk, and this function, which takes a and be and adds them together is once again a thunk, as the evaluation of a+b is delayed until the function is invoked. And of course, if we were to write that function out long hand, using the function keyword, it would still be a thunk, because it still technically delays the evaluation of the code inside it. In the next clip, we'll be learning to understand Redux Thunk, which is a tool that connects Redux to the concept of using thunks.

Understanding Redux Thunk
Now that we're well versed on what thunks are, let's learn to understand Redux Thunk. So up until this point, we've only been able to pass objects to the dispatch method. Whatever objects you pass to dispatch would be propagated down to the reducers. Previously, if we tried to pass a method to dispatch, we get an error, something along the lines of dispatch can only receive objects. Now, when you implement Redux Thunk, it allows thunks, or methods, to be passed to dispatch. You now have a choice, you can pass a method to dispatch, or just the plain usual object. If you pass a thunk, the results are evaluated at the time that the action is dispatched. If you pass an object, the exact same thing happened as before, it goes straight to the reducers. Any thunks that are implemented in this way get access to two variables, dispatch and getState. Now, clever developers will quickly realize that the dispatch method passed to the thunk can be used to dispatch not just objects, but further thunks, allowing a chain of actions of any lengths. So generally speaking, dispatch will be called with an object when whatever chain of actions that's happening in the thunk is completed. If the thunk wants to do something later, for example wait for the results of an Ajax request before sending out an action, then instead of returning an object, it can return a new thunk, which will be evaluated later. The getState argument is also critical, as it allows the thunk to evaluate the state before doing something new, so for example, it could look to see if a certain data variable had been loaded from the server to the state. If it has, it could just dispatch an action containing that variable in the form of an object, but if it hasn't, it could dispatch a thunk, which contains instructions to call the server and get those results. Let's look at some examples. So here we see a basic action, the kind of which you're familiar with. There's no thunk, just an object, and this object goes directly to the reducers. Now, here's the equivalent action in the form of a thunk. Dispatch is originally passed a method, and that method has its own arguments, receives dispatch, and gets state. Inside the method, or thunk, the dispatch keyword works exactly the same as it did outside of it, so we can dispatch the object, and this is functionally equivalent. In this example, we're using both getState and dispatch. In this case we haven't figured out what the value that's going to be dispatched is at the time that we call the action. This action is smart enough to figure out what values it needs from the state, then it forms an object action based on an action type and the value it just got from state and dispatches that. Finally, here's an equivalent example, except dispatch is called asynchronously, after a 1 second timeout. Typically, you asynchronicity will be due to Ajax calls and not manual timeouts, but this shows how asynchronous code can exist very happily inside of a thunk. Using thunks in this way is the easiest way to add basic asynchronous functionality to your application. For more advanced functionality, sagas are quite a bit more powerful, and we'll be learning about those in the next module. For the next clip, we'll be learning to understand selectors.

Understanding Selectors
In this clip, we'll be discussing selectors. So what is a selector? A selector is a method which takes a state and returns a property of that state. You might say that it selects the property, and if you're wondering, is a selector also technically a thunk, it is, because it's a method. The results of a selector can often be cached, so if you call a selector to get the name property of a state once, and it returns the name, as long as that name doesn't change, the selector should just be able to return the same value as it did last time, it doesn't need to check the whole state again. The interesting part is that multiple selectors can be composed using a library called reselect, which we'll be using for our application. So here's an example of the most basic possible selector. It doesn't implement any special libraries, you just pass it the state and it returns the property of the state called channels. Here's an example of a curried selector. So when the outer method is invoked, the one that takes ID as an argument, it returns another method, this returned method is the true selector, and when passed the state, it will return the channel specifically that matches the ID that it's been curried with. And here is a reselect selector, so to create one of these, we pass a number of selectors to the createSelector method, which is provided by reselect. Each selector but the last one is evaluated, then the last selector is passed only what's returned from the first selectors. These compose selectors are easier to work with, and the results can be more readily cached. So how do selectors interact with Redux Thunk? Thunks and selectors work very well together. Since thunks have access to getState, they can get an up to date copy of the state at any time, pass that state to the appropriate selector, and you'll instantly get the property of the state that your thunk needs. Now if you're using reselect instead of just homemade selectors, then those results will be cached, so if the same request is made multiple times, it can be evaluated more quickly. Finally, reselect takes care of selectors refreshing. You won't need to manually refresh your reselect selectors when you've changed a property of the state that would affect them. In the next clip, we'll be implementing selectors.

Implementing Selectors
In this demo clip we'll be implementing selectors in our application. For this module, we'll be starting at the branch, redux-thunk-start. If you prefer to start from where I finish, you can start from the branch, redux-thunk-complete. And to view a full abstract of all the changes that are going to occur in this module, visit the URL shown. So what are we going to do in this demo? Well first we'll be installing reselect, since that's the tool we'll be using to compose selectors. We'll create a number of selectors for the various properties of our application state, and then we'll bring in the reducers from the repository. We're not spending any time in this course actually writing reducers, since we're focusing more on the advanced topics, but we will take 5 minutes in this video to look at the reducers, which are making our application run behind the scenes. So here I am in my text editor. In this clip, we're going to create selectors, so first, let's create a directory for selectors inside src. Let's start by creating a selector that will select the current user from the state. We'll create a new file and call it currentUser. Now, let's install reselect. I'll type npm install-- save reselect, and we'll import createSelector from reselect. So we'll export a constant called currentUserSelector, and it will be equal to what's returned from createSelector. So as we learned, you pass createSelector a series of methods, the results of all the first methods are used in the final method, which is the selector itself. So we only need to do one thing here, which is get the current user. So I'll write a method that returns the current user property of any state, and since only one argument is being passed to this final selector, it will just be an identity, taking currentUser and returning currentUser. Now, let's try making a selector that selects only a specific user. Let's create a new file and call it userSelector. We'll start by importing createSelector and fromJS. Then we'll export a constant called userSelector. Now unlike the previous selector that just returned what's returned what's returned from createSelector, this is a curried selector, so the outside method is just a method that receives some sort of currying information, in this case the ID. Then it returns the results of createSelector, with that ID as the variable piece of data. So first we'll get the userInfo property off the state. Now this one, the last method, will receive userInfo as its argument. So we'll find the user in userInfo, whose ID matched the ID that the selector was curried with. Now if the user exists, we'll return it, otherwise, we'll return a placeholder value that our application will receive. We'll just have a blank name, the correct ID, and a fetch status of NOT_FETCHED. Finally, we'll wrap this object in a fromJS call to make it compatible with our existing immutable state, and that's the userSelector. The remaining selectors are fairly similar, so we're just going to check them out of the repository. So we'll say, git checkout origin/redux-thunk-complete src/selectors/channelSelector, then we'll also bring in the activeChannelSelector, and while we're at it let's bring in the index file for this directory. So our activeChannelSelector resembles our userSelector, and finds the value activeChannel, and channels, before using them to extrapolate what the activeChannel is. The channelSelector is similar, but it's passed an ID, rather than finding the channel with the id that's the activeChannels, like the other one, this one just finds whatever channel that the id is equivalent to. The index files makes these selectors more accessible. Now let's bring the reducers in. Since this is an advanced redux course, I decided not to spend much time actually talking about the reducers, these are the same reducers that you'd see in any basic Redux course, except they also implement immutability. So rather than write them out, we're just going to import them and then have a quick look at them, discussing any parts of them that may be of interest. So we'll say git checkout origin/redux-thunk-complete src/reducers. Now if we look in our reducers directory, there's a few new files here for us. The activeChannel reducer, and don't worry about that missing import statement at the top there, as we'll be fixing this in the next clip, this reducer listens for the SET_ACTIVE_CHANNEL action, and when it receives it, whatever the ID is of that action becomes the activeChannel property of the state. The channelReducer is more complex, it's listening to a wide variety of different actions, UPDATE_CHANNEL_INPUT_TEXT, SET_CHANNEL_INFO, RECEIVE_MESSAGE, etc. Each of the handlers for these different actions is written separately as a method, the methods all work the same way, they receive the state and the properties of the action and return the new state. The receiveMessageHandler will return an existing copy of the state, if the message already exists. If it doesn't though, it will update the state. Notice the state. setIn line. This is a feature of Immutable. js that allows us to set nested properties of objects that are immutable. We don't have time to go through all the uses of Immutable. js, but if you'd like me to make another course where I discuss functions like setIn in more detail, please let me know in the comments. The requestCreateChannelHandler doesn't have any special logic, it just adds a new channel to the state based on what the properties of the action were. The completeChannelCreationHandler is something we'll be using for our asynchronous functionality, it's only called when the creation of the channel on the server is done, and it just updates the fetchStatus of that channel to fetched. The constant channels combines these various reducers with their keys, and introduces a few others. UPDATE_CHANNEL_INPUT_TEXT, which just updates the current user text property of that channel, and SUBMIT_CHANNEL_INPUT_TEXT, which creates a new message from whatever the input text is that the user's been entering, and updates the channel accordingly. UPDATE_CHANNEL_FETCHED_STATUS simply updates the fetched status of specified channel, based on what the properties of the action were, and SET_CHANNEL_INFO works the same way, but with the info property instead of the fetched status. Finally our userInfo reducer works in much the same way. So, here for the UPDATE_USER_FETCHED_STATUS handler, it checks to see if a user is already there by that ID. If it is, it just updates the status, but if not, it adds a whole new user to the list of IDs. The SET_USER_INFO handler works in much the same way of many similar handlers that we've seen, it finds the index of the user that's referenced in the actions property, and then it returns a modified version of the state, and our index combines all these into one reducer with combineReducers. In the next clip we'll be implementing Redux Thunk.

Implementing Redux Thunk
In this clip, we'll be implementing Redux Thunk in our application. So we'll be installing Redux Thunk and adding it to our application's store. We'll be adding some asynchronous actions using Redux Thunk, and then we'll be implementing selectors like we made in the previous clip, within those thunks. So here I am in my application, first things first, let's install Redux Thunk. Now, let's write an action that implements thunks and selectors. So let's create a new action called submitChannelInputText. This is going to use our current userSelector, so let's import that, and we'll also import chance, for a bit of randomness. Now we'll export a constant from this method, we'll call it SUBMIT_CHANNEL_INPUT_TEXT, and it's the constant that reducers are going to listen for. Now we'll export the action creator itself, called SUBMIT_CHANNEL_INPUT_TEXT. So this SUBMIT_CHANNEL_INPUT_TEXT returns a thunk when invoked, it takes the arguments channel and text. First, well use the selector to get the currentID, so we'll pass getState to the currentUserSelector, and then we'll get that user's ID. Now, since within our thunk we have dispatch, we can call dispatch again with the action object that's been created inside our actionCreator. The type will be equal to the constant we defined earlier, the channel and text properties will be the exact same as were passed to the actionCreator, the owner will be the ID that we just got from our selector, and the ID of this newly created message we'll just create now. Since reducers aren't allowed to be random, if we ever need to create a random thing like an ID, it has to be inside the actionCreator, or at the very least, somewhere outside of the reducer. Now that this action is updated, let's update the CurrentChannelTextInput component, so we'll import our submitChannelInputText creator from actions, then we'll also import our activeChannelSelector and currentUserSelector from the selectors directory. Now here in mapStateToProps, we no longer need to use this demo text, we can get the real values by using selectors. So here, instead of just saying state. get, we can use our activeChannel selector here, so we can just call activeChannelSelector on state. So for text we can say activeChannel. get, and get the property called currentUserText. The fetchStatus can be the fetchStatus of the activeChannel, and the userStatus can be the status of the current user. To get the current user, we'll call the currentUserSelector on state, (Working) and then we'll get that user status. Now here in submitMessage, we no longer want to do this console. log, we want to invoke submitChannelInputText, and once this is invoked we need to pass whatever's invoked to dispatch. If it's a method, the method will be called with the arguments dispatch and getState. Now, let's add Redux Thunk to our store. Here inside getStore I'll import Thunk from Redux Thunk. (Working) Now in this applyMiddleware statement here, I'll just put thunk at the top. Alright, so now thunk is in our application. Before we get going, we're just going to bring in the remaining actions from the repo. There are quite a number of actions, and we don't have time to write them all out by hand, so we'll just import the entire actions directory from the repository and look at what it contains. So I'll call git checkout origin/redux-thunk-complete src/actions, and as you can see we've brought in quite a few actions, but don't worry, these are, these are fairly simple actions, it's not like we've glazed over a lot of complexity, so let's just take a minute to review what these actions contain. So generally, the actions contain two things, a constant, which is what the reducer is going to listen for to update and response that action, and the ActionCreator itself. (Working) ActionCreators that use the makeActionCreator helper are never asynchronous, and always follow the same pattern. The first argument is the type of the action, then each following argument is going to be a property of that action object with the key that's that string. In other words, it's just a normal action with no asynchronous functionality. Here we've updated index to export all the channels and their related constants. OpenContactChannel is the most complicated of the actions, when it's called, it uses a selector to see if the channel that's being opened is already loaded into the state. If it is, it just dispatches a setActiveChannel event, but if not, then it also creates a metadata for the channel and dispatches a requestCreateChannel event, so you can see here how a thunk is propagating additional thunks before it's finished. Here is receiveMessage it's just another vanilla generic message, same with requestCreateChannel, setActiveChannel, setChannelInfo, and etc. As you can see, actions often take the form of this basic utility that's used to represent a simple change in the application state. SetUserInfo functions the same way, we're already familiar with submitChannelInputText, updateChannelInputText also works as a generic action, as with updateChannelLoadedStatus, and updateUserFetchStatus. Finally, just like we updated the one component, the rest of the components directory needs to be updated to interact with these new actions. So, let's check out the components directory from the repository. So we'll check out src/components, now let's look at what's changed. Here in ChannelContentContainer, we're now using a real selector to get the active channel of the state. Here in ChannelList, we're now dispatching the setActiveChannel creator, when we call setActiveChannel. (Working) Here in ContactListContainer, nothing's really changed, but ContactListItemContainer now uses the userSelector, and also calls the openContactChannel method with this batch. The CurrentChannelTextInputContainer now calls dispatch both on updateText and submitMessage. In addition, it uses the activeChannel selector to get the active channel. The CurrentUserContainer now uses the updateStatus action creator when updateStatus is called, and the messages now use the userSelector to find who the owner is of the message. Alright, so with that all brought in, run npm start and open your application. So as you can see here, the application is now looking a lot more solid. The inputs thinks the actions we've created, actually work. When we press Chat though, it creates a new chat, but we never get the opportunity to say anything. That's because the thunks we have are great for interactions within our application, but for doing stuff outside of it, like with the server, what we really need is Redux Saga, which we'll be implementing in the next module. For now though, let's wrap up with a conclusion.

Summary
It has been a challenging module indeed. Let's review what we've learned. So we've learned that despite their special name, thunks are basically just normal functions. They often appear as arrow functions, but really a thunk is technically any function. We also learn that when a thunk is used in Redux Thunk, the arguments for that method are almost always dispatch and getState, and we learned that these two work together to allow an infinite number of actions to be chained together. We also learned that thunks can be asynchronous, performing an Ajax call or using a timeout and then calling dispatch again when it's done. Finally, we learned that selectors work well with Redux Thunk, because getState is provided inside of that thunk, and with getState, a selector can find any property of the state. In the next and Penultimate module, we'll be discussing and applying Redux Saga. The useful information in this upcoming module is, in my opinion, at the apex of the learnings available on this topic at this time. So I look forward to you joining us.

Redux Saga
Introduction to Redux Saga / Module Roadmap
Hello and welcome to this module on Redux Saga. In this module, we'll be learning about Redux Saga, the popular Redux middleware, as well as implement it in our application. Let's start with a quick introduction to Redux Saga. So Redux Saga is a middleware that manages side effects. Side effects refer to anything that happens outside you application, so a communication with an API or a database, or a logging service, anything like that. Redux Saga has over 7, 000 stars on GitHub. This is a lot, especially for a middleware, and it's one of the most poplar Redux middlwares. This is important because with so many stars, you can rely on it getting steady support from the community. Finally, Redux Saga uses the yield keyword. The yield keyword is a part of ES6 that isn't commonly available, and it's required to use sagas, so any application that uses Redux Saga needs a precompiler configured with the latest Babel. In the case of our application, we already have one, but this is an important thing to note. So what will we be discussing in this module? First we'll look at the question, what is a saga? Redux Saga is one of the only JavaScript libraries to use the construct of a saga, so many developers won't be familiar with a saga right off the bat. Next, we'll look at what is Redux Saga, what is this tool that connects Redux to this idea of sagas? We'll learn the various advantages, as well as disadvantages of sagas. We'll learn a bit about the yield keyword, the special, asynchronous keyword that's used in almost all sagas, then we'll take the opportunity to implement a saga in our application. Our application will then be able to communicate with outside entities. After that, we'll look at saga effects. Effects are special methods in the Redux Saga library, that allows us to take data from a saga and return it to our application. After that, we'll learn about interacting between sagas, how can sagas talk to one another? Finally, we'll implement some additional sagas in our application, this will complete our application, minus the dev tools, and give it the full functionality that we saw in the original video. In the next clip, we'll learn what is a saga.

What Is a Saga?
So what is a saga? Well if you ask the dictionary, you might get a definition like this- Saga, any very long story with dramatic events or parts. This traditionally refers to the kind of saga that's told via spoken word, but in many ways it's like a programming saga as well. For example, in Redux Saga, the sagas are meant to be long lived, you start them once and they can run for the entire duration of your application, hence very long, and in Redux Saga, the parts aren't so much dramatic as they are functional. They all do stuff, usually with APIs outside your main application. So, as we discussed, a saga is a long running process. It initializes at the beginning of your application at the same time you initialize the Redux Saga middleware, then it continuously waits for events, or actions, that are dispatched from your application. For all intents and purposes, the components of your application don't know that the saga exists, all they do is dispatch events to the dispatcher related to what's happened, and the saga takes care of the rest. It does so by responding to actions in basically one of two ways. The first is with new actions, so a saga can take an action in, do a bit of asynchronous code, and a few moments later dispatch a new action with the results of that code. This action can then be interpreted by components or even other sagas, as we'll learn later. The other way it can respond is by side effects, so for example, calling an external database API. Anything that changes the state of something that isn't your core application, is referred to as a side effect. Alright let's imagine two people in a hypothetical situation. John owns a little diner that is frequented by a farmer named Dave. Dave lives out in the country, so whenever mail comes for Dave they don't deliver it directly to him, but just to John's diner. Since Dave is such a regular, every time he comes in he just gets his mail from John. So in this example, the service John provides is a saga. Let's look at how this breaks down. So the mail is delivered for Dave, but Dave lives far away, so this action can't be completed in one go, not synchronously, there needs to be some asynchronous action. So John holds his mail until such a time as Dave picks it up. So here we have three players, and they all represent different parts of our application. First, there's the Post Office. The Post Office represents the interaction with the application, or the user's input. When the user makes an interaction, the so called Post Office sends a notification. In the example, this notification goes to John's diner. John's diner is a symbol for a saga, it is just a long running process that relays messages from one place, the Post Office, to another, Dave's mailbox. So in this case Dave's mailbox is a side effect. It's not happening within the saga of John's diner, it's something else. We can almost look at it as a database, in which input is saved. So sagas have a bit more nuances than John's saga diner, but this is a good framework for us to go forward and understand sagas a bit better. In the next clip, we'll learn about Redux Saga.

What Is Redux Saga?
So we've learned a bit about sagas, but what is Redux Saga? So Redux Saga is, as the name suggests, middleware that's inserted into the chain of middleware in your application. This one deals specifically with sagas. The way it works is that sagas, which is a general term for any sort of long running process, are started, and then those processes are passed a copy of any actions that are dispatched by your application. The saga then determines if those actions are meaningful to it, and dispatches new actions or creates side effects accordingly. Let's look at it step by step. First, at the beginning of your application, the middleware is initialized. The saga middleware is then passed a bundle of sagas, which are then initialized. The middleware which had the sagas added to it, is then added to the store, whenever an action is dispatched, the action is passed via the middleware to the saga. The saga then executes, or doesn't, but if it does then it may create some side effects. Then, the process repeats indefinitely from actions passed from middleware to saga. These last three steps occur again and again, possibly thousands of times, during the application's lifestyle. In the next clip, we'll compare Redux Saga to Redux Thunk.

Redux Saga vs. Redux Thunk
Redux Saga and Redux Thunk are often grouped together in discussions about Redux middleware, but are they really equivalent? Let's find out. So Redux Saga at its whole is middleware, it follows the middleware pattern, and is inserted into your Redux store. You have to compile your sagas before they'll run on any modern web application. This is because sagas use the yield keyword, and this can't be interpreted yet by most browsers. While Redux Saga passes actions to sagas, it doesn't actually change them in the same way that say Redux Thunk would, so other pieces of the middleware chain aren't even aware that Redux Saga is there in the middleware chain above it. Redux Saga creates side effects, so it causes things to happen that are outside of the application, and ultimately, a saga is suitable for any use case where you have to make a call asynchronously to some kind of API. Now, let's compare it to Redux Thunk. So Redux Thunk is also middleware, in that way the two middlewares are the same. Generally, you don't have to compile your Redux Thunk, Redux Thunk relies mostly on arrow functions, and these are largely supported. So for example, if your application only intends to target Chrome, you don't need any compilation to get Redux Thunk going. Unlike Redux Saga, Redux Thunk is in there changing your middleware chain. when an action is passed in the form of a method, Redux Thunk executes that method with the expected arguments. This is instead of the application crashing due to an error. In other words, the middleware chain has been changed by what Redux Thunk is doing behind the scenes. Redux Thunk does not by default create side effects, you can implement them by say using an Ajax call in a thunk, nut ultimately Redux Saga is more suitable for that, Redux Thunk is more suitable for preparing data synchronously. As we learned in the previous chapter, you can use selectors inside thunks to prepare data in advance for actions which will be dispatched. Alright, in the next clip we'll take a moment to understand the yield keyword.

Understanding Yield
In this clip, we'll be learning to understand the yield keyword, the powerful keyword that is used in almost all Redux sagas. So yield is a special keyword, it can only be put inside a special kind of function that we'll be seeing, called a generator function. When a generator function is run, the parent process is suspended so that a child process can run. When that child process gets into the word yield, it is suspended, and at that point the caller process resumes. This can continue numerous times, as multiple values are yielded from the generator function. Now due to the large amount of material that we're covering in this course, I haven't had the chance to talk about yield in as much detail as I'd like, but if you'd like me to put together another course, diving even deeper into yield, let me know in the comments. In the next clip we'll be implementing the UserStatus saga.

Implementing the UserStatus Saga
In this clip, we'll be implementing the UserStatus saga in our application. First, we'll install Redux Saga and implement it in our middleware chain, then we'll create a user status saga that listens to actions and updates user status. We'll use the middleware to connect the saga to events that are happening in our application, and we'll use the saga to create side effects that are going to effect the API portion of our app. So, let's open our IDE, and jump right into it. So here I am inside my IDE. First, let's install Redux Saga. We'll type npm install--save redux-saga. Now, let's implement the saga in our store. Let's go to getStore. So here I am in getStore, and we're going to import createSagaMiddleware, so we'll import that from Redux Saga. Below this, we'll initialize our saga middleware. We'll create a const sagaMiddleware, and we'll create it by calling createSagaMiddleware. Now, we'll put the saga middleware at the top of our enhancer. Now, let's write our first saga. So in the src directory, create a new folder called sagas, and inside this directory let's add a file called currentUserStatusSaga. So the currentUserStatusSaga is a very simple but typical saga, it's going to listen for our updateStatus event, then whenever it hears it it's going to call the server and basically let the server know, hey, the status has been updated. It's simple because it's not going to be interested in what the server says in response, it's just letting the server know. First, let's do our imports, we're going to import UPDATE_STATUS, the constant from actions. It's going to listen to this action type to decide whether or not to take action when an action happens. Next, we'll import our currentUserSelector. Selectors are not just useful in Redux Thunk applications, but in Redux Saga applications as well. Next, let's import a few things from redux-saga/effects. So we'll import three of these so called effects, takeLatest, call, and select. We'll be learning more about these in an upcoming clip, basically effects our ways of taking information out of your application and putting them in a saga, and vice versa. Now, let's define our currentUserStatusSaga. So the UserStatusSaga is a function with a star at the end of it, a generator function. Inside the generator function we can call yield, so all it will do is yield the takeLatest of UPDATE_STATUS. So what this means is that every time UPDATE_STATUS runs, it'll run the function, putUserStatus, which we haven't written yet. Let's write putUserStatus. This is also a generator function. So what happens in here is very much like a regular function, except instead of return, we need to use the yield keyword to know that the thread that called it has to resume. So first we'll find our currentUser. Now here's where we'll use the select effect, the select effect is placed after yield, and passed any kind of selector. This effect will call the selector with the state of the application, and then resume the next line of script with that in memory. So we'll get the ID of the currentUser that we got from the selector. Finally, we'll call an outside method, so we'll say yield call. Now whatever's inside this call bracket, will be executed when the application gets to this line of code, and the results will be yielded to the parent function. So here in this method we'll call the built-in fetch API, and we'll call the API URL /status/id/status, and we'll put a console. log here too, just so we can get a better insight into what's going on. So now, whenever the updateStatus action is dispatched, the putUserStatus method will run, ultimately it will call the API before yielding the thread. Now all we have to do is go back to our store and initialize the saga. So we'll import our new userStatusSaga. So then we'll tell our saga middleware to run the saga, and let's just change this to. /sagas, so it knows it's a local path. Now if we run the application we'll actually see an error. Before running a Saga, you must mount the Saga middleware on the Store using applyMiddleware. So let's go back to our IDE. So basically, instead of calling sagaMiddleware. run here, right after we've imported it, we have to call it right at the end, above our getStore method. And lastly, let's just quickly disable our logger for a minute so we can more easily see the logs in our console. Now let's run the application and check it out. So here's the application. Every time we interact with this, the Put user status method is called. Once we complete the application in one of the upcoming clips, this will update the data on the server, but as you can see, the currentUserStatusSaga is called whenever the action that it's listening for in takeLatest is called. Alright, in the next clip we'll step back and learn a little bit more about Redux Saga effects.

Redux Saga Effects
In this clip, we'll learn about Redux Saga effects. Let's start with a definition. According to the docs, an effect is simply an object to be interpreted by the middleware. So, like in our previous example, all an effect does is take an object and either transfer it to or from the middleware. So effects are always used in conjunction with the yield keyword. When you call an effect after yield, effect will wrap whatever functionality you want in such a way that it's appropriate for yield. In this way, you can take data that's in the saga, like what's returned from the server, and bring it back to your application. We saw there were a few different kinds of effects. In our example we used takeLatest, but in the next demo we're also going to be using take, which runs the child process every time an action is run, instead of just the latest time. Like the yield keyword, we could spend an entire course discussing Redux Saga's effects, so if you'd like to learn more, let me know in the comments and I'll be sure to put together another course just on this topic. In the next clip we'll learn about interacting between sagas.

Interactions Between Sagas
Let's quickly discuss the interactions between sagas. So in addition to creating side effects, sagas can dispatch other actions as well. These actions are passed along to every other saga that's being managed by Redux Saga. These sagas don't know if that action came from within your application or another saga, so it will reply to it in the same way. That saga can then dispatch another action, and the other saga can dispatch another action and so forth, creating a long chain of easily managed asynchronous functions. This is the most testable way of doing a long chain of asynchronous functions in your application, and is far superior to doing so inside a thunk or series of thunks. We'll have a look at this when we implement it in the next clip, so let's do that now.

Implementing Additional Sagas
In this clip, we'll be implementing additional sagas to make our application functionally complete. First we'll organize our sagas into a single directory with an accompanied index. We'll create sagas for channels and input, and we'll use effects including take, takeEvery, call and put. So, let's jump into our application and get right into it. So, in the interest of time, rather than writing all the sagas by hand, I'm just going to check them out of the finished repository and take some time to talk about what's going on inside each of them. So we'll say git checkout redux-saga-complete src/sagas, oh and that should be origin/redux-saga-complete. Now if we look in our sagas directory, we have all of these new sagas that have been prepared. Let's have a look. So the activeChannelSaga, which is very similar to our userInfoStatus, takes the latest of the SET_ACTIVE_CHANNEL events. It then finds that user's ID and calls the server letting it know that user's activeChannel has changed. This is so that when they refresh they'll see the same channel they viewed right before they closed the application. The channelSaga is a little bit more complicated. Here it is. Now if we go to the bottom, we can see the channelSaga once again just takes every instance of the SET_ACTIVE_CHANNEL event, and it calls fetchChannelInfo. Now when this runs, it listens to the event and it says this active channel that's just fetched, have we already got the information, the metadata about that channel? If it isn't, it will use two yield statements in a row, that's because fetch returns a. then a promise, so instead of calling a chain of. then, we can just call yield twice in a row. This gives us our channelInfo, or the information the server had about the channel. Then when it receives that data, it sets the channelInfo using the preprepared action. Otherwise it just yields, which means to end the execution of the generator function. The createChannelSaga works very much like the activeSagaChannel, it takes every instance of a particular event and it passes it on in the form of an API request to the server. By now you're probably beginning to realize that sagas hold a particular shape, and you also almost never see long callback strings in sagas because of the gray yield keyword. The currentChannelInputSaga functions much the same way, keeping the server updated of what the user currently has partially typed in in the channel. We're already familiar with the currentUserStatusSaga, and here's the userInfoSaga. It's a bit more complicated, so let's look at what it does. So whenever the SET_CHANNEL_INFO action is dispatched, this saga will call fetchChannelUsers. Now, fetchChannelUsers is very interesting, it gets passed an array of IDs, all the users that are in this new channel that maybe we don't have any information fetched about them. So we'll do a for of loop. The for of loop is a very interesting construct that works with yield. Inside notice that we've called yield fork, followed by a new method. For will create different child processes for each of these arguments, in other words it'll make a separate parallel Ajax call for each one of the IDs. It's amazing how easy this is to set up and yield, whereas how complicated it would be to set up in a traditional ES6 environment. The fetchUserInfo saga is once again pretty simple, it just gets the user based on the user's ID. If the user's already fetched, it does nothing, but if they're not fetched, it just calls the user endpoint of the API. Here in this index, I've organized all of the sagas into one file. Now, let's bring in a file that initializes all the sagas from the main repo. (Working) So we'll just bring in from origin/redux-saga-complete src/initSagas. js. So if we have a look at it in sagas, it's a very simple function that just takes all the sagas, it's passed the middleware as an argument, and then it inits all of those sagas using the middleware. Finally, let's check out getStore. js, just to update it to work with all the sagas instead of just one. As we can see, it's all the same but initSagas is now called, instead of just our initializing the one saga. So now when we run the application we can see that all the sagas are running. If I go to this conversation, and these will be a little different from you due to the random seed, but just go into any conversation and type something in. Now if we refresh the page, our message is still there, the saga has sent it to the server. Similarly, if we create a new chat, it'll appear on the left. Then if we refresh, it persists, because it's been created on the server. Wow, it's amazing how much server functionality we put in using just a few sagas. It's at this point that the application is functionally complete. We'll be adding the dev tools, as well as cleaning up some of the rough edges in the next module, but this is a great opportunity to sit back and look at the app that you've created in this course. In the next clip, we'll be reviewing what we've learned.

Redux Saga Review
Let's review what we've learned in this module. So we learned that Redux Saga's a middleware for creating side effects, and we learned that side effects are basically things that happen on your server, or another server. Any number of sagas can all be run in parallel, and this is one of the big strengths of sagas and probably how they should be applied. We learned a saga is a long running process, you run it once at the start of your application, and then it'll keep running for the entire duration of your application, sometimes months. Sagas use generator functions, as in functions with a star, and the yield keyword almost every time. These keywords are challenging to master, but simply by applying their basic use, our code is a lot more readable. Finally we've learned that those sagas can receive actions and generate side effects, they can also dispatch actions, updating your application or otherwise, notifying other sagas about work they have to do. In the next and final module, we'll be learning and implementing Redux DevTools.

Redux DevTools
Introduction
Hello and welcome back. In this module we'll discuss and applyRedux DevTools. Redux DevTools are a useful tool for debugging any Redux application. So what will we be covering in this short chapter? First, we'll answer the question, what are Redux DevTools, then we'll demonstrate proper installation of the Redux DevTools. Finally, we'll look at how an application can be tested using these DevTools. So in the next clip we'll discuss what are Redux DevTools.

What Are Redux DevTools?
So what are Redux DevTools? Well, like Redux Thunk or Redux Saga, Redux DevTools is middleware. It's added to the application's middleware chain, and it passes this information, the actions that go through it, along to the DevTools interface. Now this interface is actually pretty similar to the interface that's already in Chrome DevTools, except it's full of Redux specific stuff like reverting to previous states. So you can do this undo behavior right in the application. Redux DevTools will also log anything that's happened, similar to the Redux Logger. Finally, using Redux DevTools can enable time travel debugging, or a process in which the application can be paused and then resumed at any previous state to look at that application at that time. Alright, so in the next clip, we'll install DevTools in our application.

Debugging the Application with DevTools
In this clip, we'll be debugging the application using Redux DevTools. We'll be demonstrating how to show and hide DevTools, how to disable and enable actions, as well as how to revert to previous states. Let's get started. Here I am in my IDE on the branch devtools-start. First, let's create our DevTools component. So inside src/components, let's create a new folder called DevTools, and inside that we'll make a file called DevTools. jsx. Now, let's import React and the createDevTools method of Redux DevTools. So we're going to import two components of DevTools, first we'll import the log monitor. The log monitor shows previous states of the application and can be used to change its history, so we'll import LogMonitor from redux-devtools-log-monitor. So we'll import the DocMonitor from redux-devtools-dock-monitor. This allows the DevTools to be docked on the screen like Chrome DevTools. Now let's install these two packages in our terminal, LogMonitor and DocMonitor. (Working) Alright, so now let's export DevTools, and that will be a createDevTools call. So in order for createDevTools to work, it needs to be passed a JSX component, so we'll start by passing in the DocMonitor. Now, let's give it some properties. First, the toggleVisibilityKey property, and this is the button that will make it visible or invisible. Let's set it to ctrl-h. We'll define a changePositionKey, which moves the DevTools around. We'll make it equal to ctrl-q, of course you can choose something different if you want. We'll set a defaultPosition to bottom, and we'll set defaultIsVisible to true. Alright that's set up, now we'll add a LogMonitor as a child of the DocMonitor, and LogMonitor needs fewer properties, so we'll just give it a theme property, and we'll make that equal to tomorrow. Alright, so our DevTools component has been written. Let's update our index. Now let's add the DevTools to our middleware chain. Let's go to getStore. So we'll import the DevTools from our directory. So here in our compose, after applyMiddleware, we'll add DevTools. instrument as an argument. So now the DevTools has been added to our store, but DevTools consists of two components, the middleware that you add to the store, and the component which you actually see. So, let's go to main. jsx. We'll once again import our DevTools, and now at the bottom of render, underneath Main, we'll just put DevTools, and we'll pass it the store, and that's just equal to the store variable. Now if you run the application, you'll notice we have these DevTools at the bottom. Now you'll recall that we set up some hotkeys, if we press Ctrl+H while we're on this page, the DevTools disappears or appears depending. More usefully, if we press Ctrl+Q, the DevTools will move around. It's easier to read when it's oriented to the right, so let's set it up here and have a look at what's happening. So it's receiving these RECEIVE_MESSAGE events from the server, whenever an action happens, DevTools lists the action on the right side of the screen. So for example I can change my channel to this one, and when I do, we see the SET_ACTIVE_CHANNEL event right here, so any actions that are taken are shown in the DevTools. Of course what's much more interesting is if I click this, it's now disabled, and the app runs forward as though every event but that one has happened, so it's just like the same thing except the channel never changed. This is a very cool debugging ability that you can only do in Redux DevTools. If the Reset button is clicked, the app goes back to its initial state. If you click the Commit button, then whatever state that app was in, is now saved. Should we ever want to go back to that committed state, we can click the Revert button. It's also possible to save and load the application state as a string using DevTools, but we won't be demonstrating this right now. Alright, well it looks like our application is complete. In the next clip, we'll be wrapping up this chapter.

Conclusion
Let's summarize what we've learned in this module. So we learned in terms of look and feel, the DevTools are really similar to the Chrome DevTools that we are so familiar with. We learned that the DevTools has both a middleware and a component aspect, and both need to be included in the application. We saw that Redux DevTools can turn back the clock on an application, reverting to previous states. It can also create a whole new preset state by deleting actions that occurred previously in the history. Overall, Redux DevTools are a debuggers dream come true. They make it much easie to figure out Redux problems, especially complicated ones. Alright, in the next module we'll conclude and review this exciting course.

Conclusion
Reviewing the Application
Welcome to the conclusion of this course. This course, in my opinion, has definitely been the densest and most full of knowledge course that I've taught, so it's important that we take some time to review what we've learned. We'll start by reviewing the finished application. We'll review the application's immutable state, its middleware stack, its React-Redux components, its thunks, its selectors, its sagas, and how all these components fit together. Alright here I am in the editor, I've opened up the master branch. The master branch is similar to the DevToolsComplete branch, but I've just taken some time to clean up the line endings, remove the comments, etc. So the immutable state of the application is found throughout, but it's most obvious in any of the reducer files. All of these reducers look different than non-immutable reducers. They use methods like set and set in, that only work on immutable objects. The middleware stack can be found in getStore. We can recall that we installed the sagaMiddleware for sagas, the thunkMiddleware for thunks, and the socketMiddleware for doing WebSockets. We also added DevTools, and persisting the DevTools state, which we didn't get a chance to talk about, but it's here in the master branch if you want to have a look. All our application's components follow the container display pattern. For example, in ChannelContent, we have out ChannelContent container, which has a mapStateToProps, and a mapDispatchToProps method, and that ChannelContent, which contains just a dumb React component that cannot interact directly with the state. All our components, other than the DevTools, follow this pattern. To see our thunks, we have to go to the actions directory. Rather than creating this action with the generic action creator, if the action is a method which returns another method, that method can be passed the arguments, dispatch and getState. GetState can be used to find parts of the application before any logic is done. In our application, since we used both sagas and thunks, we were able to output any of the side effects onto sagas, so we found that thunks work best for asynchronous actions that much occur within the application. Our selectors here in the selector directory are simple and easy to use. They're just a function that's passed state and returns a property of that state, but we've found there's many opportunities to use selectors both in thunks and in sagas. Speaking of sagas, the sagas are the most unusual part of this application. The functions with a star, the generator functions and the yields, are unlike the syntax you see in any other application, but as we can see here, using yield instead of callbacks or promises, requires a lot fewer lines of code, and if you understand what yield does, it's much easier. All our sagas look basically the same, with a createSaga method, and then a different function that it delegates the actual nuts and bolts to. If you combine all of these, you get our application. Of course, you can have an application that uses thunks but not sagas, it all depends on what you need. This application that we made is really a toolbox of every tool that exists for the Advanced Redux developer. In the next clip, we'll summarize what we learned in the course.

Course Summary
We'll now summarize everything that we've covered in this course, to quickly cement what you've learned in your mind. So first we learned about immutability. We learned that Immutable. js takes mutable JavaScript objects or arrays and turns them immutable. We found that in practice immutable state is more challenging to work with than mutable state, you can't simply access the properties with dots and change them, you have to use specific functions. This results in fewer opportunities for errors to find their way into the code base. Whenever you change a property on an immutable object, it usually has to be deliberate. And we found that since immutability works best with relational state shape, as in state where values are never repeated, we should use that state shape in our application. That's because it's hard to edit multiple parts of a state in one method, which you have to do if any parts are repeated and they change. Regarding combineReducers, we've learned the following. The default combineReducers is good because it forces developers to use best practices, but it only works for a single use case. We learned if you want to use immutable state, you have to use some kind of custom combineReducers. We also learned that if desired, combineReducers can be made in such a way that individual reducers get more than just one property of the state. Next up we learned about Redux middleware. Middleware is needed for any activity that's not dispatching an action or updating the state. Middleware can also do interesting things like modify actions or stop them, as they find their way down the action pipeline. Middleware can and should be used to create side effects. A side effect is, for example, a change in the database. And finally, for many common use cases, middleware already exists on npm. Let's review what we learned about React-Redux. So React-Redux is a tool that basically takes the Redux state and turns it into a React view. Now when providing access to the state to components, it separates reading the state with dispatching events; this optimizes performance. In a React-Redux application, display components, which do not contain any business logic, are wrapped in container components. Container components are created using the connect method, which is a method available in the React-Redux package, and the provider class, also available in the package, passes the state to any connected children. Now let's review what we've learned about Redux Thunk. So Redux Thunk changes dispatch so that methods can be passed to it. Before this change, only objects can be passed to dispatch. Methods that are passed a dispatch get called with getState and dispatch arguments, and within a thunk, you can use dispatch to dispatch an action, or another thunk, creating a chain of asynchronous actions. We also learned that selectors, which are a performant way of accessing the applications state, can be used inside thunks, to great effect. Finally, we found that for creating these selectors, Reselect, the npm library, is an excellent choice. Reviewing Redux Saga, to use Redux Saga in your application, you need to use generators and the yield keyword, so you're going to need a high level of ES6 support. We learned that Redux Saga manages side-effects, so if you're talking to a database or communicating with an outside API, a saga is the best way to do it. We learned that to get the middleware running, you insert it into your middleware chain and then run any number of sagas. We learned that sagas can, in addition to dispatching more actions back to the application, create side effects by communicating with outside servers. Finally, we noted that sagas can respond to actions that come from other sagas, creating a new way to chain asynchronous actions. Finally, let's review what we learned about Redux DevTools. We found that they're similar to Chrome DevTools in that they appear nested next to the application and can be used to view its state. Redux DevTools logs any changes, and the actions which cause them. Redux DevTools can let you undo or redo actions to note their exact effect on the state of the application. And finally, Redux DevTools can recreate the whole past state of an application, allowing for the most in-depth troubleshooting possible. In the next clip, we'll discuss continued learning.

Continued Learning
Now that you've reached the end of this course, you may wish to continue your learning on this topic, or other closely related topics. Here are my suggestions for materials you can use to continue your learning. First, I recommend you check out JavaScript Weekly on a weekly basis. This is like a combination of all the relevant JavaScript articles and new technology that have been released over the week. This is the best way to just keep your learning about JavaScript up to date. In addition, I recommend you check out the JSConf videos on YouTube available at this URL. JSConf is great because the people who speak there are really industry leaders. There are a wide variety of talks, and their low production overhead results in more up to date materials. And if you'd like to see me visiting either of these sites and explain them further, please check out my course, Learning Flux and Redux, in which I take a full dive into these two websites. Finally, if you'd like to look at some of my other courses, please check out Pluralsight. com/authors/daniel-stern. In case you're wondering, I have courses available on Integrating Node Applications with GitHub, testing your React applications with Jest, and my most popular course so far, Building a Full-Stack App with React and Express. So you'll find especially with the last case, Building a Full-Stack App, what you've learned in Redux will be very valuable, and if a deployment is what you wish to do, then you'd definitely benefit from watching my course on Integrating Node Applications with GitHub, since the teaching there can be used to deploy an application that's very much like this one.

Thank You!
Wow. It has been quite a course, and I sincerely hope that you learned as much watching it as I did putting it together. Now if you're watching this video, that means you've watched all the way to the end of this course, and if you haven't watched the whole course and are just skipping to this video, go ahead and watch the course now. I'll wait. For the rest of you, I want to extend a very special thank you to you personally, for completing this course, as well as a congratulations. In general, starting a task and then seeing it through to completion is one of the hallmark qualities of good character, and by completing this course, you've demonstrated that quality. I hope you use this knowledge of Redux well in your workplace, or just on personal projects that really get you excited. I've been Daniel Stern, you can follow me on Twitter @danieljackstern. Good luck, and happy coding.
