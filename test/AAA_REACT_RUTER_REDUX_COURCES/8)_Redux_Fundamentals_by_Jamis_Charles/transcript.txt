Application state is the central and crucial piece for any single-page web application. When your app starts to become confusing, this is generally where things go wrong. Painful and confusing bugs start creeping in and you can't seem to keep them out. In this course, Redux Fundamentals, you'll learn how to transform an existing web app to use Redux. First, you'll explore a React app with state problems and look at whether you should use Redux to fix these state problems. Next, you'll discover how to apply Redux piece by piece and analyze the basic building blocks of Redux in simple terms. Then, you'll delve into migrating your React app to Redux. Finally, you'll learn how to add Redux to any web app. By the end of this course, you'll be able to add Redux to an existing app or a brand new web application with confidence, and be able to exercise good judgment to choose when, how, and if using Redux is the right choice for your team.

Course Overview
Course Overview
Hi everyone, my name is Jamis Charles, and welcome to my course, Redux Fundamentals. I am a UI engineer at PayPal. That means I spend all day writing client-side JavaScript and Node. At PayPal, I led the migration from the send money app from Backbone to React and Redux. What an improvement. Our whole team now loves Redux. Redux is a powerful tool to help simplify state management in your JavaScript web application, and has taken the JavaScript community by storm. In this course, we are going to learn all there is to know about Redux, and no prior React Redux experience is required. Some of the major topics that we will cover include deciding whether Redux is a good fit for your project and team, common state problems and pitfalls with single-page applications, how to migrate your app to Redux beginning to end, Redux under the hood, how to add Redux to any web app, React or otherwise. By the end of this course, you'll be the Redux expert on your team, and you'll be able to implement Redux with confidence in your web application. Before beginning this course, you should be familiar with basic JavaScript and npm. I hope you'll join me on this journey to learn Redux with the Redux Fundamentals course at Pluralsight.

Introduction
Introduction
Hello. My name is Jamis Charles, and welcome to Pluralsight's course, Redux Fundamentals. I'm a user interface engineer at PayPal, and for the last several years my team and I have been using Redux to manage the complexity of our JavaScript web applications. We have been very happy with Redux, and I'm excited to share my experience with you. So why Redux? What is Redux? At its simplest, Redux is a tiny JavaScript library that helps you organize the data in your single-page web application, and it helps you visualize how data flows through your application. This is something that can often get really complicated in web applications, and Redux really makes that a lot simpler. According to the website, Redux is a predictable state container. If you have no idea what this means, don't worry, we'll talk more about this in a few minutes, but for now let's take a look at the course overview. We'll start with a crash course into React. Redux is often used with React, so I'll be showing some demoes with it. If you aren't very familiar with React, this will get you up to speed so you can follow along nicely. Then, we'll show the difficulties of managing and maintaining state in a web application. Following that, we'll integrate Redux into this React web application. This will be a great foundation into Redux, whether you plan on using React or another web framework. Then, we'll show how to use Redux with other JavaScript frameworks like Angular or Vue, and what the benefits and tradeoffs are. Lastly, we'll rebuild Redux from scratch to give you a deep understanding of what Redux is doing under the hood. This course is primarily intended for frontend web developers who know JavaScript. In order to get the most out of this course, it helps if you've used a web framework like Backbone or Angular or React or View before, but that's not a hard requirement. Even if you haven't, you'll still get something out of this course. The GitHub repository for this course will live at the following address. The most recent information or updates can be found here. If there are any significant API changes, or if you're concerned that you don't have the most recent content, this is the place to go. We've mentioned state several times, but what exactly is state? Let's take a look at a simple UI here. We have a currency converter that converts, in this case, 30 U. S. dollars to 28 Euros and 20 cents, and the conversion rate is 1 U. S. dollar to 94 European cents. In this user interface, we have labels like Convert and Conversion Rate, and we have several values, like the from amount which is 30, the to amount, which is 28. 20, we have two drop-downs which show currencies, and we have the conversion rate values. All of these values are part of the state. A good way to represent this state is as a JavaScript object, and this is often called a model. So here we have the fromAmt, the toAmt, the fromCur, the toCur, and the conversion rate. Sometimes some of these state values can be incorrect. In this case, the toAmt suddenly shows 2820 euros, instead of the expected 28 Euros and 20 cents. This is what we would consider a state bug. As we try to troubleshoot this, we need to find out where in the JavaScript this went wrong. In a simple web application, you could just step through the JavaScript and find out pretty simply, but in a complex single-page application, this can sometimes be difficult. But to understand how state bugs like this can occur, let's take a look at how data flows through a traditional client-side single-page application. In a traditional client-side MVC framework like Backbone, you have models that contain the state. Usually you have several models, which is a nice way to break up the state so it stays manageable. These models contain the state for the application. These models then call for the UI to be rendered, while passing in the state information to the user interface. Then, if the user comes along and chooses to change any of the inputs or any of the drop-down values, a UI change event is fired to the model, and then the model can choose what to do. Sometimes that means that the model will simply update itself, and update the state for the application, in other cases it may call an API and fetch information from the server like currency conversion rates or calculating fees, things like that. Then, when the data comes back from the API, usually the model updates itself, which generally will trigger the UI to re-render itself, so the model will automatically re-render the user interface if any of the models change. So far, so good, nothing too crazy yet, but it's often common in Backbone to have some models that listen for change events in other models. That means if this model here changes, this model up here, or this model down here, may change itself as well, and a lot of these cascading or rolling changes can in turn also cause UI changes. So you can see here how pretty easily, if you're not careful, you could get into infinite loops where the UI is updated, which updates a model, which makes an API call, which causes a model to change, and then you just get in this crazy cycle where the rendering never stops, and that's one of the issues with this model. Another one is that sometimes there's not a clear, one-to-one representation between a model and an API. So you could have this model calling several APIs. This is pretty common actually. Now what happens if you have a state bug? Let's say the state in the UI shows the wrong amount, like we just saw, and that happens to be represented by this model here. The first thing you're going to ask yourself as you're troubleshooting this is, why did this change happen, and what caused this? What other piece of code, or what other actor, caused this state change to happen? Well here you can see that there are many other pieces that are allowed to change this model here, so it becomes very painful to track down how these models change. I once remember spending three days tracking down one of these state bugs, and it was extremely painful. I had to go through lots of code, all these weird edge cases, until we finally figured out that this random situation would cause a model to change where we didn't expect it to. These situations are extremely painful, but state bugs like this can be extremely common with traditional client-side MVCs. This is the exact problem that Facebook was trying to solve when they came up with Flux. They released Flux as this idea, and a lot of people, including my team, were really excited about this. A lot of people experimented and came up with some better solutions, and the community kind of came together around Redux, which most people agree is the best way to do Flux. So don't worry about Flux, this course is all about Redux. So nowadays I don't think anybody would recommend that you start with Flux. Instead, they'd say, just skip Flux entirely and move straight to Redux. So this is a course about Redux. So how would Redux handle this situation? Instead of models, Redux has the idea of a store, which is essentially a big JavaScript object which contains all of the state. And, again, to keep it better organized, you can break up the state into several objects which renders its data into the UI, very similar to the traditional MVC, you have data that's being rendered into the UI. Now with Redux, any change event is called an action. If the user comes in, changes a drop-down, or changes an input value, we fire a change action, like currency amount updated, which those actions in return you could say I need to make some API calls. So you could have another action, then, that makes an API call, like request currency conversion rate, or request fee amount. Once this API data comes back, you could fire another action, which you could call a received data action, like received currency conversion rate, received fee amount, received total amount, things like that. The store is then updated by using a reducer. A reducer is a function that decides how to handle the current action. The currency reducer could listen for the received conversion rate action, and then update the store. The UI is listening for updates from the store. If the store changes at all, the store will fire change events saying hey, UI, I have changed, and the UI can then re-render itself to ensure that the UI has the most recent data or the most recent state. Now in what ways is this different than the traditional MVC, besides simply using some different terminology? As you can see here, the data is flowing in only one direction. This is called unidirectional data flow, and this is one of the key components of Flux and Redux. What that means is only actions are allowed to update the store, and the store chooses which actions are allowed to update it. And the UI only gets re-rendered when the store changes. Because of this unidirectional data flow, tracking down state bugs becomes much simpler. If you know that a certain UI action causes the state to go wrong, you can just go down the pipeline and say, okay, when I change this part of the UI, it fires this action, which then requests this API data. Now, if the API data that you've received back is correct, you can go to your store and you say, when I receive this action along with its payload, am I storing this correctly. So you can go down each step and see exactly what the code path is, which becomes much more predictable, and much more reliable. In cases where it's been hours or days previously tracking down where these state bugs were happening, once we switched to Redux, it took no longer than 5 or 10 minutes to track down where the problem was happening, which really freed me up to spend my time solving other problems. This was really, really great. So in summary, Redux is really great at managing and helping you manage your state with unidirectional data flow. It's much more predictable about state changes and state updates. It makes it easier to track down when and where state bugs happen. Redux is awesome.

Important Concepts
In this section, we'll be covering two important concepts that will help you understand Redux. The first is pure functions. Pure functions are an idea that come from functional programming. Let's take a look at some code to illustrate this further. Here we've got a fairly standard function called convertAmount. It takes one parameter, amount, and then returns amount times conversion rate. This is considered an impure function. Now in contrast, we have a convertAmount function which takes two parameters, amount and rate. The second one is considered a pure function. But what is actually the difference between these two? As you may have spotted, the only difference is that the first function relies on a global variable, conversion rate, whereas the second function relies only on the arguments passed in. It doesn't rely on any global variables. So, pure functions really have three primary characteristics. One, they don't access any variables that are outside of the scope of the function. Two, pure functions have no side effects. What that really means is that pure functions do not reach outside of themselves and mutate or change any variables that are not inside of the function. And three, that means that given the same input, you will always have the same output. Always. An addition function is a great example of a pure function. If you add 3 and 2, you will always get 5 back. The real power with pure functions is that this gives you some guarantees and will make the code more predictable and more reliable, which is really important when you're trying to avoid bugs. Pure functions are a really big thing in the React ecosystem. There's a focus on having pure React components wherever possible. So in summary, reliability and simplicity are really the biggest benefit of pure functions. When you're building complex web applications, keeping things simple and predictable is a really huge deal. This will save you a lot of stress and heartache. Pure functions are great. I like using pure functions whenever possible. The next concept is called immutability. Immutability is another idea that comes from functional programming. In order to explain this better, let's head to the node REPL and look at some code. Let's say we have a simple game where the state consists of a single JavaScript object. Our player's color is read, his name is Adam, and he has 5 points. So the current state of this game is as follows, color: red, name: Adam, points: 5. In a traditional single-page web application, if you wanted to change the amount of points, you just mutate this object. Now state is 25 points. The problem with this approach is we have now lost the prior history entirely. This mutation overwrites what previously existed in memory. We can't get that back. This makes tracking down changes, or tracking down mutations, or tracking down problems, really difficult, because we may not even be able to know if the state has changed, or what state has changed, because we just have the new state that we're looking at. So we don't know what's changed, and we don't know why it's changed. By allowing our state to be mutable, we lose all that previous history, and we make it much harder to track down problems and to troubleshoot our application. The solution to this problem is to make our state immutable, which essentially means that we create a copy or we clone it before we modify it. In JavaScript, starting with ES6, we can use the Object. assign method, which is very similar to jQuery. extend. The Object. assign method can be used to clone objects or to merge objects together. So let's start with a brand-new object, then we want to copy in all of the properties from the state object, and then I would like to merge in a points property, which is now going to be 50. Since this will create a brand-new object, we need to save this. So now we have state, which is still 25 points, and we have state2, which is now 50 points. We now have two snapshots in time of the state of our application. If we wanted to, we could create a history array and save these. So why does this matter? Managing mutation and state changes is one of the major pain points in making a single-page application. Having immutable data and keeping track of this history makes it much easier to manage your state and to track what has changed and when it has changed. When you're forced to create a new copy before you modify it, you're creating another snapshot in time, so you can now compare the old state versus the new state. Some really neat things that holding on to the history allows is we can now take snapshots of our state. We can do things like undo, where if the application goes wrong you just push an undo button and it goes back to the previous state. We can recreate state from URL, which allows much easier refreshing, which is a major pain point in many single-page applications, because you refresh, and everything is gone, which can be extremely frustrating. Another neat possibility is time travel, which allows you to go back, say, 5 steps or 10 steps in your app without having to do a lot of complicated service head work. So in summary, immutability means that you don't just mutate your object, but if you want to change it you make a copy first, and then make modifications on that copy and you hold onto the original. Immutability is one of the key components of how Redux works, and how it manages to track changes and stay performant. We'll be touching on this again later.

Summary
We began this course by talking about common state problems in single-page applications, and how Redux helps to manage the state complexity. Following that, we explained why pure functions and immutability are important. In the next module, you'll get a crash course intro to React. I can't wait.

React Crash Course
Introduction
Hello. My name is Jamis Charles, and welcome to this module of Pluralsight's course, Redux Fundamentals. This module will give you a quick crash course into React, which will really help in the next module when we add Redux to an existing React application. We'll start this module off with a simple Hello World example in React. Then, we'll look at using JSX with AJAX in React. Finally, we'll take a look at how Babel and Webpack help with our React development. Let's get to it.

ES6 Class Syntax
In this section, we'll be talking about ES6 class syntax. React makes heavy use of ES6 class syntax, so I think it would be useful to spend 2 or 3 minutes and talk about how classes work in ES6. Prior to ES6, the closest thing we had to classes was this syntax. Here we are defining a car constructor function, and attaching a prototype method of getColor. That allows us to instantiate a new object of type Car, and when we are instantiating the car, we're passing in the color. So my car is an object of type Car, with a color of red, and I can call myCar. getColor, because I've defined it above, great. So how would this example work with ES6 classes? With ES6 class syntax, you would use the class keyword followed by the name of the class, and then what was previously the constructor function above now is named constructor and is a constructor method here, and then any prototype methods are simply in the body of this class, and named as before. So we have the getColor prototype method, and we have our constructor function. And we can now call this the exact same way as before, myCAr2 = new Car2. MyCar 2 is an object of type Car2 with a color of blue, and we can call myCar2. getColor just as before. Now it's important to note that ES6 classes do not add classical inheritance to JavaScript. This is simply sugar around prototypal inheritance. What I mean with that is that classes make it easier to do basically the same thing that we're doing here above, but it makes things like inheritance much easier to manage. Now one final example. Here we've got a very simple React. Component. We are defining a class named simple, which extends, in other words, it inherits properties from the React. Component base class, and it defines a render prototype method. Since Chrome doesn't understand JSX, let's just pretend that it returned a string, and then we can use this class to instantiate an object the same way with a new keyword. Now comp is a React. Component of type Simple. We didn't pass in any props or any context. If you go up the porotype chain, you can see that there is the render method. These are all the methods and properties that are being inherited from the React. Component base class. That's why you have to extend it like this. If we didn't do that, it wouldn't inherit all of these things. ES6 class syntax really simplifies how you do prototypal inheritance in JavaScript, and it really makes this a lot cleaner, you have to use much less syntax, so I am a huge fan of ES6 syntax. If you're not familiar with how prototypes work in JavaScript, don't worry about it too much, it's not that important for this course.

React Hello World
In this section, we'll be looking at a simple Hello World example in React. For this example, I've created a new project with an index. html file, a js folder with some JavaScript files, and a package. json file. Let's open these up in our editor. Let's start with the index. html file. We've got a fairly simple html file, we have a div with an id of one, that we'll be rendering React content into, and then we have three script tags. The first two are loading the React dependencies, and the third one loads our example1. js file. Let's take a look at that now. This is a very simple React. Component called Hello, and on line 9 you can see how this is actually rendered into the DOM. We can ReatDOM. render, pass in the component, and then as the second parameter we specify the DOM element this is passed into. This is how React is rendered into the page. Now, let's take a look at the class definition. This class contains one prototype method, the render method. Render is the method that React calls whenever you're going to render something to the page. So in this case, when React says, I want to render this component, it will return what here looks like HTML. The templating language that React uses is called JSX. You may have noticed that JSX is not valid JavaScript, and this will not work in a browser. So how do we get this to run properly in the browser? We need to run this through a compile step that will take this JSX syntax and compile it down to valid JavaScript. The tool we will use for that is called Babel. You may see here that it says command not found: babel. That's because we don't have the Babel command line tool installed yet. Let's do that now. Now anytime you install a CLI locally, the executable for that will be available under node modules in the. bin folder. There we see Babel. So this is how we can run Babel. Now we still need to install a Babel plugin so Babel will know how to transform the JSX syntax. We'll npm install the babel-plugin-transform-react-jsx module, and by passing the --save-dev flag we will save it locally in our dev dependencies. Great, so let's try and run this on our example1. js file. Then --plugin, we pass in the transform that we want to use, and then the file we'd like to use it against. Okay, great. In this case it just spits out what we want here, which is what we expect, return React. createElement. So this now is valid ES5 syntax that will run in the browser, great. But I'd like to automatically save this to a file. We can assign an output file by using the -o flag. We'll do. min. js. We ran the Babel compiler on the example1. js file, and saved the output of that to the example1. min. js file. Let's take a look. There it is, fantastic. Let's try and load this in the browser now. Let's update this here so we can load the. min file, and then let's head over to the browser and try it out. There we go, Hello, World. We've now rendered our first React. Component to the page, awesome.

React Scoreboard
In this section, we will show a React component that displays a scoreboard. Let's take a look at those files now. In this example, we have a React. Component named Score. The primary new element in this example is on line 6, where we call this. props. teamName inside of an expression. This is the preferred way of passing in outside properties into a React. Component, and we're doing this on line 19. We're passing in a teamName key with a value of Tigers, and we can now reference that under this. props. teamName. This is a great way of passing in any outside values that you would like to pass in to a React. Component. So let's try and run this and see if we can get it showing up on the page. You can see that we are injecting this into a DOM element with an id of two, so we'll have to make sure that exists on the index. html page. Let's head over there now and do that. Let's duplicate this div here, and give it an id of two. And to separate it, we'll add a horizontal rule. Then we'll also need to load in the JavaScript file once it's built by Babel. Let's try and open this in the browser and see what happens. So we see the horizontal rule, but we do not have our example2. min. js file generated yet. Let's head back to the command line and use Babel to generate that file. We find the Babel executable under the node_modules. bin folder, but I don't really want to have to call this every time. So let's see if there's any special flags we can add. You can see here that there is a -w flag that we can pass which will watch the local files, and any time you make a change it will automatically recompile that file, so let's use that. We want to process the example2. js file and save the output as example2. min. js, and the plugin we're using, once again, is transform-react-jsx, and we're going to add the -w flag, which tells it to watch the files. Let's try it again. Okay, here we go, Score board for the Tigers. Tigers is the property that was passed in, and then we've got a plus button and a minus button which don't do anything yet. So next we're going to instrument these buttons so they will increment or decrement this score. Let's head back to the component file. First thing we'll want to do is to add a click handler. And then we'll need to add a method with that name. So React will take a look at this element, and automatically bind the onClick event to the incrementScore method. Let's try it and see if this works. And on the console we can see that every time we click plus it logs increase, great. So the event binding worked. Now what about the actual value itself? Let's head back. In order to increase this, we need to replace this 50 value with some local state. So how do we store state locally in a component? You use state. First you add a constructor method. Then you create your state object. Adding it to the constructor ensures that each component, which is really just an object created from this class, will have its own copy of the state object. Let's try this. We see this error, must call super constructor in derived class before accessing 'this' or returning from derived constructor. What does this mean? Let's head back to the code and take a look. If you are extending a base class, and in this case we're extending React. Component, before you're allowed to call this in a constructor, you must call super first. But what does that really do? Super calls the parent constructor, in this case, the parent is React. Component, so super calls the constructor in React. Component first. That's what you have to do so that this is available in the derived class, in this case the child class. Let's try that. Great, that works, no more errors. Let's head back to the code. You'll see here that I'm passing in props to the constructor and to super. That's not really needed, but I'm leaving it here for the sake of clarity. This is to illustrate that the properties get passed in to the base constructor so they are then part of the component, which is really just an object that's created from these classes. Now, we can use this. state. Let's try it out. This. state. score by default is 0, and this part still works. So now let's bind these two together. The way we do that is by using the this. setState method. Let me pass in an object. And we wanted to find the new value for score. It will be this. state. score +1. The important thing here is that this. state can be used as a getter, but should never be used as a setter. If you want to change state, always use this. setState. The primary reason for that is that React uses this. setState to know when it should re-render the component so that it's always the most up-to-date HTML that you need. In React, any time the state changes via this. setState, it will automatically call the render function again to make sure that the most recent content is rendered and available. Let's take a look. Oh, there is an error. Cannot read property 'setState' of null. Let's see where this occurs. That means that the this keyword is not available in the incrementScore prototype method, so how do we make it available? Let's head back to the constructor method. There is a method called bind, which is available on any function which allows you to pass in the value of this. So calling function. bind, in this case, this. incrementScore. bind, will return what is called a bound function. You can use this technique to also bind arguments. So now the click handler, which is in the render method, will point to this new bound function, and the this keyword will then be available in the incrementScore prototype method. So any time we now call this. incrementScore, the this keyword will be available within that. Anytime we use the this keyword in the Score class, this refers to the object that is created from the Score class using the new keyword. So when you tell React to render a component like we do here at the very bottom, it hands you an object based on the Score class, and renders that to the DOM. Let's see if this works. There we go, magic. Let's also instrument the minus button. Let's see if this works. There we go, fantastic. So in just a few short minutes, we now have a React. Component that can pass in properties and has some local state. Let's head back. In summary, for anything that you're going to pass in, you'll be using properties, which can be accessed via this. props, and for anything where you need to maintain a local memory or a local state, you'll set that initial state in the constructor method, and then you can access that state via this. state in the other methods. One thing you'll notice is how the logic here, as well as the template, is co-located. It sits right next to each other. This was one of the things that I really liked about React when I first started. In traditional MVCs, it was very common to have separate files for all these things. You would have a template file, which had just your HTML in it, and this would be a separate file, and then you would have a model file which had some logic in it, and then you'd have a controller file. But I really, really like this, because it's much easier to figure out what's going on when the variables are being figured out right next to the code that actually renders them onto the page. This is one of the big selling points of React, in my opinion. Everything is right next to each other, it's compact, and it's mostly JavaScript. React is really great. I love React. I'd like to highlight two more things here. One is that if we head back to the command line, we can see that because of the Watch mode, every time there's a change it updates this file and prints a change. If there's any errors, that'll show up here as well. For example, we now see a very helpful babel error that says that Adjacent JSX elements must be wrapped in an enclosing tag. One of the quirks of JSX is that it expects one root element, and so the closing tag here is missing. Let's add that back in. And there we go, everything is good again.

React and Webpack
In this section, we've got a React weather widget app that uses Webpack. Let's take a look at the relevant files. Webpack is a module bundler that combines our files. So instead of having six or so script tags, we have one bundle. js script here instead that we pull in. Then if we head over to our index. js, we see that thanks to Webpack we can now import files here. This is really nice and convenient, and means that we can use npm to handle our client-side dependencies. We've got a fairly simple React. Component here that makes an AJAX call on load. Now let's take a look at the webpack. config file. This is essentially a JavaScript file that exports a configuration object. Webpack allows us to use special transforms. Here we're using the babel transforms to convert our ES6 and JSX code to ES5 code. Nothing too crazy here. Let's take a look at our package. json next. In order to use Webpack, I had to install a lot of local dev dependencies, like webpack, and the dependencies like babel-core, babel-loader, and babel-presets. Now in this app I'm going to be using Webpack primarily in two ways. The first one, which you see here, is the webpack-dev-server, which will start when I run the npm run start or the npm start command. Let's take a look at that now. Npm start runs the webpack-dev-server, which bundles up the client-side js files, and will re-compile any time you make changes. Let's take a look in the browser. So localhost:8080, we now have our React weather widget. This app is now using Webpack, and we'll be using Webpack throughout the rest of this course. If you need more help setting up a webpack. config, I suggest heading to the docs, or taking a look at the Webpack course on Pluralsight.

Summary
In this module, we looked at several React examples, starting from very simple, and then increasing in complexity. We saw how JSX is a nice template syntax that compiles down to regular ES5 JavaScript that runs in all browsers. We learned about component nesting, props, local state, and how React handles click events. Finally, we learned how Babel and Webpack can be utilized to make the local dev experience more enjoyable. In the next module, we'll take a closer look at a React application that could really benefit from using Redux. I can't wait.

The Problem with State
Introduction
Hello. My name is Jamis Charles, and welcome to this module of Pluralsight's course, Redux Fundamentals. This module will help you decide if Redux is a good fit for you. First, we'll take a close look at a React app that is starting to have some state problems. Then we'll discuss some of the reasons for and against choosing Redux. Let's do it.

State Problems
In this section, we're going to be taking a closer look at a React app that's starting to have state problems. Here we've got a single-page application, which is a currency converter. Here we can say that we'd like to convert 250 U. S. Dollars, and it'll show us the conversion rate, the fee that we're required to pay for the service, and the total cost. So we'll have to 287. 50 in order to convert 250 U. S. dollars to 235 Euros. And you can see that we made four AJAX calls to two different APIs. The first one is API/conversion, the second one is API/fees. We can assume that the first one will give us the conversion rate and the amounts, and the second one will tell us how much we owe in fees. On the client-side we're using React, and on the backend we're using Node for these AJAX calls. Nothing too crazy here in the UI. Let's go take a look at the files. Let's start by taking a look at the package. json file. We start the app by running npm start, which concurrently starts two processes. First it runs npm run server, which you can see here on this line will start the node app, which is located at server/app. js, and then at the same time it'll run npm run webpack, which will run "webpack-w" which will build a client-side assets bundle and watch the files for any changes. Our dependencies and devDependencies look fairly standard. Let's take a look at the folder structure. Our node files live in the /server folder with app. js being the main entry point for the node app, a fairly standard express app we have a few routes here. We have one view that we're rendering @/, and then we have a bunch of JSON routes, api/conversion, and api/fees, and then a few helper functions here which help calculate the conversion rates, etc. Then in views we have one primary view that we render, index. js, which really just renders our single page application. Now, let's take a look at our client-side files. Our Webpack setup is pretty much the same as the previous example. We start at public/js/main. js as the main entry point, and we create a bundle in public/js/build/bundle. js, and we apply the babel-loader transform with the react and es2015 presets. Now let's take a look at our client-side files. The primary entry point for the client-side JavaScript lives at public/js/main. js. You can see that we're importing react, react-dom, a conversion component from the components folder, and then here we have our main root component that we inject into the DOM via the container div. I really like having a root level react container that we inject in. This helps your react app scale nicely and have a simple and nice entry point. And then here in the main render function you see that we're nesting the conversion component. So let's go there now. This is where the bulk of our application logic lives. Let's take a few minutes to review this file carefully so we know what's going on. Here at the top, see that we're importing React PropTypes from react, and then axios, which is the Ajax library we'll be using. I could have pulled in jQuery, but it's overkill to load jQuery just for Ajax. And finally, we're loading lodash. debounce. Lodash is a utility library that solves a lot of problems for us. We're loading the debounce method only. Here we have a FeesTable React. Component, then we have a render function. Here we've got some ES6 destructuring. If you're not familiar with this, what this basically is is shorthand for var conversionRate = this. props. conversionRate, and the same for each one of these variables. So instead of having to type out five or so lines here, we can just do this all in one line, which is really convenient. This is called ES6 destructuring. Then we've got our render method, where we're rendering the FeesTable with the conversionRate, the fee, the total amount, then here we have our second React. Component for this file. Lower down in the file you can see that we're exporting that Conversion component, which we're importing into the main file which we saw before. Let's head back up to it. So here we have the Conversion React. Component, we have some initial state here, origin amount, currency, destination amount. This is the state that you see when you first load that file. And then we're binding all of the event handlers with this, so that the this keyword in those methods will refer to the React. Component object that's created from this class. You can see here on these two lines that we're also binding a parameter. For the bind method, the first argument will be used as the this keyword, and any subsequent arguments will be bound as arguments in the function returned. This allows us to create two functions with prebound arguments, the handleOriginCurrencyChange function, and the handleDestinationCurrencyChange function. So why did I do that? If we look down here in the render method, the onChange event requires a callback function, so I can't pass the parameters there. I could theoretically call the bind method in the render method, but that is not a good idea, because bind returns a brand-new function each time it's called, so in every re-render, which there are a lot of in React usually, a new function would be created, which would waste JavaScript resources. And we have some interesting things here happening in componentDidMount. If you recall from the previous example, componentDidMount is a lifecycle method that gets called immediately after the first render, and this will only be called once for the lifetime of each React. Component. If there are any initial Ajax calls you need to make right as the page loads, componentDidMount is the place to put it. Let's head down to the render method, which is the most important part of this React. Component. So immediately we see if there is an error message, we'll render an error banner at the top, then we see that we have label, an input, a select drop-down, which is the currencies, another input another drop-down, which is the destination currencies. Then we're inserting the FeesTable component here at the bottom. Nesting components like this is a really nice way of separating and breaking up your logic. So for this drop-down, when it first loads, the value of the drop-down will equal what's in this. state. originCurrency. If you change the drop-down, we call this. handleOriginCurrency change, which will then update and display the new currency. Let's talk about what's new here that we haven't seen previously. Occasionally you'll want to do things like focus an input when the component loads, or integrate with a jQuery plugin or other third party JavaScript library. That usually requires having a reference to DOM element that you can call focus on, or that you pass to that other code. This is where refs come in. Ref attributes take a callback that is executed on every render. So we want to ensure it's something simple. What you see here is an ES6 error function that desugars to the following. The return here doesn't really matter, so let's ignore that. Every time the render method is called by React, this callback function will be called, and we'll assign the input field to this. originAmountInput. We can then use that reference anywhere else in this component, including in the componentDidMount method. Let's head back to the componentDidMount method. Here we see the componentDidMount method, which again, gets called immediately after this component is first rendered to the page, and this is only called once. So the first thing we do is we debounce our makeConversionAjaxCall, and we debounce our makeFeeAjaxCall, and then we focus on the originAmountInput field. And since we're using refs, we can call this. originAmount. focus in order to grab that element and focus it. This allows us to avoid having to add an id to that element, and then using document. getElementById. So we can keep our DOM a little bit cleaner, which is nice. Now you may not be familiar with what debouncing is, or why it's necessary. Let's open the browser back up to explain that. For this input field, we've bound the event handler to the input's onChange event. That means any time I change this input field, an Ajax call will be made. You can run into problems here if somebody is typing 1000. You don't want that to make four Ajax calls. This is terribly inefficient, because three of those calls are going to be worthless, and this could make your servers crash. So debouncing will essentially wait until the person is done typing, or until the event has stopped firing for a certain amount of time. In my case, over here I'm saying wait until this event has stopped firing for 350 milliseconds, and then you can fire that. So you can see here, if I just keep typing, it shouldn't fire any more Ajax calls until I stop. And then once I stop, it makes those Ajax calls, so that's why we are debouncing. In this case, I'm using lodash to replace the _makeConversionAjaxCall with the this. makeConversionAjaxCall, which is the properly debounced version of this function. And componentDidMount is the right place to put this, because this will only get called once. As soon as this thing renders the first time, we make our Ajax calls available properly and de-bounced, and we focus the originAmountInput field. Let's take a closer look at the Ajax logic. If we look at the Conversion React. Component, we can see that most of the logic here is Ajax call logic, and that's really the bulk of this here. If the currency changes, we verify which one has changed, and then we call setState to immediately update the UI, because the UI will always reflect what's in this. state for this component. Then based on the result of that first Ajax call, we update the state, which will automatically update the UI, which in React, automatically will call the render function again with that new state. And then we make another Ajax call to calculate our fees based on those new values. So you can see here that this component is starting to get a little bit complicated. So we're trying to handle the success state, we're trying to handle the error state, and we're really not handling a lot of edge chases here. This is really a fairly simple UI with just a few Ajax calls happening, and you can already see that our React. Component is starting to get pretty complicated. Same thing here, for this we're going to have to do the same thing. We make several Ajax calls, we're trying to handle success and failure. Let me demonstrate the error scenario that we're handling here. So if you go offline, and we can demo that pretty well, if you go offline here and you try to convert something, because, oh no, the app appears to be offline. That's because all of the Ajax calls are failing completely with a status of 0, so that's what we're checking for within the app. And then if you can make a successful call, the error message goes away, great. We're handling that here in the handleAjaxFailure. So after we make the Ajax call we check the status, if the status is 0, we set the state to this. state. errorMsg, and we show the message, and then down in our render function we check for the existence of the error message in state. If it exists we show an error message, if it doesn't we show no error message. And then anytime we make a successful Ajax call we have to make sure that this. state. errorMsg is empty, great. So if you look at all of this Ajax logic, which is really just handling a few very simple use cases, it's not even handling all of the possible error states, you might ask yourself, okay, is this the point where we need to start using Redux, and that's exactly what we'll be talking about in the next section. See you then.

Should You Use Redux?
In this section, we'll talk about how to decide if you should use Redux in your React app. From looking at this code, at this point you might start saying, this is starting to get a little bit confusing, a little bit messy, we have a lot of Ajax logic here, a lot of state logic. You can see how pretty easily bugs can come in here. Beyond that, some people think that you need to use Redux immediately once you want to start using Ajax in React, and that's just not the case. My suggestion would be to use React, and use setState until you feel like it's not working for you anymore. In this case, I feel like this is getting a little bit too complicated, and I'm seeing this strange bug. Let's take a look at it. I've got a bug here where this part of the UI works fine, where I set the origin amount, the from amount is 200, which converts to 188 Euros, here's the conversion rate, everything looks good. Here, if I change the drop-down value of the from currency to Euros, I see that it's one-to-one, but the second input hasn't updated, so 200 Euros should be 200 Euros. Troubleshooting these with my current setup can be a little bit difficult. The first place I'd probably go to is look at the Ajax calls and see whether or not the API is returning the correct data. So here we see a conversion call and a fees call. The conversion call, we're passing 200 Euros, and the destination currency is Euro, so we're passing the correct information, and the service returns 200, so the problem is clearly not with the service. Now where do we go from here? This is where, with a standard and simple React app, within a few minutes we can probably figure it out. If you have a more complicated application with many react components across many different files, this can take a really long time, especially if you have a lot of different places setting state. Now if I wanted to keep using React, and not use Redux yet, how would I improv the organization of this file? The first thing I would probably do is see if I could refactor this a little bit. Maybe I could move the Ajax logic out into a vanilla JavaScript file that just makes the Ajax calls from a separate function, and I could just import that into this file, and just call it. That would move most of this logic out, which might work nicely. You pass parameters in, you make some Ajax calls, you get the result back, and then you update the state here based on what that function returns. That would be the first thing. The next thing would maybe be to break this down into some smaller components. Right now I kind of like having the similar components in the same file, but this is getting just long enough where it's a little bit confusing, so I'd probably start with those two things. We've spoken for a moment about whey we might not want to use Redux, but why would we want to use Redux? In my case, I had an app similar to this, and I started passing all the state around, and I had to have one component talk to another one, and we had to show error states, and there were all these Ajax calls happening, and it got crazy really fast. So I thought, let me try it Flux, then let me try it Redux, and I found in my situation with my app, it really, really helped me make sense of what was happening, and it made the state predictable. Even in this situation, I don't know exactly when a state call is happening. From the UI, I make changes. I don't know if my bug is being called by two conflicting setState function calls, I don't know if my bug is happening because I'm setting state wrong, or if I'm setting state too quickly after each other, or I'm setting state correctly and then wrong, or vice-versa. Any of these things could be causing this bug, and right now I have very little insight without manually coming through the code to why this is occurring. So we have the exact same problem that we talked about earlier, that we used to have on my team with our Backbone app. We have now moved to React, which alleviated some of those issues. We still have a lack of insight, a lack of transparency, and we felt this pain more as our app grew bigger and bigger. We had a lot of different pages, we had a lot of different components, and some of these had to talk to each other, and it just got messy fast. The important thing to remember is that no framework is going to be a silver bullet and magically solve all your problems. It's all about trade-offs. At this point, I need to ask myself, should I solve this problem on my own, or try a popular open source solution. I could make this React component and this app better, but in that case I'm kind of on my own, I'm inventing new things, I'm trying to decide what the patterns I can manually try to enforce that would make this better and less confusing. Or, I can choose an established framework, which will give me some of these conventions, and some of these things for free, and there happens to be a large community around this. So, again, there's trade-offs, but in this case I'm choosing to avoid rolling my own solutions to this problem. I'm deciding I'm going with a popular solution that solves this problem for many other people, is well-documented, well-tested, is performant, and seems to make a lot of other people happy. So to me that's a great way to evaluate frameworks like this. First you ask yourself, what problem am I currently having, and does this framework claim to solve my problems? I think one of the primary problems with JavaScript fatigue, which we've been hearing so much about, is people getting exhausted about new framework after new framework, because engineers feel this pressure to immediately jump to the next big thing. I think that happens because engineers often think solution first, instead of problem first. If we're being responsible engineers, we start by saying, my app has this specific problem. Now let me try and find solutions, either that I can build myself or that exist out there in open source already. In this case, I am having state problems. One possible solution to these state problems is Redux. Let me try it out in a little side project first, let me evaluate it, and if I like it I'll slowly start applying it to our main project, and we'll see how the team likes it. If everybody is on board, we'll keep moving with it. To me that is a good way of moving to a new framework or a new technology. This is exactly what we did on my team. We were using Backbone, we were having a lot of state problems, the React team claimed that React was solving some of these problems, so we moved to React, then we had some other state problems. Flux claimed to solve these, so then we tried out Flux and Redux, and we found that for our use case and for the size of our application, Redux really, really, really helped with a lot of these state problems, and making the app more predictable, and giving us more insight into what was happening in the internals of our application. And so we started migrating to Redux, and now two years later we're finally done, we have a big app. But everybody was on board, we figured out how to do it slowly and properly, and now we're on Redux, and everybody is still really, really happy with it, so Redux is great. To sum up, to me it really comes down to this. Are you currently having problems, and is the framework you're choosing or you're thinking about, claiming to solve these problems? In this case, with this example application, we're starting to run into state problems, it's starting to get a little bit messy, and I'm going to choose to try out on a side project, Redux, and see if it helps to solve these problems. If you're having a hard time deciding if you should use Redux, the creator of Redux, Dan Abramov, wrote this great article, You Might Not Need Redux, in which he talks about some of the reasons for and against using Redux. If you're really on the fence, I suggest you take a look at this, but for me the guiding principle always is try something like Redux out on a small side project where the cost of being wrong is very low. You can try it out, learn it over a weekend or over a week, and then if you like it enough and you think it'll solve your problems enough, bring it back into your team, try it out with one feature or one part of your app, or one URL, or one route, or one page, and this is a great way to try something out, and the whole team can say if they like it or not. This is what we did on my team, and we've loved Redux.

Summary
In this module, we discussed in what cases Redux would be beneficial. We took a closer look at a React application that was starting to become unmaintainable because of some confusing state and Ajax logic. Then we talked about how Redux could help simplify that app. Finally, we showed some good patterns for evaluating new technology. In the next module, we'll start applying Redux to this application. I can't wait.

Redux Basics
Introduction
Hello. My name is Jamis Charles, and welcome to this module of Pluralsight's course, Redux Fundamentals. In this module, we'll learn about the basics of Redux. First, we'll examine the simple building blocks of Redux. Then, we'll take one local state property and convert it to Redux. Finally, we'll add the React Redux npm module to your project. Let's get to it.

Redux Building Blocks
In this section, we will build the simplest version of Redux possible. We will start by taking the react app we've been working on and by slowly adding Redux to it. Let's take a look at the relevant files. Here we've got the same node express app as we did before, with a few server files and a client-side React single-page application. Let's fire up our app using the npm start command, which starts two processes for us. First, it'll start our node express application at port 3000, and then it'll also start Webpack in Watch mode, which it'll generate in the build folder. Let's take a look at this in the browser real quick. Here we've got our Currency Converter, exactly the same thing we've seen previously. Now let's head over to the editor and look at the important files. We've got our main. js file, which has our main wrapper component, which simply takes the Conversion component and shoves it into the DOM at the container element. Now let's take a look at the Conversion component. We looked at this extensively in the previous module, but essentially we have two components here, FeesTable, which renders the conversion rate, fee, and total cost table, and then we have a Conversion component which renders the rest of the form. If there's an error, it shows the error message, and it shows the two input fields, the two drop-downs, and the FeesTable component. Currently this uses local state, and we use this. setState to update this state. Now how would we start using Redux here? First, we'll need to install Redux from npm. We use the --save-dev flag, because client-side dependencies with Webpack need to be saved as dev dependencies, because you don't need to install or load them in production. Now we can import and use Redux in our Conversion component. The first step in using Redux in this file is to import it, and here we specifically want the createStore method. So what is the simplest way we could use Redux? Let's start with a simple example. At the very first, we probably want some state, so we'll call this defaultState. And this is often shown as an object, but it doesn't have to be. Why don't we just use a number? We'll start with 0. Then we need what's called a reducer, which is really just a function that will update the state. So we'll call this amount. And the reducer takes two variables, state and action. We'll explain those more in detail later. And then the reducer updates the state somehow, so why don't we just say return state + 1. So the only thing this amount reducer will do is add one to your state, it'll increment it by 1. So we have our defaultState, we have our reducer, now we need a store, which is our data store where our state is saved. That's why we need the createStore method, var store = createStore, and the argument we pass it is the reducer. So now we have a Redux store, great. That doesn't really help us unless we can do something with it. With a state store of any sort, we want to do two things. We want to update the state, or set it, and we want to read from that state, or get it, so we want to get and set. Let's start with setting. The way you update the Redux store is by using store. dispatch, which fires an action, and this action must be an object. Let's try that in the browser and see what happens. Actions may not have an undefined type property, great. One of the really nice things about React and Redux is they try and have really helpful error messages. So we must define a type property on here. I think I can leave it empty, though, great. So we think something has happened, but we don't really know because we're currently not reading from the store. So let's try and read from the store. We can subscribe to updates from the store using store. subscribe, and then passing a callback function. Now we can log out. The state after dispatch gets called, after an action is fired. The way we read the state is by calling store. getState. Let's recap here. We start with a defaultState of 0, which is just a number, and we have a reducer function called amount. The only thing this reducer function does is it receives a state argument, which it increments, and then returns. And here we've created a store. We call the createStore function and pass in that reducer. We'll need to move the subscribe first, so that we are subscribed to it when we call the dispatch action. So then here we are subscribing to store updates. So anytime the store is updated, we are going to console. log the current state, and then here on line 20 we are updating the store by calling store. dispatch. That's how you fire actions, and indicating that you want to update the store. Let's see what happens. So state is not a number. What happened here? We have defined defaultState here, but we're not really using it. That's because the very first time the amount reducer gets called, state is going to be undefined. So undefined +1 is not a number. So we can do one of two things here. We can do state = state or defaultState. This has previously been a nice way to offer default values. With ES6, there's a little bit of a nicer syntax for default parameters, so instead of doing what we're doing here on line 11, you can do = defaultState. These two lines mean essentially the same thing now. If state is defined, use state, if it is undefined, use defaultState. Let's try that again. Great, now state is 2. So why is state 2? Let's head back to the code and take a look. We would expect state to be 1 because we've only called dispatch once. State in this case is 2, because when you create the store, Redux calls the reducer once. That's not going to matter in a few minutes, so we can kind of ignore that. At this point, this isn't very practical yet, because we're going to want to have more than one action. So let's add an action type. So we could name this action INCREMENT. And then in the amount reducer, we could check for the action type. So if action. type equals INCREMENT, then we'll return state + 1, else we'll just return the default state. So now we'll have several dispatches, but these will be blank, and let's see what this does. So now state is 1. So we can see here that dispatch was called three times, so we dispatched three actions. Only one of them was of the type increment, and so when the action of type increment came into the reducer, we incremented the state and returned that new state, and when it wasn't of that type we just returned the current state, which was 1. So you can see that all Redux really is, is a state object, and then pub/sub around that state object. And by pub/sub, I mean publish-subscribe. You use the publish subscribe pattern. You can subscribe to events that you can then publish by calling store. dispatch. If you're familiar with pub/sub, hopefully that makes sense, if not, don't worry about it. At the simplest level, what is Redux or what is the store? The store right now consists of one reducer which gets called anytime you call store. dispatch. So anytime you call store. dispatch, it is simply calling this amount function, and it passes in the current state, and if it doesn't exist, use the defaultState. And then whatever is returned will be the new state, which you can read or get by calling store. getState. So this is really the basic building blocks of Redux, and at this scale it's actually pretty simple. It just consists of these few things. There is the defaultState, there is the reducer, the store, and the actions that you dispatch. Those actions then update the store, and you can listen or subscribe to the store updates, and then read the current state of the store by calling store. getState. For this example, it was useful to have state be a number because that's very simple, but our state usually is not going to be a number. So what if we want to make it an object? So here we could have maybe originAmount, and 0. 00 could be the default value. And then the action might be CHANGE_ORIGIN_AMOUNT. So then how do we get the new amount? We would add a second key here, which can be any key, but I commonly use data. Let's say we want the new amount to be 365. Now we are dispatched an action of type CHANGE_ORIGIN_AMOUNT with a data property, which is a string of 365. So now we no longer want to just increment this, so then we'd have to return state here. So what we're doing here is we're directly modifying the state object. We're signing action. data to state. originAmount and returning state. Let's see if this works. This appears to work, but it breaks one of the core principles of Redux. Redux only has a few hard rules that you must observe for it to work properly. One is that you cannot mutate the state. You have to make immutable updates. We talked about this in detail several modules ago, but the reason this is important is that when you update the object directly, Redux loses all sort of history for the state updates, and Redux uses this history to make comparisons to know if the state has changed. Here we are mutating the state object directly. Instead, we want to make a copy, and return that new copy with those changes, which helps keep these updates immutable. The simplest way to do that is to use Object. assign, and the first parameter means we are creating a brand-new object. Then we are merging all of the properties of the state object into that new object, and then we are signing the value of action. data to a property called originAmount. So this effectively creates a brand-new object and merges all of the properties of the state object onto it, and then copies in an originAmount property with the value of action. data, and then it returns that as the new state. Let's try it out. Fantastic, the dispatch worked, the state update worked, the action worked, and we now have a new state object, which has an originAmount of 365. Here is a very simple test you can do to know if you're using the same object. You can use triple equals to see if you're referring to the same object. So you can do console. log, and then do state === newState. This will tell us if the state object occupies the same space in memory as newState, or in other words, is it the exact same object just a reference to the exact same object. Let's see what happens. It says false. Now if we did it the old way, where we just assigned it, so now it's true, because this is still the very same object. So let's go back to the proper way, there we go. One final thing I'd like to show in this section, in the Redux docs or other places you might see this syntax. So what does this... state mean? Let's see if this even works for us. This does not work, because this is not supported JavaScript right now, and even Babel doesn't understand it. So what is this? This is a new proposed JavaScript syntax called the object spread operator. Let's talk about how this works. These two statements are equivalent, one is just more compact. This is using a JavaScript feature called object spread. So here we are saying return a new object, and copy or spread all of the properties that exist on the currentState object onto this new object, and then also define a new property called originAmount and assign it the value of action. data. These two statements are equivalent. You are fine to use either, but now I'll show you how to use the object spread operator. Object spread has not been officially approved yet, which means it's not part of ES6, ES7, or even ES8, which more commonly is called ES2015, ES2016, ES2017 based on the year that these features are officially added to the language. Let's head over to the Babel docs, and see how we can add this. If we head to the Babel website, and then go under Docs and Plugins, and then go under the Presets Stage-X section, it explains how experimental presets work. So here's how JavaScript gets new features. There is a committee called TC39, which is the Technical Committee 39, which kind of owns and oversees JavaScript. When somebody has an idea for a new JavaScript feature, they submit that, and that is stage 0. Then they make an official proposal, and that moves that to stage 1. If that goes well, it moves on to stage 2. If that goes well, it moves on to stage 3, and people can try it out, and then once everybody likes it, then they vote on it again, and then they decide whether to reject it or to move forward. If it moves past stage 3, it moves to stage 4 and is considered finished. It will be added to the JavaScript official language, and will be added to one of the ES, ECMAScript specs for that year, it could be ES2018, and then all of the browsers will add it eventually. Object spread is currently in stage 3. So here we see that the stage 3 preset includes the transform-object-rest-spread plugin. And when you're using Webpack, using Babel presets is the easiest way to go because it bundles plugins for you. So let's add this preset to our local Webpack setup. Here's how to install it, and then we add it to our presets property in our webpack. config. And, again, we'll use the --save-dev flag to save it as a local dev dependency. Now that it's been installed, it should have been added to our package. json, and we can now use it in our webpack. config file. Here under presets, for our JavaScript files we add the stage-3 preset. Let's try it again and see what happens. Since we updated the webpack. config we need to restart Webpack. No errors, there we go, it works just as before. You are happy to use either syntax, whichever you're more comfortable with. I prefer the object spread syntax because it's a little bit more compact, but you can use Object. assign just as well. I wanted to explain it here, because many of the Redux examples use the object spread operator. So to sum up, in this section we implemented a very simple Redux example where we set up some default state, we have one reducer called amount, which updates the state, and we created a store based on that reducer and we subscribe to store updates. And lastly, we updated the store by dispatching actions. And when we dispatch an action of type CHANGE_ORIGIN_AMOUNT, we pass a payload along with a property of data, and when that comes in, we create a new copy of the state, update the origin amount, and return that to Redux.

A Splash of Redux
In this section, we will take one property and move it from local state over into Redux. First let's start our local dev server. This will start our express app, as well as starting Webpack in Watch mode. Let's open it up in the browser, here we are. Now let's take a look at the code. Here we've got our local quick-and-dirty Redux example. But now we'd like to use Redux properly. So the first step is to move this store somewhere else. We are going to want to share this Redux store among all of our React components, and that means it shouldn't live in this one React component. The first option could be to move this up one more level. But we take all this here. We could move it into this file, but it wouldn't be very practical to import it from other components then, so we will create a separate file and put it there. Redux convention is to create a store folder, and then have a configureStore. js file name. This is not required, this is just kind of the convention that came over, I think this came from Flux initially, and, again, you're not required to use this file convention, but one of the nice things about conventions like this is if you're using Redux on one team, and then switch to another team or even another company, chances are that that team will be using the same conventions. So, again, file structure is entirely up to you. This is kind of a loose Redux convention. So we have a configureStore file here, which will create a store, and then export the store, and then we need to import the createStore function, from redux, and here we go. So we have our configureStore file, which includes, for now, our single reducer, which is the amount reducer, and our store. So this store will listen for these actions, and when it receives the CHANGE_ORIGIN_AMOUNT action it will update the origin amount, and it will notify any subscribers that the store has changed, great. So now we can import the store from this file. Okay, so now we have our Redux store, and we have our origin amount property in that store, but how do we get this value from Redux into our component? The simplest way I can think of is to pass it in as a property into the conversion component. So that means here in the main component we need to be able to access the Redux store, and the originAmount property from the Redux store, and then pass it into the Conversion component as a property. So that means here we want to say something like originAmount=, and then pass in that value. We can access the store by calling import, we can name it store, from, and that's in the store folder, configureStore. And then we can call store. getState. originAmount. This is how we read the state that lives in Redux, so store. getState, and the name of our property is originAmount, and that will be passed in as a property in the Conversion component. We should be able to now use, instead of this. state. originAmount, we should be able to use this. props. First let's test it by console logging in the render function. Right here we can say console. log, this. props. originAmount. And if it worked, this value should be populated. Let's try it out, there we go. This. props. originAmount is 0, great. So now let's take a look at the state here. In this component, originAmount is currently part of the local state. So we're going to comment this out, and anywhere we find originAmount we're going to swap out this. state. originAmount with this. props. originAmount, because it's now being passed in from the props. I think that's it, this. props. originAmount. Let's try that out. Okay, it seems to work great. Now what happens if we update this? As you can see, nothing is happening. Let's head back to the code and take a look. so on this input field, we can see that onChange we call this. handleOriginAmountChange, which uses setState to update the originAmount. But now this input field is listening to Redux, so we need to be able to update the state in Redux, instead of updating it locally in the component. The way we do that is with an action. So we call store. dispatch, and we pass in the action object, and then we define the type of action it is, which is the CHANGE_ORIGIN_AMOUNT, and the data will include the new amount. If we wanted to, we could just call this property newAmount, but I like using data because it keeps it uniform, but that's just my preference, you can call it whatever you want. So I'm going to say data newAmount, newAmount. So now we will fire a Redux action of type CHANGE_ORIGIN_AMOUNT with the newAmount, and we will no longer set the local state of the new originAmount. But store will probably not be available here in this file yet because we haven't imported it. So let's pull in the store, the same way we did in our main component. Let's see if that worked. Still not working. Now why is that? Ah, but every time we dispatch, we will console. log the state. We can see that the state in Redux is changing slightly, but our UI is not reflecting that. Why is that? Let's head back to our main component to find out. So what we see here is that store. getState. originAmount will be passed in as a prop when the main component is rendered, but there is nothing here that tells it to listen for Redux store updates, and there's nothing here that tells the main component or the conversionComponent to re-render itself if there is any change in that state. So those are the two things that we have to solve. The first thing we have to solve is we have to subscribe to the Redux changes, and we know we do that by using store. subscribe. Now we have a callback function that will be called any time the store is updated. So how can we then tell this component to re-render itself? In React, the primary way you tell a React component to re-render itself because something has changed, is to call setState. If you call setState on a component, it will re-render that component and re-render all of the child components. So what we'll want to do here is add the subscription on the componentDidMount prototype method, so this only gets called once. The first time after this React component gets rendered, and then within this we can call this. setState, which will call setState on this component and cause the render method to be called, which will re-render this component and the child components, including the conversion component. You may have noticed that I'm just passing this empty object into the setState method. By using this trick, I can say call setState, just use an empty object so we're not really making any changes, but because we're calling setState, React will assume that some state has changed, and will therefore re-render its children, which means that when it's re-rendered it will call store. getState. originAmount again, and pass that in as a new prop. Let's try this and see if it works. Here we go. The UI is updating itself, and it seems to be working appropriately, awesome. So we've now taken one property that used to exist in local state of the converter component and moved it entirely into Redux. So now it's being read from Redux, and when we update this value, it dispatches to Redux, awesome. This is a fairly simple way of listening to the Redux store to make updates. If you think this seems a little bit tedious and a little bit messy to have to manually subscribe to the store like this, there is an npm module called react-redux that does the subscription for you. In the next section, we will use react-redux instead of manually subscribing like this. Let's get to it.

React-redux
In this section, we will replace our custom Redux subscription with the react-redux npm module. First, we'll install react-redux. Next, let's head over to our main. js file. The first thing we'll need to do is we'll need to import the provider from react-redux. Provider is a special component called a higher order component. We will wrap our MainComponent in this Provider component. We make sure to pass the store as an attribute to the provider. This ensures that all of the components in MainComponent have access to the Redux store. Then we'll start our app and Webpack with npm start. Next let's head over to the browser. The React team has provided a helpful Chrome extension called React Dev Tools, which allows you to inspect React components. Provider is a special component that wraps MainComponent with additional functionality. It passes in a dispatch method via this. props. dispatch. It also tells all the child components which Redux store to use for passing in the store property. Here you can see that at the root there is the Provider component, and then it provides that functionality to all of the children components. Let's head back to the Conversion component. We no longer need to import the store since it's now provided by the Provider, and also, we should remove all the references to store. Dispatch is now provided via this. props. dispatch thanks to the provider. Great, now let's head back to the MainComponent. We have a little bit of clean-up left here. We could remove the componentDidMount method with the custom subscription, as well as the originAmount prop, since we'll be accessing that directly from Redux. Next, let's head over to the browser and see how things are looking. Let's try to change one of these values and see what happens. This. props. dispatch is not a function. We're seeing this error because we haven't connected the Conversion component to Redux yet. Let's head over there and do that now. The first thing we do is we import the connect method from the react-redux module. Then we head to the bottom of the file, and we use this connect method to wrap the Conversion component. This will essentially connect this component to Redux. Let's pause and explain this syntax for a moment. So we have a connect method, which returns a function that we then call, and that return function is what we pass the Conversion component into. So what is the parameter for the first method? For the first method, we pass in an anonymous callback function. This function will be called any time Redux updates the store, and it helps us map the Redux state to the props of this component. It has two parameters, state, which is the Redux state, and props, which are the props from this component. Let's log out the state and the props so we can take a look at them in the browser. Before we head to the browser, let's head back to main. js and add a test property so something will show up in props. So here we see state, which is logged from our reducer, then connect state and connect props. Connect state has the originAmount from Redux, and connect props has our testProp, fantastic. And here we've got a helpful error message, mapStateToProps must return a plain object. Instead received undefined. Let's head back. In the mapStateToProps function, state is populated because we wrapped MainComponent with Provider and passed in the store that way. That's how this function knows what store to pull its state from. This function needs to return an object, and this return object is then merged with the this. props object from the conversion component. So we are signing the originAmount prop to the originAmount state that lives in the Redux store. Now let's add a console statement for this. props in the render method so we can verify that this. props has all the things we expect. Now let's head over to the browser and check. There we go. So now this. props contains our testProp, the originAmount, as well as dispatch, which is passed in because we have connected this conversion component to Redux. Let's head back to the code. Now for some cleanup. Let's remove our console. logs. And since we've been using ES6 error functions, let's convert mapStateToProps to an ES6 error function. The name here doesn't really matter since it's an anonymous function anyway. Let's head back to main. js and remove our fake prop. Let's head back to the browser and verify that everything still works. There we go. Everything seems to be working just fine, great. Now you may be asking yourself, why not just use subscribe, in some ways that seems simpler. So technically you could do that and just use store. subscribe, but the Redux folks really don't recommend that because they make a lot of performance optimizations under the hood, so for this reason they really recommend sticking with react-redux, and having the subscriptions handled via the connect method. The next question you may ask yourself is, now should I connect all of my components? Well the answer is no. What the Redux team recommends is that you separate your components between what used to be called smart and dumb components, which they now call container components versus presentational components. What this basically means is that if you find yourself with a collection of pieces or features or components that all use similar state, that that should be moved under one parent container, which is called the container component. This container connects to Redux, and then any children of that component are just presentational components. In other words, they do not know about Redux, they do not connect to Redux directly, they just receive the props passed in from their parent container component. In this case, the Conversion component is naturally the container component, and we should consider the FeesTable component a presentational component. Now we could keep them in the same file, but I would like to illustrate how we would split these out. So I'm going to move the container component here into a separate folder called container, and then the FeesTable component is going to be in a component folder. Again, you don't have to do it this way. This is kind of a loose convention that's been established, and if you don't have anything you like better, this is a great way to start. If you have any more questions about react-redux and some of the other features that it has, you can head over to the docs, and here in the left rail you can find usage with React. And here it also explains some more details about presentational versus container components. In this section, we removed our custom Redux subscription, and instead used the react-redux npm module. While it may seem like there's a little bit of magic here, it's a really nice way to connect these components to Redux, as well as providing the store functionality and the dispatch functionality directly down to the components without having to pass down everything manually. So you get a lot of things for free here. I think they've done a really good job with this.

Summary
In this module, we learned about the basic building blocks of Redux, including the store, reducers, and synchronous actions. Then we talked about how to migrate parts of your local state over to Redux. Finally, we learned about the benefits of using react-redux versus manually subscribing to the Redux store. In the next module, we'll learn about asynchronous actions, and how Redux helps with ajax calls. I can't wait.

Asynchronous Actions
Introduction
Hello. My name is Jamis Charles, and welcome to this module of Pluralsight's course, Redux Fundamentals. In this module, we'll learn about asynchronous actions in Redux. First, we'll learn about how middleware unlocks additional features in Redux. Then, we'll show how we can use redux-thunk for async actions. Finally, we'll show some common Redux conventions like action creators. Let's go.

Middleware
In this section, we'll apply middleware to Redux so we can console. log our Redux state changes. One of the big selling points of Redux is that it makes state changes more predictable and transparent. What if we could console. log all of our Redux actions. That is where middleware comes in. If you've ever used server-side web frameworks like Express or Ruby on Rails, you're likely familiar with middleware. In a nutshell, middleware is a convenient way that frameworks allow you to inject your own code when certain events happen. Let's head over to the browser and take a look at an example. This here is redux-logger. This is a great example of Redux middleware that you can apply to your app. This middleware will log state changes to your console. Let's take a look at the installation instructions. Frist we'll npm install it, then we'll apply this configuration to our store. Let's do that now. First we'll run npm install with the --save-dev flag, and now let's head over to our store. First, we'll need to import the logger, then we need to import the applyMiddleware method from Redux. Then we'll actually apply the logger middleware, right here. This is how we tell Redux to include this middleware, the applyMiddleware method, and we only want to apply the logger. Next let's head to the terminal to start our app. And now npm start to start up our app. Great, let's head to the browser and take a look. This first state log is still left over from the console. log statement in our reducer, so let's enter this here, here we go. Action CHANGE_ORIGIN_AMOUNT, it gives us a nice timestamp, and here's the part that I'm really excited about. It shows us the previous state, and then the name of the action, including the data that we've passed along with our action, and then the state after. One of the key things with Redux is that state changes can only happen because of an action, and if we can show our actions here very clearly, this makes our state changes very predictable and very transparent. This right here is one of my favorite things about Redux, because it makes it much easier to see what is happening under the hood. As I mentioned earlier in this course, I've spent days troubleshooting issues where state was mutated where it wasn't supposed to be, but if you use this to log your state changes, you can see exactly what UI changes cause what actions, and in turn cause which state changes to occur. This makes it so much nicer and so much easier to track down complicated state changes. This right here is what I really love about Redux. As we click through the rest of the UI, it also makes it very clear that we only have one action in Redux right now, since it's not firing any other actions here. So let's head back to our file and remove the console. log. We'll just take this one out right here, there we go. Let's head back to the Redux Logger docs to take a look at some more configuration options. If you scroll down, there's a recipe section that gives you a lot of other configuration options, like the option to only log in development. On my team, we don't really want to show these state changes in production, so we use process. env. NODE_ENV, which is a node environment flag which Webpack can help us inject here to only enable this in local development mode. Then there's a few other options here like loading it collapsed, instead of expanded, things like that. There are some neat things here. I'm not going to go into how we do this with Webpack because that's a little bit outside of the scope of this course, but Webpack will allow you to inject your environment variables here so you can turn on functionality or turn off functionality based on whether you're running in dev mode or in prod mode. Webpack is really great there. You can see how easy middleware makes it to enhance Redux with custom functionality. Other people have created middleware that logs actions to their analytics frameworks, for instance. There are many other such loggers that can be found on NPM. You can also create your own if you have custom needs. In the next section, we'll convert our Ajax calls to Redux actions. Let's do it.

Async Actions
In this section, we'll introduce asynchronous actions and move over one Ajax call to use Redux. Let's head over to our Redux store. Let's take a moment and talk about how dispatch and actions work. When you call dispatch, it calls the reducer function that is defined in your createStore method. It calls the reducer function, in this case amount, and then passes in two parameters. Th first one is the current state before the action is applied, and the second parameter is the action, in other words, the plain object that you have passed in to the dispatch method. Currently, dispatch only allows you to pass it a plain object, so it's easy to see how we would handle synchronous actions. But what if we wanted to make an Ajax call, for instance? There are several ways to solve this. Middleware is one possible solution to this problem, so which middleware could we use for this. Redux-thunk is middleware that Dan Abramov, the creator of Redux, wrote to solve this problem. In short, redux-thunk allow us to use async actions. We'll explain more in a bit. If, like me, you'd never heard of a thunk before, here's a simple definition from the docs. A thunk is simply when you wrap some code in a function in order to delay its execution. Don't let the name scare you. We'll explain how it works in a bit. So here's how we install it. Now let's head to the terminal and install it. We'll run npm install. Now we'll head over to our redux store, we'll take this here out, then we'll import the redux-thunk middleware, and then we've got to apply the middleware. It's important to note that logger needs to be the last parameter here, or else it'll log incorrectly. Let's head over to the Conversion component. When dispatch is called with an object, it calls the reducer with the current state and the action object. Because we added the redux-thunk middleware, we can now pass a function to dispatch. When dispatch is called with a function, it executes it and then Redux swallows and ignores the function. So this function by itself doesn't call the reducer, and it doesn't affect the Redux state at all. So how is this useful? We can use this function to do some async work, and then call dispatch with the result. As a convenience, redux-thunk passes dispatch as the first parameter to this function, so we'll be using that. This is nice because we don't have to worry about how the this keyword is bound. Let's demonstrate redux-think with an async action using a timeout. Right before I do something async I like to fire an action that says, hey, I'm about to do something asynchronous. And then I run my async code, in this case it'll be a setTimeout, and then after that async code completes, I fire another action saying, hey, this async action has completed. In this case, I'm just setting it to a type of CHANGE_ORIGIN_AMOUNT just so we can see it happen, and I'm going to set the amount to 5000. So let's head to the browser and see what happens. Here we go. We immediately see our two actions, and then after a few seconds we see our CHANGE_ORIGIN_AMOUNT action fire that was placed in our asynchronous setTimeout function, which changes the state from originAmount 3 to originAmount 5000, which is also reflected in our UI, and we can see here that the logs are a little bit hard to look at with them loading expanded by default. Let's head over to the redux-logger docs, and see if we can somehow load them collapsed by default. In the docs for redux-logger, if we scroll down, here there's a section that shows us how we can create our own logger with custom options, and right here I see an option to set the logs to collapse by default. Let's head back to our code and implement this. Instead of importing the default logger, we'll import the createLogger method so we can create our own custom logger, and then down here we'll call that method and pass in our custom options. Let's head back to the browser and see if that worked. And there we go, collapse by default. This is much nicer to look at. Now let's head back to the code. Let's comment this out, and then try and apply this pattern to a real Ajax call. So here we've got the this. makeConversionAjaxCall method, where the first parameter is the payload followed by the success callback and the failure callback. So technically we could just dispatch an action here signifying that we're going to make an Ajax call. And then when we get the response back, we could fire another action saying, I've received the Ajax state back, and it was successful. So technically we don't even need redux-thunk, we could just do it like this. So why use redux-thunk? Let's implement this now using the redux-thunk pattern, and we'll compare. With Redux we don't really care about the Ajax call itself, rather we care about the state before the Ajax call, and immediately after the Ajax call. So this right here is a good place to implement our actions. So let's add our dispatch here, and then pass in our async thunk function, and then we'll bring this entire method call in here. For an Ajax call, as far as Redux is concerned, there are two important parts, when you make the request, and when you receive the response. Therefore, it makes sense to have a request action and a response received action. So here we have the REQUEST_CONVERSION_RATE action, which indicates that we are about to make an asynchronous call. Now let's extract the parameters that we passed to the Ajax call, so we can log these here. And then we'll fire an action when we've received the Ajax response, and I like to prefix these with Request and Received. That's kind of a nice way of knowing immediately if it's going to be before or after an Ajax call. So how is this pattern better than what we just showed. This here allows us to combine all the functionality in this action, together in a function, regardless of whether it is asynchronous or synchronous. We'll see this pattern pay off more clearly in the next section when we introduce action creators. But, as with all things Redux, it's really up to you. These are patterns, and in some cases, loosely suggested patterns. You are not required to use this if you want to use Async in Redux, you could just manually dispatch your actions and be fine with that. In my opinion, redux-thunk scales a lot better. We'll see more of that in a bit, though. Let's head to the browser and take a look. Let's enter 300 here. We see a lot of REQUEST_CONVERSION_RATE actions, but only one RECEIVED action. The REQUEST one we can see the payload of what we send, and that we don't affect the state, which is great, but the number of REQUEST_CONVERSION_RATE actions, you would think that we're making a lot of Ajax calls here, but we only see one RECEIVED_CONVERSION_RATE action. That's because the callback that contains the RECEIVED action is actually debounced because the Ajax call itself is debounced, but the dispatch that we fire right before the Ajax call is not debounced. Let's ignore this for now. We'll fix this later. Let's take a look at the RECEIVED action. We can see the payload that we received back from the Ajax call, but we can also see that we're not affecting the Redux state at all. Let's change that. Now let's move over this setState call to Redux. That means we'll need to move over the conversionRate state and the destinationAmount state over to Redux. Let's take a look at our state object for this component. We'll want to remove destinationAmount and conversionRate from this object, but let's not do that quite yet. For now, let's head over to our reducer and update our store when we receive the new actions. So, if we dispatch an action of type RECEIVED_CONVERSION_RATE, then we'll set the new state to the current state, plus the conversionRate and the destinationAmount that we receive back from the Ajax call. Let's head to the browser and take a look. Great, we can now see that our Redux state has been updated, but not our UI. Let's head back to the editor and swap conversionRate and destinationAmount with the Redux state instead. Let's remove these two values now from the state of the component, and then head to the bottom of the file. We need to inform Redux to pull in these two state values from the Redux store, and make them available as props in this component. Now let's find all the instances of this. state, the destinationAmount, and now the same for conversionRate. Let's head back to the browser to verify. Hmm, let's read the first error here. Failed prop type: The prop 'conversionRate' is marked as required, but it's undefined. So what's going on here? Let's head back to the Conversion component to find out. You can see here that we used to provide some default values to the local state that populated the state and the UI before any Ajax calls are made. Now we've lost those in Redux, but thanks to our prop types, we are notified that those values are missing, rather than the UI just having bugs. Let's add these default values in Redux. Here we go. We'll add defaultState values for destinationAmount, and for the conversionRate. Let's head back to the browser and see. We'll refresh. Great, we can now clearly see that the RECEIVED_CONVERSION_RATE updates both the Redux state, as well as updating the UI, fantastic. So in summary, in this section we demonstrated how we can use Redux actions to clarify asynchronous state updates to our local app. On my team, this kind of a use case was a cause for a lot of confusion. As I've mentioned earlier several times, I used to spend days tracking down complicated state updates that were asynchronous. Using Redux in this way, really simplifies and allows you to see exactly how your state is being updated, and when it is being updated, with what values. This makes it much easier to troubleshoot and pinpoint where the state went wrong, and what action caused it go wrong, since in Redux the store can only be updated as a result of an action being fired. Redux is really great. In the next section, we'll convert the remaining Ajax calls, as well as refactoring this a bunch. I can't wait.

Action Creators
In this section, we will introduce action creators. This statement here seems pretty simple. We are calling dispatch and passing in a plain object with the action name and the payload. Dispatch then immediately calls the reducer we pass to createStore, and then updates the store. This pattern works great for a very simple app, but what if we need to dispatch this action from several places in the application? At that point, it probably makes sense to abstract the parts that don't change. That's where action creators come in. I've created a new folder named actions with a file named actions. js. Let's head over there now. As a recap, here is the folder structure. Our actions folder will contain our action creators, our build folder contains our generated Webpack bundle, our components folder contains our presentational components, our containers folder contains our container components, which are connected to Redux. Then we see our main. js file, which starts up the app, and we have our source folder, which contains the Redux store. In this case, I'm choosing to only have one actions file, but as your app scales you can choose to have several or many action creator files. Let's copy in our dispatch here so we have a reference point, and create our first function. We'll call that changeOriginAmount. The sole purpose of this function is to return the action object that we will pass to dispatch. Great. We now have a function where we pass in the newAmount, and it simply returns a plain object that represents the CHANGE_ORIGIN_AMOUNT action. In Redux, this function is called an action creator. We need to export this function so we can import it in the Conversion component. Now, let's head over to the Conversion component so we can replace our inline action object with this function. With ES6 imports, using * as actions means it will import all the exports from that file, and group them under the actions object in this file. Now, let's go back down to our original dispatch. Since we've now abstracted this object, let's replace it with the CHANGE_ORIGIN_AMOUNT action creator. So now we call actions. changeOriginAmount, which returns an object, and then that object is passed to dispatch. Let's verify in the browser that things still work. Before we forget, let's start the app. Then let's head to the browser, great, everything still works. Let's head back to the code. For the sync action, the action creator is really simple. Now let's make an action creator for our async action. Hmm, so which parts here should we carry over. Let's bring in the whole function and see. We'll start by crating the function. We'll worry about a proper name later. With funcs, dispatch expects a function rather than an object, so we'll return this function here. We'll want to pass in the payload as a parameter so that we can remove the payload definition here, great. Here we've got a call to the makeConversionAjaxCall method, which is defined in our conversion component. Previously, it made sense for that method to live in that component, but now it doesn't make sense for the component to call in to this file just to call back into the component, so let's bring that method over here as well. Let's just bring all that in. Let's paste this in here at the bottom. Okay, so what do we have here? Really, the makeConversionAjaxCall function consists of only two things. We have the actual Ajax call, and then the preparation of the payload for the Ajax call. Let's bring the Ajax call into our function. Now instead of the success and failure callbacks, we'll have the success action, and the failure action. Now we can remove the rest down here, great, looking much better. Now, for the name of this action creator, I like to prefix my action creators with the prefix fetch to indicate that it is async, so I'll name this fetchConversionRate. Before we forget, let's import the axios library. Now the only leftover code we have here at the bottom is the code that prepares the payload. Let's move this back to the Conversion component. First, let's add a dispatch with our new async action creator. Now, we need to prepare the payload. Let's look at the Ajax call and see what payload fields it actually expects. We can simplify some of this logic quite a bit since we aren't abstracting anymore, and it can be more single purpose. Let's inline those here, and then we don't need this anymore. We know that originAmount is the amount changing, so we'll just pass that newAmount in here. We'll comment out the old code for now, we can remove it later, great. This is looking quite a bit simpler now. Let's head over to the browser and test it out. It looks like the actions are firing just fine, but we can see that the destinationAmount in the UI is not being updated. Now this here is a classic state problem. Prior to Redux, I'd manually and painfully start going through the code. Thankfully, we are logging Redux state changes. Let's look at the logs here. I would expect a destinationAmount to be updated once the RECEIVED_CONVERSION_RATE_SUCCESS action fires. We can see that this action is not updating the state. That usually means that we need to check that the reducer has a condition for this action type. While we're here, let's check the data we received back from the API. Interesting, two things immediately stand out. First, we're incorrectly passing the response object from the Ajax call, instead of just the response data. Second, destinationAmount shows as NAN, not a number, so there's clearly a problem there. Let's verify that we're passing the correct payload to the API. Hmm, interesting. The value of destinationCurrency is undefined, that's likely what's causing the API to respond with an incorrect value. Now, by just looking at these logs for 2 minutes, we've uncovered 3 bugs in our code, and we didn't even have to look at the cod. This here is one of the main reasons I love Redux. We now have three issues that need to be fixed. One, the reducer probably doesn't have a condition for the RECEIVED_CONVERSION_RATE_SUCCESS action. Two, the Ajax response in the action creator passes on the response object, instead of just the data. And, three, the payload value for destinationCurrency in our component is undefined. Let's head back to our code and fix each of these in turn. The action name is missing the SUCCESS suffix. Let's add that. Now, let's head to the async action creator to fix the second issue. Here we go, when we dispatch the success action, we are passing the entire response object, instead of just the data property. Great, and now to the Conversion component to fix the payload issue. The destCurrency property had a value of undefined. Let's take a look at our state object to verify. Ah, the prop is destinationCurrency, we have destCurrency, let's fix that. Great, that should do it. Let's head back to the browser to verify. Great, the destination amount now shows up in the UI, but we have another issue. You can see that we've lost debouncing. This is bad for two reasons. First, most of the Ajax calls are just wasting server resources. Second, and more importantly, with async calls you can't control the order that the responses will come back. Here we see that 300 dollars is converted as 2 Euros and 82 cents, because the first Ajax call came back last. This is a wonderful illustration of why debouncing is necessary. Let's head back and fix the debouncing. So where should we debounce? The way we debounce a function is basically to add a clamp at a specific point that checks all the calls to the function, and doesn't let any through until you've stopped calling the function for a specified amount of time. You might be tempted to debounce the fetchConversionRate action creator. This would throw errors, because we call this function and pass the result to dispatch. So during the debouncing, dispatch would be called with no parameters, which would throw an error. Essentially, it's probably not a good idea to debounce something that has a return value, so let's debounce the dispatch and the Ajax calls. We'll move this to a separate function, and call it makeConversionAjaxCall. Then we'll need access to the payload, and to dispatch. Up here we'll call the debounce version, makeConversionAjaxCall, which doesn't exist yet, and before we forget, let's bring in the debounce method, and then we'll debounce the _makeConversionAjaxCall function and save it as makeConversionAjaxCall. Great, let's head to the browser to verify. Beautiful. We see that we have many change actions that update the UI, but only one request action and one received action. And as a result, our bugs are resolved, and the conversion is working properly. Before we complete this section, let's head back to our component and convert the second Ajax call in the handleOriginAmount method. One of the benefits of refactoring like this is that we have an opportunity to reexamine the logic, and to correct any mistakes, and think about how logic should work. Unfortunately, this is also a time new bugs can creep in. The first question is, should this second Ajax call happen in parallel with that first call, or after it? Is there any state that the second call has in the payload that we don't have until the first Ajax call completes? The answer is no. Therefore, we can just let these calls happen concurrently. Like we did with the other Ajax call, let's prep the payload here and move over the rest, including the actual Ajax call. We'll bring this here up, because that's part of the payload, then we'll copy the rest over here to our new action creator. Then there's this calcNewTotal method. Let's take a look at that. So here we first calculate a value from state, and then we update the state. We can easily move this to Redux as well. And since we still have some non-Redux code calling this, we'll just copy it over instead of cutting it out for now. Now let's add an action creator and update the Redux store when that action is fired. Let's use fetchConversionRate as a template, and since this call is also debounced, we can also copy _makeConversionAjaxCall. Then we'll want to debounce this one as well, add some more name changes, one last one, and here we go. Now let's bring in the actual Ajax call from the Conversion component. Pretty simple, let's copy it over. Then let's compare. It looks like the only difference is really the Euro, so let's just copy that in, great. Now we'll want to update the action names. This will be RECEIVED_FEES_SUCCESS and RECEIVED_FEES_FAILURE. And finally, REQUEST_FEES, there we go. Next, let's head over to the reducer and add a condition for this action. Let's add a check for the new action we just created, the RECEIVED_FEES_SUCCESS action. Let's see what the name of the property we want to bring over is, feeAmount, okay. So I'll do feeAmount equals action. data. feeAmount. And then this is also where we're going to want to bring in the calcNewTotal method. The important thing to remember about a reducer is that it must be pure. That means, for one, that there can be no so-called side effects, no Ajax calls, no variables that aren't explicitly passed in. So this here can easily stay in the reducer because it doesn't violate those rules. We'll pull the originAmount from the Redux data that was passed in to the reducer, and we can get the new feeAmount from the payload of this action. So we'll use the new feeAmount here, and here, and then we can easily convert this. setState totalCost to the Redux state totalCost, which is going to be the new total up here, great. Let's head back to the component and use our new action creator. So we'll add the dispatch with our new action creator of fetchFees. We pass in the payload, and then we'll remove the old Ajax call. Great, much simpler. Let's head to the browser, 300 once again. Now we can see in the Redux logs that the state in Redux is correct, it's what we expect it to be, but the UI doesn't reflect that because we're still using local state. Let's have the UI show the feeAmount and totalCost from Redux. Let's connect feeAmount and totalCost to Redux so we can pass them in as props. And since there are still other parts of this component that may use the local state for feeAmount, we won't remove those entirely at this time, we'll just pass them in here to the FeesTable component. Let's head back to the browser and verify. Whoops, it looks like we forgot to add the default values for those two props. Let's add them to the Redux store. You see the default values for feeAmount and totalCost. Let's bring those over to the Redux store, and feeAmount, totalCost, great. Now let's try again. Three hundred again, fantastic. Now the originAmount, the destinationAmount, the conversionRate, feeAmount, and the totalCost are all controlled by Redux, great. In this section we saw how action creators can be helpful in moving some of the complexity from side effects like Ajax calls, out of the component itself and into a separate file. We also gained some more experience in converting another Ajax call to Redux.

Switch and Constants
In this section, we'll talk about two more common Redux conventions. In our reducer, we've been using if statements to watch for the action type. This works fine when you have just a few actions, but some people prefer switch statements. In addition, most Redux examples you'll see will likely use switch statements, so let's show how this reducer would look with switch statements. There we go, fewer braces, less code, and arguably easier to read. If you haven't used switch statements before, here's a quick recap. You start with a switch statement at the top that receives an expression, and then you add a case clause with a value to check against the expression in the switch statement. Whenever they match, the case block is executed. So in this case, when action. type equals CHANGE_ORIGIN_AMOUNT, then that first block is executed, and the default block is executed if none of the cases above match. The important thing to remember with switch statements is that you need to either return or use the break keyword at the end of each case block, or else it will successively execute each case block in turn. I don't use switch statements often, but I think for reducers they're a great fit. There's fewer braces, and less code in general, which makes it easier to scan, and also less prone to bugs. Let's head over to our action creators file to talk about another convention. Currently we specified the action type as an inline string. We referenced these in our action creators and our reducers. Nothing to crazy yet. As our app scales, we may be referencing action types from several reducers. Constants can be a nice way of ensuring correctness and having a central place we can update action types. Let's demonstrate this by taking the CHANGE_ORIGIN_AMOUNT string and converting it to a constant. I've created a file called constants. js. We'll just have this live next to main. js. Let's head over there now. We'll start with a simple object called ActionTypes, with a property of CHANGE_ORIGIN_AMOUNT, which has the exact same value. Then we need to export this so it can be imported. Great, let's send it over to our action creators file. We'll now import that constants file, and since we used the export keyword in the other file instead of export default, we will have to use the destruction here. And by using ActionTypes as types, we are specifying that we want to bring in the ActionTypes variable and assign it as types in this file. Then we'll replace this first type here with our constant. Type is types. CHANGE_ORIGIN_AMOUNT, great. Let's head back to our constants file. So what benefits does this have? For one, I think it's easier to avoid typos. You can also lint for misspellings, and it provides a nice central place which makes it easier to see what kind of actions are available in your app, similar to the action creators. Once you start typing out a lot of these values, it may seem annoying to type the key and the value twice if it's exactly the same. There's a simple module called keyMirror that helps with that. I've already installed it via npm. The way this works is that we import the keyMirror method, and then we can pass that method an object and it'll then go through the keys and specify that the values be exactly the same as the keys. Let's console. log this to verify. And then let's head over to our browser. There we go. We can see the ActionTypes object, and that the key matches the value, and everything else still works, great. So in this section we learned about constants, and about using switch statements, two simple improvements, and again, totally up to you. You're not required to use any of these conventions. My suggestion is to try it out, and if it works, keep it, and if not move on to something else, great.

Summary
In this module, we learned about how we can log Redux actions with middleware. Then, we explained how redux-thunk can be used for async actions, but is not strictly required. Finally, we talked about how async action creators can move your complex Ajax logic out of your component. In the next module, we'll finish converting this component entirely over to Redux. I can't wait.

The State Tree
Introduction
Hello. My name is Jamis Charles, and welcome to this module of Pluralsight's course, Redux Fundamentals. In this module, we'll complete our transformation to Redux. First, we'll introduce root reducers. Then, we'll show how to make serial Ajax calls with Redux. Finally, we'll show how to construct the state tree with multiple reducers. Let's get to it.

Rootreducers
In this section, we'll show how to split our state with several reducers. Having one reducer works fine for a very simple app, but once your app scales, you'll likely want multiple reducers so the state tree doesn't become unwieldy. That's what we'll demonstrate now. I've created a new folder named reducers with two files, index. js and amount. js. We'll need these files to split our reducer into several parts. Let's head to the store now. This is where we create our Redux store, and as you can see, most of this file consists of the amount reducer. We're going to take the amount reducer and move it to its own file. So we'll cut that here. Great, now we'll head over to the new home for the amount reducer. Now we'll paste that here in the reducers amount. js file, and before we forget, let's export this file. Now let's head over to our index. js file. If you recall, the createStore function expects one reducer. Now that we'll have several reducers, we need some way to combine them so we can pass them to the createStore function. Fortunately, Redux provides us with a combineReducers function. This combineReducers function allows you to define the shape of our Redux state object. So here we've defined that the state returned by our amountReducer function will live under the amount property. Before we forget, let's import the amountReducer and we'll export this with the export default statement. Let's head back to our Redux store, and we'll import this new combineReducer, and this often called the rootReducer. Now we need to make sure that we pass in the rootReducer to the createStore function. This rootReducer is going to change the shape of our Redux state object. Let's head over to our Conversion component to see how. In our connect function call here, let's console. log state so we can see what the new shape of the state object is. Now let's fire up the app and head to our browser, npm start, and here we go, now to the browser, restart. Let's scroll up, because the first error is usually the most helpful. Failed prop type: The prop 'conversionRate' is marked as required, but its value is 'undefined'. We've seen this error before. This indicates that some required props are missing. That's because the shape of the Redux state object has changed, so we now need to change our code. And here we can see that all of our state now lives under the amount property. That's how we defined it in our combineReducers function. Let's head back to the Conversion component to fix this. We'll remove this console. log statement, and correct the path to include amount. Let's try it again, and refresh, great. Everything works again, fantastic. So in this section we saw that combineReducers can be used to split our reducer logic to help us scale our reducing logic as our app grows. In the next section, we'll convert the currency changes to Redux.

Currency Dropdown Conversion
In this section, we'll convert currency changes to Redux. When we try to update the currency, we see that the drop-down value changes, but the conversion Rate and Fees are wrong. We'll fix these bus as we move the currency drop-down to Redux. Whenever you need to change a UI feature or fix a bug, the first question is always, what code runs when I use this feature? With React, you answer that question by looking at the render method. Let's do that now. Let's start with the originCurrency drop-down. We can see that the value is populated by this. state. originCurrency, and changes are handled by this. handleOriginCurrencyChange. Let's examine the handler. Here we see that we've created two new methods by binding the first parameter on the handleCurrencyChange method. This allowed us to reuse the same logic for both drop-down fields. Let's take a look at the handleCurrencyChange method. To simplify things for us, let's create a new handleOriginCurrencyChange method. We can combine the functions again later if it makes sense. That means we should modify the conflicting binding. We'll still need access to the this keyword in the method, so we'll just remove the first parameter binding. So now by calling bind on the handleOriginCurrencyChange method, and passing in this, we are assigning the component that is generated from this class to be available under the this keyword when the React event calls this method. Let's head back to our method. First thing we'll want to do is to dispatch an action to update the UI when the drop-down value changes, and we get the new currency value from event. target. value. This changeOriginCurrency action creator doesn't exist yet. Let's add that now. This is very similar to the CHANGE_ORIGIN_AMOUNT function, so we'll just copy this and then modify it. Great, let's head back. Let's take a look at what else is happening in the handleCurrencyChange method. As far as Ajax calls, we fetch the conversionRate and the fees from the server. We did something similar for the handleOriginAmount method, so let's see if we can steal some of that code. This looks pretty good. Let's copy this and bring this into our new method. We'll paste it in here, and we can remove this newAmount code here, since we're dealing with currency instead of the amount. Now, what needs to change? We'll add newCurrency here, since we'll be reusing this several times in this function, and since originAmount now is in Redux, we'll use this. props. originAmount instead, and then we'll set originCurrency to newCurrency. Then we'll do the same thing for the second payload. Great, let's head to the browser and try it out. And refresh, enter the amount, and we'll try and change the currency. No errors to the console right now, but we see that the drop-down value isn't being updated. Let's head back and fix that. We forgot to move our originCurrency state over to Redux. Let's do that now. Let's start with the default value. Then we'll add the case clause, and we could copy this one since it's very similar. Then we'll change that to CHANGE_ORIGIN_CURRENCY with the new property and value, there we go, good. Now we'll connect this new Redux property. So, originCurrency is equal to state. amount. originCurrency. Now we need to change this. state. originCurrency to this. props. originCurrency. It looks like we have a few of these. And that's it. Let's head back to the browser to verify. We'll enter amount first, then try and change the drop-down currency, and everything seems to work, fantastic. Let's head back and convert the destination currency as well. Since almost all of the logic will be identical, let's duplicate the handleOriginCurrencyChange method and rename it. We'll name the new action creator changeDestCurrency. Let's head over and add an action creator for it. We'll just copy this one here, and then rename it, and when that's done we'll head back to our component. Now we need to fix the payload here as well, and originCurrency since it lives in Redux is now this. props. originCurrency, and newCurrency is now the destinationCurrency. And the same thing for the second payload. We'll want to update the binding for this method as well, And same as we did before, we're binding handleDestCurrencyChange to handleDestCurrencyChange, and passing in the this keyword. Now we'll head to our amount reducer to move the destinationCurrency property to Redux. Again, we'll add the default state, then the case clause for this action. Now our only step left is to connect this property to the component. We'll connect destinationCurrency, and then we'll go through and change all the references from this. state. destinationCurrency to this. props. destinationCurrency. Now to the browser for a final check. Here we are. All this still appears to work. We'll clear this. Then let's change the currency. We see the Conversion Rate change, the Fee, everything appears to be working fine, great. Let's inspect some of the state here just to verify. After the CONVERSION_RATE_SUCCESS call comes back, you see that we have our state. amount property, we have originAmount, totalCost, feeAmount, looks good. Let's check our FEES_SUCCESS. FeeAmount is 6, totalCost 306, great, everything looks good. Now finally, what happens if I try and change the destination Amount? Hmm, it doesn't work at all. So, the originAmount works, the origin and destination currency work, but the destination amount doesn't work, and that is exactly what we'll be fixing in the next section.

Serial Ajax Calls
In this section, we'll show how to do serial Ajax calls in Redux. Let's head to the relevant files. We need to fix a bug with the destinationAmount field. Here we can see that the handler for the onChange event for that field is this. handleDestAmountChange. Let's head there now and take a look. No wonder this isn't working. It looks like we're still using the old local state. Let's take a look at the handleOriginAmountChange as this is similar functionality, and already has been converted to Redux. This one here is very similar functionality and looks pretty simple. Let's copy this over and use this as a template. And we've changed the name, and let's go down here and comment out the old one. There we go. The first few lines look fine, since they still apply, and then the first thing we'll need to change is right here. We'll want to change the action creator here. Let's rename it to changeDestAmount. Let's head over to the actions file and create the new action creator. Let's duplicate this one here, great. Now let's head back to our component to see what else needs to change. The next thing we need to change is the calcOriginAmount property needs to be set to true. This signifies to the API endpoint that we don't know the originAmount and want to calculate it from the destinationAmount. So we will change the name of the property from originAmount to destAmount. Great, everything else looks good. Let's head over to our amountReducer next and make sure that we are listening for the changeDestinationAmount action. Let's duplicate this one here and rename it. Now let's head over to our component to connect this. We can see here that it's already connected to Redux, which is great. So now let's fire up the app and then head to the browser and try it out. Now to the browser, and let's try to change the destinationAmount. So we can see that the Fee is updated, but the originAmount field never changes. Let's inspect these logs and figure out why. I would expect the originAmount to change after the RECEIVED_CONVERSION_RATE_SUCCESS action fires, so let's inspect that. The payload here states that the newOriginAmount is $212. 77, but that's clearly not reflected in the UI. Let's see if the Redux state has been updated. The Redux state is still 300. So even though we see that the payload clearly came back with 212. 77 for originAmount, the Redux state remains at 300. That indicates that the problem lies in the reducer. Let's head over there now and take a look. So when the RECEIVED_CONVERSION_RATE_SUCCESS action fires, we would expect that the originAmount is updated, and here we are missing that property, so let's add that, action. data. originAmount. There we go, let's try that. And we'll change the destinationAmount again. Here we go, it seems to work, great. So we celebrate, we push this out to production, and it sits there for about a week or so. And then our product manager comes to us and says, hey, we've noticed that the fees are off, and the company could be sued if we don't fix this quickly. So the product manager did a bunch of testing and figured out that the fees are only wrong when we update the destination amount. So our job now is find out why the fees are incorrect when the destination amount is updated, and most importantly, to fix it. Let's clear this. Let's change this to 300. Let's see what the RECEIVED_FEES_SUCCESS logs tell us. So when the action comes in, the originAmount shows as 300, which is incorrect. In this case, the destinationAmount is 300, and the originAmount is 319. So it appears that the data that we get back from the FEES_SUCCESS call is wrong. Let's see what we send, along with our payload. So here REQUEST_FEES, we tell the API that the originAmount is 300. So it seems that we are sending the incorrect amounts to our Fees API, and that's why the fees are incorrect. This is a pretty big deal. This originAmount should read 319. 15 instead of 300. Let's head back to our code and fix this. Ah, I see what the problem is here. For our second Ajax call, the fetchFees call, we can see that we are setting the newAmount, which in this case is the destinationAmount, to the originAmount property that we are passing to the API. So how can we access the proper originAmount value at this point? As this is currently coded, we can't, because these two Ajax calls happen in parallel. As soon as the first one dispatches, the second one dispatches right after. We need to wait for the first call to come back so we can use the originAmount that is returned in that first API call. There are several ways to fix this problem. The simplest in this case is probably to add a new action creator that makes these two Ajax calls serially, one after the other. Let's do that now. So we'll name this fetchConversionRateAndFees. And we'll remove the second call. And if we look at the payload from the fees call, we need originAmount, originCurrency, and destCurrency, and we already happen to have that from the first payload, great, so we don't even need to change the payload. So we will now instead dispatch the action, which is returned from the fetchConversionRateAndFees action creator. Let's head over to our actions file and add that function now. Let's use fetchConversionRate as a template, since that already has half the functionality that we need. So we'll change this name here, and this name here, and this name here, and there we go. Now for the actual body of the function, we'll want to make our second Ajax call after we dispatch our RECEIVED_CONVERSION_RATE_SUCCESS action. We have several options here. We could just inline the FeesAjaxCall and put all that logic here. Or, we could save ourselves some trouble and just dispatch the action returned by the fetchFees function. And since we have the action creator right here, conveniently in the same file, why don't we do that. We'll call dispatch, fetchFees, and then pass in the feePayload. Now we'll need to prepare the feePayload first. For our reference, I've copied this in from the Conversion component. So we need originAmount, we need originCurrency, and destinationCurrency. We know that the initial payload already has two of the three, so why don't we use that and clone it. Object. assign helps us create a brand-new object, and in this case the first parameter is an object, which means we start with a fresh object. And then we merge into that the payload that is passed into this function, and then we want to merge in the originAmount response that we receive back from the conversionRate Ajax call. Now we can clean this up, and here we go. So we make the conversionRate Ajax call. When that completes successfully, we dispatch the RECEIVED_CONVERSION_RATE_SUCCESS action, then we prepare the feePayload for our feesAjax call. Then we call the fetchFees action creator, which returns our asynchronous action, and pass in the feePayload, which is then used to make the Ajax call, great. Let's head to the browser and see if this works. Let's update the amount again, and then let's change the destination Amount, and it appears to be working. Let's inspect the logs to verify. So the first good sign is that we can see here that the REQUEST_CONVERSION_RATE action is fired, and then only once the RECEIVED_CONVERSION_RATE_SUCCESS action comes back does the REQUEST_FEES action fire. So we can clearly see here that we're requesting the conversionRate Ajax call, and then once that comes back, at that point then we are requesting the FeesAjax call. Let's verify the payload here. So the destination I'm going at is 200, and the originAmount is 212. 77, great, just as we expect. And then the state that is then set in Redux is the conversionRate, destinationAmount, Fees, everything looks good, fantastic. Our product manager is happy, we're not going to get sued, and life is good again. So in this section we learned how to make serial Ajax calls. So we now know how to make Ajax calls that could be in parallel, and Ajax calls that need to be done serially. In the next section, we'll be setting up a new reducer to handle the errors in this application.

Multiple Reducers
In this section, we'll show how to use several reducers by adding an error reducer. Let's head over to the Conversion component. Currently, we have an errorMsg local state property, and we have these two methods here that help display error messages when there are errors with the Ajax calls. Generally, it makes sense to have Ajax error handling live near where the Ajax calls happen. Now that we've moved our Ajax logic over to our action creators, let's move these two methods over to our actions. js file. Since these are more like helper functions, I'm going to paste these in at the very bottom here, and add a heading to indicate that these are helper functions. We could easily move these into a helpers. js file as well. Then we'll turn this into a proper function, and this one as well. Let's take a quick look at these two functions. The second one really just updates state, and dispatch in action is really really the proper way to update state, so we don't really need this second function here. So we'll comment that out. And then for the first one we also don't want to update state here, so why don't we change this instead to return the message selected. There we go. All this first function really does is to return the proper error message, so why don't we change the name. Now let's head to one of our failure callbacks. Here we go, RECEIVED_FEES_FAILURE. This gets dispatched when the Ajax call fails. Now there's several ways we could handle this. One thing we need to ask ourselves is do we want to handle all of the Ajax failures the same way, or differently. In this case, I'm going to start by handling them all the same way which means I'm going to dispatch a generic action for failures across the board. So I'm going to dispatch a RECEIVED_AJAX_CALL_FAILURE. This is kind of a nice way to keep it very generic. Since this is not really an error object, but axios gives us back the response object, let's change the name of this param, and then what we want to pass along. We have our helpful getErroMsg helper, so let's use that to get the appropriate error message. And then we'll pass to the reducer the error message, as well as what call it was that actually failed. So now when the feesAjaxCall fails, we will dispatch the RECEIVED_AJAX_CALL_FAILURE action, and pass along the message, as well as a property indicating which call failed. Technically we could have dispatched in our helper, but I like having the flow logic all in one place so we can clearly see what's happening. Now, let's create an errorReducer which can listen for this action. I've created a new file called error. js in the reducers folder. Let me paste in some boilerplate to get us started, great. So we've got the default state, we've got a reducer called error, and then we export the error reducer. Let's head over to the index. js file in the reducers folder to pull this into the Redux state tree. The object that we pass to the combineReducers function defines the shape of the Redux state tree. So let's add our errors reducer to that. First we'll import it, then we'll add it here. So now we're telling Redux that our Redux state tree will have two properties, the amount property and the error property, each with their own state properties. Let's head back to the error reducer. Let's add a case clause here for that action, RECEIVED_(AJAX_CALL)_FAILURE, and then we'll set errorMsg to action. data. msg. Then we'll also want to update the default state for this. Great, so now when the AJAX_CALL_FAILURE action comes in, we update the errorMsg state. Let's head over to our Conversion component and connect this. Let's add it here, since it's not here yet, now state. error. errorMsg, and now we'll replace all the instances of state. errorMsg with props. errorMsg. And we don't need this one anymore, so let's remove it. And come to think of it, we no longer need feeAmount and totalCost in the local state either. Great, let's start up our app and then head over to the browser. And to the browser, and we'll refresh, hmm, Cannot read property bind of undefined. Okay, it's trying to bind a method that no longer exists because we removed these. So let's head back in and remove this line. Now again, great, things look much better. First, let's test out the happy path, everything looks fine. Now I added some code to the backend that will return a 500 when I start with the number 9. Okay, we see the action RECEIVED_AJAX_CALL_FAILURE, and the call returned a 500, great, so that appeared to work. Now let's see if it clears again. Once the RECEIVED_FEES_SUCCESS action fires, I would expect this error to go away. That hasn't happened. So let's head back to our reducer and fix that. Let's add a case here for the RECEIVED_FEES_SUCCESS call. And then we'll reset the error message. You may be wondering if we are allowed to listen to the same action across several reducers. Well the answer is yes. Since dispatch calls all of the reducers, you can have several reducers listen for the same action, which is a really nice feature of Redux. So the map reducer updates the state based on this action, and then the error reducer also updates its own state based on this action. In this case, if we receive the AJAX_CALL_FAILURE, we update the state with the appropriate error message, and if we receive the RECEIVED_FEES_SUCCESS, we wipe out that error message, which should make the UI error go away. Let's head back to the browser and test it out. Alright, let's try again. First happy path, everything looks good, and then unhappy path, Error, Pease try again. The Fees call fails. Then we'll change it to happy path again. The error goes away, great. Now let's try the other scenario that I have in my code. Let's test offline mode. So when we go offline, the same call fails, which results in the RECEIVED_AJAX_CALL_FAILURE action being fired again. And we have some logic in our action. js file, which analyzes the response code and then returns this message, great. Now, when it comes back online, let's see if this works, fantastic. Let's head back to our reducer and talk through a few more scenarios. Our example above is nave in the sense that we are only checking one Ajax call. Most likely you'll want to check all the Ajax calls and take action on that, and in that case you'll end up with more complicated error handling here. For instance, maybe you want to show an error if any of your Ajax calls fail, or only if certain ones fail. I'd suggest handling that logic in the action creator, and then firing actions once you know what state changes you want to make. Here we have very simple, shallow data structures, which is what I'd recommend, because it helps keep your reducer logic very simple, but in more complicated use cases, that may not be possible. So what if we wanted the message property here to be an array, or an object so we can keep track of which Ajax calls fail and which ones succeed, and then show errors if one of them fails, or show no errors if none of them fail. Let's head to the Redux docs, and see what we can find. I'd like to point out two documents here. The first one you can find in the left rail under FAQ and Performance, and there's a section about deep-cloning the state in your reducer. Basically, if you have nested state, you should deep clone the properties, but if you have values that don't change, you don't necessarily have to deep clone them. Let's take a look at the second page, which should make this more clear. The second page here provides some helpful patterns for updating nested objects and making sure that they stay immutable. You can find this page in the left rail under recipes and Immutable Update Patterns. Here it talks about some helpful common mistakes so you can avoid them, and then here it shows an example of the correct approach. As you can see, you have to go through each level and clone each level, which can get pretty tedious. Here it shows an example of using arrays. So you can't simply use array. push either, because that mutates the original reference. My suggestion is that if you can avoid it, keep your state in your reducers, very flat, preferably one level. If you have to do two levels, that's manageable, but if you can avoid it at all, I wouldn't go beyond that. There is a lot of very helpful documentation on this site that can really help you understand how to structure your reducers, how to separate your reducers, how to make sure you follow the proper patterns. It's really worth checking out. Let's head back to our reducer so I can address one more point. Something you may have asked yourself is how to split up your reducers. My suggestion is to try to arrange them by domain, and by domain I mean not just UI features that might change frequently, because it could be very tedious to have to change your reducer structure frequently. In this case, I know that I will always have errors in my UI, so it's pretty safe to have an error reducer. I also know that I'm going to have an amount feature where I can change amounts, or a transaction feature, so that's also pretty safe domain because that's not going to change. Even if the UI changes, certain properties may change, but that domain is not going to go away. As with all things Redux, I encourage you to experiment, try several things. If it works keep it, if not, try something else. In this section, we've talked about how to use several reducers, how to split them up, and how to deal with errors. In the next section, we're going to wrap this up, and make sure that our transformation to Redux is complete.

Cleanup
In this section, we're going to tidy up our app, remove all the dead code, and make sure that the transformation to Redux is complete. Let's head over to our Conversion component. Let's start here at the very top. We no longer need our local state object so let's script that out. We still need the super call because we're calling this in here. And we still need the bindings to handleOriginAmount, destinationAmount, originCurrency, and destinationCurrency. We no longer need this one here. Then here in our next method we see that we have some debouncing, and if you recall we moved all of our debouncing logic for our Ajax calls to our actions. js file, so we can remove these. Then what we're left with is the focus, which we want to keep, so when the component first loads the field is focused, great. HandleOriginCurrencyChange looks good, it's all Redux. Same thing with handleDestCurrencyChange. Then handleCurrencyChange is a remainder of the old code, so we can rip this out. HandleOriginAmountChange looks good. handleDestamountChange looks good. Let's remove this commented code, and then the old handleDestAmountChange code we can rip out. Then the makeConversion call AjaxCall. We no longer need this Ajax call because we moved all this logic over to our action. js file Same thing with this Ajax call. And calcNewTotal is now only being used in our actions. js file as well. Let's take a look at our render method, everything looks fine, we have our connect at the bottom, great. Let's head back to the top and see what actually remains. So we till have our constructor, which does some binding, we have our componentDidMount, we have a few event handlers. For the amount and the currency, no more Ajax calls, and then just the render, great. Previously, this file was about 300 lines, and after removing the Ajax logic, which was the most complicated piece, we're now at about 162 lines, so we've reduced almost half of the lines of code in this file, which is awesome. That makes it much easier to deal with. Let's take a look at our FeesTable component real quick. What's really nice about presentational components is that since they're not really making any Ajax calls, since they don't know about Redux, you don't have to update these at all. These are small, these are simple, these just take properties and render something. This looks good. So what's left? Let's head over to our actions. js file. So one thing we can see is that only the first action creator uses our constant. So we'll want to update the rest of these as well. Let's see what else there is in this file. Ajax calls look fine. At this point, we're mainly looking for commented out code that we need to remove. Right here there's some. We no longer need that, great. So let's now quickly go through and make all of these types constants. I'm going to skip ahead until all these are converted. Now that all these are converted to constants, let's head to our constants file and make sure that those are all present. I'm going to skip ahead here too, and not bore you with the details. And when it comes down to it, you can see that we really don't have that many action types. Let's head to our reducers, and use the constants there as well. Same here, I'll just skip ahead. Here we go, and finally, to our error reducer. Let's update this one real quick. Great, now we're using our constants and all of our reducers and all of our action creators. The important thing to remember is that all of these abstractions are intended to help you. They aren't required, you don't have to use them. My suggestion is to try them out, and if they help, and if you like them, keep using them. If not, stop using them. Now, let's head to the browser and make sure everything still works. The first thing we notice is that our ActionTypes object is now fully populated, which is great. It can be really nice when you come to a new Redux app you're unfamiliar with to simply just look at all of the actions. Then we'll try happy path, looks good, Try the error, still works, and then, great, it goes back to happy path. One of the really nice things about logging actions here is when you join a new team that's using Redux, a really nice exercise is simply to click around the UI, and to see what actions are firing. This gives you a very simple, a very transparent way to see what state is being affected by what UI changes. Prior to Redux, if you're not logging these sort of state changes, that can be really, really difficult. That's it. Our transformation to Redux is complete. Fantastic.

Summary
In this module, we learned about how we can use rootReducers to split up our state tree. Then we showed how we can simplify serial ajax logic with action creators. Finally, we talked about how to use multiple reducers, and how to handle nested state objects. In the next module, we'll build Redux from scratch. I can't wait.

Redux Internals
Introduction
Hello. My name is Jamis Charles, and welcome to this module of Pluralsight's course, Redux Fundamentals. In this module, we'll build Redux from scratch. We'll start with the createStore function. Then we'll move on to the combineReducers function. Finally, we'll wrap things up with the applyMiddleware function. I can't wait.

Writing createStore()
In this section, we will rebuild the createStore Redux function from scratch. As you can see here, we have a very simple Redux example. We have the default state, which is just a number in this case. Then we have our apple reducer, which only checks for one action type. Then we create our store, and we pass our apple reducer to this store. Then we manually subscribe to store updates, and you can see that store. subscribe returns a function which we can use to unsubscribe from store updates. Then we check the state, we dispatch an action, check the state again, then unsubscribe from store updates, and then one final dispatch. Let's start by stubbing out our createStore function. So here we can see that when we call createStore it returns an object with getState, dispatch, and subscribe methods, great. What's next? Let's start by filling in a little bit of pseudo code. So createStore takes the reducer function, and getState returns the state, which is pretty self-explanatory. Then dispatch calls the reducer, saves the state the reducer returns, and finally calls any subscribe functions. And then the subscribe method saves the functions that are passed into an array, so these functions can later be called from the dispatch method. Finally, subscribe returns an unsubscribe function. Let's start with the getState method. This simply returns the state object. That means that this function needs to have a state variable. That one was pretty simple, great. Let's try dispatch next. Dispatch takes an action parameter which contains the action object, and then simple calls the reducer with the state and the action. Then it calls the subscribe functions, but we haven't implemented that yet, so let's write the subscribe method now. You pass in a callback function that is called any time the state is updated. Then we add this function to an array of subscriptions. Now we need to add that array, and then we need to return an unsubscribe function. When we call unsubscribe, it'll simple remove the function that was previously added to the subscriptions array from that array, great. Now let's finish the dispatch. Since it's an array, we can use the forEach method, which takes a callback function, and each item in the array, in this case, is going to be a function. And then we simply call the function, no parameters or anything. So let's take a quick review here. When createStore is called, we pass in a reducer, it instantiates a state variable and a subscriptions array, and then returns an object which contains the following methods: getState, which simple returns the state, dispatch, which calls the reducer and pass in state and the action object, and then notifies each of the functions that have subscribed that the state has been updated. The subscribe method adds any functions passed in to the subscriptions array so that they can be called when dispatch happens. Unsubscribe simple removes functions from that array. This is looking pretty good, but we are missing one very specific thing. If we scroll up here, we can see that we create the store, we add our subscription, and then we immediately call store. getState. Well the problem is, if we call store. getState at this point, state is still undefined. Dispatch has to run one time in order for the reducer to sign the default state and return it to the createStore function. We fix this by calling dispatch once in the createStore function. Let's do that now. So instead of returning here, we simply assign this to the object variable, and then down here we dispatch. And we'll make this a type of REDUX_INIT, though it doesn't really matter what the type is. Now we can return the store object, great. There is one other very important piece that I have forgotten here. When we call dispatch, we call the reducer, and the reducer returns the new state that it has calculated, and we need to reassign that here to state so that we can keep track of it, so that the next time we call store. getState it'll return that most recent state. If we leave this out, the state will always be undefined, great. So to sum up, we call createStore, we have our basic state, we have our subscriptions, we have our object with all of our important methods, then we call dispatch the first time, which will call the amount reducer and pass in our undefined state, which then forces the reducer to use the default state, and then returns that default state in here and assigns that to the state variable. That means immediately after we call createStore, we can now call store. getState. In the next section, we'll be writing the combineReducers function.

Writing combineReducers()
In this section, we'll be writing the combineReducers function. We've made a few slight changes here. We now have two reducers with two default states. We have the apple reducer with the defaultAppleState, and then we have the orange reducer with the defaultOrangeState. Then, instead of just passing the one reducer to the createStore function, we now create a rootReducer, and then we pass that rootReducer to the createStore function, because createStore expects only one reducer to be passed in. Let's scroll down and create our new function. It takes one parameter, which is an object, which reflects the shape of the state tree. And just as a reminder, let me paste in the shape of that tree. This combineReducers function then returns one function that will call the apple reducer, and assign the result of that to the apple property here. And then it calls the orange reducer, and then assigns the result of that to the orange property. So, really, all combineReducers does is it returns a function that traverses each of the properties, calls the associated reducer, and then saves the resulting state of that call to the property that it's assigned to. The first thing we'll want is a list of all of the properties on that object. Then we'll want to return that rootReducer function. And since it is an actual reducer, it has the same function signature, meaning that it takes in state and action as the two parameters. Then we'll want to loop through each of these properties in the state tree. Let's assign the property key, then the associated reducer, and then the subState for each of these reducers, meaning in this case the state for apple and the state for orange. There's a lot going on here, so this can be a little confusing. Don't worry, we'll review it at the vey end. Then, we go through and we call the reducer at each of these levels. We pass in the subState and the action, because when dispatch is called, the action gets passed to every single reducer. And then we assign the resulting state from this reducer call to the associated property on the state tree. And then when all is said and done, since this is the reducer, we have to return state. That was a lot. Alright, let's recap. CombineReducers takes in an object which defines the shape tree that the overall store will have. In this case, we have an apple property and an orange property that are tied to the apple reducer and the orange reducer. So when combineReducers is called, it returns a rootReducer function that is in itself a reducer that calls all the other reducers, and then combines the state from each of these reducers into one big state tree that follows the shape of the object that's passed in to combineReducers. Because this is a reducer, and it is bound to be called at some point without any state that is defined, we need to define some default state, great. So when state is not passed in, we'll simply start with a blank object. In the next section, we will be writing the applyMiddleware function.

Writing applyMiddleware()
In this section, we'll be writing the applyMiddleware function. This file hasn't changed much, but there are two key differences. First, we've pasted in the logger middleware function here, and while this looks a little bit crazy, we'll be carefully stepping through each of these points in this section. Now if we scroll down, we still have our two reducers with their default state, we still have our rootReducer, and then the second change here is that we now call applyMiddleware, pass in logger, and that is the second parameter that we pass in to the createStore function. Let's scroll down and get started. Now this function could receive one or many parameters in the form of middleware functions. To make our job easier, let's use the rest operator, which is signified by three dots. What this essentially does is it takes all of the parameters that are passed into this function, and will now give us an array by this name, which is a lot easier to work with. This is similar to arguments, but arguments is not a true array, and so this is a little bit more convenient to work with. The three dots can either signify the rest operator or the spread operator, based on the context. If you use the three dots in an array or an object, then it's called spread, because it's spreading the properties out. In this case, it's taking the rest of the parameters, or the rest of the arguments, and kind of catching them in the functions array. In our examples here, I've worked very hard to try and keep the internals very simple, but I still want these functions to actually work when we're done, so I need to honor the proper API contracts and proper connections. The applyMiddleware out of these three is the most complicated. In simple terms, what applyMiddleware does is it takes the normal store and it modifies the dispatch method so that when dispatch is called it calls all of the middleware functions that have been passed in to applyMiddleware. In this case, that's only the logger function. Let's take a quick look at the logger function. When logger is called, pass in the store where it can get the state, and then there is these two functions that are returned which you don't really need to worry about now. The important piece is right here. So when dispatch is called, we call this function first, we pass in the action, so then it'll console. log. We'll dispatch action. Then, we call the real dispatch, which will update the store, and then after that has happened, we console. log again and log the state after, and then return. When we call dispatch, the normal dispatch method returns the action that is passed in, so in this case return value is going to be the action object. Let's head back to our applyMiddleware function. In the earlier section, I forgot to have dispatch return the action, so let's do that now. So at the very end it'll just return the action. For our example it doesn't really matter, but it's good to stay consistent. Now let's head back to the applyMiddleware function. So in order for applyMiddleware to modify the dispatch method of the function, it uses an interesting technique. It might seem a little bit confusing, but we'll slow it down. So this is kind of the signature that it uses. ApplyMiddleware returns a function where we can pass in the createStore function, and then when that is called it will return another function which is used to create the store, and then modify dispatch, and then return the store with that modified dispatch. So this mechanism here allows us to modify the store, and specifically the dispatch method on the store so it'll call the middleware. We'll fill in this details in a little bit, but there's an important piece missing from the createStore function. Let's add that now. So applyMiddleware is passed in as the second parameter to this function, and in Redux this is called an enhancer because it enhances the store, so we'll use that same terminology here. And here's the important piece that we were missing previously. So if enhancer is passed in, and it's a function, we're going to stop here, call the enhancer function. If we look up here, we can see that applyMiddleware is already called, and we're passing in logger. So that means that enhancer is the first function that is returned from the applyMiddleware function. So here we are saying call that first function that was returned, pass in the createStore function, and then from the function that is returned from that, pass in the reducer. I find this a little bit confusing. I'm not sure why it was done this way. Dan, who made Redux, is very smart, and I'm sure there is a very good reason. So let's head back and take a look. So the enhancer is this function here where we saw that createStore was passed in, and then immediately it called the second function here and passed in reducer, which in turn this function here now has access to the store because this one is calling back to the other function and calling the createStore function with only one parameter so it won't return early. So here we create the store, we modify it which we'll fill in here in just a second, and then we return the store. Now for the most complicated part of this function. If you've ever used a framework like Express, you're familiar with the concept of middleware, where you specify a bunch of functions in a row, and then express when a certain event happens, like a certain _____ route is being called, it will call one function after the other until the very end. And the last function in that chain is usually responsible for either rendering a page or setting JSON. In this case, we want to do something very similar. We want to string together these functions so the first middleware calls the second middleware, and so on, until there's no more middleware left, and then at the very end it calls the original dispatch method, which will update the store and notify any subscribers. So how do we do that? Here's what it looks like. If you haven't used reduce before, the reduce function basically takes an array and starts with the first element, and then loops through it, but keeps track of whatever you return. That's called the accumulator. So you could use reduce to add a bunch of numbers in an array and not have to keep track outside of this call, the running total. That's one of the things that reduce could be used for. In this case, we're using reduceRight, which starts from the end of the array and moves backwards. That's necessary because of the way we are chaining these functions together. So we're starting with the original dispatch, which here is called oldDispatch. And the first time this is run, oldDispatch will be assigned to the previous variable, and current will be the last middleware in the functions array, and here is an example here in the comments. So in this line we're essentially saying, call the logger middleware function, pass in the store, and then pass in oldDispatch. So let's go take a look at the logger function real quick. So we're calling logger, we're passing in the store, and then for next we are passing in the oldDispatch. On this line, when next is called, it'll call the oldDispatch, which updates the store, etc. Let's head back. So this is basically a fancy way of stringing together all of the middleware functions, and then at the very end calling the original dispatch function. So, to sum up, applyMiddleware takes control of the store, creates it, modifies the dispatch, and then returns the store with our modified dispatch, which includes the middleware chain. Now before I forget, we need to save off the original dispatch so we can add it at the very end of this middleware chain. So we'll say oldDispatch = store. dispatch. This allows us to save it when we clobber it here on here on this line. So now we've managed to rebuild all of the functionality that we've been using. This is a very simplified version of Redux. Things that I have not included are important performance optimizations, there are certain safety features that are included in Redux which are not here, so I would not recommend using this in production, but this is very useful for learning, and for illustrating what actually happens with your Redux internals. And let's see if this actually runs. I'm going to run this file using Node, but you could just as easily drop this into your console in Chrome or something. Let's run this side by side so we can compare. There we go. And right here. The first one here is state:before, store. getState, before dispatch. Then we call dispatch here, at which point the middleware calls will dispatch. After that, the actual original dispatch method is fired, which we happen to subscribe to, right here, so that's why we console. log 'STATE UPDATED'. Then, again, the logger calls 'state after dispatch' right here. Then down here we call state:after again. And then we unsubscribe from storeUpdates, so this callback function here will no longer be called. Then we dispatch one more time, which then only logs the messages from the logger middleware, great. I think picking a library or a framework and trying to rebuild certain parts is a great way to learn how it works under the hood, and to simplify some of the complicated bits. I've taken this code here and posted it on GitHub. You can see that on GitHub under jamischarles/tiny-redux, And there's some basic instructions for how to run it. It has our two examples, and then it has these three functions that we just made, fantastic. As I stated earlier, this isn't all of Redux, there are certain pieces that I've left out on purpose just so we can have a simpler example. But the amazing thing is that it works, and it runs, and this is great for our combined learning. Thank you.

Summary
In this module, we learned how Redux works under the hood by writing our own versions of the createStore, combineReducers, and applyMiddleware functions from scratch. The final code worked great, but it's mainly intended for learning purposes, and shouldn't be used in production. In the next module, we'll show how to use Redux across various frontend frameworks. I can't wait.

Redux Across Frameworks
Introduction
Hello. My name is Jamis Charles, and welcome to this module of Pluralsight's course, Redux Fundamentals. In this module, we'll show you how you can apply Redux to just about any frontend framework. First, we'll show a tic-tac-toe app written in Vue. Then we'll convert it to use Redux. Finally, we'll do the same for an Angular app. The goal of this module is primarily to show how we go about adding Redux, or any state management tool for that matter, to an app that uses local state. Let's get to it.

Vue.js
In this section, we'll show a very simple tic-tac-toe game built with the Vue. js framework. Let's start the app and then head to the browser. And we can now head to the browser at localhost8080. This is a very basic tic tac toe game where you can mark the fields, and then by pressing the Clear button here you can clear the field, pretty simple. This is all built using the Vue. js framework. Let's head to that website. The website for Vue. js lives at vuejs. org. when you go to Get Started, and then Installation, there is a CLI option down here that you can use to automatically set up your project for you. These are the steps that I took. Let's head back to the command line and take a look. Let's take a look at the folder structure here. Here's a bunch of folders that the CLI generates for us. The important files, though, are in the src folder. We have an App. vue, a main. js, and a GameCanvas. vue. These are the only files that are really modified. Let's open these up in our editor. Let's start with main. js. This is the root of our Vue application, and very similar to how we do this in React, we create a new Vue application and specify where in the DOM it gets injected, as well as the template and the components. Next, let's head over to App. vue. App. vue is the root component here. You can see that similar to React there is this idea of co-locating the template, the JS logic, and the CSS styles, which I really like. It helps keep things nice and contained. So here at the top we have the template, which shows a div with an ID of app, the h1, and then where we inject the GameCanvas component. And then here on line 9 we can see that we are importing GameCanvas from the components folder. Then we're exporting the app component, which is imported into the main. js file we were just looking at. Then here at the bottom we se some styles, fairly straightforward. Let's head to the GameCanvas component. Let's head down here to the logic first. So here we are exporting the GameCanvas component, and we are specifying that the state which is shown here by whatever the data method returns. The default state consists of message, fields, player1, player2, and currentPlayer properties. And we have some methods here that we can call from our template. We have handlePlay and handleRestart. And then we have an uppercase filter, which simply uppercases whatever value is passed in. Let's take another look at the default state here. Fields is an array that by default has a length of 9, and is populated with false. Player1 is marked as x, player2 is marked as o, and we start as the currentPlayer being player1. And if we head up to our template, we can see how we are rendering these values. At the top, we see a clear button, which is bound via the click event to the handleRestart method, and then we see a fieldContainer that has several template tags. A template tag in Vue is simply used to control the flow. You can use that for looping or for conditionals, and these do not now show up in the DOM. So here we take the fields value, which, as we've seen below, is an array, and then we loop through that, and each item in the array gets assigned to the field variable with index being assigned to the current index. On the next line down, if field is false, which it is by default, we render this div here, and when we click it the handlePlay is executed. If it is not false, if that field has already been played, we go ahead and do the field value, which is uppercased. Then here at the very bottom we can see some additional CSS, great. Let's take a quick look at the methods. We've got the handlePlay method, which takes an argument of index and then takes the fields and clones it so it's immutable. Then we figure out, based on the currentPlayer, whether an x or an o should be played, then we update that index in the new array that we've cloned, and then we replace the current fields array with the new one that we've just cloned. This helps keep it immutable, which is important in Vue just like it is in Redux, and to a certain extent in React. Then we update the new currentPlayer. If we're currently player1, toggle to player2, and vice-versa. The handleRestart method simply replaces the field array completely with a brand-new array of length 9 which is filled with false values. In the next section, we'll add Redux to this example.

Vue.js with Redux
In this section, we'll be adding Redux to the prior example. I know that we'll be using Redux and Redux logger during this section, so let's install that now. And we'll use the save-dev flag so it'll be saved to our package. json file, great. Let's head to our code now. The GameCanvas component still looks the same, but I've added a new file, reduxState. js, which contains all of our Redux state. Let's head there now. This file contains all of our Redux logic. I've used as few abstractions as possible just to keep it simple. We're pulling in the createStore and applyMiddleware methods, and we're using the createLogger middleware. We have the same default state that we have with the plain Vue version, then we have a game reducer that listens for the RESET_FIELDS action, which resets the fields property. Then at the very bottom you can see that we are creating the store and returning the store. So all of the state update logic here is the same as it currently exists in Vue, with the main difference being that we are listening for Redux actions instead. This is a fairly simple implementation, which should work great for this example. Let's head back to our GameCanvas component. The first question when trying to add Redux to an app that doesn't have it yet is always, where are the natural seams, and where can I insert the various Redux pieces? For Redux, we mainly have to think of two things, how to get the data out of Redux, then how to set it. First, we have to think of how to get the data out of Redux when the component first loads, so we can populate the component. Then, when we make UI updates we have to think of how to set the state, and update the Redux state. And then, lastly, we have to think of how to listen to those Redux updates and then update our Vue component in turn. So those three steps. Initial state when the component loads, then how to make updates to the store based on actions in this component, based on actions in the component UI, and then we need to reflect those state changes back to the UI. Let's start with something simple. Let's start by dispatching actions in each of these methods. In order to dispatch, we need to access to the Redux Store, so let's import that. This should give us access to the store, which we can then use to call store. dispatch. So after handlePlay is called, we will dispatch the MARK_FIELD action. That expects a payload of, let's check, it looks like the only thing it relies on is the current index assigned to the fieldIndex property, fieldIndex equal index. Okay, now down her in the handleRestart we'll dispatch the RESET_FIELDS action, and that one doesn't expect any sort of payload. Let's start up the app and try this out in the browser. Npm start does the trick, and now to the browser. If everything worked properly, then this should all still work, and redux-logger should be logging the state changes to the console. Let's open up the console and see. There we go, MARK_FIELD, and RESET_FIELDS, Create. Let's inspect one of these. You can see that the previous state contains a fields array with all false except for the first one. Then after the action fires, it's now updated the second value as well, great, so this seems to be working fine. Let's close this. So we know now that the dispatches are working, that the state is being updated properly in Redux, so the setting part is working fine, but we are not getting any of the state out of Redux. Let's head over and do that now. So we know that we can call store. getState to access the Redux state. As we saw in one of our earlier modules, we need to subscribe to the Redux store. The question is, should we do that here at this level, or try and do it at a higher level at one of the root components, like we did in our React example. In this case, I'm going to head to the main. js file and implement that there. We are now in the main. js file, and this seems like a good place to subscribe to Redux store updates, and we can pass in the Redux data down to the components. Let's start by importing the store. And then we can immediately get the reduxState by calling store. getState. So far, so good. Then how do we get this into Vue? We can pass a data property here, and then assign it. This property now exists for this Vue app, and we can access it from the child components. So this should take care of the initial loading use case, but what about updates? For updates, we need a subscription, so let's add that now. And when there are updates, we'll update the reduxState. So we now have the data property here. Let's head over to the template for the GameCanvas component and see how we can access this data. Instead of using fields, we can now use this. root. data. fields, and this will access the fields property from the Redux Store. If we take a look at the template here, we can see that we're not really accessing any other values from the Redux Store. So let's come down here and remove the local state. Msg seems to be a remnant that's not being used anywhere, so we can pull that out. And all this other state now lives in Redux, so we can remove all of this. And in the handlePlay method, all of these state changes, again, live in Redux, so let's rip all this out so only the dispatch remains, same thing for the handleRestart. Then we still need our filter here, because we're using that in the template above, looking good so far. So we now know that the only state property we actually render is the fields property. Let's head to the browser and try this out. Things seem to load just fine, but when I start interacting with the UI, we see that the actions are being dispatched, but the UI isn't updating. Let's inspect these logs. It looks like Redux is being updated fine, but here's something interesting. The previous state shows as an Observer object, so clearly we messed something up. Let's head back to our main. js file and see what's wrong. Here's what the problem is, Redux and Vue have fundamental differences in how they handle state updates. In Redux, every time the state is updated, we wipe out all the state and return a brand-new copy of the entire state. In Vue, the parent state object stays the same, and Vue then listens to see if any of the child properties of that object change. That's how Vue listens for state updates. If you wipe out the parent object, then you're wiping out all of those listeners. So we need to update this code so that the parent object that we pass to the data property here doesn't change. Let's do that now. So instead of storing the state here, we'll just make reduxState a new object. And then we'll specifically bind what properties we care about. As we looked at the template, we realized that the only property we really care about is fields, so when there is an update we'll say reduxState. fields = state. fields. So instead of replacing the entire reduxState object, we are simply mutating the child and replacing that child with the new fields array. This allows the reduxState object to live on, and then Vue can listen for any child mutations. We can't forget to add the default state though, so let's do that, great. So when it first loads, we have an object called reduxState, which has the fields property, which it gets from the Redux Store. And this redux. State object is assigned to the data property in the Vue app at the root level, which allows Vue to listen to any changes to the child properties of the reduxState object. So now anytime we call dispatch, the callback function defined here and subscribe gets called, which we can then fetch the new state, which will then mutate and replace the fields value on the reduxState object, which will then signal to Vue that something has changed, which will cause Vue to re-render the components. Let's see if this worked. Here we go, fantastic. This fields array, you can see, is still observable, which actually shows us that Vue is observing this array right here. Great, it seems to work just fine, fantastic. Let's head back to our code so I can address one more thing. There's several important things that I'd like to point out. This is a simple example to illustrate how you can use Redux in many different use cases, and how you could integrate it with pretty much any framework. This is an exercise in finding the natural seams, and to show you how you can apply Redux to other code bases, whether it's vanilla JavaScript, React, Angular, Vue, it doesn't really matter. However, with most of these frameworks there's a natural evolution that happens where people most likely start using Redux manually like this, and then they add official bindings similar to React Redux where they say this switch the official way for you to plug in, and then I think the next evolution after that is for somebody to come and say, okay, we really like Redux, but what would be the Vue way or the Angular way of using Redux. Let's learn from this, and let's create something that leverages all of the goodness that we already have in this framework, uses all of the conventions, and is tailor-made, specifically for this framework. In the case of Vue, that's Vuex. Let's head to that website now. If we head over here under What is Vuex, it's explained that Vuex is a state management pattern and library. If you scroll down here, we can see some similarities, and here it clearly states that it's very heavily inspired by Flux, Redux, and Elm. We have actions, we have state, very similar. So if you're planning on using Vue, my suggestion would be to use Vuex. Now at a small scale, it doesn't really matter, you can do whatever you want. If you plan on building something large for the rest of your team, my suggestion to use Vuex with Vue, because that is the officially supported and blessed solution, great. In the next section, we'll be looking at tic-tac-toe written in Angular.

Angular.js
In this section, we'll take a look at our tic-tac-toe app written in Angular. Let's start up the app and head to the browser. Now let's head to the browser and take a look. Great, everything seems to work just fine. Let's head to the Angular docs and take a look. Angular is another popular web framework. If we head over here to Get Started, we see a QuickStart tutorial where it instructs us to install the CLI, and then we can use that to create a new app. That's what I did to set up the folder structure. Let's head back to the terminal to take a look. The generated folder structure is pretty similar to what we had with Vue. The CLI generated a bunch of test files for me, which I removed. Angular usually comes with a bunch more files. The important ones are under src/app. Let's open up the relevant files in the editor now. Let's start with the styles. css file. I've added the exact same styles as I had in Vue to this file. Next, let's head to app. module. ts. As you can see, all of the file extensions end in ts. That's because Angular uses TypeScript. This file here is similar to our main. js file in Vue, and defines the structure for the application. I haven't changed anything here. Let's head over to our template. One thing you'll notice is that Angular, by default, splits out things more, whereas Vue have a template, the logic, and the css in the same file, in Angular it's split apart a little bit more. We have very similar logic here. We have the Clear button, which is bound via the click event to the handleRestart method. Then we have some template logic that loops over the fields array, assigns the index to the i variable, and assigns the value of fields to field. and then we have some if conditions, if field is false render this, if it is not false, render the value of field, very similar to what we had in Vue. Now let's head over to our component logic. Here we specify the selector that is used for this component, then the template file, as well as the style file. Now here is the part that we really care about. We export the AppComponent class, where we specify the default state, as well as methods that can handle our events. We have handlePlay again, with the exact same logic as we did previously, and handleRestart. Great, the important thing to note here is that when the state changes, Angular will automatically re-render the component. So when the handlePlay method is called, we update this. fields with our new fields array, which then causes Angular to re-render the component, fantastic. In the next section, we'll be adding Redux to this example.

Angular.js with Redux
In this section, we'll be adding Redux to our Angular example. Since we know we'll be using Redux and redux-logger, it makes sense to install those dependencies now. Now, let's open up the important files in our editor. Our app. component. ts file hasn't changed at all, but we've now added a new reduxState. ts file. This is the exact same file that we used in Vue, it's just normal JavaScript, but I had to change the extension to ts, for TypeScript, in order to use it in this project. So just as before, we see our Redux default state, we see our Redux actions, and this returns the story that's created with the logger middleware applied, great. Let's head back to our app. component file. And, again, the first question is, where are these natural seams where we can start introducing some Redux. Just like before, I'm going to dispatch from these handlers. Let's start by bringing in the Redux Store. Now we can call store. dispatch. That was a type of MARK_FIELD, and then the payload is an object with a property of fieldIndex, where we pass the index of the field that has just been played. And then down here we dispatch in handleRestart, and pass the RESET_FIELDS action, great. Let's start up the app, and then head to the browser. Npm start does it, there we go. Let's head to the browser, there we go. As before, dispatch is updating the Redux Store, but the Angular component is not listening to the Redux changes. Let's head back to the code and fix that now. Let's start by trimming down the handlers. All this logic, as with Vue, is going to be handled in Redux. Same with the restart, great. Now what about the default state. Let's pull the default state from Redux, and the template really only needs access to fields, so we can remove these other properties. And then the default state of fields can come from Redux. So far, so good. This should work for first load, but how do we handle the Redux updates. We'll want to subscribe again, but where do we subscribe? Angular, like React has a concept of Lifecycle Hooks. Let's head to the docs and see what we can find. Up here in the Search, we can search for Lifecycle Hooks, here we go. Great, so there is an ngOnInit hook which is only called once, so that would be a good place for the subscription. In general, we want to be careful not to add more than one event listener, and then we want to make sure to clean it up when we're done. So what's the opposite of onInit, ngOnDestroy, great. So we'll use the ngOnInit and ngOnDestroy lifecycle hooks. Let's head back and do that now. So ngOnInit, and then ngOnDestroy. Now here we can add our subscription, and then when the store is updated we want to reassign the fields. So every time the Redux Store is updated, which really is any time dispatch gets called, this callback function will be called, and this. fields, for the component, will be replaced with the fields property from the Redux Store, great. And then we need to unsubscribe when this component is destroyed. In order to do that, we need reference to the unsubscribe function that's returned from store. describe. The easiest way, probably, is to make that a class variable here. So let's do that now. Now we can save that function as this. unsubRedux. And then down here we can call unsubRedux. Why don't we test that this works by calling it in the onInit function. Let's head to the browser and see if that worked. If that worked as expected, then clicking these fields should update the Redux Store but should not update the UI. There we go, great. So the unsubscription worked, let's remove that. Let's head back. We're seeing an error here, Cannot set property 'fields' of undefined. Let's head back and see. This is a pretty common error. I used the old-school function, which means that the this keyword is not bound within that. The simplest fix is to just use an error function here, so let's do that. The error syntax will automatically bind the this keyword, so let's try that, and there we go, fantastic. So now when we interact with this, Redux is being updated via dispatch, and the Angular component pulls in the state from Redux, and then renders that into the component. Let's head back to the code for one final note. As with Vue, this was a great example to illustrate how we can start using Redux and integrating it in a variety of frameworks. And, again, on a small app this works perfectly fine. This isn't the cleanest code, this isn't the blessed way, but if it's a tiny app, and it's just you, you're probably fine. If you want to do it the way that the Angular community recommends, you've got two options. First, there's the Angular bindings for Redux, which is the Angular version of React Redux, and in the ReadMe down here you'll find a lot of resources. And then, similar to Vuex for Vue, there is a library called ngrx. That's kind of the blessed Angular version of Redux. If we head down here to the Readme, we can see that one of the packages is ngrx/store, which is the RxJS powered state management for Angular applications inspired by Redux. Let's take a look at this. Here's instructions for how to install it, and this looks very similar to Redux. It uses the reducer, but it is, in fact, not Redux. So if you're using Angular as part of your team, and you're interested in using Redux, my suggestion would be to stick with what the community is doing. That will save you a lot of headache. But, as always, I encourage you to experiment, I encourage you to try things out. I have had the most success experimenting on small side projects by myself, and then I bring those lessons back to the larger team to avoid pain and _____ for the rest of the team. That's it.

Summary
In this module, we saw how Redux could be added to a variety of web frameworks, specifically Vue. js and Angular. In both of these cases, we learned how to implement Redux, but that it may sometimes make more sense to use a solution like Vuex or ngrx. This concludes this course. I hope you enjoyed it. I certainly did.
