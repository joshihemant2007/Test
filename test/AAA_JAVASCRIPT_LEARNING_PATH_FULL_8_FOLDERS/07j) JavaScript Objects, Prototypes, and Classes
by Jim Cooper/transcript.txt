Objects, prototypes, and classes are extensively used in JavaScript programming. Understanding each of them beyond a surface level will help you more deeply understand the foundations of JavaScript. In this course, JavaScript Objects, Prototypes, and Classes, you will learn the foundations of creating and working with objects including a deeper understanding of how JavaScript works with regards to objects and inheritance. First, you will see different ways to create objects and properties and how to work with them, including modifying property descriptors, using constructor functions, working with getters and setters, and more. Next, you will discover what prototypes are, how prototypes and prototypal inheritance work in JavaScript, and some of the hidden complexities of prototypes. Finally, you will explore how to create objects and handle inheritance using classes. When youâ€™re finished with this course, you will have the skills and knowledge of JavaScript Objects, Prototypes and Classes needed to create powerful and well structured applications that take advantage of the dynamic power of JavaScript.

Course Overview
Course Overview
Hi everyone. This is Jim Cooper, and welcome to my course on JavaScript Objects, Prototypes, and Classes. I've been working as a software developer for more than 25 years, and I've been a serious JavaScript developer for the past 7 years, and now I'm excited to bring you this JavaScript course on Objects, Prototypes, and Classes. In this course, you'll learn not just about the different ways to create objects, but the deep behind-the-scene things that happen when creating and working with objects and prototypes. Consider prototypes, for example, they're a little mind bending and can be challenging to figure out, but the funny thing is, once you really get prototypes, you'll realize that they're not really that complex. I promise you, you'll understand them deeply when we're done. Some major topics that we'll cover include creating objects with object literals, constructor functions, and classes, working with and configuring object properties, including property getters and setters, a deep behind-the-scenes look into what prototypes really are and how they're used for inheritance, and how to do all of this with JavaScript classes. We'll even take a look at a few built-in JavaScript objects while we're at it. By the end of this course, you'll know everything you need to know about working with objects in JavaScript. Before beginning the course, you should be familiar with basic programming concepts, basic JavaScript syntax, and working with variables. All of this is foundational to working with JavaScript. So let's jump in, and you'll soon start wowing your friends and colleagues with the depth of your knowledge about JavaScript objects, prototypes, and classes.

Creating JavaScript Objects
Introduction
Hi. This is Jim Cooper, and welcome to this module on Creating and Using JavaScript Objects. As part of this course, we'll explore three different ways to create objects in JavaScript, object literals, constructor functions, and classes. In this module, we'll focus on the first two, object literals and constructor functions. We'll also explore some important concepts related to working with objects like object equality, merging object properties, and immutability, plus a few other handy tricks and shortcuts in working with objects. So let's jump in.

Getting Started
To help get us started quickly, I've created this small GitHub repo, and I'm just going to go ahead and clone it. If you're not familiar with Git, you can just use this Download ZIP and download it locally, that's fine too. But I've got Git all set up, so I'm going to go ahead and clone it. And now that that's cloned, I'm going to go ahead and open it up in Visual Studio Code. And now I'm going to right-click on this demo.html file, and click Reveal in Explorer. And then I'm just going to double-click that to open it up. Cool, so we have this site that says Hello World, and I'll resize that off camera. Okay, so now we have our web page over here, and we just have it kind of small so we can look at it on the side, and it's displaying Hello World. So where is that Hello World coming from? Well, this is a very simple project. You can see there are just a few files here, and this first one is demo.html file, and it's really simple, it's just loading these two script files here, and it has this h1 tag where we'll display our output. And you don't need to worry too much about this file, we're not really going to be spending time in here, this is just a little helper file so we can display the results of our code. So let's switch over to our demo.js file. This is where we're going to be creating all of our code, and you can see here this is where we're displaying Hello World. So as we work with our demo code in this course, we'll write all of our JavaScript in this file. And notice that I've got use strict up here at the top. I recommend that in all of your JavaScript files, so that it enforces cleaner JavaScript. And then we have this function with these corresponding brackets down here. Don't worry too much about this, this is called a self-executing function, and it's just helping behind the scenes with the way our demo code is set up. So we'll be working in this file, and whenever we want to display the results of our work, we'll call this display function. Notice if I change this and save, that it changes the output over here in the HTML. And this display function is defined over here in utils.js. You can see it right here. I don't want you to worry too much about what's happening in here, this is all just part of wiring it up, so it automatically displays our changes in our browser. And you can see down here at the bottom of the file that we have this reload.js function. And you can see down here that we're calling that every 1 second. So essentially every 1 second, this file is going to reload our demo.js file, so that as we make changes, it will reload it and automatically show up in the HTML in our browser. Alright, so now that you understand the environment that we're working in, let's get coding.

Using Object Literals to Create JavaScript Objects
Let's start by taking a look at one of the simplest and most common ways to create objects in JavaScript, the object literal. Actually, before we do that, let's just talk briefly about objects. Objects are basically just more complex variable types. So for example, we could have a couple of variables like this, and imagine if every time you wanted to describe a person, first name, last name, age, eye color, hair color, you had to declare individual variables and pass each one of those variables around in your program. An object is essentially a way of just grouping information like this together into a single variable. So instead of multiple variables, I can have a person object, and I can just pass that person object around in my code just like I would any other variable. But in doing so, I'd be passing all this information around. Of course objects can also be used to encapsulate not just information, but functionality related to that object using methods. We'll get to that in a bit. For now, let's see how to turn this data into an object. The easiest way to do that in JavaScript is with an object iteral. So first I'm going to create a variable called person, and then I'm going to set that variable equal to a new object, and this is where the object literal comes in. To create an object with an object literal, you simply define the properties and their values inside braces like this. So here I've created a new object named person with two properties, firstName and lastName. And notice if I call our display function and print out person.Name, if I save that, it displays Jim. Well that was easy, now I have this person object with firstName and lastName properties on it. And I can pass this person object around in my code, for example, say I had a registerUser function, and I want to pass in this person into that function, I could do that like this. I just call registerUser, and pass in person as a parameter just like I would any other variable. So that's the easiest way to create objects in JavaScript using an object literal like this. Next, let's talk about the dynamic nature of objects in JavaScript.

The Dynamic Nature of JavaScript
If you come from a background in statically-typed languages, you might be wondering what exactly we just did here. What is person? We haven't even defined a class. Well that's one of the interesting things about working in a dynamically-typed language like JavaScript. You don't need all the ceremony of creating types ahead of time so that you can use them in your code. Of course the downside is that you don't get static type checking, but in JavaScript, when you want an object, you just create it. Of course there are times when you want something that behaves more like classes in a statically-typed language, and you can achieve a lot of that same behavior in JavaScript. We'll get to that shortly, but first let's explore a little bit about objects and the dynamic nature of JavaScript. One of the cool things about dynamic languages like JavaScript is that you can completely change the shapes of objects after they're created. Let's say we wanted to add an age property to our person. No need to go back and edit our object literal, we can just add it like this. And now if I come down here and print that, you can see my person has an age, yeah, 29, that's totally my age. But notice in our object literal there's no age property, we added person.age after we created the object. That's really powerful and maybe a little scary sometimes if you're coming from a statically-typed language. And I can hear what you might be saying in the back of your mind or perhaps yelling at the screen, how can you write an entire system like that? Sometimes I need a person to look like a person, and I need to be able to rely on the fact that a person will always have a certain shape. Well, that's very true, and for the most part we can do that with JavaScript. We'll get into that in a second, but before we do, let's take a quick look at functions and how you might add a function to an object.

Adding Functions to Objects
Adding functions to an object is almost as easy as adding properties, you just do it. Let's add a way to determine if a person is an adult. We'll add an isAdult function to our person object like this. So here we've added an isAdult property essentially to a person, but that property is not a value, it's a function. So we don't really call these properties, we call them methods. And then we can call methods on an object like this. And if I save that, you can see this returns true because the isAdult function returns true if the person's age is greater than or equal to 18. The keyword this that is used right here is a way to reference other properties on the object from within the object. So because this isAdult function is part of the person object, when we refer to this.age, it's going to look on the person object for the age property. And now notice if I change the age of my person to 17, then the isAdult function returns false. And of course we don't have to add the isAdult function to the person after creating the object, it's more typical that you add it as part of the object literal like this. So you just start with the name of the function, isAdult, and then a colon and the keyword function, followed by the function body. So we can delete this down here. And while we're at it, let's go ahead and move the age property up here, and we can delete this down here. And if I change age up here again to 18 and save it, then you can see our isAdult function returns true again. Next, let's take a look at another interesting way to create object literals.

Object Literal Property Shorthand
Sometimes you'll want to create an object using variables for the property values. To demonstrate that, let's create a registerUser function like this. And then let's just say inside this function we want to create a new person object using those firstName and lastName parameters. What we've seen so far with object literals is just hardcoding the property values like this, so we're just creating a firstName and lastName property, and we're setting those to the strings Jim Cooper. Well in this case, we want to create a user not with the name Jim Cooper, but with the firstName and lastName that is being passed in to this function here with these parameters. Well, that's easy, I can just do that like this. So instead of this string here, I'm just going to use fName, and instead of this string, I'll use lName. So you can set object literal properties using variables. Now down here, if I were to call this registerUser function like this, so I'm going to pass Jim Cooper into that function, and then inside this function, let's just display that user. Okay, now if I save there, there, you can see that I'm printing out the person object, and it has a firstName set to Jim and the lastName set to Cooper, but we're passing that in here and setting those with variables. So I could change this to Kris, for example. And there we go, our person is now Kris Cooper. But let's explore one more thing, what if these were actually called firstName and lastName? Then we could use those here like this, and that works too, but this looks a little bit redundant here where we're setting the firstName property to firstName and the lastName property to lastName. Well, it turns out this sort of thing is pretty common, and so in JavaScript there's a shorthand syntax for this. So I can actually get rid of this duplication like this, and if I save that, you can see that it's still working. And if I change this back to Jim, now it prints out Jim Cooper. So that still works, but this syntax is interesting. If you didn't know about the shorthand syntax, you might look at this and be a little bit confused, but all this is saying is create a person object, and set the firstName property to a variable that is also named firstName. That's the property shorthand syntax. Now let's take a look at an object literal shorthand for methods.

Object Literal Method Declaration Shorthand
You may remember this isAdult function from earlier. It's a method on this person object, but there's actually a more simple way to declare this function using object literal method declaration shorthand. I can basically just get rid of this colon and the word function like this. And you can see that still works. If we change the age of this person to 17, then it returns false, and this functions exactly the same as the old declaration did. But it's important to note that this syntax is specific to object literals. You can't just create functions like this outside of an object. You can use this type of syntax in classes, however, and we'll get to that later. For now, let's take a look at some functions in the built-in native JavaScript object.

Inspecting Object Properties with Object.keys() and for...in
JavaScript provides an object Object, that is an object whose name is Object with a capital O. There are several functions on Object that we can use for inspecting, manipulating, and doing other things with objects. Let's take a look at the Object.keys function. It's not too common, but every now and then you'll want to discover all of the properties and methods on an object. Let's try it out. The Object.keys function takes an existing object like person as a parameter, and it will return an array that lists all of the names of each of that object properties and methods. So down here, instead of displaying this, we'll display Object.keys, and we'll pass in the person object. And if I save that, you can see it printed out an array here. And if we make this window a little bit bigger, you can see it printed out firstName, lastName, age, and isAdult. So it's displaying all the property names or keys of the object, not the property values themselves. Sometimes you use that when you want to inspect an object and do something with its properties. In fact, notice if I display person, that it's displaying all of person's properties and their values. So I could've used the Object.keys function when I built this display function, and that would've worked just fine, but I actually used a little different syntax that I like a little bit better, and that is the for in syntax. So that is a for loop that looks like this. So this is just a for loop, and notice that I passed in the person object here. So this is going to loop over all of the properties and methods in person, and each time it will set this property name variable to the name of each property, which means if I come inside this loop and display propertyName, then when I save this file, notice that all of the property names are listed here. And of course methods like isAdult are properties also. So Object.keys and for in basically accomplish the same thing, they give you access to each of the property and method names on an object.

Object Equality and the Object.is() Function
Alright, we've been talking about objects for a little bit, let's go on a brief tangent to talk for a minute about equality. And then we'll see how the Object.is function is used for equality. Equality is, well, interesting in JavaScript. There are three different equality operators we can use, double equals, triple equals, and Object.is. These can all be used for equality, but they behave differently. The first one, double equals, should be pretty much always avoided. It's really only useful in a few rare cases, more on that in a moment. The triple equals operator is much more commonly used and should be used in almost all cases. And then the Object.is operator is less commonly used, it is almost identical to the triple equals operator with a couple of small mathematical differences, which we'll get into next. If you're not sure what the syntax of the Object.is operator is, it would look something like this. So you pass two objects into it, and it will return true if it determines that they are equal. Okay, let's dig into each of these a little bit more. Taking a closer look at the double equals comparison operator, the big reason why we should avoid using it is because it is not type safe. For example, when using this operator, the string value 42 is equal to the numeric value 42. This can cause all sorts of unintended issues, so it's best to avoid this operator. It could, however, sometimes be useful if you're receiving input as a string and intentionally wanting to know if that is the string equivalent of a numeric value, but that's not a very common need at all. Here are some of the other examples where the double equals operator is weird. The number 0 is equal to the value false, null is equal to undefined, an empty string is equal to 0, and an array of numbers is equal to a comma-separated string of the same numbers. This is all a little weird, so unless you have a specific reason to do this, it's best to avoid this operator. Okay, now the other operators. Triple equals and Object.is work almost identically with a couple of small differences, but both of them are much better than double equals. First of all, both of these operators are type safe, so you can feel free to use either of them. The triple equals operator, however, is much more convenient and concise, whereas the Object.is operator is more verbose. So triple equals is much more commonly used. You should probably plan on using triple equals for equality checks unless you have some very specific needs for the way Object.is works. So how is Object.is different? Well first of all, with triple equals, two not-a-number values are not equivalent. If you're not familiar with not a number, or NaN, it is the result of a non-numeric mathematical equation. So for example, if you tried to divide the number 1 by the letter A, you would get not a number. And if you were to compare two not-a-number values, the result is going to be false with triple equals; however, if you compared them with Object.is, it would indicate that they are equal. That is the first difference between these two operators. The second and only other difference between these two is that with triple equals, +0 is equal to -0, + and -O, are those even a thing? Well yes, in mathematics, there is such a thing as -0, +0 is what we usually just call 0, so it is possible to have a -0 number, and with triple equals, if you compared +0 with -0, they would be equal, but with Object.is, +0 does not equal -0. Other than these two differences, these two operators are identical. So to just wrap up on object equality, let's talk about what it really means for two objects to be equal. If you consider this code, when we create this new person1 variable, that gets stored in memory in a specific memory address like this one here. If we then create another person object, person2, that gets stored in another memory address like this. And if we compare these using double equals, triple equals, or Object.is, the result will be the same, they will all return false. That's because what is actually being compared is not the values contained within the object, but rather the actual memory address of these objects. So that's how equality works with objects, and it's important to note that this is only true for objects, not for primitive types like strings, numbers, and booleans, for example. So consider these two separate string variables that have the same value. These are of course stored in two different places in memory, but unlike objects, all of the equality operators will consider these two variables equal. So for primitive types like strings, JavaScript compares their values, but with objects, it compares their memory addresses. Alright, that was a quick tangent on equality, and we saw that this is how you use the Object.is function for equality comparisons.

Object Assign and Immutability
Sometimes in JavaScript, you'll want to create a new object from an existing one, or merge the properties of two objects together. The Object.assign method allows you to copy or merge the properties from one object to another object. To demonstrate that, let's create a new object, and now let's use Object.assign to copy the properties from person1 to person2. So Object.assign takes multiple properties. The first one is the object that is going to be modified or have properties copied into it. So if we display person2, you can see that person2 now contains all of the properties that person1 had. It even copied the isAdult method. And now if we apply what we learned about equality, and compare person1 to person2, and save that, you can see that returns false because even though the properties are the same between the two objects, they are not the same object in memory. Let's take a look at another example now that might better demonstrate how you might use Object.assign. So instead of this person2 object, let's create a healthStats object like this. So imagine you're building a weight loss app, and in one section of the app, you gather the person's basic info as shown in the person1 object, and then you gather their height and weight in a separate place as shown in this healthStats object, and then you want to merge them together. Object.assign is perfect for that. We can just do that like this. So I'm going to take the healthStats properties and merge them onto the person1 object. So if we take a look at that, there we go, so we can see that we have firstName, lastName, age, and isAdult from the person object, and height and weight from the healthStats object. But what if we didn't want to mess with that person1 object? Sometimes you don't want to change an object like that. For example, imagine this Object.assign function was inside another function like this. So this mergeHealthStats function takes in person and healthStats parameters, and then merges them together and returns them. So if I come down here, we'll call that function, and then I'll assign the value returned to mergedPerson. So if we display mergedPerson now, there we go, you can see it's all merged together as we would expect. But we have an unintended side effect here. So notice if I display person1, which is the object that we passed into the function, that person1 also got mutated. That's because when we passed in person1 to this function, we then called Object.assign and passed that person in as the first parameter. Remember, Object.assign merges the properties into that first object, so it mutates it, and then it also returns the mutated object, which is why I could return the result of that function call here. So our person object got mutated, but good immutability practice says that a function really shouldn't ever mutate the objects that are passed into it. So what can we do to avoid mutating that object? Well, Object.assign actually takes in unlimited parameters, and it will just merge all of the properties from the objects on the right into the object on the left. So we can do something like this, so here I've created a new empty object literal, and I'm passing that in as the first parameter. And then the properties from person and healthStats will both get merged onto that new object. So if I save that, there, you can see when we displayed the mergedPerson, it output the merged object, but person1, when we displayed it, did not get mutated. This is how you'll often see the Object.assign method used, with an empty object as the first parameter to avoid mutating the other objects. Object.assign is really handy for working with objects in this way.

Using Constructor Functions to Create Objects
So we've seen how JavaScript allows you a lot of freedom to work dynamically with objects. Not only can we change property values, but we can even change the shape of objects after they're created by adding properties at any time. But sometimes you want something a little less dynamic, for example, sometimes you want a person object to look and behave the same all throughout your application. Let's say I wanted to work with multiple objects here, so let's change this person variable to Jim, and we'll change that here too. And now let's create another person. So we'll create a sofia object and set that to a new object with firstName Sofia, lastName Cooper, and age 17. And then the isAdult function is going to be identical to the one in the Jim object. And let's go ahead and print the age of Sofia. So we've successfully created two person objects, but it's a lot of extra code, and we have a problem. What if we decided that we wanted to update this for a country where the adult age is 21? Well, we could just change this to be 21 here. But now we need to change this everywhere in our code base where we created a person object, so I'm going to have to change this up here also. Right here that's not that big of a deal, but imagine this was a really large application with thousands of files in it, and you had to change this everywhere wherever you created a person. Well, that's where object-oriented programming and constructor functions come in. So what if we actually wanted to create something that allows us to create multiple instances of person objects all with the same object structure, like a class in a statically-typed language. We can do that in two ways with JavaScript, with either constructor functions or classes. A constructor function looks sort of like this. So notice that this is just a simple function, and there's nothing special about this function. Also, notice that it's creating properties on the object represented by this, and then it sets the value of those properties. So more on that in a second. With this constructor function, I can now create a new person like this. Now let's take a look at that person. So we'll just display person, okay, so you can see that our lowercase person variable is now a pointer to a person object, and that person is named Jim Cooper. I realize this isn't too helpful yet, we don't want all people to be named Jim Cooper. But first let's explore exactly how this worked. What exactly is happening here? To really understand what's going on, it's important that you understand what the keywords this and new are in JavaScript. The this keyword always refers to an object, and which object it refers to depends on the context of the code that you're executing at the time. So when we executed this person function, what was this referring to? Well, it was referring to a new empty object, and that's what our new keyword does for us. It creates a new empty JavaScript object and sets the context of this to that new object. And then it calls the constructor function that follows. That's really all there is to constructor functions and the new keyword. New creates a new object, sets the context of the this keyword to that new object, and then the constructor function is called, and in this case, that constructor function sets firstName and the lastName on that new object to Jim Cooper. But let's fix this, we don't want all people to be named Jim Cooper, and remember, constructor functions are just simple functions, so we can pass in parameters here like this. And then inside the function, we'll just set this.firstName to that firstName parameter, and same for lastName. So now if we save this, well, then you see we have a problem. So we have a new person object, but firstName and lastName are now undefined. Well, that's just because we haven't passed in anything here for the firstName and lastName parameters. So let's just pass in Jim and Cooper. Now if I save that, there we go, now our new person object is displaying Jim Cooper for the first and lastNames. And now we have a function that we can use to create new person objects. These functions are commonly called constructor functions, but you can see there really is nothing special about them, they're just functions, but we use the keyword this inside them and call them with the new keyword. So now let's just add an age property here, and we will add the age and isAdult functions to this object. [00:29: 07.655 ] Okay, and then let's pass in an age down here. Alright, and now that we have a function for creating multiple person objects, let's delete these up here, so we don't need those anymore, and we'll call this person Jim, and then let's create a Sofia person. And then let's go ahead and display Jim and Sofia. Cool, so we have two different objects, but we only had to define what the object looks like once, and if I call isAdult on each of these, then you can see that's working, and the logic for isAdult is only defined once. So we're getting some good object-oriented behavior here, and that's really all there is to using constructor functions. Later on in this course, we'll take a look at doing the same thing with classes. For now, let's just take a brief look at the Object.create method.

Using Object.create()
So far, we've looked at two different ways of creating objects, object literals and constructor functions. It's worth noting that behind the scenes, these are both essentially using Object.create to actually create the objects, and we can use Object.create ourselves if we really want to, but you'll see why most people don't really want to. So consider this person object literal here. We could create this same object using the Object.create syntax as follows. So I'm just going to call Object.create, and the first parameter in that function is the prototype that we want to use for our new object. The second parameter is an object that represents the property descriptors for each of the properties that we have for that object. And so here you can see I'm setting firstName, I'm setting the value to Jim, and enumerable, writable, and configurable to true. Same thing for lastName and age. So now this person object is identical to the person object created above using the object literal. If we just rename these to person1 and person2, and then display them, so now if we take a look, there we can see that we have two identical objects, and you can see why nobody really likes to use Object.create because it's very verbose. The object literal is so much cleaner and easier. And constructor functions actually do a little bit more than this with regards to the prototype, but both approaches are essentially doing this behind the scenes, and you can see it's much nicer to be able to use object literals or constructor functions for creating objects.

Summary
Here's a quick summary of the important bits that we learned in this module. First, objects can be created using object literals by defining properties inside braces like this, and we can easily add functions to object literals. If you're using existing variables to initialize property values in an object literal, you can use the shorthand syntax like this if the desired property names match the variable names. You can use object keys or for in loops to inspect or loop over property names in an object. And we saw how to create constructor functions and use them to create new objects. We also learned that when it comes to comparing equality, double equals should be avoided, triple equals and Object.is are identical, except when comparing not a number and comparing -0. Now it's time to dig deeply into object properties. There's a lot more to learn about object properties than you might think, so let's take a look.

JavaScript Object Properties
Introduction
Hi. This is Jim Cooper, and welcome to this module on JavaScript Object Properties. Since we just talked about objects and how to create properties on objects, you might be wondering how we could possibly have a whole module dedicated to properties, but it turns out there really is a lot more to properties in JavaScript than meets the eye, and there are some pretty cool things you can do with properties if you're aware of them. You'll learn how to do some advanced work with properties, including working with property attributes and using getters and setters, so let's take a look.

Using Bracket Notation to Access JavaScript Properties
In the next couple of examples, you'll see me using the bracket notation for properties. This can be very useful in a few cases. Of course we know we can look at this person object's firstName property as we have been with dot notation like this, person.firstName, and if I save that, that displays Jim as we would expect. But we can also use bracket notation like this, instead of a dot, I'm going to use brackets, and I'm going to pass in a string that is the name of a property. So this is requesting the firstName property on the person object, and if I save that, we get the same result. So dot notation and bracket notation do the same thing, so why would you ever use bracket notation? What if you, for some reason, needed to create a property on an object using a property name that is not a valid identifier, for example, a property name with a space in it or some other special character. For example, we could create a property on our person object called hair color like this. So person, and then bracket notation and a string, hair space color equals brown. Now let's take a look at that value, so we can fetch it the same way, and if I save that, you can see that displays brown. Of course this is not common at all, it could happen maybe if you're using a third-party source of JSON data that has property names that are not valid identifiers or something, but you never really run into this. A much more common usage is if you have a variable that contains a property name, and you want to get the value of that property off of an object. So imagine I had a variable like this, so propertyName variable, and it is set to the string firstName. I could then get the value of the person object's firstName property like this. So I'm just going to pass in that propertyName variable into the bracket notation, and if I save that, there we go, we're displaying Jim again. One example of a use case for this is using it in conjunction with object.keys or a for in loop to display all of the property values on an object. So we could do that like this. So this is a for in loop that is looping over all the property names in the person object, and each time through, it's setting the propertyName variable equal to the name of that property. And if I save that, then you can see what is displayed is the name of a property, a colon, and then the property value, and if you look at our display statement here, you can see that we are displaying the property name like firstName, and then a colon, and then the property value using bracket notation. Bracket notation isn't common, but it is quite useful in the rare cases where you need something like this.

Modifying Properties with Property Descriptors
Now let's take a closer look at properties. You may be surprised to learn that a property is more than just a name and a value. Every property has a property descriptor that we can use to see the attributes of that property. Let's take a look at the property descriptor for the firstName property of our person object. We'll use that with Object.getOwnPropertyDescriptor. So let's see what getOwnPropertyDescriptor returns. There we go, this is describing the firstName property of the person object. You can see that it has a value, and it's set to Jim, and then it also has writable, enumerable, and configurable attributes. Let's take a look at each of these one at a time.

Using the Writable Attribute
The writable property does what you would probably expect. It defines whether the properties value can be changed from its initial value. So let's make the firstName property non-writable. We can change property attributes using the Object.defineProperty method, and the first parameter of this method is the object that you would like to modify a property on. So we want to modify a property on the person object. And then the second property is the name of the property that you want to modify. So we'll modify the firstName property. The last parameter is an object that contains the attributes you'd like to modify. We want to modify the writable attribute, so we'll do that like this. So it's just an object with a property writable set to false. So if I save that, then you can see over here that the firstName property is not writable now. So let's see what happens when we try to change the value of the firstName property now. So firstName is not writable, and that's how you use Object.defineProperty to change the writable attribute. But let's see what happens if a non-writable property contains an object. So let's add a name property to our person object, and it will have a firstName and lastName property. So now person.name .firstName is Jim. And now let's change this to name, so we're going to make the name property on person non-writable. So now we can't change the name property, but interestingly, we can change properties on the name property, so I could set person.name .firstName to something else, and if I save that and display it, there, you can see that I was able to change the firstName property of the name property to Kris, even though the name property itself is not writable. What I wouldn't be able to do is set person.name equal to a new object, that would fail, and this makes sense when you consider that the name property is really just a pointer to an object in memory, and when you make it read only, you're just preventing that pointer from being changed, so you can't point the name property to a new object, but you can change properties on that object. As a side note, however, you can prevent properties on the object from being changed using object.freeze. So I can freeze the person.name property, and I save that, then you can see we're getting an error again. So with the property frozen, I can't even change properties on that property. Next let's take a look at the enumerable attribute.

Using the Enumerable Attribute
Okay, let's take a look at the enumerable attribute. First, let's bring back our for in loop. So we're looping over all the properties in the person object, and we're displaying the property names and values. By default, properties on an object are enumerable, meaning we can enumerate over them with for in loops and list them with object.keys, but we can change that. Let's set enumerable to false for the firstName property. We'll use the Object.defineProperty method like we did with the writable attribute, but this time we'll set enumerable to false. And there, now notice that even though we're looping over all the properties in the person object, that the firstName did not get printed. That's because that property is no longer enumerable. Setting the enumerable attribute to false also makes it so the property does not show up in Object.keys. So if we display the keys for the person object, notice that it displays only lastName and age. And finally, setting enumerable to false also effects JSON serialization of the object. So if I serialize the object and display that, notice that it displays the lastName and the age properties, but not the firstName property. So that demonstrates the power of the enumerable property. Note that you can still look at the property normally, however, using dot notation or bracket notation. So person.firstName displays Jim, you just can't enumerate it with a for in loop or with object.keys, and you can't JSON serialize it.

Using the Configurable Attribute
The configurable property locks down a property to prevent the property descriptors themselves from being changed. It also prevents the property from being deleted from the object. Say we want to lock down the person's firstName property so that its attributes cannot be changed. We'd use Object.define property again, and we'd just set configurable to false. Now if I open my error console, if I then try to change the enumerable property, so I'll use defineProperty again, and I'm going to set the enumerable property to false after changing the configurable property. If I save this, notice that I get an error, cannot redefine property, so I'm trying to change the enumerable attribute after changing configurable to false. That's what configurable does, it prevents you from changing property descriptors. And here's an interesting tidbit, once you change configurable to false, you actually can't change it back again. So if I save that, and let's refresh, notice that I'm still getting cannot redefine property. So you can't even change the configurable property back to true again. Interestingly, however, you can change writable after changing configurable to false. So if I save that and refresh, notice I'm not getting any errors. So that's interesting, making a property non-configurable makes it so you can't change the enumerable or configurable descriptors, but you can change the writable descriptor. There's also one more thing that changing the configurable property does, it makes it so you can't delete a property off of an object. So let's make the firstName property configurable again. So we'll delete this line, and we'll just comment this out so we're not making it configurable false. And now notice that I can delete the firstName property like this. So this actually removes the firstName property off of the objects. So if I display person, there, you can see lastName and age are there, but firstName isn't. Now it didn't just make it not enumerable so I couldn't see it, it actually deleted the property off of the object. But if I make this firstName property not configurable again and save, notice that it says cannot delete property. So making a property non-configurable makes it so you can't change the configurable or enumerable attributes, and you can't delete the property.

Creating Property Getters and Setters
Getters and setters are a couple of pretty cool attributes on a property that let you specify the return value of a property using a function, and set the value of a property using a function. This person has a name property, and that name property is an object with a first and last name. What if we want to know this person's full name? Let's use a property getter to create a fullName property that does that. To create getters and setters, you have to use defineProperty like this. So notice that I'm creating a get attribute and setting that to a function. So this function is our getter. Now let's just implement it like this. There, now we have a fullName property that will return the first and lastName appended. Now let's take a look at our person's full name. If I save that, there we go, notice that returned Jim Cooper. So I was able to call person.fullName, and that executed a function that returned Jim Cooper. That's pretty cool. But what if we wanted to go in the other direction, what if we want to set the first and lastNames when the fullName is set? Well, that's where setters come in. So let's add a setter for that. So I'm going to create a set attribute, and that's going to be set to a function, and then we'll just go ahead and implement that function, so I'm going to use the split function to split the incoming value string into two parts, and then I'll set this.name .first to the first part or the part before the space, and this.name .last to the part after the space. So the important part of this is that this is a set function that is going to set properties on our person object. So now we can set this person's name like this, person.fullName equals Fred Jones, and now if I save that, that when I display person.fullName, it returns Fred Jones, but it didn't just set the fullName property, it actually set the first and lastName properties. So if I display person.name .first and person.name .last, then you can see that they are set to Fred Jones. So you can see that you can do some pretty cool stuff with JavaScript objects, and there really is a lot more to JavaScript properties than initially meets the eye.

Summary
Here's a quick recap of the key takeaways from this module. First of all, we learned that we can access properties not just with dot notation like this, but also with bracket notation like this, and that this allows us to use variables to access properties on objects. We also learned that we can use Object.defineProperty to make properties read only, or non-enumerable, or even make it so we can't change the property descriptors at all. And finally, we learned how to use Object.defineProperty to create getter and setter properties that allow us to create properties that are backed by functions. In the next module, you'll learn about prototypes, how they're used to create inheritance chains and how to create your own prototypal inheritance.

JavaScript Prototypes and Interfaces
Introduction
Hi, this is Jim Cooper, and welcome to this module on JavaScript Prototypes and Inheritance. If you've heard about prototypes, but haven't really ever used them, or perhaps stumbled across some JavaScript code that used prototypal inheritance and it left you scratching your head, this module will give you a solid understanding of how prototypes work and everything that is going on behind the scenes. Once you understand prototypes, you'll be able to write simple, yet powerful code that otherwise would've eluded you. It will also help you understand JavaScript object and property behavior that may otherwise leave you a little confused. So let's jump right in.

What Is a Prototype?
What exactly is a prototype? The answer to that question isn't exactly simple. For starters, a prototype is an object that exists on every function in JavaScript. So notice if I create a function like this, then notice that is has a prototype property. So I'll save that, and you can see in our display in our browser that it displayed an empty object. So every function in JavaScript has a prototype property. And objects, while they do have a prototype, they do not have a prototype property. So if I create a new person object and try to display its prototype, then notice that's undefined. You can see an object's prototype, however, by looking at the __proto property. So if I save that, notice that it is also an empty object. But an object's prototype and a function prototype are used differently, so let's provide a couple of definitions that we can work with going forward. These might not make a lot of sense now, but they will once we provide a few examples. A functions prototype is the object instance that will become the prototype for all objects created using this function as a constructor. An object's prototype, however, is the object instance from which the object is inherited. It's important to take note of the word instance in those definitions. A prototype, whether it's a functions prototype or an object's prototype, is actually an instance of an object in memory. So when a function is created, a new prototype object is created in memory an attached to the function behind the scenes. If that function is then used as a constructor function with the new keyword, the new object that is created has a proto property that is pointing to the same object in memory that is the function's prototype. This is much easier to understand in code, so let's take a look at an example. So let's create a Person constructor function. And to start with, let's look at this function's prototype. Okay, you can see that it is a person object, or in other words, it's just an empty object right now, and it's type is person. Now let's create a new person from that constructor function. Now let's look at Jim's prototype. It is also an empty object of type person. And notice if we compare them, they're actually the same instance. So if I save this, they are equal, and if you remember from our earlier discussion about equality, if two objects are equal, they are actually the exact same object instance in memory. You can actually see that if I change one of them. So let's change the person function's prototype. So we'll add an age property to the prototype, and if I save that, you can see that while I only change the prototype for the person function, it is also reflected in Jim's prototypes, since they are the same object. And the same holds true if I create another instance of person. So let's create a Sofia person, and if we display Sofia's prototype, they all look the same. And just to demonstrate this a little further, let's actually change the age of Sofia's proto object. There, notice that in our display, the ages of all of these objects changed to 19, so they are truly the same object in memory. So the object instance that is the function's prototype becomes the prototype for all objects created from that prototype.

Instance vs. Prototype Properties
Okay, so we've seen how adding a property to a function's prototype affects all objects constructed using that function, but let's take a closer look at what exactly is happening behind the scenes when you add a property to a prototype like this. Specifically, let's take a look at exactly where those properties live. Here we have our Person function and two people derived from that function. And notice that the Person function's prototype has an age property that is set to 29. That means that each of our person objects also have an age of 29. And we know that if we change the Person.prototype .age, that will change the age for all persons derived from that function. And we know that if I change Person.prototype .age, that it will change the age for all persons derived from this function. But what happens if instead of changing the prototype's age, I change the age of just one of those persons? Interesting, in this case only Jim's age was changed, so what's going on here? If the age property is coming from the prototype, which is shared, how is it that I can change one without changing the other? Well, it's because we didn't actually change the prototype's age property, what we really did here was add a new property to the Jim object. Notice that Jim still has access to both values, so jim.age and jim.__proto__ .age, and jim.age is 18, where Jim's prototype age is still 29. The key concept to notice here is that prior to setting Jim's age directly, the Jim object never actually had an age property, only its prototype did. But if that's the case, why is it that if I delete this jim.age property and save, we can still ask for the age property on Jim and get a value back? This is because what JavaScript is really doing when we ask for the property value is that it looks at the object to see if it has a value for that property name. If it doesn't find a property on that object, then it asks its prototype to see if it has that property. We can see this further by using the hasOwnProperty method. So let's see if Jim has a property named age. So the hasOwnProperty method will look at an object and see if it has this property on that object itself, and you can see that is false. So it does not have an age property, but we can ask for it and get a value back. That value came from the prototype, but if I now add a jim.age, then you can see that hasOwnProperty returns true and it returns the value from the Jim object. And by the way, everything that we're doing here with properties, you can also do with functions on objects or methods, since methods are really just another type of property. So if my person prototype had an isAdult function, it would behave in exactly the same way that the age property does with regards to prototypes and inheritance. Next let's take a look at this in another way to help understand exactly what is happening here.

A Graphical Overview of Prototypes
Here's another way to look at prototypes. First of all, when we created our person function, JavaScript also created another object in memory. This is essentially an empty object at this point. It does have a proto property that we'll talk about later, but other than that, this is just an empty object. After creating that object, JavaScript updates the function's prototype property to point to this new object. And note that we haven't even created a new person object yet, this is just the prototype object that was created for us when we created our person function. And we can manipulate the properties on that function's prototype object like this. When we add age to the person function's prototype, it adds that property to this object. Remember we haven't even created a person object from our function yet, this is just the hidden prototype object that the JavaScript created behind the scenes. So let's create a new person object from our function now. We do that like this. When we do that, the new object takes care of creating a new object, but the new keyword also does something else behind the scenes, it adds a proto property to our new object, and that property is a pointer to our person function's prototype object. Then the new keyword executes our Person function, and the this keyword in this context is pointing to our new Jim object, so it adds the firstName and lastName properties to our new object. And if we create another instance of person, the same process is followed, a new object is created, its proto property is created and is pointed to the function's prototype, and the instance properties are added. Notice at this point the Jim object itself does not have an age property, only its prototype does. So if we ask for Jim's age at this point, what's going to happen? When I do that, JavaScript will check the Jim object to see if it has an age property. Since it does not have an age property, it will then check its prototype parent to see if it has an age property, at which point it discovers that it does, so this console log would log 29. Now what happens if we want to update Jim's age? In code, we simply do that like this, and that adds an age property to our Jim instance here. Now if we ask for Jim's age, it will check to see if Jim has an age property, and it does, so it returns the value of 18 without ever checking to see if the prototype has an age property. So the instance properties override the prototype properties. So what would happen if we updated the person function's prototypes age property? We could do that in two ways, either directly like this, or we could do it through Jim's proto property like this. As our code stands now, this would have the exact same effect. It is possible, however, for these two statements to have a different effect. We'll talk more about that later. For now, let's just stick with the more direct approach. So when this line of code executes, it will change the age property of our function's prototype here. Now what would we get if we asked for Jim's age? We would get 18 because the instance property overrides the prototype property. And what if we asked for Sofia's age? We would get 25 because Sofia has no instance property for age. Now let's revisit the definitions we created earlier and see if they make a little more sense. So a function's prototype is the object instance that will become the prototype for all objects created using this function as a constructor. An object's prototype is the object instance from which the object is inherited. Hopefully these definitions are starting to make more sense now. Prototypes are not really that complex once you understand what's happening behind the scenes.

Changing a Functions Prototype
In the definition of a function's prototype, we said that the function's prototype is the object instance that will become the prototype for all objects created using this function. Let's take a look at a quick example that illustrates that. So here we have our person function and two persons, Jim and Sofia, which were derived from that function. If we look at their ages, you can see that they are both inheriting an age of 29 from the person function's prototype. We now know that if we change the age of the prototype, that that will also change the age of Jim and Sofia through inheritance. But what if we actually change the function's prototype to point to a completely different object? Let's try that like this. So we'll set Person.prototype equal to a new object, and that new object has an age property that's set to 18. So if we save that, notice that it did not change Jim and Sofia's ages, they are still 29. So unlike simply changing the age of the prototype as we did here, we actually pointed the prototype to a completely new object. And if we look at the person function's prototype, we can see that it has an age of 18. Notice now if I add a new person after having changed the prototype to point to a new object, so I'll create this Kris person, and if we then display Kris' age also, then you can see that Kris' age is 18. So what exactly is going on here? This really highlights that the Jim and Sofia objects have prototypes that are pointing to an instance of an object in memory, and the Kris object is pointing to a different instance. Let's take a look at what really happened. Here we have our diagram from earlier showing our person function and the two instances of person, and you can see that they are all pointing to the same prototype in memory. When we change the prototype of our function, what we really did was create a new object in memory and changed the person function's prototype to point to that new object. However, the existing Jim and Sofia instances of our person still have prototypes that are pointing to the old prototype object. When we then created our new Kris instance of a person, it created a new object and set its prototype to point to the current prototype of the person function. This really highlights again the fact that prototypes really are objects that live in memory, and as you'd expect, they behave like any other objects with regards to pointers. Hopefully all of this helps solidify how prototypes really work. Now let's take a look at object inheritance.

Multiple Levels of Inheritance
So far, we've only been talking about a single level of inheritance, where our person objects inherit from a prototype object, but actually the objects we've been working with have multiple levels of inheritance. So for example, we know that Jim has a prototype that was created from our person function, what we haven't seen is that person prototype also has a prototype. Notice that its prototype was created from the object constructor. So what if we keep looking up the prototype chain? Notice that object's prototype is null. Eventually as you walk up the prototype chain, you always find a null prototype, and this is usually after hitting object's prototype. By default, all objects in JavaScript inherit from object, and object has no prototype. This is a prototype chain and demonstrates that we already have multiple levels of inheritance, and it always ends in null to indicate the end of the chain. But let's make this more interesting by creating a more meaningful inheritance chain.

Creating Your Own Prototypal Inheritance Chains
Let's start with our familiar person constructor function, and notice that it has a fullName property getter. Now imagine that this code resides in an application for a college admissions site, where we'll have students enrolling in courses. So we might have student objects that look like this. So here is a student constructor function, and it has an enrolledCourses property, and it has an enroll function that takes in a courseId and adds that courseId to the enrolledCourses array. And then it has a getCourses function, which we'll implement here in a minute. Okay, so here's our student function, but student's are people, so they will have a firstName, a lastName, and an age just like our person object does. Now I could just implement these firstName, lastName, and age properties as part of my student object, but that's a bit redundant, and I wouldn't get the benefits of things like this fullName getter without re-implementing it. So what I really want to do is make Student inherit all of that from Person. If you remember from earlier in this course, objects can inherit properties and methods from their prototype, and you can chain prototypes. As it is right now, any objects created with this Student function are going to have a prototype of Student, and so it will have these enroll and getCourses functions, but we want to also have these properties and methods from the Person constructor function. So we can do that by adding Person to the prototype chain. So we'll do that down here right after we create our Student function, we will set the Student function's prototype to a new Object that we will create with Object.create. And that object is going to have a prototype that is the Person function's prototype. One more thing we need to do is set the prototype's constructor, so we do that like this. We'll come back and explain these two lines in depth in a minute, but for now, just know that if you want to create a prototype inheritance chain, these are the two lines that you need to implement. And now I could create a new student like this. So I'm going to create a new Jim Cooper student, and let's take a look at it. Okay, so you can see that object looks like a student object, and if we look at that object's prototype, you can see that it is a student object. And if we walk up the prototype chain once more and look at that prototype's prototype, then you can see that it is the person prototype. So we have a nice prototype chain, but we aren't really done yet. Notice that when we displayed this Jim object, that it displayed this object here, and even though we've got an inheritance chain, we're not seeing any person properties here like firstName and lastName, etc. Well, if you remember, we also haven't done anything yet with these parameters here. What we want to do is call our person function from within our student function. So we'll do that like this. So this call function allows us to call the Person function while setting the context of this. And remember, inside this Student function, this is referring to the new object created by the new operator. So we're passing along our new Student object to the Person function for it to manipulate it however it wants. So now if we save this, you can see that our new Student object now has the Person properties, including our handy fullName property. Now let's just round this out by implementing our getCourses function. In here, we'll just print out this student's name and their courses like this. So notice that we're calling this.fullName, and then we're printing out their enrolledCourses. So now to demonstrate this, let's come down here and we will enroll Jim in some courses. So we'll enroll Jim in CS205, MA101, and PS101. Now let's just display Jim's courses. So we'll just display jim.getCourses, and let's save that, there we go. So now we can see that Jim Cooper's enrolled courses are CS205, MA101, and PS101. So the important part of that is that we printed out Jim Cooper's using this.fullName here. So we're able to access the Person object's fullName property from our Student object. So our inheritance is working nicely. But let's back up a little bit and just explain these two lines. First of all, why are we using Object.create here? Well that because if we use the new keyword, it would actually execute the Person function at this point, and we don't really want to do that here. We don't actually want to call it until we're actually creating a new student. So Object.create just creates a new object with Person as its prototype, that's the first parameter of the Object.create function. And then we set that new object as the Student function's prototype. What about this line? To understand that, you have to understand that all prototypes have a constructor property that points to the function that was used to create it. To understand that a bit more, let's get rid of this display call here, and then right here, right after we create our Student function, let's display Student.prototype .constructor. And then we'll comment everything out below this for now. So if I save this, you can see that this is just a big Student function string. So this is actually the Student function. Now let's uncomment this line here, and then we'll display this again here. So we'll display it before and after setting the student prototype. There, now you can see that the function before setting the prototype was Student, and after setting it, it is Person. This is a side effect caused by the fact that we created a new object from the Person prototype, which has the Person function as its constructor, and then set that prototype for our Student object. So to undo that side effect, we just need this line here. So now if we move this display call down here, and save it, there we go, now it is the Student function both before and after setting the prototype. I can't think of a typical use case where this actually matters, but this makes everything technically correct. So that was a lot of explanation, but in the end, the only three lines that we needed to actually create an inheritance chain was these three lines. And if we clean this all up again, so let's delete these extra displays here, and then we'll go ahead and create Jim and enroll Jim in three classes. Then if we display jim.getCourses again, there we go, it's working great. And that's all there is to creating prototypal inheritance chains, or creating inheritance in JavaScript where one object inherits properties and functionality from another object.

Summary
Okay, here are the key takeaways from this module. First we learned that functions have prototypes, and that those prototypes point to objects in memory. And when you create new objects from those constructor functions, they also have prototypes that point to the same object in memory. We also learned that objects themselves can have properties, as well as their prototypes. And when we ask for the value of a property on an object, it asks the object first, and then its prototype. We also learned how to set up inheritance with constructor functions by setting the prototype of one function to an object created with the prototype of another function, and that we can initialize the parent classes properties by calling its function using the call function and passing along the context of this. Now let's see how to do all of this with classes.

JavaScript Classes
Introduction
Hi, this is Jim Cooper. In this module, we'll start working with JavaScript Classes. Classes play the exact same role as constructor functions. They are templates for creating objects and encapsulating logic related to those objects. We'll explore the depths of JavaScript classes, including using classes to create objects, properties, methods, getters, and setters. And of course we'll explore inheritance and creating inheritance chains. If that all sounds familiar, it's because we just did all that with these constructor functions. Basically anything we can do with constructor functions, we can do with classes. In fact, classes are really just syntactic sugar for a cleaner way to do all this, and it's important to understand that classes don't really do anything new, including inheritance. The end result is the same, including using prototypes for inheritance behind the scenes. Classes just offer a little cleaner syntax to accomplish it, and we'll transform all of this into class syntax so we can see the difference. One last thing to mention, it's important to note that classes were introduced in ECMAScript version 6, which means that classes are supported in all major browser versions including Edge, but unfortunately not including Internet Explorer. So keep that in mind if you're still supporting Internet Explorer. But if you're working on the server side or don't need to support Internet Explorer, classes can be really nice. So let's jump in and see how to do all of this with classes.

Creating Objects with Classes
To get started, let's save this constructor function code to a new file, so we can compare and contrast the class syntax to the constructor function syntax as we go. So I'm just going to hit Ctrl+Shift+S and then save this to a constructor- functions.js file. And then let's close this, and open up our explorer, and we'll open up demo.js, and then we're going to open up constructor- functions.js to the side. Now let's create a person class to replace this constructor function. So let's go ahead and move this window pane over a little bit, and we'll delete this code in here. Okay, so this is where we'll create our new class. We'll start with the class keyword, followed by the name of the class, and then brackets. Alright, now we need to add some properties, and we do that inside a constructor. So a constructor in classes is code that is run whenever a new object is created from this class. So it's kind of like the code that gets run inside of a constructor function every time you create a new person, except this is how you do it in classes. So now our constructor will take in a few parameters, firstName, lastName, and age, so that we can initialize these properties when we create a new person. And then we create properties on our class in a similar way to how we did it in our constructor function here. So, we're just going to use the this keyword to create a new firstName property, and a lastName property, and an age property. Okay, now we can create a new person object. So I'm going to create a Jim object with the first name Jim, last name Cooper, and age 29. And then let's go ahead and display that. So I'll save this, there we go, we have a new Jim Cooper object, and we've created our first class with JavaScript. And so far it's not too different from using constructor functions, but it's nice and clean. Now I don't really have to initialize this age property up here, so I could delete this code and this parameter here, and then I could just create an age property still, and just initialize it to something like 0, or null, or something. So you can create properties without requesting that the user initialize them right away when they create an object. And now I don't have to pass this in here, and I could then, after creating the object, change the age of course. And that has the same effect. Of course if I don't initialize it, then Jim Cooper has an age of 0. So not all properties need to be initialized via the constructor, but for now, let's go ahead and leave that how we had it. That was easy and really not too different from our constructor function code. With the constructor function, you just use the keyword function instead of class, and you just define the properties inside that function. But what about these getter and setter functions? Let's take a look at how to do that with classes next. Getters and setters in

Creating Getters and Setters with Classes
classes are nice because the syntax is simple compared to the syntax in constructor functions. With our constructor function, we had to use this Object.defineProperty function to create a getter and setter. Let's check out how to do this with classes. So let's move this over a little bit, and then in here inside our Person class, we create a getter like this, so you just say get, and then the name of the function. So this essentially creates a fullName property on the person that is backed by functionality in a function. This is really nice compared to having to use the Object.defineProperty syntax. So now let's just copy this implementation over here, we'll place that right here. So the get fullName getter is just going to return firstName plus lastName. And now down here, I can just access that like this. And if I save that, there you go, now you can see it's displaying the fullName Jim Cooper in our browser. Now let's add the setter. So that syntax is the same except for the keyword set, so we're going to set fullName, which will take in a fullName parameter, and then let's copy that implementation from over here also, and we'll just drop that in here. So we have a get fullName and a set fullName, and then right here we will set it, jim.fullName equal to Fred Jones. If we save that, there you go, you can see that we're setting it to Fred Jones, and then when we display the jim.fullName property, it's displaying Fred Jones. Cool, that syntax is really nice. Now let's take a look at adding functions to our class. Over here in our old constructor function,

Adding Functions to Classes
we had this isAdult method. Let's add that to our new class. The syntax for this is nice and simple too, you just start with the function name like this, and then the implementation just goes inside here. And that's it, that's noticeably more simple than the constructor function version. So now we can call that function down here, so we can display jim.isAdult, and you can see that returns true because Jim is 29. So adding functions to a class is super easy, you just start with a function name, followed by parentheses and the function body. So we've seen how to add methods or functions and properties to classes, but let's take a look now at how we might manipulate properties on a class using property descriptors.

Modifying Property Descriptors on Classes
There's something interesting going on with our person objects that you may not have noticed just yet. After we create this Jim object down here, let's display it. So there's something notable missing here. We have this fullName getter, and so there's a fullName property on our Jim object, but it's not showing up when we display the object, that's because when you create a getter, it is created with enumerable set to false. Generally this isn't a big deal because it's not too often that you iterate over the keys of an object, but if you needed to and you wanted your getters to show up, you'd need to set this getter property to enumerable first. Unfortunately there isn't a good, clean way to do that with classes, so we'll have to revert back to our Object.defineProperty method. We'll do that just outside of our Person class. Now which object are we going to define this property on? The question is where does that fullName property exist? Well it's not on the Person class itself, but it's on the Person class' prototype. Yep, classes have prototypes, just like functions do, and that's an interesting thing to note. Getters and setters live on the prototype, whereas other properties like firstName, lastName, and age live on the Person object instances. That makes sense when we really think about it. There is nothing stateful about getters and setters, they're really just functions, so they can live on the prototype, but the other properties like firstName and lastName contain state that change from instance to instance, so those need to be instance properties. So the fullName getter is on the prototype, so we'll modify the person.prototype, and we want to change the fullName property and set it to enumberable: true. There, now when I save this because we're displaying Jim here, you can see fullName shows up here in our browser, so our fullName property is now enumerable. And of course you can do this with the other property descriptors too, like configurable and writable. Now let's take a look at inheritance with classes.

Using Inheritance with Javascript Classes
We've already created this Person class, let's go ahead and create a Student class that will inherit from this Person class. So I'm just going to come down here, and I'll just paste this in, so this is a Student class, it has an enrolledCourses property, and notice the constructor takes in a firstName, lastName, and age that we're not doing anything with yet, and then it has two functions, enroll and getCourses. So this looks familiar because we already created a Student constructor function that looks a lot like this, only it doesn't inherit from the Person class yet. With our constructor function, we set up inheritance by setting the constructor function's prototype and constructor like this. With classes, that's a lot easier, so we can just use the extends keyword, which goes here. And then we specify the name of the class that we want to inherit from. So Student will inherit from Person, and that's it, Student now inherits from the Person class. Of course we're not doing anything with these firstName, lastName, and age parameters yet. With constructor functions, we called the Person constructor function from within the Student constructor function like this, but what we want to do with the Student class is we want to call the Person class' constructor function, and now that the Student class inherits from Person, we can do that with the super keyword. So inside of our constructor function, we're going to just call super. This keyword is used to call the constructor on the class that we're extending. So we can just pass in our parameters like this. So our constructor takes in firstName, lastName, and age, and we'll just pass those along to our Person constructor function. So now when somebody creates a new student, and then we will enroll Jim into CS101, and then I'm going to display Jim.getCourses. And if I save that, there we go, we can see that it says in our browser Jim Cooper's enrolled courses are: CS101. So the important thing to note here is that right here in getCourses, we call this.fullName, but fullName is not a property of student, it's a property of person, so you can see that we have access within the Student class to properties on the Person class because Student inherits from Person. And if we just display Jim, then you can see that Jim has a firstName, lastName, age, and an enrolledCourses property, so that is all the properties from Person and from Student. So I love this syntax with classes, it really is a lot simpler than creating inheritance using constructor functions.

Using Static Properties and Methods
Static properties and methods are items that you can access on a class without having to first create an instance of that class. This getCourses method is not a static method because in order to use it, I have to create a new Student object like this. So I can call this function like this using jim.getCourses because Jim is an instance of a student, but I can't call it like this, I can't just call Student.getCourses and expect that to work. And you can see over here that I'm getting an error here, Student.getCourses is not a function, and that's because there is no getCourses directly on the Student class, it's only on instances that are created from this class. But you can create useful static functions that do exist on classes. So for example, imagine that in our college registration application that user first creates an account, and then they enroll as a student. In that case, you might already have a person object for them, and so they might have come and registered as a new user, and at that point you created a new person object. And now they're enrolling as a student, and so you want to create a new Student object from this existing Person object. With a static function, we could do that something like this, where you could call from Person on the Student class itself, and pass in a Person object. And then this fromPerson function could return a new student with Jim's person information, so let's implement that. We start by declaring a function with the keyword static, and so we've created a fromPerson function proceeded by the keyword static. And that we'll just implement that by having it return a new student object, and using the person, we'll pass in the firstName, lastName, and age. Okay, so we call fromPerson, pass in a Person, and it returns a Student. So now down here where we've already called this, let's display jimStudent and see what we get. Okay, there we go, we get a Student object, and it has a firstName, lastName, age, and enrolledCourses. You can see that we created a new Person, and then on the Student class we called fromPerson, and passed in a Student object, and that returned an instance of a student. You can use static functions like this for all sorts of things, and there are static properties too. If we come up here on this Person object, I could add an adultAge property that is static. And then I can display that down here like this, so I'm going to call Person.adultAge, and notice that returns 18. Cool, so that's how you create and use static methods and properties. If you're wondering when you might use something like this, consider the built-in math object. It has static properties like math.PI, which returns the value of PI. And it has static functions like absolute value, which return the absolute value of a number that you pass in. The math object may or may not being using classes, however, because it's worth noting that you could accomplish the same thing with constructor functions. All you do on a constructor function is add a property to the function itself. So if I had a Student function, I could set Student.fromPerson to a new function, and that would work fine with constructor functions also. So for example, if open up our constructor function code that we had used before, I could come down here to the Student function, and after I declare it here, I could create a static fromPerson function like this. So I'm just going to say Student.fromPerson = function and then the implementation here, and I could call this in the same way that we did with our class syntax by just calling Student.fromPerson. And so that's how you implement static properties and methods in JavaScript classes and constructor functions.

Summary
So here's a quick recap of this module. We create new classes with the class keyword, and then we can create new instances of the class using the new keyword. The constructor is used to initialize property values, getter and setter properties are super easy to create, and so are methods. We can create static properties and methods using the static keyword, inheritance is easy with the extends keyword, and we can call Parent class constructors using the super function. Classes are really nice because the syntax is so much cleaner than constructor functions. Now let's wrap things up by taking a look at a few built-in JavaScript objects that are commonly used.

Using Built-in JavaScript Objects
Introduction
Hi. This is Jim Cooper, and in this course we've talked a lot about how to create and work with our own objects. Now let's take a quick look at some objects that come built into JavaScript. We'll take a look at three common objects that you're likely to use in JavaScript. We'll start with the Math object, which comes with lots of static functions for various mathematical operations. Then we'll take a look at the Date object, which we can use to create, manipulate, and inspect the dates. Finally, we'll take a look at the Regex object, which is used for searching and validating strings using regular expressions. The Math object is pretty straightforward, but the Date and Regex objects have some complexity to them, so let's jump in and take a look.

Using the JavaScript Math Object
The Math object is a built-in JavaScript object that has a handful of properties that contain some math constants, plus a whole host of math functions. This Mozilla developer documentation is a great resource for discovering all of the available functions and how they work. We won't go into all of these, but let's just see how to use a couple. All of the properties and functions on the Math object are static, that means we don't need to create a new Math object before using it, we just use it directly. So let's access one of the Math object's constants, PI. We'll display the value of PI like this. So we just call Math.PI, and notice that displays the approximate value of PI, and you could use this in mathematical calculations. We can also directly call functions on Math, like Math.max, for example, max takes in unlimited numerical arguments and returns the largest of all of them, or we could call Math.round, round will round a number to the largest whole integer. We're not going to demonstrate all of the other Math constants and functions, but just know that you can look at this documentation whenever you need to tap into common Math functions like this.

Managing Dates with the Date Object
The Date object is fairly involved, and we'll take a look at some of the more common features here. First, let's create a new Date object like this. So we'll just call new Date. And creating a date like this without passing in any parameters creates a new Date object that represents the current date and time. There are a few constructors though that we can use when creating a date. The next one we'll take a look at takes in a number as a date, so we'll pass in 0 here, and this parameter is the number of milliseconds since January 1, 1970. So if I create a date like this with 0 ms, and then display it, then you can see Wednesday, December 31, 1969 at 17:00:00 hours. Well, this is a little bit confusing because I said it's the number of milliseconds since January 1, 1970, and this is 5 hours before that, but that's because this is being displayed in Mountain Time, which is the local time zone on my computer. So this actually is January 1, 1970 Universal Time. And if you look at that time, 17:00:00, and I change this now to 1000 ms, you can see that this is now 1 second after 17:00:00 hours, or 1 second after January 1, 1970 Universal Time. So you might be wondering why January 1, 1970. That is what's commonly called Unix epoch time. But this isn't a very useful way to create dates, so let's move on to a more intuitive constructor, which takes an ISO 8601 string, which looks like this. So now if I save that, you can see we're looking at a date of March 25, 2050 as represented by this string. This seems really useful, but there's a problem with this constructor in that different browsers may handle that string inconsistently. So by far, the best constructor is not this one, but one that takes in each date and time part as an integer like this. So these parameters in order are year, month, day, hour, minute, second, and millisecond. So if we save this, there we go, we now have April 25, 2050, wait, what, April, why does that say April? I clearly put 3 as the second parameter, which is the month parameter. Well for some unholy reason, the month parameter is zero based, and everything else is 1 based, so 0 is January, 1 is February, and 2 is March, and so of course 3 is April. Try to embed this in your mind because I can almost guarantee it will trip you up some day. But this is the most useful and accurate way to create dates in JavaScript, so with this constructor. And covers the different constructors. So now let's take a look at these following functions. Each of these has a corresponding setter also, so I could call date.setMonth and pass in the month. So I'm going to pass in 5 here and save that, and so that changed the month. And if we display this date now, it's important to note that these getters return values that correspond to the time zone of the computer they're running on. But there are also UTC versions of these, and so these return the UTC minutes, and day, etc. Another useful thing to be aware of with dates is that you can subtract two dates in order to learn the amount of time between them. So if I create two dates like this, so this first date is going to be April 25, of 2050, and the second date, which is identical, except for the milliseconds at the end, 5 ms apart. So if I subtract date1 from date2, notice that it returns 5 ms. Of course if I change the year on date2 to 2051 and save that, that's about the number of milliseconds in a year. So you can use this to determine how much time has passed between two dates, and these are the most common things you'll do with dates. Again, like the math object, the Mozilla developer documentation is a good place to look for other less-common date methods.

Validating Strings with the RegExp.test() Function
The JavaScript regular expression object can be used to search strings to see if they contain text that matches a regular expression. Regular expressions are search patterns, and the syntax for all the different possible search patterns are beyond the scope for this course. But let's see how to use the JavaScript regular expressions object. Consider a function like this. This function needs to make sure that a password meets a minimum complexity threshold. We can create a new regular expression like this. So we're going to call new Regex, and pass in our expression. But we just have one problem. Because this expression is defined inside quotes as a string, this backslash is going to be interpreted as an escape character, so we're going to have to actually escape that backslash by adding a second one here. Okay, so this regular expression will now test to see that a string has lowercase characters, uppercase characters, numbers, and is at least 8 characters long. And now that we have a valid Regex object, How do we use this to test strings to see if they're valid passwords? Well the Regex object has a test method that we can call like this. So I can call the test method and pass in the string that I want to test. And let's just go ahead and return the results of this. Now we can go ahead and call this checkPasswordComplexity function, and pass in a password, and this regex.test function will return true if the password adheres to the regular expression. If I pass in a string that doesn't match the regular expression, I'll pass in a weak password, and if I save that, you can see it returns false because there are no uppercase letters or numbers, and it's not at least 8 characters long. So this one will fail too. If I have a capital letter and a number, but it's not 8 characters long, so if I save that, that fails also. But this one will return true. Now this weird thing that we had to do with the double backslashes, that's a common problem with treating regex as a string, and so there's actually a shorthand syntax for creating regular expressions that makes it so that we don't have to deal with this. So I'm going to copy this regular expression here, and then let's create a new Regex variable, and the shorthand syntax for a Regex just uses two forward slashes, and then you just up your regular expression between these slashes like this, except we don't want these quotes. And now because this is not inside quotes, we don't need to escape this backslash. We'll continue working with this new syntax. Before we do though, I just want to mention something for you to keep in mind. This Regex function up here takes a second parameter, in a minute we're going to talk about Regex flags, which alter the way a Regex searches a string. So for example, I could put an extra parameter in this function call like this, those are two Regex flags that we'll touch on in a minute, which mean search globally and ignore case. To compare to that to the shorthand syntax, those flags will go here. I just wanted to point that out so you could see how this works in both places before I delete this version up here. Okay, so if we save this now, you can see this is still working. Just to prove that, I'll refresh here, and you can see it's still returning true. So that's the test function. Next, let's look at one other Regex function, the exec function.

Searching Strings with the RegExp.exec() Function
Like the test function, the exec function is used to search a string, but instead of returning true or false, it returns information about what it found. To demonstrate that, let's delete all of this, and let's imagine a function that is used for searching through application logs for alert messages. Now let's create a Regex that looks like this. So this is going to search for the word ERROR, followed by a colon, and then we will call the exec function like this, and pass in the logData or the string that we want to search, and we'll return that from our function. And that will return some information about what it found. So let's demonstrate this by creating some logData, and notice this has an error, followed by a colon in the string. And then let's just call our findAlerts method, and pass in the logData. So our regular expression should find this error in our string. Let's take a look at that result. So we'll just display result here and save that. Alright, the output here is a little interesting, so let's take a closer look at it. You should understand that the Regex function returns an array, and that's what we have here. What was returned was an array with the string error:, so it's an array with one item in it. But what you might not know is that arrays in JavaScript are really just objects, and you can actually add properties to arrays. So that's what all of this is down here. My display function just breaks these out, so it's easier to see them. So notice that the returned array has two additional properties, an index property and an input property. Let's just log each one of these independently to make that a little bit more obvious. So first I'll display the first item in the array, and then I'll display the result.index and result.input. And if I save that, there we go. So you can see that I'm accessing result like an array to get the first item, and then I'm also accessing the index and input properties like normal properties. That's an interesting thing to know about JavaScript arrays, arrays are actually just objects. But you might be asking, if they're just objects, why can I access them like an array with a 0 in brackets like I am here? Well remember our earlier clip about bracket notation, we're just using bracket notation, and it has a property named 0. Okay, so let's just change this back to display the full result. It returned an array with one element in it, and it is the string that matches our Regex. That's the first thing to understand about the exec command is that it returns an array, and the first element is the string that it found. Any other elements in the array only show up if you're using Regex capture groups. More on that in a minute. If you're not using capture groups, the array will always just have one item in it. And then exec also puts these other two properties on the array. The first one, index, indicates where in the array it found the string, input is just the string that was passed in to the exec command. That one's not too helpful, but we were able to get our Regex function to find that the string did indeed include an error, and we know that the error starts at position 8 in the input string, but this leaves a few questions. Number one, why does the array return the exact string that we search for in the Regex? Our Regex is ERROR:, and that's what's returned, and that doesn't seem too helpful. Number two, what if there was more than one error in the string, how would we find them all? And number three, what else can appear in that array? Well, let's take these one at a time. So first, why is it returning the exact text of our Regex in the array? Let's consider a more complex Regex. So let's move this back over, and let's add a little bit more info to our error string here, so let's say after the word ERROR:, in parentheses, it indicates the severity of the error. And if I save that now, our Regex exec function returns nothing, so let's fix the regular expression to find all errors regardless of the error level. So we'll come up here and change our Regex to this. That will find the string error, followed by any characters, and then followed by a colon. The question mark just makes sure our Regex isn't too greedy. We won't get into that in this course. But now if we save that, the value returned in the array is not the same as our Regex anymore, but it is all of the text that was found using our Regex. That makes this more useful. Okay, now for the next question, what if there were multiple errors in this string? Let's add one and see what happens. So here at the end of this string, we'll add a second error, and now if we save this, you can see nothing changed in our output, except for the input property, which we've already established is not very helpful. You may have expected to see multiple results returned in the array. I know I certainly did when I was first learning about Regex exec. But here's the interesting thing, the Regex object is actually stateful, it keeps track of every time we call the exec function. So up here in our function, let's call it multiple times. So I'll call it once here, so I'm going to call exec and pass in the logData, and then let's go ahead and display that. And then for now, instead of returning this, let's just display it too. And then just to make this a little more legible when we output it, let's display a long line between the two of these. Okay, let's see what that did for us. Well dang, it's displaying the first error both times. This is where flags come in. By default, each time we call exec, it's going to find the first match and stop trying. To have it keep searching past the first one, we need to give it the global flag. So over here in our code, in our regular expression, let's just add a g at the end here, and then let's save that again. Okay, great. Now the first time we call exec, it finds the first one, and the second time, it finds the next one. So the Regex object uses internal state to track where it is in searching the string for future calls. Now there is one thing to be aware of with regards to that state. What if we changed our function to just return the result again like this, and then down here, what if we call findAlerts multiple times. So I'll just cal lit once with logData, and then we'll display a line, and then we'll call findAlerts again. And then if we save this, notice that we're back to finding the first error twice again. Each time we call findAlerts, we create a new Regex here, and every time we create that, it resets the state. So just remember that when working with exec, you want to create the Regex once, and then call exec multiple times. Okay, now to our last question, why does exec return an array if there's only ever one item in it? Well, that's for Regex capture groups. So let's put this back how we had it, so we're going to delete these calls, and we'll just call this here without displaying it. And then up here again, we're just going to call exec multiple times. But now let's add a couple of capture groups to our Regex. Capture groups allow you to capture and return data from within the input string. So let's add two capture groups, one to capture the level of the error, and one to capture the error message. So the parentheses here is what creates the capture group. The first one is going to capture everything after the word error, and the second one is going to capture everything after the colon, and then we want it to capture everything up to the semicolon, which is where the next error occurs. And if I save that, then you can see it spit out a lot of stuff, but it's a little bit messy. To make this a little easier to read, I created a display Regex array method that breaks down the display of that array a little bit. So let's use that here instead of display, and let's save that. Okay, that's a little easier to see. The first element in the array is still what the regular expression matched, but the second element in the array is our first capture group. It captured that this is a high-level error. And the second element shows the error message, that's pretty handy. There's just one last thing to demonstrate here. The way I've written the findAlerts method will only ever find and display two errors. If I was to add another error to the string, it wouldn't get displayed because we're only calling exec twice. So let's make this method a little more useful. We'll just keep calling exec until we don't find any more errors. So let's delete this, and right here we'll call regex.exec, and pass in logData, and set result to that. And then we'll start a while loop, and let's indent this. And then each time through this loop, we'll display the current error level and message, which are the second and third elements of the result array. And then we'll add a little divider here. And let's indent those appropriately too, and then at the bottom of the loop, we'll just call exec again and set result to what's returned. So this while loop will keep looping until exec returns null. So let's save that, and there we go. We can see that it kept looping and it printed each error. And if we add another error to the logData here, so this is how you can use a while loop to keep looping over the exec function until it stops finding results. And that captures the major things that you need to know about the Regex object. There's a lot to it, so you might want to come back and review this clip if you didn't quite catch it all.

Summary
In this module, we learned about the Math object and how it encapsulates a host of math constants, like Math.PI for the value of PI and other constants. The Mozilla developer documentation is a great place to look for more info on the various Math functions available. We also took a look at the Date object. The key takeaways are that you can create a new date that represents the current date like this. We also learned that there are a few constructors for creating dates with specific dates and time. We then discovered the various methods to inspect the different date and time parts of a date, and don't forget that the number returned by getMonth is zero based. That can trip you up if you forget. Also remember that these functions use the local time zone, and that there are UTC versions that return values in the Universal Time. Finally, we looked at the Regex object. Remember that there are two different ways to create a regular expression using the new keyword or using the Regex shorthand, and then you can use the test function, which will return a boolean indicating whether the string contains text that matches the regular expression. We also looked at the exec command to search a string, and remember that the Regex object is stateful, meaning that you can call exec multiple times and keep finding multiple matches in the string. And with that summary, this wraps up this module and course. In this course, we also learned how to create objects using object literals, constructor functions, and classes, how to modify property descriptors with Object.defineProperty, and how to create property getters and setters. We took a deep look into what prototypes are and how they affect inheritance behind the scenes, and how to create inheritance chains with constructor functions and with classes. Thanks for joining me, and I hope you've enjoyed this course on JavaScript Objects, Prototypes, and Classes.
