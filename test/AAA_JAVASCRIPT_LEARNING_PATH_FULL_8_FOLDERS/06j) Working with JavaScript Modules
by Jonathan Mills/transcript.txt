resource will be at root level working_javascript_modules.zip


At the core of JavaScript is a thorough knowledge of Modules. In this course, Working with JavaScript Modules, you’ll learn how to break your code out into modules in a logical way and use those modules in your application. First, you’ll learn what modules are and why you should use them. Next, you’ll explore how to import and export code from modules. Finally, you’ll discover how to use those modules in a real-world application. When you’re finished with this course, you’ll have a foundational knowledge of modules that will help you as you move forward to build easier to maintain JavaScript applications. Software required: JavaScript.

Course Overview
Course Overview
Hi everyone. My name's Jonathan Mills, and welcome to my course, Working with JavaScript Modules. Now I'm a technology adviser at Worldwide Technologies and a frequent speaker on JavaScript topics around the globe, and sometimes working with JavaScript can feel unwieldy or awkward, especially if you're doing it in just your HTML files or in a vanilla JavaScript application. And sometimes even outside of that our JavaScript can evolve into just a massive spaghetti code that's really gross and hard to deal with in all of our JavaScript files. Now in this course, we're going to talk about how to break that up a little bit and start breaking code into smaller, usable pieces using the new ES6 module syntax. In this course, we're going to talk about what modules are and why in the world we would even use them. We're going to talk about creating modules and then exporting individual pieces of that module out for the rest of your application. And once you're exporting code, now you're going to need to import that code, so we're going to talk about the import keyword and how to use that appropriately. We'll do all of this in the context of a real-world example so you can see the mechanics of it as we go. By the end of this course, you'll have put both import and export into practice and understand how to start breaking up your own applications into modules. Now before beginning this course, you should be familiar with JavaScript in general, but you won't need any framework knowledge, no React or Angular or anything like that yet. You will apply this to those, but you don't need to know those in order to understand modules. Now I hope you'll join me on this journey to learn about building reusable and maintainable JavaScript code with the Working with JavaScript Modules course, here at Pluralsight.

What Is a Module?
Introduction
Welcome to Working with JavaScript Modules, and in this module, we're going to kind of start from the beginning and we're going to talk about what a module is and how you start to use them. Now to get started, I had mentioned that we're going to wrap the entire conversation in a real-world environment. So, we're going to take a minute or 2 to set up our demo environment. We're going to download some code from GitHub and we're going to get some things up and running, and we'll start to look at the problem set and why we need modules. And once we get through that, we'll talk about what modules are and what the syntax is a little bit and why you use them and how you go about getting those created. And then we're going to talk about some things to think about because modules work a little bit differently than many other things in JavaScript. So, we just want to talk briefly about a couple of things to keep in mind as we go and build out the rest of the course. So the first thing to do, let's go get our demo environment set up.

Setting the Scene
Before we get going on modules, let's take a minute to set the scene here. We're going to run this course in the context of the Globomantics user conference. Now this is a website that we have inherited, and honestly, the code's a little gross. So, over the course of this course, you're going to clean it up and break some of this JavaScript out into modules for better maintainability. Now I've gone ahead and set up the starting point in GitHub, so let's take a minute and get that downloaded and installed. Let's go out to my GitHub repo, and I've set up a bit.ly link for you if you would like that, and you can click here to download or to clone the repo based upon your own personal preferences. This is really the only interaction with GitHub that I'm going have, so I'm not going to dig in very much here. If you're not familiar with GitHub, just click Download and drop it in a folder somewhere. Now right now I have this set up to run in a very lightweight Node application. You don't need to know anything about Node to go through the course, but if you don't have Node installed, it's a very simple process out here on nodejs.org, just download the LTS version and you should be good to go. Once you have the code downloaded and Node installed, open the code directory up in your favorite IDE. Now for this course, I'm going to run everything in VS Code. You're free to use any IDE you want, but VS Code is emerging as the default standard for web development, so that's what I'm going to use. Once you have the code downloaded and opened in your IDE, we're going to run two commands to get this up and running, npm install, which will get Express and Morgan installed, and then we're going to run npm start to run the website on port 3000. So now let's open this up in Chrome, and there you see our Globomantics website. If you scroll down, this section right here is the part we'll be playing with in this course. So let's look at the code behind this piece and start this process.

Cleanup the Old Way
Okay, now that we have this thing up and running, let's take a couple of minutes and look at how we would deal with this situation before modules and what problems modules are actually trying to solve. So, if you come out to this Globomantics website that we have up and running and we go to the code back behind it, let's go into public, and then index.html. Now in here if we scroll way down towards the bottom where our JavaScript is, you're going to see, let's slide this over, you're going to see a lot of code. So we've got sessionTemplate that has a whole template for returning a session. You have this render function, you've got our data items right there. All of this code is sitting in this index.html, and its sole purpose is to populate these items right here, and that data is coming out of this sessions.json file. If we look in there, you'll see those three items. Okay, now we know for sure we don't want all of this code sitting in our index.html, and so typically what we would do is we'd come in here into JavaScript, our js folder, create a new file, and call it app.js. Then we come back over to index and we scroll up to this script tag right here to our getSessions, scroll all the way down to the getSessions, we'll cut that, clean it up just a little bit. This chunk of code right here is for the hamburger menu and we don't want to mess with that, so we'll just leave that there. We'll save that. And then in app.js, we'll drop all that code in. Save it, come back over to index.html, and we add a script tag, script src app.js, let's add the js in front of it. Now if we save that and go back over to our window, we refresh, and notice it still works. Now, just in case we go to inspect just to make sure it's working right, and now if we look down here, there's our script, app.js. If we go to Sources in js, you see now we have our app.js. So, that worked. But it still has a problem because everything's available still at the top level, and we can see that. If we come back over here and we scroll down to this script tag here. If I just say console.log data.listItems, which is where we're storing all of that session information when we get it back from our sessions.json file, we still have access to this data object even though it's not in index.html. Check this out. I'll keep my console open, I'll refresh my page, and look, I have this empty array. And the reason it's empty is because it gets loaded here in a minute. So, actually, if we just wrap this in a setTimeout and just wait a second before I run that console.log and I refresh, now you'll see, look, there's all my stuff. So that's not a really good idea. I don't want to expose all of my JavaScript up to the parent level, so it's not good enough just to pull everything out into a separate JavaScript file. So what we would do then, is we'd come into our app.js and we'd wrap this in what we call an IIFE. And now an IFFE is an immediately invoked function expression. And what it looks like is that. And so we say this is a function, we take all of our code, and we drop it inside. And now what's going to happen is when app.js gets called, it's going to run this code and it's not going to share anything outside of its scope. So if I save that, come back over here and refresh, now you see it still worked, but notice it blew up because data is not defined. So that's good. We're protecting things from the global scope and we're hiding things from index.html. So index.html is all nice and clean, but you you have this weird, funky IIFE grossness, and it's not really easy to surface things back up to the global scope that we can share back with index.html, and we want a way to clean that up and make that nice, and that's where modules come in and that's where modules will make our lives a lot easier. And so what we're going to do over the course of the rest of this course is we're going to talk about how modules are going to give us the ability to take this code and partition it out somewhere and share pieces of it back and forth across either other modules or back up into our index and make our code a lot cleaner and easier to follow.

What Are Modules?
Luckily for us, we no longer have to rely on weird syntax or kludgy workarounds to build clean, standalone bundles of code. ES6 has introduced a mechanism that allows us to build modules natively in JavaScript. Now we do that with two new keywords, import and export. Export is the keyword we use to create the module, and then import is going to be the keyword we used to consume that module. So here's a hint: that's going to be module 3 and module 4, respectively, of this course. Now, the import and export keywords allow us to encapsulate our code into a single protected entity. Basically, that means we get to create this little bundle of code that we can package up and then only expose pieces out to help guide understanding about what this chunk of code can do and utilize that chunk of code in a meaningful way. Now then that allows us to control access to the code as well. We saw in that last clip, just putting code in a script file doesn't prevent you from accessing individual members of that code, and we don't really want to allow that, and modules are going to allow us to protect our code so that people who are consuming our code can't necessarily go in and make changes to what's going on. And last but not least, we can reference our own dependencies internally. Now what that means is that if a piece of code needs to reference like a Lodash function or something similar to that, I don't have to import that globally into the whole application. I can just use it in my one module to keep scope to a to a minimum. Now, before we dive into what this looks like in practice, let's take a quick look about some of the considerations you need to think about as we go through and work through modules because some of these are pretty different than what you might expect or what you're used to. First, modules are singletons, and what that means is when you export something from a module, every other thing that imports that module gets the same instance of it. And now that can be super helpful out of the gate, but can cause some oddities if you don't expect it. Just keep that in mind. You're using the same thing everywhere that you import a module. Now, along those lines, the individual items exported are not just values, but they're pointers or bindings to the properties. Now we'll dig a little bit more into that a little bit later, but just know that if something is exported and then changed, it changes everywhere. Also, once you define what's being exposed through an export, you can't change it later at run time. Once it's loaded, it stays how it is, and that can be a little weird in JavaScript where you can normally change anything at run time, like nothing is static in JavaScript, well, except the things you're exporting out of a module, those are static. We also have one module per file. Modules are filed-based, and if you're loading multiple modules into your browser, you're going to request those files one at a time over HTTP. And let's talk about that for just a second because that can be a little disconcerting. Now, when we get to HTTP/2, that'll make things a little bit more palatable because that's going to hold up in a socket connection, you load multiple files, and that'll be fine, but in the meantime when we get through modules, normally what we're going to do is use a module bundler like webpack or something like that to consolidate them all down into one file. Now, we're not going to cover specifically the use of webpack or something like that in this course. This is just to get us an understanding of what modules are and how to use them, and then depending on your implementation, you may pick a module bundler that's going to work for you.

Summary
All right, so we have just gotten started in this course working with modules in JavaScript, and so far we've only got a couple of things, but we set up our demo environment. So if you don't have your demo environment working, that's going to be important if you're going to follow through for the rest of this course. So take just a minute, go back to that second clip, and get your demo environment up and running. Secondly, we talked about what modules are and just a little bit of the four basic characteristics of things that make up what a module is and why they're going to be beneficial to us moving forward. And lastly, we talked about just a couple of things that are a little bit different in modules. So, as you're using modules and as we go through the rest of this course, there's just a few things that are a little weird potentially about modules that you want to make sure you're paying attention to as we go through the rest of this course and just as you use modules in your day job. All right, now that we're there, we should have a demo environment up, we understand what modules are, let's take the rest of this course to actually go in and start writing modules and then consuming them in modules 3 and 4.

Creating Modules
Introduction
All right, now it's time to get to work with creating modules. And if you're dropping in for just this piece, that's fine. In the last module, we set up our demo code, and we basically have a little demo environment that we've got going on that we can start to play around with some code. And you can just watch and follow along, you don't have to code along if you don't want to, but if you are, great, you should be up and running and ready to go. All right, now in this module we're going to start creating some modules using the export keyword. And basically what the export keyword is going to do is allow us to take this bundle of code and just present pieces of it out to the consuming applications. And this is done in one of three different ways, and we're going to cover all three in this module, the first one being named exports. Basically, I'm going to take a thing, a function or variable or something, and I'm going to export it out to the larger world. And when you import it, you've got to know the name of it, so import the same name as the thing that we export, and that's a really easy way to get multiple things out to the larger consuming application. But we also have default exports, and that's the next thing we'll talk about is what if I don't want to have to know what the name is. When you call session repo, we're going to give you this thing and that's all you're going to get. And that's default exports, and we'll talk about that a little bit. You can also do both of them at the same time, and we'll cover that when we get down there and basically say, hey, I have a default export, but here's a couple of named exports as well. And the last piece is aggregating modules, and basically that's I'm going to export another module. I'm not going to import it first, I'm just going to directly export it. And the reason we're going to do that is because it's going to allow us to keep our imports tight in our app.js. Basically app.js doesn't need to know about all these different modules, it just needs to know about the one, and that one module will pull things together and re-export it, and that'll make a lot more sense once we get down to that piece. All right, so buckle in. Let's go. Let's go talk about named exports.

Named Exports
All right, let's get this thing started by building out a module using named exports. Now, if you go into our demo code that we have before you, look at app.js. We've got a whole bunch of code in here, and the whole point of what we're trying to do is we're going to start pulling this out into modules, and the first thing we're going to pull out is this template that we have. So there's a function starting right here on line 13 called sessionTemplate. We're just going to grab that whole thing and we're going to cut that. We're going to create a new file called template.js. Let's just paste that in there. All right, so now we have a chunk of code in a file called template ready to go, except nothing can get to it, right? So the whole point of this is we want to expose some things, and what we're going to do just so I can work through what all the different styles of named exports are is we're going to break this up a little bit, we'll clean up this function some. So let's come up here and we're going to do, we're going to create an error message and we're going to take this error and stick it up there. All right. And then if there's an error, we're going to return an error message. Now, we also have this function here, and I'm not a huge proponent of having anonymous functions inside my map, so let's just cut that out and let's say, hey, sessions.map applyTemplate. And then right here on line 3 we'll paste that function and give it a name of applyTemplate. Clean everything up. Now, I have three items in this JavaScript file, I've got my error message, I've got my function, applyTemplate, and I've got my sessionTemplate. And really, all I want is for the consuming application to know what sessionTemplate is. And I don't want it to know about anything else, I just want to know about that, and the way we do that using export is I can come in here, there's a couple different ways, but the first way we're going to talk about is I just say export function sessionTemplate. Now I'll give you a little sneak peek. We'll talk about this next time in the next module, but this gets exported, sessionTemplate gets exported, and then I just import it on the other side, I just do import sessionTemplate. And notice the curly braces there, that's how this is going to be exposed. And actually I can come up, if we just copy this, I can actually just export my error message and I can export my applyTemplate, I can export everything that I want and just export it all. And that's fine. Then I could just import all those things in a list. That's one way to do it, and that's fine. You can go through and you can look through this JavaScript file and see everything that's being exported. There's another way to go about this, and it's the way that I prefer, which is to bundle all that up. And so we'll come down here at the bottom and we're going to say export, and we're going to make a list. So we're going to say sessionTemplate, and let's just export sessionTemplate and errorMessage, that's all we need to export. We don't need to export anything else. We don't need export this applyTemplate because this is just a private function that only sessionTemplate uses. So let's save that. Now I have a module called template that's going to work just fine, and the only thing available to anything consuming this module is the errorMessage and the sessionTemplate, and that's all. All right, let's do one more thing. Let's go back over to app and we've got this getSessions thing. So let's apply the same premise to that. So if I right-click on JS, let's create a new file called sessionRepository.js. So let's do getSessions, let's cut that, just that one piece. And so we're going to create a little repository that's going to handle the getting of sessions. And we're going to do the same thing we just did on the other side. So I'm going to come down here and we're going to create a a sessionURL. This is where the sessions come from. We'll just cut that out there. All right, now that we have that, let's use this sessionURL right here, and then we're going to store the sessionList. Excellent. So now, instead of right here when everything comes back, instead of just resolving and sending the target response, let's just save that sessionList just like that. All right, now I have the sessionList that's available, I've got getSessions, which goes out and and pulls everything from our sessions.json file, and I've got my URL. Now I don't want my URL exposed out to the world. I don't want my sessionList necessarily exposed out to the world, all right, I just want my getSessions. And so I can come back down here, same as before, and say export getSessions. And remember, so you'll notice the red underline, that's not how this works, right? Declaration or statement expected. Well, that's because it takes a list like that, right? If I can export up there just fine, and that'll work, but if I'm going to export down here, I have to export as a list, just like that. And that's what I want to do. That ultimately is all there is to a named export, right? So I have created a named thing and then have exported it. Now I can change the name, I could come in here and say as sessions, and that'll work just fine. And when I do my import, I'm importing sessions, not getSessions, so I can rename things right there as I want to. All right, so that's named exports, but I have to know the name of things when I'm importing them, right? And I don't necessarily want that for my session repositories, right? I want to just import session repository. I don't want to have to know what all the pieces are, so that's where defaults comes in. And so let's look at what export default meets.

Default Exports
All right, so we've seen named exports, and the struggle with named exports is that you have to know what the names or the things are inside that module before you can use it, and I don't necessarily want to do that. So, there we have default exports, and that's what we're going to play with now is how do I export something and say this is the default thing that you get when you go. And you may imagine from the name it involves using the keyword default, and you'd be totally right. So let's look at this for just a second. I'm going to comment this line out, and then I come up here to getSessions. Now with default, I can just do this, export default getSessions, right? And what that means is now if I do an import from sessionRepository, I'm going to get this function, and I don't have to know the name of this function, I just get this function, and the same thing that works for any part of this, const sessionURL export default. Now you can only export one thing as the default, you can't export a bunch of things as default, it wouldn't work. What would you get? So, let's go back down here. This is one way to do it. And I would do an import, notice import sessions, right, that's how that works. And so my other option is if I come down here, if I keep this mentality around it, I can say as default. And now I'm exporting getSessions as default, and same import, it works the same way, but now this is my default thing. Now, I can also come in here and I could do my named exports too. I can still export my sessionURL, but my getSessions is my default. And so that's what we're going to do. And the purpose of default is just to simplify up how you're doing your imports, right? I don't want to have to expose everything out to everybody else, I just want to have, you know, hey, just just call my module and I'm going to give you this thing and you don't have to worry about what it's called, just call it whatever you want on the other side. So that's a default export. And when we go over to the import side, we'll put that into practice.

Aggregating Modules
All right, the last thing I want to talk about real quick is aggregating modules. So, one of the things we want to do is make sure our modules are compact and they're tight, but at the same time I don't want to have to import a whole bunch of different things. And let's look at what this looks like. If I come back over to app.js, right now we've pulled out our sessionRepository and our template both, and we're going to use sessionRepository right here in getSessions, when we do the imports, that's where that's got to go. But then up hear we're also using sessionTemplate and we pull that out to template.js, and so now I have to import two things. I have to import from sessionRepository and I have to import the template. So what I want to do, as said, is just import everything from the one thing, from sessionRepository. So, what we're going to do when we do that is come back over here to sessionRepository, and then I can actually just export my sessionTemplate right here and then have it all come together. Now, template.js does not get added to scope for sessionRepository in any way. Like, I can't access that anywhere, it's not an import. But I can just say hey, also in addition to exporting getSessions and my sessionURL, also export sessionTemplate from this other thing over here. And this allows me to keep what's being imported into app.js very minimalistic and tight. I'm just importing the one thing from that one section, and that's all that I'm importing. Okay, now I've got all my exports, so let's summarize just real quick and then let's go build some imports.

Summary
All right, we've started the process of breaking our code out into modules by using the export keyword to go create modules. And it was really quick, it's not a whole lot of content here, it's just knowing what this export keyword is and how we use it. And we started with named exports and we exported a bunch of stuff from sessionTemplate and from our sessionRepository, and we just said, hey, export this thing and then you have to import it by name, and that's kind of the downside of that. Then we talked about default exports, and default exports basically said export this thing and you don't have to know what it's called. It doesn't matter what it's called because when I just do an import from, I'm going to get this thing out of it. And lastly, we talked about aggregating modules, basically re-exporting a module immediately. So I'm not importing it to my scope, I'm just re-exporting it externally, and then I can aggregate everything up into just one bundle. All right, so that's export. That's half the job. Now let's go and look at import, and we can pull all this stuff together and make it all work

Using Modules
Introduction
All right, in the last module we built a module, basically. We have our sessionRepo module ready to go, and in this module, we're going to start using those modules just to keep saying the word module over and over again as much as we can. So that's what we're going to do. We're going to start by looking at the new keyword that we use to import items from a module into our code, and that's going to be the import keyword. And there's some complexity to it, and the first thing we're going to do is we're going to talk about actually being able to use modules. There's some things we need to do in our script tag that are going to allow that to happen. We'll also look at compatibility, like what browsers allow you to do this and which ones don't. Then we're going to talk about default imports. In the last module, we talked about default exports, now we're going to how do we import those items into our code and we're going to make our code work again by having a default import out of our session repository. Then we're going to work with named imports. So, we were doing named exports, now we're going to go import those couple other things that we were getting out of our session repository. We'll pull those things out. Okay, now that we've got this laid out, let's go look at how to turn this thing on.

Enabling Modules
All right, in this first section, what we're going to talk about is actually setting up modules. So in our browser, being able to use modules in our app.js. And the first thing we're going to look at when we're talking about setting things up in the browser is actually looking at browser compatibility for our import statement. And notice, Chrome, Edge, Firefox, Opera, Safari, all your web views, except for Samsung, they all work. Internet Explorer doesn't work, so you can't do modules in Internet Explorer, but all the rest of these browsers in a fairly up-to-date version are all going to work. So just make sure you've got a browser of this level and you should be ready to go. So if you go into your code in index.html in this app that we've been following along in, if you're just dropping in, that's fine. You don't have to follow along if you don't want to, but if you do, jump back a couple of modules and download our demo code from GitHub and follow along from there, but right here we have app.js and we want to convert app.js to be module based, not just our standard JavaScript style. So what we actually have to do is come in right here and say type=module, and what that's going to do is turn on modules for this piece and allow us to use the import and export statements inside JavaScript. If we don't have that type=module there, it doesn't work. Everything kind of falls apart. So this just lets the browser know that that's the type of thing that we're doing.

Default Imports
All right, now that we have modules enabled, let's actually start using this thing that we built in this last module by talking about default imports. Now what we're going to do is we're going to go into our app.js, and we're going to start to change this up to leverage the sessionRepository and template that we built in the last module. So the first thing we're going to do is we're going to get rid of this IIFE. We don't need that anymore, we don't want it, and it won't work if we did. So, let's format real quick. There we go. Now, I need two things. I need getSessions that's going to come from the sessionRepository, and I need sessionTemplate, which is going to come out of our template. But if you recall from the last module, we are re-exporting sessionTemplate right here so everything is going to come out of sessionRepository. But the first thing we're going to do is actually just do this. We're going to import getSessions from sessionRepository.js, just like that. And what that means, this is what we call a default import. So it doesn't matter what I named this, I could actually just call this import jon, and this thing will still work. It doesn't matter what it's called, and that's the reason why it's called a default import because I don't have to worry about what sessionRepository is. If you go back to sessionRepository, remember, we are exporting getSessions as default, and that's what's getting exported is this getsSessions function. But from the app perspective, we don't care what it's called. So let's go back to having it called getSessions just so we are all on the same page. Now that's a default import. That's all there is to it. And actually, just so we can have this thing up and running, let's go into template, and actually, let's export sessionTemplate. Let's export sessionTemplate as default as well. Then we'll just come in here. Now I have both getSessions and sessionTemplate both being imported, and as long as we get rid of that export, we'll put that back in in the next clip, as long as we're there, now our app should work again. Everything should just work and pull in, so let's look at this. If we come back over to our Globomantics website and we go to Network, first of all, I want to show you this. Let's clear. I'm going to refresh, and you see template and sessionRepository both are pulled in, look at this, from app.js lines 1 and 2. And so if we come back over to our code, app.js lines 1 and 2 are where we pull those things from. So that import statement is what's actually going and pulling those two files. If we come back over to our code and go to our console, we'll see no errors and everything works. So that's the default import. We're back up and running and everything works in the default way. Now, there were some other things that weren't default that I might want access to. If we come back over to our sessionRepository, you'll notice I'm also exporting the URL, and actually, I just want to explore the sessionTemplate right here, so I don't need those two things. We don't do that with default imports, we do that with named imports. So, let's look for just a minute at what that's going to look like.

Named Imports
All right, now that we have default exports working and our application is back up and running, let's look at named imports, which means let's look at some of these other things that we're exporting for our modules and see how to get a hold of those as we pull them in. All right, while we prepare to put template back together, let's go over to our template.js. Let's actually not export that as default because I've got two things. I've got sessionTemplate and errorMessage, and I want to import maybe both of those things into my app.js. So when we do that, instead of saying import sessionTemplate, like import default, now we're going to import by name. And basically what that means is I've got to come over here in the same way we export, I just have to import it with the curly braces on either side. And then I could just say import sessionTemplate and import errorMessage from template. And now these have to be the same. Remember, getSessions didn't have to be the same name as what was coming out of sessionRepository because it's just exporting the default. But in this case, sessionTemplate and errorMessage have to be the same name as what's coming in. And so I may not want them to be the same name, and so I have the option to come in here and just say, you know, as template, I can totally do that, and then just change sessionTemplate down there to be template, that's totally viable and that totally works. Or I could just leave it like this, however I want to do it. And I'll save, and let's go back to our website, we'll refresh, and notice everything still works. So this is how you do named imports. You just import sessionTemplate and errorMessage. Now I'm importing everything from template, and it seems kind of silly if I have to to just kind of list everything out, so I don't actually have to do that. I can say import * as template from template.js, and what that's going to do is take everything that's exported from template.js and drop it into a namespace or an object called template. And then I can take that with a dot and say, hey, template.sessionTemplate, and now that's going to work. If I come back over to my website and refresh, you'll see everything still works. Excellent. So that's named imports. I can import star, I can import the individual things, but remember here I was re-exporting in sessionRepository, I was re-exporting sessionTemplate because I don't want to have to do both things. So if I save that after I got rid of the comment and I come back over here, I can actually just get rid of that and just say, hey, I'm importing getSessions and then I'm importing also sessionTemplate. And the rules for this type of import are the same. So basically what I'm doing here is I'm saying import getSessions, so important the default, and then in addition to the default, give me all the named stuff. So, sessionRepository has coming out of it sessionURL and sessionTemplate in addition to the default of getSessions. So here I've got import getSessions, the default, and then sessionTemplate and sessionURL coming back out. Now I can do the same thing I was doing before, * as sessionRepository, let's say sessionRepository.sessionTemplate, and now I've got my default, getSessions, and then everything else coming from sessionRepository. So, that's named imports, that's default imports, that's hybrid imports where you're importing kind of your default and your named and everything all together, and now what we have is a module called sessionRepository that deals with all of our session stuff. It provides the getSessions method, it provides the template that we're going to render for, it does all the work, and it's bundled and separated away from our index.html code and even our app.js code. App.js can't get to anything that isn't exposed to it from our sessionRepository. So one more time, let's pop over to our app, we'll refresh this, and notice now in our network, template.js is coming out of sessionRepository instead of app.js and sessionRepository is coming out of app.js, so see how those imports have moved around. And when we refresh, everything works, but now instead of having everything baked into our index.html where we have all this gross code sitting in here, now everything's nice and split up and easier to understand and reason about what's going on.

Summary
All right, that's it. That gets us through this brief course on JavaScript Modules. And over the course of this course, we started by talking about what modules are and how they're these little packages of code that we can expose pieces of, but other than that are secure and safe in just being their own bundle. We talked about creating modules with the export keyword. We use export to either export named pieces or export as default to export default pieces of code out to the consuming application. And then we talked about consuming those modules, so being the consuming application, with the import keyword, and it's import, the default thing, or import and a list of names to import all the pieces out of that module. And with this, basically you have all the information you need to go and start chunking your code up and getting to having small, reusable pieces of code bundled together as a module and just exposing the pieces. Now from here, you may want to go and look at something like webpack, which is going to bundle those modules together and make them a little bit easier to consume holistically instead of having a whole bunch of different files. That would be the next step that you would take from this spot.

