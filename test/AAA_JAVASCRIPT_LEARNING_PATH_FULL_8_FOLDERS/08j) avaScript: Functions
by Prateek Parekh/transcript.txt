Code is hard to maintain, especially when you keep adding new features to your project over several months and years. If you are not careful, you can end up with spaghetti code where several parts of the project are essentially doing the same task and any change in one feature can cause changes in several other parts of the code. In this course, JavaScript: Functions, you’ll learn the foundational knowledge to write modular code that not only prevents duplication, but also increases code readability and maintainability. First, you’ll explore what Functions are and how to write them. Next, you’ll discover the power of Arrow Functions in improving readability. Finally, you’ll gain the ability to use additional language features that come with JavaScript out-of-the-box to write applications with multiple functions interacting with each other. When you’re finished with this course, you’ll have the skills and knowledge of Functions needed to write modular, re-usable, and concise code in JavaScript.

Course Overview
Course Overview
Hi everyone. My name is Prateek, and welcome to my course, JavaScript: Functions. I'm a senior staff engineer at eBay. JavaScript has consistently been listed as the most commonly used programming language, and functions are at the very heart of JavaScript. In this course, you are going to learn how functions can help you write modular, reusable, and maintainable code. Some of the major topics that we'll cover include functions and scope, arrow functions, call, apply, and bind methods, rest parameters, and the spread operator. By the end of this course, you'll know not only how to write your own functions, but also call and leverage the power of existing functions. Before beginning the course, you should be familiar with the basics of JavaScript, like variables, expressions, and conditional statements. I hope you'll join me on this journey to learn functions with the JavaScript: Functions course, at Pluralsight.

Writing Modular Code with Functions
Introduction
Hi everyone. I'm Prateek. Welcome to this course on JavaScript Functions. This course will teach you how to write modular, concise, and reasonable code with functions. Before we dive in, let's review what we'll be covering in this module. First, we learn what a function is, why use them, and how to write and run them. Next we introduce arguments and how they let us pass information to our functions. We also cover how the variables in a function are scoped and how to access them correctly. Then, we look at Immediately Invoked Function Expression, also known as the IIFE pattern, and compare it with regular functions. Next, we introduce closures. A closure is a combination of a function and its context. The context contains the variables defined in the function, as well as those that are visible to the function when it was first defined. We'll look into it in more detail later on in the module. Finally, this course is filled with demos, so I really encourage you to code along. The more you practice, the better you will understand these concepts. Let's get started.

Setting up the Environment
Let's take a look at the development environment we'll be using for this course. All the demos in this course will be done in Visual Studio Code, which can be downloaded from code.visualstudio.com. To get the most out of this course, you should already know the basics of JavaScript, things like how to use variables to store information, the different data types like string, numbers, and boolean values, and how to write conditional statements and loops. There are several Pluralsight courses you can look at if you need a refresher or you are completely new to JavaScript. Once you have downloaded and installed Visual Studio Code, open the editor. Let's briefly review how we will run our demos. First, install the live server extension by clicking the Extensions tab on the left. This will let us change our code and view the output at the same time. Next, we have two files in the same directory. We have an index.html file with some template code, and in the body tag, we have an h1 tag with the JavaScript Demo and script tag that references the app.js file. This template can be easily generated in Visual Studio Code by typing exclamation followed by the Tab key, and then you only have to reference the app.js in the body as shown here. You can right‑click and select Open with Live Server, and this will open up the browser displaying the content of your h1 tag inside the body tag. And any changes you make and save in your HTML file will immediately be reflected in your browser. Since we'll be printing our output to the console, you should open the developer tools in your browser as shown here. Next, we look at this empty app.js file referenced in our index.html file. This is where we'll be spending most of our time in the demos. If you type console.log Hello world here and save, it shows up in the browser console. With the environment setup out of the way, we are ready to move on.

Introducing Functions
Functions are at the very heart of JavaScript. They are a powerful tool that lets you create reusable chunks of code. They make coding faster, easier, and less error prone. So let's look at a simple definition of what a function is. A function is a block of organized, reusable code that's used to perform a single related action. In other words, it's a set of statements that perform a task or calculates a value. To use a function, you must first define it. Here's a simple example. A function declaration consists of the function keyword, followed by the name of the function, a list of optional parameters enclosed in parentheses separated by commas, one or most statements that define the body of the function. These are enclosed in curly brackets as shown here. Note that the function definition by itself doesn't really do anything. In order to run a function, you have to invoke it. This is done by calling the function as shown in the statement here. You include the function name, followed by parenthesis, and a semicolon. The output here would be Hello John. Another thing to note here is that by default, all functions return a value. In our example, the returned value is undefined. So how do we go about returning a value? We do this by including the return statement at the end of our function body. This is similar to our previous example. Instead of printing the Hello John string through the console inside the greeting function, we return it. This return value is collected in the message variable that the greetings function is being invoked. We then print the message variable to the console. Before we look at another example, let's clarify the difference between an argument and a parameter. An argument is a value that we pass to the function when we invoke it. A parameter, on the other hand, is a variable that we list as part of a function definition. In this example, we define a function called sum that takes in two parameters. We invoke the sum function with arguments of values 2 and 3, and assign the return value to the result variable. Finally, we output the value of result variable to the console. In this example, we have a function name greetings with one parameter name. In the function body, we can reference this parameter just like any other variable. We invoke this function with the argument name whose value is initially set to John, and then we invoke the same function with the argument Mary. Can you see the flexibility arguments provide us? This is especially useful when we get to more complex examples that do a lot not more than printing to the console. Now let's look at the arguments object. There may be times when you need to invoke a function with an indefinite number of arguments. The arguments object allows us to represent them as an array‑like object. It's array like and not exactly an array because it has a length property, and all values are indexed beginning at 0 index; however, it doesn't have other built‑in array methods, like for each and map. In this example, we define a function that prints all the arguments that are passed to it. First, we invoke it with 5 arguments, and then we invoke the same function with only 2 arguments. ES6 allows us to achieve the same result using REST parameters, and we will revisit this example in one of the subsequent modules. Let's see some of these examples in action in our demo. To begin, let's take our first example from earlier. Here, we have the greetings function definition, and notice how we have to invoke the function to get the output in the console. Next, we have the same function, but we return the message instead of printing it to the console. One thing to keep in mind here is that when your function is returning a value, you should assign it to a variable, as we are doing here with the message variable. If you don't, you simply lose the return value. In this example, we're calling the sum function with values 2 and 3. The result, 5, is displayed in the console. What happens if your number of arguments and parameters don't match? Let's try it out. We invoke the sum function with only one argument. The output is an n, which stands for not a number. This is because when the sum function doesn't get any value for num2, it defaults to undefined, and JavaScript evaluates the addition of num1 and undefined as not a number. This is our example from earlier with the arguments object. We are able to invoke the same function, printAll, with different number of arguments. The output is displayed in the console.

Understanding Function Scope
It's important that we understand the lifetime of variables within a function. In this example, we have a function greeting that simply declares a variable message and assign the value Hello to it. We invoke the greeting function first. When we try to access the message variable, we get a reference error. This is because message has function scope, and as soon as the greeting function completes execution, the message variable is no longer available. In other words, message is now out of scope. Here's another example. We have a greeting function with the message variable initialized through the string Hello, but we also have a nested function, sayHi. This is a function expression in which the function Hi is set to the variable sayHi. In the nested function body, we log out the message to the console. We add a statement invoking the sayHi function at the end of the body of the greeting function. Finally, we invoke the greeting function to start its execution. Notice that when we get to the line where the output is being redirected to the console, the message variable is still in scope, even though it's not declared inside the nested function. Whenever a function cannot find a variable, it looks to its parent function. So its able to find the message variable right here. Moreover, JavaScript will keep looking at a parent and its parent for deeply nested functions until it either finds a variable, or you'll get a reference error. Let's look at one more example. Here we have the same function as before, but this time we declare another variable message inside the nested function sayHi. We set it to the value's hi closed nested function body with the curly brace. We then invoke the sayHi function before logging the value of the message to the console. So you could choose the same variable name as the variable in the parent function, but it will go out of scope as soon as the nested function completes, and you get the value Hello in the console. Let's see function scope in action in Visual Studio Code. Here we get a reference error since message variable is declared inside the greeting function. If we move its declaration outside the function, we can see its value in the console. In this example, we declare another message variable, which is completely different from the variable by the same name in the parent function. As discussed earlier, when we print its value outside the nested function, we get the value Hello and not Hi. However, if we override the message value, then we get Hi as we are referring to the same variable.

Understanding Block Scope
Block scope was introduced in JavaScript in the ES2015 release. Before we look at an example, let's clarify what exactly is a block. When we say block, we are referring to the code placed between curly braces. So with block scope, we are talking about the lifetime of variables within the curly brace of an if statement, a while, or a for loop, or any set of curly braces other than a function. Also, note that the variables declared with the var keyword or created by function declarations do not have block scope. Examples will make this clearer. We have an if statement that evaluates to true, and inside the body of the function, we declare and set the value of count variable to 100. Next, we print the value of count to the console, but get a syntax error. Why? The count variable was declared inside the if block, and as soon as the code block execution completed, it went out of scope. This is similar to the last example. Here we are declaring another variable with same name as the variable before the if block and setting it to inside if block. Then, we log the message variable and it prints Inside if block. But when we print the message variable again outside the if block, it prints Hello. So, as you can see, we are allowed to reuse variable names within code blocks, but they override the value of message while the block is being executed. Once the execution moves outside of the block, the value is still what it was before the if block code execution started. Let's see this in action in our demo. In our first example, as we saw earlier, trying to access and print the value of count results in a ReferenceError. However, if we change the type of count to var, then we get 100. This shows that count no longer has block scope. Therefore, it is always a good practice to use let instead of var to declare your variables. Next, we'll take a look at immediately invoked function expression, also known as the IIFE pattern.

Immediately Invoked Function Expression
The IIFE pattern lets us group our code and have it work in isolation, independent of any other code. It stands for immediately invoked function expression. Let's break it down. A function expression lets us define a function and assign a true variable. Immediately invoked means invoking the function immediately where it's defined. Let's see an example. Here's a regular function that we have already been working with. In order to run it, we call the function name followed by a parenthesis. Next, here's the IIFE function that accomplishes the same thing; however, note that it doesn't have a name and it's completely inside parentheses. Finally, it has an opening and closing parentheses appended to it, followed by a semicolon. This function will be invoked right away. To make it a function expression, we just assign it to a variable or use it in some other expression. We will review this with an example, but before that, let's take a look at closures.

How Closures Work
We really looked at how variables and nested functions go out of scope once the functional block they're contained in completes execution. However, there are times when we would want to hold onto them, even after a function is executed. Closures allows us to do just that. Here is a familiar example. We have available greeting that is set to an IIFE. The body of the IIFE contains a variable message set to Hello and another variable getMessage set to an anonymous function that just returns the message variable. If you try to print greeting.message, we get undefined as the message variable is out of scope. So how do we prevent message and getMessage from going out of scope? We use closures as shown in the next slide. This is the same as the last example, but we create a closure right here. Return object with a property getMessage and the value is the function getMessage. Typically, the property and value names are the same, but they don't have to be. This object is what gets assigned to the greeting variable. At the very bottom, we log the greeting.getMessage output. Here is another example of when we would want to use a closure. We have a setup counter function with one input parameter. Inside the body of this function, we return another function counter that simply increments the input parameter val. Next, we invoke the setupCounter with the argument 0 and assign it to the variable counter1. We then invoke the counter1 setupCounter again with the argument 10 and assign it to the variable counter2. Finally, we invoke the counter2 function and print the output to the console. This time, we see an output of 10. In this way, different invocations of setup counter function produce different functions with their own context and variables. Let's run this example in Visual Studio Code in our demo. We define a setupCounter function as discussed earlier. Next, we are setting up two functions, counter1 and counter2. Each of them have their own environment and variables, and anytime we call either counter1 or counter2, the variable that was initially set up in the context is incremented. Let's run it and we can see the expected output. Calling the counter function again keeps incrementing the value returned. This brings us to the end of our module. Let's read what we covered so far.

Summary
Introduce functions, what they are, why we need them, and their syntax. Next, we looked at how arguments let us pass information to functions, and also how to use arguments object to arrow through the list of input parameters. Then, we looked at function and block scope and why it's good practice to use the led keyword, instead of var. Finally, we looked at how powerful the IIFE pattern is and how they can work with closures to hold onto variables declared in a function even after the function has completed execution. In the next module, we'll take a look at arrow functions.

Improving Readability with Arrow Functions
Overview
As a JavaScript developer, you will spend a considerable amount of time defining and invoking functions. Arrow functions provide you a syntactically compact alternative to a regular function expression. Let's see what we'll cover in this module. We'll begin with looking at what are arrow functions, what problems do they address, and when you produce them over regular functions. Additionally, we'll also look at some of the side effects of using arrow functions that you should be aware of. Next, we learned how to define arrow functions. We take a regular function first and then go step by step on how you could replace it with an arrow function. We'll go through a few different examples as an arrow function can look very different depending on the number of instructions and parameters in its body. We'll also review what exactly is the this keyword in JavaScript and how its behavior changes in an arrow function compared to a regular function. Finally, we'll see arrow functions in action in our demo. We'll cover a wide range of examples that really gives you an appreciation of how much value arrow functions provide.

Introducing Arrow Functions
What exactly is an arrow function, and how do we write them? They are anonymous functions with their own unique syntax. In this module, we will go through a few examples to illustrate not only how to write them, but also how they differ from regular functions. Arrow functions were introduced in the ES6 version of JavaScript. If you come from a Java or Python background, you may also know them as lambda expressions. They greatly simplify creating function expressions. This will become a lot clearer when we rewrite some of the examples from a previous module using arrow functions. So, why would you want to use them? Well, normally they make our code concise and more readable because of the shorter syntax, but it's also a lot easier to understand how variables are scoped within them. Again, we'll go through a few examples to really illustrate this point. One thing to note here is that arrow functions are not really a substitute for regular functions. When you use arrow functions, you have to be aware of several side effects, especially around how the this keyword behaves, as well as how they don't have their own implicit arguments object. So, we can't really reference the arguments object the way we did in the last module.

Writing Arrow Functions
Here's our first example. We declare an anonymous function with no parameters and whose body contains a single statement returning the string, Hello World!. This function is then assigned to the variable greetings. Next, we invoke this function and collect the return value in the message variable. Finally, we output the value of message to the console. The output as expected is Hello world! Now let's write the same code using arrow functions. Our anonymous function has been replaced by opening and closing parentheses. This implies that there are no input parameters. This is followed by an equal sign, immediately followed by a greater than sign. Finally, we have a block containing the body of our arrow function inside the opening and closing curly braces. This block is identical to the block in our previous example. Just like before, we are assigning this arrow function to the greetings variable before printing it to the console. We can simplify it further. Since a function body only has one statement, we can omit the braces, as well as the return statement as shown here. The string Hello World! is implicitly returned and assigned to the greeting variable. Let's see an example with one parameter. This is the same example that we have already been working with in this course. Instead of an anonymous function, we define a greetings function that takes in one input parameter called name and returns to string with Hello prepended to the name parameter. This function is signed to the greet variable. Finally, we invoke this greet function with argument John and assign the value returned to a variable message before printing it to the console. Now here's the arrow function where the empty parentheses have been replaced with the input parameter name. Everything else is exactly the same. So what did we learn here? If you have only one input parameter, the parentheses around it is optional. This makes our code even more concise, and you'll come across JavaScript code with arrow functions defined in this manner all the time in the real world.

Demo: Add 2 numbers
Let's see arrow functions in action in our demo. We'll begin with defining a regular function to add two numbers, and then change it to use arrow functions. First, let's define our sum function. It takes two input parameters and returns their sum in the body. We then invoke the sum function with arguments 10 and 5, and assign the returned value to the variable output. We then log the output value to the console. As you can see, the value 15 is displayed in the console. Now, let's follow the steps to change this into an arrow function. First, we remove the function keyword and the function name. Then, let's create a variable sum to hold the value returned by the arrow function. Next, we add the equal sign, immediately followed by the greater‑than sign before the opening curly brace. Now, since there's only one statement inside the function body, we can delete the return keyword, as well as the opening and closing curly braces, and move everything on one line. Finally, we invoked the function with values 10 and 7, and save. As you can see, the value 17 is now displayed in the console.

Behavior of This Keyword
Before we look into the behavior of this inside an arrow function, let's briefly review the this keyword. In JavaScript, this always refers to the owner of the function we are executing. So if it's a standard function, this refers to the global window object; otherwise, it can refer to the object that a function is a method of. The point to note here is that unlike regular functions, arrow functions do not have their own this value. Moreover, the value of this is always inherited from the enclosing scope.

Demo: Using This Keyword
Let's see this in action in a demo. To begin with, we define the message object having a property name with value John. Next, we have two additional properties, regularFunction and arrowFunction. Each of these properties has a value that is a function. In regularFunction, we print the string Hello, followed by the value in this.name. In arrowFunction, we print the string Hi, which is again followed by the value in this.name. Finally, we invoke both these functions one after another. In the console, the regularFunction prints out Hello John. However, the arrow function just prints out the string Hi. This is because when we log our message.regularFunction, our this keyword refers to the message object that holds a function. So when we access this.name, we get John. Let's print out the value of this inside the regularFunction. As you can see, its value is the message object. Next, when we call message.arrowFunction, it looks for the name variable in the global context, the Window object, and cannot find it. Therefore, only Hi gets printed to the console. If we try to print this.name, we get an empty string. If we try to print just the value of this, we can see the Window object in the console. That brings us to the end of this module. Let's see what we have covered so far.

Summary
We began with understanding what are arrow functions and why would we use them. Then, we went through several examples on how we can define an arrow function. Finally, we looked at how the this object gets its value in regular functions and arrow functions. In the next module, we'll look at function prototypes.

Changing Function Context and Built-in Functions
Overview
A function in JavaScript is really a specialized kind of object, and since functions are objects, they can have properties and methods just like any other object. In this module, we'll first understand the different ways in which a function can be created and how the context is set in each of those cases. Then, we'll look at the call and apply methods and how they allow you to indirectly invoke a function as if it were a method of some other object. Next, we'll look at how the bind method lets us bind a function to an object and return a copy of another function. Finally, we'll look at some of JavaScript's built‑in functions. These include eval, parseInt, parseFloat, escape, and unescape. By the end of this module, you'll feel comfortable understanding when to use the call, apply, and bind methods and what benefits the built‑in JavaScript functions provide. Let's begin.

Understanding Function Context
Before we look at the call function, let's review the different ways in which we can create a function and how does that affect the value of the this object? Here's the function we have seen in the previous module. We're simply printing the string Hi and the value of this to the console. In the previous module, we learned that every JavaScript function while executing has a reference to its current execution context to the this keyword. So what would be the value of this here? As expected, it's first to the global Window object. Now here's another example. This time we declare a greeting variable and assign an empty object to it. Then, we define a property, sayHi, whose value is an anonymous function. Its body is the same as that of the earlier function. Now the value of this is no longer the global window object because the execution context in this function is different. The value of this now refers to the object referenced by the greeting variable. Let's look at yet another way of functions created in JavaScript. This time we are using the new keyword when invoking the sayHi function. This is also known as the constructive function. The value of this here will be an empty object. Any time you invoke a function with a new keyword, JavaScript implicitly creates an empty object within the function before returning it. So in my example, the variable greeting will hold this empty object.

What Is the call Method?
So now that we have a good understanding of how that this object gets its value, let's look at the call method. In this example, we have two objects with properties name and age assigned to the variables, person1 and person2. Next, we have a function expression sayHi that prints the string Hi followed by the values stored in the this.name. We know that calling the function sayHi just prints Hi as this reports to the global window object which does not have a name property. What we really want here is to set the value of this to something other than the current execution context. Every JavaScript function object has a few properties that come out of the box. One of these properties is the call method and you can pass another object as an argument to this call method as can be seen right here. Passing the person1 object to the call method as an argument of sayHi binds the value of this in sayHi to the person object, and this time, the string Hi, John gets printed to the console. In the same way, when we pass person2, the value Hi, Mary is printed to the console. You can also pass additional arguments to the call method. Here, we are passing a message variable in addition to the person1 object. Call lets you run the function, sayHi, in the context of the first argument message. Let's see this in action in our demo. In this example, as expected, we get Hi, John and Hi, Mary in the console. Let's comment both our call methods and just run the sayHi function, save the file, and the string Hi is printed to the console as a window object doesn't really have a property called name. Another thing to note here is that calling the sayHi.call method without any arguments is the same as calling the sayHi function. Also, you can only invoked the call method on another function. Calling person1.call will result in a type error as person1 is not a function.

What Is the apply Method?
Just like call, every function object also has an apply method. In the examples we have seen so far, you can easily replace a call with an apply method. How does an apply then differ from a call? While the apply method syntax looks almost identical to that of a call, call accepts an argument list, while apply accepts a single array of arguments. We have an introduction function that takes in two parameters and prints out a message. First, we call the introduction function with the arguments John and student. Next, we call the same function once with apply and then with the call method. Note that the apply method takes in an array as the argument, while the call method takes a list of arguments. We are not really changing the function context of this value here, so we just pass undefined as the first argument. So how do we decide when to use a call or an apply? Use the apply method when the input parameter is already in the form of an array consisting of similar values; otherwise, if you're dealing with multiple arguments that are not really related to each other, use the call method. Let's see this in action. This is our example from earlier. We define the introduction function and invoke it in three different ways. Note that we pass the input in the form of an array to apply, where as call accepts all the input as separate arguments. The output of all the three functions is printed to the console.

What Is the bind Method?
With call and apply, we call an existing function and change the function context that is the value of the this object. But what if we would like to make a copy of a function and then change the value of this? The bind method allows us to do just that. Here, we have a person1 object with the name property set to Mary and a getName function that just returns the value and name. Next, we have another person2 object with the name property set to John. When we call bind on the person1.getName function and pass the person2 object as an argument, a new function is created and returned and assigned to the getNameCopy variable. Additionally, the value of this in the new function is set to the person2 object. Therefore, when we print the output of the getNameCopy method call, it returns John, and this way, we are no longer changing the context of an existing function the way we did in call and apply, but instead create a new copy of function and then change its context to another object. Let's look at the bind method in our demo. Again, this is our example from earlier. If you saved the output from invoking the getNameCopy function, John is printed to the console. If we just print getNameCopy, it prints the body of the anonymous function to the console. Note, however, that this is a copy of the getName function in person1. Next, we look at some of the built‑in JavaScript functions.

Using Built-in Functions
JavaScript has several functions built into the language. In this module, we'll look at what they are and how to use them. We begin with the eval function. Eval, as its name suggests, accepts a string as input, a valued set, and returns a value. We have two variables, x and y, initialized to the values 1 and 2, respectively. Next, we append the output of the eval function that takes an expression and string format as input. The value 4 is spread due to the console. In this example, we declare additional string variable s with value abc. If you try to evaluate the expression, x + y + s, the string value 3abc is displayed in the console. Therefore, when JavaScript comes across a string value abc, it concatenates that value with the number 3 and returns a string value. The function parseInt parses a string and returns an integer. Optionally, you can also specify an additional base or radix argument to return an integer of that base. If the first document cannot be converted to a number, then parseInt returns a special value of NaN, not a number. Here, both the statements spread 15 to the console. The first statement returns the value F and base 16 while the second statement returns a value of 15 in decimal, which is also 15. The third statement returns a not a number. ParseFloat works just like parseInt, but it returns a floating point number. The first 2 statements here return 3.99 and 39.9, respectively, and we get not a number for the third statement as an empty string cannot be parsed to a floating point number. Escape returns the hexadecimal encoding of an argument in the isolated one character set. For example, alphanumeric characters like a text is text in this character set, while non‑alphanumeric characters are represented as percent XX, where XX is a hexadecimal encoding of the RC character in the isolated one character set. Unescape does the opposite of escape, it returns the RC string for a given input value. Let's run these functions in our demo. This is our eval function. If we save the file, the expression x + y + 1 is evaluated first and then 4 is printed to the console. When we declare another variable s with the value abc and pass the string x + y + s to the console, the numbers are added first and then concatenated with the string abc printing 3abc to the console. Here, we are printing the output of three separate calls to parseInt. Each parseInt function takes two arguments, a string and the base the value needs to be parsed to. If only the value is provided, the decimal place is assumed. So we get not a number for the value F and 15 for the value 15. Again, we are printing the output on three separate calls to parseFloat here to the console. And if the input is invalid, the output in the console is not a number. Finally, we are making three calls to escape, followed by three calls to unescape, and the output is displayed in the console. There is the output from the escape statements as the input for the unescaped statements. This shows us how encoding and decoding works. This brings us to the end of the module. Let's review what we covered in this module.

Summary
We began with how and when to use the apply and call methods, how they differ from each other, and how they let us chain the context to another object. We also looked at how the bind function lets us create a copy of a function and then change the function context. Finally, we looked at some of the built‑in functions in JavaScript and when to use them. In the next module, we'll look at the spread and rest parameters.

Constructing Rest Parameters and the Spread Operator
Overview
In this module, we'll cover additional JavaScript features that work very well with functions. These include default and rest parameters and the spread operator. Although these features are relatively new to JavaScript, they really provide a great deal of flexibility in how you define and use functions. Let's get started.

What Are Default Parameters?
Default parameters allow you to give a default value to a parameter in a function. Here's an example. We have a function, sayHi, that takes in a parameter name and contains a single line of statement. This is what is called a default parameter. We have two ways we can invoke the function sayHi. First, we invoke it without any arguments, as shown here. The name variable will be initialized with the value World, printing Hello World to the console. Next, we invoke the function, sayHi, with an argument like John. This time since we have provided a value for name, the string Hello John will be printed to the console. Let's take a look at another example. Here we have the same function as earlier, but it takes an additional parameter message without any default value. First, we invoke the function, sayHi, with only the argument, Hello. In this case, the name parameter value is World and Hello World is displayed to the console. Then, we invoke the function, sayHi, again with two arguments, Hi and John. Now, the output is Hi John. Please note that the default parameter in our function definition should always come after the regular parameters. So in our sayHi function here, message cannot come after the name parameter. Let's see this in action in our demo. Here's the first example. If we save the file, we get the expected output in the console. Here's the second example with the additional message parameter. Again, we save and get the expected output printed to the console. If we move the message parameter after the name parameter, we get undefined in the console and message never gets initialized; therefore, always declare the default parameter after the regular parameters in your function definition.

Constructing Rest Parameters
With rest parameters, you can define a function to store multiple arguments in a single array. This is especially useful when you're invoking a function with multiple arguments. Let's look at it in more detail with an example. Here we define a greet function with the names parameter. The dot, dot, dot is what makes names a rest parameter and allows greet to accept multiple arguments, as shown here. We pass three string values, Mary, John, and James to the greet function. The names parameter stores all of these values as an array. In the greet function, we call the forEach method on the names array. We iterate over each name value and print the string Hi, followed by the name, to the console. So the rest parameter really allows us to send any number of arguments to a function and then collect them in an array. Here's another example. We have the same greet function, but with an additional parameter message. Again, just like the default parameters, rest parameters should appear after any regular parameters in your function definition. We call the greet function with four arguments, Welcome, Mary, John, James. The value Welcome gets assigned to the message parameter, while the rest of the arguments get stored as an array in the names parameter. This is also how a rest parameter gets its name. It always stores the rest or remaining arguments as an array. Let's run this example in our demo. Here's a greet function with the message parameter and the rest parameter names. We call the function with the values Welcome, Mary, John, and James, and save. The output is printed to the console. Let's see what happens if we remove the message parameter from the function definition. We also remove the first statement so that we don't get a reference error. Now, the welcome string is part of the rest parameter names, and we get this unexpected line, Hi Welcome, in the console. This is not what we want. So even though rest parameters provide a great deal of flexibility, you need to be careful when they are mixed with regular parameters. Let's set the message parameter after names and save. We get the error stating that rest parameter must be the last formal parameter. That's expected, as we want the rest of the arguments to be stored in a rest parameter and not a regular parameter. Next, let's take a look at the spread operator.

Using the Spread Operator
The spread operator is the opposite of how a rest parameter works. It allows a function to take an array as an argument and then spread out its elements so that they can be assigned to individual parameters. Here we have a function greet with 2 parameters, person1 and person2. We invoke the function, but instead of passing in two arguments, we pass an array with the spread operator. Although it looks very similar to the rest parameter example in the previous module, we are doing the opposite here. We are passing an array as an argument and then spreading its elements into individual parameters of the function. So the two values and names get assigned to person1 and person2, and the output Hello Mary and John is displayed in the console. In this example, we define a function display with four parameters and print them to the console. Next, we declare and initialize the variable letters to the string abcd. Finally, we call the display function, passing the string letters as an argument along with the spread operator dot, dot, dot. The output is printed to the console. Since string is an array of characters, each of the characters in the variable letters is spread out to the parameters of the display function, so the spread operator can be used with any iterable like string, array, or list. Let's take a look at the spread operator in the demo. The display function accepts four parameters and prints them to the console. The string abcd is assigned to the variable letters. We run the display function, passing in the letters variable using the spread operator. So the first letter gets assigned to char1, the second to the char2, and so on. When we save, we get the output abcd in the console. What happens if we initialize letters with more than four letters and then run the display function? As we can see, the additional letters never get collected, since we only have four parameters. What if we had a rest parameter call others to the display function and then print it to the console? As you can see, all the additional letters get stored in the rest parameter, so it's easy to use both rest parameters and the spread operator at the same time. To review, while the rest parameter collects individual arguments and stores them in an array, the spread operator takes an array as argument and spreads it into individual parameters. Let's wrap up this module with the summary.

Summary
We first looked at default parameters and how you can use the equal to sign to assign a default value to a parameter when defining a function. Then, we looked at rest parameters and how we can use the dot, dot, dot notation with a parameter in a function definition such that we can store a list of arguments as an array. Finally, we looked at the spread operator, which allows us to pass an array with the dot, dot, dot notation and have its elements spread across various parameters. This wraps up the module and this course. By now, you should be familiar with all the different ways you can create functions in JavaScript to write modular, readable, and reusable code. With some practice and effort, writing and working with functions in its various forms will become second nature to you. You can continue your journey to master JavaScript with several other courses on Pluralsight.
