At the core of working with variables and types in JavaScript is a thorough knowledge of employing variables, literals and assignments, and applying primitive types. In this course, JavaScript Variables and Types, you’ll learn how to work with variables and types in JavaScript. First, you’ll learn how to employ variables. Next, you’ll explore employing literals and assignments. Finally, you’ll discover how to apply primitive types. When you’re finished with this course, you’ll have a foundational knowledge of employing variables, literals and assignments, and applying primitive types that will help you as you move forward to work with variables and types in JavaScript.

Course Overview
Course Overview
Hi everyone, my name is Barry, and welcome to my course, JavaScript Variables and Types. I am an independent software developer and architect with a passion for the cloud and web development. JavaScript is one of the most used programming languages for developing web applications. Because of that, you should learn as much as you can about it so that you can excel at creating web applications. In this course, you are going to learn some advanced JavaScript topics that can help you to make your code more readable and maintainable. Some of the major topics that we will cover include template literals and tagged templates, the difference between the let and const keywords, and how to test strings for specific content. By the end of this course, you'll know how to make your JavaScript code more maintainable. Before beginning the course, you should be familiar with JavaScript and the basics of web development. I hope you'll join me on this journey to learn some advanced JavaScript features with the JavaScript Variables and Types course, at Pluralsight.

Using Variables, Literals, and Assignments
How This Course Works
Hi, I'm Barry. Welcome to this course about JavaScript variables and types. This course will teach you some advanced concepts and techniques in JavaScript that can help you to create readable and maintainable code. In this first module, you'll learn about variable use, string literals, and array and object deconstruction, which assigns values to new variables. And before we dive into the code, we'll discuss how this course works and what you need to follow along, and after that, you can enjoy lots of demos to learn some advanced JavaScript techniques. Ready? Let's dive in. Before we dive in, I want to quickly show you how this course works and how you can follow along with the demos. I've set up the demos as simply as I can so that you don't have to do a lot of complicated setup to follow along. All the demos are done in Visual Studio Code, which is a simple yet powerful code editor, which is available for most platforms. You can download it for free at code.visualstudio .com. I also assume that you already know what JavaScript is and how it works. You should also know the basics of web development, so what the structure of a basic website looks like and how it is used to paint a website on the screen of the user. The demos are all done using a simple website. You need the code for the website to follow along. In the next slide, I'll show you where to get it. And finally, the course contains lots of demos. Most techniques are explained in simple demos, and some are explained through slides. The demos are built around a simple web application, which you can download from GitHub at this address. All right, let's take a look at the demo application. Here it is in Visual Studio Code. Here you can see the files of the web application. It is a simple app that has an HTML file, some CSS, and most importantly for us, a JavaScript file. You can get this code straight from Visual Studio Code by doing View, Command Palette, and then use the Git Clone command and enter the URL of the GitHub repository for the demo code. Alternatively, you can also go to the GitHub page of that address and download or clone the code manually. Let's take a look. The application is used to apply for a loan. The JavaScript code base is messy, and we are going to use some advanced JavaScript techniques to make it more readable and maintainable. This is the index.html file, which is the only HTML file. It contains a table with fields that users need to fill in to apply for a loan. These are things like their name and date of birth. Also, we have a CSS file. This contains the basic styles for the web application. Nothing fancy here. And this site.js file is what this course is all about. This is the JavaScript that makes the application work. It is pretty straightforward and, like I said, pretty messy. It defines a loan application class that we use to store applications for loans in. We store those applications in this array here, and when the application loads, we load some existing loan applications into the array so that we have something to play with. A loan application consists of an applicant's name, date of birth, annual income, and some risk factors like if she has kids or other loans. Applicants also need to fill in the purpose for the loan and the amount they want to borrow. When the application loads, it populates an HTML select element, which is a drop-down list with the preloaded loan applications. I do that here by iterating over the array with the applications and creating new items for the drop-down list. And when a user clicks on an item in the drop-down list, the loan application gets loaded. This simply gets the loan application and loads its values into the input boxes on the screen. There is a lot more code in this JavaScript file. There are functions that validate the user's input and functions that add a new loan application. It's not important to know exactly how the app works. I'll cover the pieces that we need to clean up in the demos. So let's see this thing in action. You can run the web app by simply opening the file system like this and opening the index.html file in a browser. I use Google Chrome, but you can use your favorite browser if you want. Please avoid using Internet Explorer, as that doesn't play well with web standards and some of the things that we are going to cover. As you can see, I can load an existing application, and it creates a summary for me at the bottom, like this. All right, that's it. Enough introduction. Let's dive in. We'll start with a demo about JavaScript template literals and tagged template literals. These can help you to make strings more useful and readable in code. We'll also cover the difference between the let and const keywords, and we'll take a look at how to easily put values from arrays and objects into distinct variables using the destructuring syntax.

Using Template Literals
Here we are in Visual Studio Code. I have the JavaScript file for the web app open, and on the right I have opened the app in a browser. This way I can easily refresh the browser and show the result of what I'm doing in JavaScript. I'm in the loadApplication function. This is triggered when I click an existing loan application in the drop-down box. It finds the loan application and takes its values and puts them in the input elements. It also shows a summary, which I call the risk profile, right here. This is just text that is put in a label element and is generated by this function. Let's take a look. The generateRiskProfile uses the inputs from the user to generate a risk profile for the loan. Obviously, this is not how your bank does it. Well, I hope it doesn't. For instance, I take a look if your name and title has an MD, PhD, or doctor in there. If it has, the risk gets lowered. I also take a look at age and adjust the risk for that. And also, the amount that you want to borrow versus your income and so on. And here at the end the risk is calculated, and I aggregate that with some other details into a long string that I return and is displayed on the screen. We are going to focus on this string. This is not a great way to create a string like this. It is long and not very readable in code, especially on a screen like this. So what can we do? We can use a template literal to make this more readable and useful. A template literal is sometimes also called a string literal in JavaScript. How do we do that? First, I want to make this one long string without the concatenation, like this. Remove this one and this one. Okay. And now I use backticks to indicate that this is a template literal. There we go. And here is the beautiful part. I can now add variables through interpolation with a dollar sign and curly braces. This will add the applicant name at runtime. I'll do this one as well. And finally, the risk profile also. Okay, let's save this and see if it still works. Refresh the browser, and load an application. All right, it still works. Oh, I do have an additional period here though. This is the text that I insert that says that the application will be reviewed or not. All right, I would also like to format the text by creating line breaks. I can easily do that in a template literal by formatting it how I want it to look. And it automatically preserves the line breaks. See, it works. Let's add another one. This also improves the readability of the code as it is much more clear what is happening now. Let me change it slightly by taking this string and put it in here. Now add the loan amount as well. I just want to show what that looks like. This is the amount that the user wants to borrow. I still need a currency sign in front of that. I can, for instance, do that like this. I can create expressions in here that are simple like this or are more complex and add numbers or call functions. Pretty cool, right? That is a simple template literal. In the next clip, we'll expand on this example to make it more functional.

Create a Tagged Template Literal
Here is the template literal that we've created in the previous clip. It uses backticks, interpolation, and line breaks to create a string that contains dynamic values and formatting. I've added a line to the string that shows users their unique application code. Applicants can use this code as a reference code when they need to contact us to talk about their loan. This is a string that I generate randomly with the createApplicationId function here. The code always starts with the \t characters, so I've put that here. So every time that I load an application, you can see the new application code. It's not actually stored with the application as I generate it at runtime, I know, but it serves its purpose for this demo. The code that shows up here doesn't contain the \t. That is caused because \t is interpreted as a special character. \t is used to create tabs in HTML. Although it is not interpreted as such, it isn't shown here. So how can we fix that? We fix that by using the String.raw function in front of the template literal, like this. Let's save it and reload the page. Try it now, and yep, that works. The \t is now visible. The String.raw function takes the complete string of the template literal and renders it raw, including any escaped and special characters. In this case, String.raw is actually a tag for the template literal. We call it a tag because the template literal is now tagged with a function. The tag acts as a prerendering function. Let's make this a bit more interesting. We can create another function that we can use as a tag. We'll create one that can make certain parts of the template literal bold. In this function that we'll use, I define two parameters, strings, which contains all of the strings in the template literal in an array, and a spread of values. The … means that however many values there are, put them into an array called values. This is a conventional function signature for using tag templates. So what I can do now is create a loop that loops over the strings in the template literal, like this. And the stings are all the pieces of characters in the template that aren't values, so these ones here are all of the strings in the template, including the one at the end. No matter if it has content or not, this also a string. Now if i is greater than 0, I add a piece to the output string that contains the value in bold. I use when i is greater than 0 because the array of strings is always bigger than the values array. The template always starts with a string and ends with a string no matter what. Even if the start string is empty, it will start with an empty string. That's also why I use i-1 for the value here. Let me visualize that for you, like this. There are always more strings than values in a template literal. So after adding the value, I add the next string to the output string and continue the loop. And finally, I return the result. That's it. Now I can put this function in front of the template and thereby tagging the template with it. I can't also use the String.raw as I can only have one tag in front of a template. You can call another function from the tag and then another and another to create a chain of functions as a tag. Let's see if this works. Let's load an application. It kind of works. I do render the bold tags, but they aren't interpreted as HTML. I know why this is. I set the innerText and not the innerHTML value of the label. Let's see what happens when I change that. Okay, load an application. Much better. But there's a new problem now. I had to remove the String.raw tag, so the \t is now gone from the application code. Let's see if we can fix that. I can do it in the tag function. The strings parameter also contains a .raw array. These are the same strings, but raw, so with all escape characters and special characters. Only the strings array has a raw array. The values array doesn't have that. Let's try this out. Load one, and yeah, that works. It works because the \t is located in a string and not in a value. But now it isn't completely bold as it isn't part of the value. Let's fix that as well. Let's see. I can create a new variable here and put the application code in it. I'll make it a template literal as well, so with backticks and a dollar sign with curly braces. Template literals are very flexible. I can use a function as a value, like this. All right, so now I can remove the \t from here, and then I can use String.raw here to render everything in the string. And let's save it and reload the page. Okay, now load one up, and there it is. The \tis part of the value, so in bold. Cool. There's one final problem. The string isn't formatted any more. Now that we use the innerHTML feature, the line breaks that I use in the template literal don't translate into actual HTML line breaks, so I'll add them explicitly, like this. Obviously, you don't have to do this when you don't render your strings as HTML. Okay, save it, reload it, and try it out. That's it. Now it works. So you can use tagged template literals to prerender your template and do whatever you want with it, like format it.

The Difference Between Let and Const
Let's talk about the different ways to use variables in JavaScript. We are going to talk about the difference between the let and const keyword. To explain this concept, I'll first use slides and then apply it in the loan application demo code. To understand let and const, we need to talk about variable scoping. Here's a function. Within the function, I can have a variable that uses var. Because I use var here, I can use this variable x throughout the function, including in an if block here. And I can even reassign it in this block, and that changes the meaning of x throughout the function. Even outside the block, x is Hello. That is because var has a global and function scope and doesn't have a block scope. Let is different from var in that respect. Let does have a block scope. You can use let just as you use var to declare variables, but let has a block scope. So here, x in the if block is a completely new variable and only applies to the scope of the block. So x outside of the block always is the value of the var, not of the let. Block scope also applies to const. In that respect, const is exactly the same as let and can also be used to declare variables. So just like let, const can have a block scope. So in this example, const x doesn't exist outside of the if block, so using it outside of the block will result in an error. Now consider this example. We use a var y here, and directly after that, I redeclare y as a let with a different value. That is not allowed and results in an error, and that is because I cannot declare the same variable as a let in the same scope. The same is true in any scope, including within a block scope. In the if block, I cannot redeclare y as a let, buy y can be redeclared as a var even though var has a global scope and the y var is already declared in the function. Now to solidify that. It is not allowed to redeclare an existing variable as a let in the same scope no matter if the existing variable was a let or a var. But of course, I can redeclare a let within its own scope. So in these if blocks I can declare lets with the same name because they don't exist outside of the scope. This scoping mechanism of lets also applies to const variables. Here is how const is unique. You can use const to declare a variable, like this array. But because it is a const, you cannot reassign it. This will result in an error no matter what the type of the value is that you try to reassign it to, including null. Reassigning is not allowed, but that doesn't mean that a const is an actual constant because you can change values of the assignment, like this. So you cannot change the thing to which the const is assigned to, but you can change the content of the thing. That's pretty confusing, right? If you do want to create a variable that has a value that cannot change, you can do that with Object.freeze, like this. So why would you use const instead of let, which has the same scoping properties? You'd use it to indicate that your intention is to not change the value that it represents. To me, const is more of a readability helper than anything else. Let's sum that up. Variables that are created with var have no block scope, but a global or function scope. Existing variables can be redeclared anywhere, and they can be used and reassigned anywhere in their scope. Let variables can have a block scope, although you can use them as global or function scoped variables as well. They cannot be redeclared within their scope, and let variables can only be reassigned and changed within their scope. That means that if a let variable is created in a block, it only exists there and can only be reassigned to another value there. Just like let variables, const variables can have a block scope. But different from let variables, const variables cannot be reassigned or redeclared. They aren't completely immutable though, as you can change the value that a const references, like a property in an object or array. Let's apply what we've learned. There aren't many places where I would use a const to indicate that I don't want to change the value, but here I have a function that generates a unique ID that I use as the ID for the loan applications. It uses this var here as the ID, and that shouldn't change. So I'll change this to a const. As discussed, the main function for const, besides the block scope, is to indicate that this value shouldn't change. Okay, let's move on. In this function, I look through the loan applications and create new select elements for them so that they appear in the drop-down list box. I use the var el here in the function scope and in this block scope in the for loop. This won't cause any problems because I can safely reassign a var, but it could be confusing. So here I will change this into a let, and for consistency, I do that here as well. If you ask me, you shouldn't change all your variables to let and const. It's perfectly fine to use var. I think that you should use these keywords mainly as readability helpers that indicate your intention for the variables. When you do that consistently, you will also benefit from their functionality.

Use the Destructing Syntax to Get Values from Arrays and Objects
We are back in Visual Studio Code. Let's take a look at the app on the right. In there, you can see some check boxes. Loan applicants use them to indicate if they are employed or not and if they have other loans or credit cards. We use that information in their risk assessment. People without employment and an existing loan, for instance, are a high risk to loan money to. I store this information in an array called factors. And here, in this function, I take that array, and I deconstruct it into several variables that I use to create a loan application object with. This syntax is all right, but when I have a lot more of these values, this will get very messy and hard to read and maintain. It is also error prone because I need to manually make sure that I type in the right index of the array. We can change this for the better using the destructuring syntax. It goes like this. I declare something that looks like an array with the names of variables that I want that comes from the Factors array. These variables aren't actually in an array because they are on the left side of the equals sign. That's it. Now I can remove what I have here. Let's see if it still works. Reload it, and load an application. Yeah, the check boxes are still loaded, so it still works. This deconstructs the array into four distinct variables. To make this more readable, I can put all of these on a new line without breaking anything. Let's test that. Reload it, and yep, it still works. And I can even put a trailing comma here without breaking it. Nice. So what would happen if I removed one of these variables? The array now has more values than I assigned to variables. Let's see. Load one, and it still works. You don't have to use all of the values in the array. You can pick and choose which ones to deconstruct. This works the other way around as well. If I would have more variables than values in the array, the variables would be filled with undefined, but it would still work. And we can even do something like this, three dots and a name. The moreArgs variable is now an array that catches whatever is left in the array. This could, for instance, be 10 more values. This is useful when you don't know the exact length of the array. And finally, I can also put default values in here. So if there isn't a value in the array for this, then hasKids gets assigned true. All right, that is array deconstruction. We can also deconstruct objects. I'll do that with the LoanApplication class here. It has all sorts of properties, like ID and applicant name. Let's see how that works. I don't really need to deconstruct objects in my app, but I'll just demonstrate how to do it here. It works very similar to array deconstruction, only it starts with curly braces, and in there I can assign the parameters of the object to new variable names, like the Id value will be stored in a variable called a, and the ApplicantName value will be in variable b. And that's it. And also, here I can put everything on a new line for readability, like this. And I don't have to assign values to new variable names. I can just do it like this, which results in variables with the names Id and ApplicantName that I can use in the rest of my function. Also, I can use default values, just like with array deconstruction. All right, that's it. As you can see, using the destructuring syntax improves readability and makes deconstructing values into variables less error prone.

Summary and Where to Go Next
That's it for this module. Let's summarize what we've learned. This will help you remember and solidify your learning. We first saw template literals that helped to make strings more readable and useful. The syntax of a template literal is to use backticks and a dollar sign and curly braces for values that you want to insert. You can easily format your template by creating new lines in code, which are preserved in the rendering. We've also seen that we can tag template literals by putting a function in front of them, like this. This function gets the strings and the values in the template as an array. This allows you to do something with the template before you return it. And when you don't want to escape characters, you can use String.raw. You can use it as a tag for a template literal, and you can also use the strings.raw array that you get in a template tag function. We've seen that both let and const can have a block scope and that variables that are declared with var cannot. Let variables can be reassigned another value in their scope, but can't be redeclared in their scope. Const variables cannot be reassigned or redeclared. The value that they are assigned to can be changed, like a property in an object, but their assignment to the object cannot be changed. You use var, let, and const to indicate your intentions for the variable as readability helpers. Finally, we've seen the destructuring syntax. This can destruct an array and an object into distinct variables using this syntax. You can also use default values, and this syntax can be spread over multiple lines in code. All right, by now you might be wondering where to go to learn more about these topics. I found the following resources very useful. First is the MDN web docs from the Mozilla Developer Network. These are very in depth. Also, the W3Schools documentation is very good. You should check that out. And finally, I would recommend that you explore this Pluralsight course by Kyle Simpson. In this course, you can learn more about the topics that we've talked about in this module. All right, ready for the next module. Let's go.

Applying Primitive Types
Introduction
Welcome to this module, Applying Primitive Types. In this module, you'll learn about some advanced JavaScript techniques that you can apply to your primitive types. Specifically, you'll learn about the following topics in this module: how to test the strings for specific content with string functions and how to test numbers for the type and if they are safe. And finally, you'll learn what symbols are in JavaScript and what you can do with them. Are you ready for another module? All right, let's go.

Test Strings for Specific Content
Here we are in Visual Studio Code in the JavaScript file of our loan application, and this is the generateRiskProfile function. I use this to assess the risk of lending somebody money based on some values that the user puts in. The risk is expressed in a number and later on translated in a text that says if the risk is low, medium, or high. You can see that here, and it changes depending on the input. Okay, so the first thing I use to assess the risk is finding out if somebody is a doctor, PhD, or a medical doctor. Of course, that's a silly thing to test on, and I hope that your bank does this differently, but hey, it works for the demo. I test the applicant's name, which also includes the title, like PhD or MD, and I use the string.search method for that. This returns the position of the value within the string and returns -1 if it doesn't find anything. This results in a lot of searches and is not the most readable solution. Let's change this. Instead of using string.search, I can determine if the user has entered the doctor title by using string.startsWith because doctor is always at the start of the name, or at least that's what I'm assuming. This returns a Boolean if it finds the value dr, and it should also test for DR in capitals. That is silly. You know what? Let's do this. I'll trim the string so that I remove any white spaces at the beginning and end of the string, and then I will use toLowerCase to make the string lowercase. Now I only have to match the lowercase value. That makes things a lot more compact. So I'll implement the rest of the values as well, including different variations like ph.d with a period in between. And I assume that MD is always at the end of a name, so I'll use string.endsWith to test for that. And then I need to test for it with a period in between and also with a period at the end because endsWith tests for all the characters at the end of a string just like startsWith tests for all the starting characters. All right, now I can remove all of this and make it a lot simpler. I just have to test if these are true as they will be Boolean values, and if they are, I lower the risk. Nice! And I can remove the old code and keep the rest. This looks a lot better, right? Let's see if it works. Reload the page, and load an application. Yeah, that seems to still work. Good. Finally, let me show you this. StartsWith and endsWith take an optional parameter of position or length. For endsWith, this parameter indicates the length of the string to search. This means that you can end the search before the end of the string. For startsWith, this parameter indicates the position in the string to start the search at. All right, let's move on. I also test the string that contains the purpose for the loan. Here, people tell us what their purpose is. If I find any keywords like house or a vacation, the risk will be influenced. And again, I use string.search to search for these keywords. Let's change this. I'll look for the keyword house by using string.includes. This returns true if any of the string contains the value. And just like earlier, I'll make things easier by using trim and toLowerCase. Okay, let's search for the rest of the keywords. I'll search for holiday, like this, and I'll also search for vacation here. And finally, I'll search for business as I want to know if the loan will be used for a business. Cool! I can get rid of this and just test for house. The same goes here. I can just test for holiday or vacation. If any of these are true, the risk increases by three. And finally, I'll test for business here. And that's it. I can get rid of the old code. Again, this looks much cleaner and is much more readable. Let's test it and reload the page. And load one. Okay, that still works. There you go. You can use string.startsWith and endsWith and string.includes in addition to functions like string.search to find values in strings. And you can make things easier by using string.trim and toLowerCase or toUpperCase.

Test Numbers for Type and Safety
Let's talk about testing numbers. Here in the getLoanApplicationDataFromInputs function, I take data from the input fields in the page and create a LoanApplication object with it. This function is used in here in the validateApplication function. It gets the loan application and checks if all the fields are inputted correctly, for instance, by looking at the application date of birth. If that is undefined, the date wasn't entered, and the user can't save the application. Let's try that. I'll modify an existing application. Let's type letters in here instead of numbers and try and save it. Oh, that worked. It has been added to the list. Let's see that. Oh, it didn't really work. The date is scrambled, and the fields are filled with not a number values. Let's try something else. I'll clear the fields, and I'll type in a date with letters. This also calls the validateApplication function. This is actually seen as a valid date once all the fields are filled in. Okay, well, let's see why that happens. That should be here somewhere. This is it. I get the values for month, date, and year from the input fields here, and then I check if they are empty or not. And if not, I create a date regardless of what's in the values. That's what is going wrong. Okay, let's fix this. Instead of checking if the string is empty, I can check if it contains a number with Number.isInteger, like this. This returns true if the number is actually an integer and false if it isn't. And I'll do that for all the values. Okay, let me make it a bit more readable and save it and test it. Let's type in a date with letters and see if that works. And no, the validation message doesn't go away, so this isn't valid. What if I save it? Let's see. No, it isn't in the list, so it isn't saved. That worked! So what does Number.isInteger test? Let's take a look at it in the developer tools console. In Chrome, I can get to this by pressing F12. Let's test Number.isInteger on the string. That is false because that's not an integer. And what if I test it on 25? That is true because that is an integer. And 25.3. That is not an integer. And what about 25.0? That is also an integer because 25.0 is stored as 25 without the decimal. And what about something else like null? Also not an integer. And infinity. That's also false. Okay, this is very reliable. In JavaScript, all numbers, so integers and also floats, are all stored in the same way. They are all stored as double-precision floating-point numbers. Because of this storage mechanism, some larger numbers can lose precision. For instance, if I take this number and add 1 to it, it is still the same because of the rounding that happens because of its storage mechanism. And if I add 5 to the same number, you'd expect something else than this, right? When we use integers, we can prevent losing precision by using numbers that fall in between the MAX_SAFE_INTEGER value, which is this one, and the MIN_SAFE_INTEGER value, which is this one. And we can easily test if an integer falls in between these values with the Number.isSafeInteger function. We don't need to test for safe integers in our application, but just for fun I'll implement it here instead of Number.isInteger. It works the same. It only does an additional check to see if the value falls between the safe max and min values. And let's see if it still works. Yep, it works. So you can easily test to see if something is an integer by using Number.isInteger. And if you want to work with big integers and don't lose precision, you should check if they are safe with Number.isSafeInteger.

Understanding Symbols
Let's talk about symbols in JavaScript. You probably rarely use or see a symbol in code, but it's good to know what it is. Let's take a look. A symbol in JavaScript is a primitive data type that can be used as an identifier for object properties. Because this use case is pretty rare, I don't need it in the loan application, and so I'll explain symbols right here in these slides. Symbols are globally unique unguessable values. No symbol is exactly the same, and as developers, we have no way of knowing what the unique value of a symbol is. Let's explore that. This is the way that you can create a symbol. Notice that you don't use the new keyword. You just create one, like calling a function. Optionally, you can pass a string to the symbol when you create it. This string can be anything you like and is a label for the symbol. The string is something that you can see in your console to help you with debugging. So if you would log the id symbol out to the console like this, you would see symbol because that is the data type. And if you would log id.toString, you would see Symbol(My Id). So you'd see the string in the console that you passed as a parameter. You don't see the actual unique value of the symbol. That will always be hidden to us, and that's a good thing because it is unique and should stay that way. We can see that here, if I create two symbols, each with the same description, they would still be unique. If I test that by logging this in the console, I would get false. The string isn't the value of the symbol. The value is hidden to us. And so whenever you create a symbol, it will be a new, unique symbol. But we can reuse symbols that are already created. You can do that with the Symbol.for. In this example, I get the symbol with a description of My Id twice, and when I test to see if they are the same, I get true because these are the exact same symbols retrieved from the global registry. All right, so symbols are unique, and you can retrieve existing symbols. So when would you use a symbol? Well, you can use them to create a property on an object, like this. The object has a name property and one that has a unique value of a symbol as its name. We don't know and we shouldn't care about what the value is. We can access the property using the symbol like I do here. You might be asking yourself why you would do this. Well, here's the reason. When you use a symbol as a property name, it doesn't show up when you query the properties of the object, so you could use this to create a secret property. Using a symbol would be a good way to signal to other developers that this property is secret. However, it isn't completely hidden because you can find it when you call Object.getOwnPropertySymbols on the object. So you can use symbols to create kind of hidden object properties. Like I said, in the real world, you probably won't use symbols in your code, and you will rarely see them anywhere. In any case, you now know what they are.

Summary and Where to Go Next
Let's summarize this module. You've learned that you can test strings for certain content with lots of string functions. We've seen string.search that returns the index of the string. We've also seen string.trim and .toLowerCase that can help when we are searching in strings. And we've seen string.startsWith and .endsWith, which tests the start and the end of a string for a value and return a Boolean. These functions take an optional parameter. In string.startsWith, the parameter determines where the search starts, and in string.endsWith, the parameter determines where the search ends. And we've also seen string.includes, which returns true if the string contains the value at any position. You've also learned how to test if a value is an integer with Number.isInteger. This returns a Boolean that says if the value is a true integer and even returns true for 25.0, which is stored as 25. We've also seen that large integers lose their precision due to the way that they are stored. You can make sure that integers are safe from losing precision by testing them with the Number.isSafeInteger function. And finally, you've learned what symbols are in JavaScript. They are objects with a unique value that you can never access. And you can use symbols as parameters in objects that are somewhat hidden. All right, that's it! I want to leave you with some resources that you can use to learn more about the topics in this course and JavaScript in general. Again, I'll point out the Mozilla web developer documentation, which is really good, and also the W3Schools docs. And here are two Pluralsight courses that I highly recommend. These are pretty long, but they go very deep. Use them to your advantage to learn more. That's it for now. Thank you very much for taking this course. I hope you've enjoyed it. Keep learning, and I'll see you next time.
