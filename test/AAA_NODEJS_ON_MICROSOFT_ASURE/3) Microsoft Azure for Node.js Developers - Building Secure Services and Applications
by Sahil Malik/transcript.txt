Node.js in Azure can be used in many ways: web apps, functions, containers, and more. While writing these applications, you'll want to offer authentication and authorization using Azure AD. You'll want to give your applications identities using managed identity so they can access secure resources in a secure, monitored, and controlled manner. You'll want your application to save secrets, secrets that are well guarded, come with great monitoring, and more. In this course, Microsoft Azure for Node.js Developers - Building Secure Services and Applications, you'll learn how to write Node.js applications that can work in any form, and integrate and make use of all the facilities that Azure AD offers. You'll also find out how Node.js applications can be given managed identities, and how such applications can safely use secrets guarded by Azure Key Vault. By the end of this course, you'll have a good understanding of how to make use of the facilities Azure offers, helping you write secure applications in Node.js.

Course Overview
Course Overview
Hello. My name is Sahil Malik, and welcome to my course, Microsoft Azure for Node.js Developers ‑ Building Secure Services and Applications. Node.js is a very popular platform. It is no wonder that it is a first‑class citizen in Microsoft Azure. Writing secure applications is a pretty big topic, but how does Azure specifically help you in writing secure services and apps using Node.js? In this course, I explain how you can support modern authentication protocols for Node.js applications using Azure AD. I show you how you can build headless applications, web applications, web APIs, and so much more. I'm not afraid of details in this course, so we get a pretty good overview of permissions, scopes, forwarding user identity, calling Microsoft graph, and managing your applications. Also, every application needs to deal its secrets, right? So I explain with examples and code how to use managed identity and key vault. There is plenty of code in this course, and by the end of this course, you'll be well equipped in making use of the facilities that Azure offers when offering secure services and applications in Microsoft Azure using Node.js. I hope you find this course useful, and thank you for watching.

Node.js and Azure
Introduction
Welcome to Microsoft Azure for Node.js Developers Building Secure Services and Applications. Let's start by talking about Node.js in Azure. Where does Node.js fit inside of Azure? My name is Sahil Malik, and let me just say this, Azure is a very important topic, Node.js is a very popular platform, and I'm thrilled to be talking about this particular topic, where I'll be focusing on building secure services and applications using Node.js in Azure. Let's dive in. Starting with a little overview, what am I going to talk about here? The first question is, what can you even do with Node.js in Azure? The next question is, I'd like to introduce you to a very important player in the Microsoft ecosystem, which is Azure AD. This course is not an exhaustive treatment of Azure AD, but just enough for us to know. Then I will talk about Azure AD versus Azure Subscriptions, an often misunderstood topic, so I think it's worth demystifying that a little bit as well.

What Can You Do with Node.js in Azure?
Starting with what can you do with Node.js in Azure? Hmm, what can you do with Node.js in Azure? In order to answer this question, I would actually invite you to ask a different question. What can you do with Node.js? So I assume that you are a somewhat seasoned Node.js developer, and this is a question that you can probably answer yourself. But let's walk through this. What can you do with Node.js? You can write web applications with Node.js. I'm sure you've written a few. Or you can write web APIs, say REST APIs or otherwise. You can even package a Node.js application inside Docker containers or run them in Kubernetes. Or you could write serverless applications depending upon the cloud platform you pick. When you write Node.js applications, you have some concerns, like my application wants to have access to secrets or wants to be able to talk to a database, which needs a connection string, which has a secret, for example, and many more things. Node.js is incredibly popular. It's a very popular platform. You can do a lot with Node.js, right? So the point I'm trying to drive home here is that all these scenarios have a place in Azure. If you can do something with Node.js, chances are Azure can support you. So let's see some of these in example, and let's see how Azure supports them. For example, web applications and APIs. You can author a web application and API in Node.js and run it in a virtual machine. This VM, for instance, could run Windows or Linux, your choice. You can host Node.js applications as something called as Cloud Services. You can write serverless Node.js applications using something called as Azure Functions. And if you wish to containerize your Node.js applications, you can run them in AKS, Azure Kubernetes Services, or Azure Container Registry and instantiate a container in Azure as well. My point is no matter what kind of application you pick, there are some common concerns in all of these applications when we talk about security or secure services. What are those concerns? Well, identity management would be a concern, isn't it? I can't really think of an application which doesn't need to know something about the user that is running the application. Okay, perhaps Notepad. But let's say 99% of the applications care to know who the user is. I would argue even Notepad needs to know because when Notepad saves a file, it needs to save it at a place you have access to. So identity management, authentication and authorization, that is something that any application is entrusted in. Secret Management. Again, it's hard to imagine an application that doesn't have any secrets. If it's talking to a database, for example, if it's authenticating itself to another service, it needs to keep some secrets. So whatever platform you pick needs to support these two tenants, and I'm sure there are many other concerns. Now I'm not disillusioned by any means that security is a small topic. When we talk about writing secure applications, you know it's an infinite amount of concerns that you need to worry about. Many of those lie in plain Node.js programming. My concern around this course is purely around what Azure brings to the picture, and I'll be focusing on the first two tenants you see over here, which is identity management and secret management. So I won't be talking about things like how do you do encryption in Node.js and what is the right encryption algorithm? That's not part of this course because I already know that all that works in Azure. That's a portable Node.js concept that works in every platform. So what does Azure uniquely introduce? When we talk about identity management, the main player here in Azure is Azure AD, which is your one‑stop shop for modern authentication. I should mention that it's got way more than just authentication. For instance, it is fully integrable with your on‑premises infrastructure. So Microsoft has had a lot of history on‑premises, Active Directory Service, right? So Microsoft offers so much flexibility in integrating Azure AD to your on‑premises infrastructure and applications. And you know what? You don't have to integrate Azure AD with on‑premises infrastructure if that's how you choose to do it. A lot of flexibility over here. And it has a myriad off security features. For example, things like intrusion detection, AI‑powered intrusion detection, and a whole bunch of other things, like managing your devices, users, so much more. Azure AD is a big topic, and there's no way I can cover that in this course. But I'll give you a brief introduction, just enough so we can get through this course. Then we talk about secret management. Inside of Azure, there is a concept called as Azure Key Vault, which is your tool inside of Azure to store secrets, certificates, password, strings, whatever you wish. And then you need an identity to talk to that key vault. And inside of Azure, there is another concept called as managed identity, which allows you to give an identity to something that runs in Azure. For instance, a virtual machine can have its identity. And using the virtual machine's managed identity, you can talk to Key Vault or, for that matter, other services. The advantage of using Azure Key Vault and with a combination of managed identity is that there is no password for you to manage or reset or anything like that. It's all based on permission model, and it's very, very secure.

An Introduction to Azure AD
Now let's start with a brief introduction to Azure AD. In order to understand Azure AD, we need to understand the history of identity, at least at a very high level. There used to be thse legacy identity protocols, NTLM, Kerberos, etc., and legacy may not even be the right word for it because they're still widely in use; however, they've been around for a while, and they just don't scale to, let's say, you know, the modern internet or distributed applications, and so on, so forth. For that, modern identity has been introduced, claims‑based identity, SAML, WS‑Fed, OpenID Connect, etc. So, identity requirements have changed, and therefore we need a modern identity solution. What should such a modern, cloud‑based identity solution have? It should be able to manage users, devices, and applications. It's not just a matter of authenticating a user anymore, what about the device where the data lives, we need to be able to manage that as well. What if there's an application that needs service from this identity solution, as in authenticate users for me? Managing those applications is also very important, or for that matter, consuming third‑party applications. Such a solution should also scale to the internet. That doesn't just mean capacity, that also means supporting the various modern protocols that such a solution needs, like supporting OpenID Connect, for example, or many other such important protocols. Such a solution must be secure and resilient because now you're on the internet, and everybody's your neighbor, good people, bad people, and everybody is going to try to hack into your solution. So, this solution needs to stay ahead of the hackers. But when we talk about authentication in the Microsoft ecosystem, we generally have two main categories, on‑premises, where you use protocol such as NTLM or Kerberos, or you have cloud‑based authentication. But what if an on‑premises application needs to authenticate to the cloud or allow third‑party users, guest users authenticated by the cloud to use an on‑premises application? So there's a lot of gray over here, right, it's not just black or white, it's not just on‑premises or cloud, there's a big hybrid component here as well. So the way that works is that Azure AD has a lot of concepts where it allows you to sync on‑premises identities into the cloud, and then users, devices, or applications, all of them can consume the services provided by Azure AD, and they can be backed by your on‑premises infrastructure. Again, I must mention that there is a lot of flexibility in how you implement this because Microsoft has, I guess, millions of customers and millions of permutations and combinations they need to support, so there's a lot of flexibility and detail there, which I won't cover in this course, but there are plenty of other courses on Pluralsight that go into those details. My point being this infrastructure can provide you with authentication services and way more. But something else important happened here, all those identities are in the cloud now. Guess what, others have their Azure ADs as well, and now they can talk with each other. In fact, they talk to each other using standards‑based authentication, and as long as you stick with standards, it doesn't even have to be Azure AD, it just needs to follow standards, well‑accepted standards that are not invented by Microsoft, but are generally accepted by the community.

Demo: A Walkthrough of Azure AD
Let's start with a little demo. I want to give you a little walk through of Azure AD. I want to mention specifically that this walk through is enough as a developer, Azure AD is a pretty big topic, and you can go pretty deep into it, but as a developer or as a Node.js developer, I'm concerned about how does it affect me as a developer, and from that point of view, I'd like to give you a little walk through of Azure AD. Throughout this course, we'll be using a very important part of the Microsoft Cloud story, which is Azure AD. So I thought,let's get a good walk through of it. So, using Azure AD is very easy. Go head and launch any modern browser, I'll just use the browser that comes with Windows 10, which is the Edge browser, and visit portal.azure.com. Now I have previously signed into this machine, so it just signs me in. And as you can see over here, this particular account that I have is associated with an Azure subscription. Now as I mentioned earlier, that an Azure AD may not need an Azure subscription. So, I have another course on Pluralsight called Getting Started with Azure AD, where I show you how to create a simple Azure AD that has no Azure subscription, so if you want to just start for free, you can use that. However, I'll be using this particular account over here for this course, and I will need an Azure subscription when I start talking about Key Vault because that is something that does require an Azure subscription. So over here, this looks like your typical Azure subscription portal, and on the left‑hand side here, it tells me that there's a link here called Azure Active Directory. If you have access to more than one Azure AD, you can click over here, and it'll show you a user interface that allows you to pick which Azure AD you wish to work with. Remember, one user account can have access to multiple Azure ADs. Notice a tool tip over here, it says domain and directory. That directory that you see over there, that is basically talking about the Azure AD, and the domain is the domain associated with this Azure Active Directory. Let's go into the actual Azure Active Directory and see what it looks like. Now, this is my, you know, play‑around Azure Active Directory, so you may see a few things in here that are already set up, this is just because I've been playing it on with this Azure AD for other purposes. And you see over here that it gives me a Tenant ID, this Tenant ID is a unique identifier for this tenant. It is associated with this Azure AD tenant. So every Azure Active Directory, well, it's an Azure AD tenant, and this GUID is something that'll become very important when we start writing some applications, as you'll see shortly in this course. This is the domain name associated with the Azure AD. By default, you get a domain name .onmicrosoft.com, but you have the ability to register a custom domain name as well. I am going with a free Azure AD, which is sufficient for the purposes of this course, but it does come with Premium features as well. And I'm currently logged in as a user that is a global administrator. Okay, you can manage roles and administrators here. Now let's go to Users. So you see over here I have some users set up over here. Some of them are sourced through this Azure Active Directory, and some of them are sourced as Microsoft accounts. So Azure AD can handle both these kinds of users. Although certain, very specific things require you to have an Azure AD account, but for the most purposes, you know, these are 90% the same. You can do various user management over here, as you see over here. You can also manage Groups. Groups are groups of users or, for that matter, groups of service principles as well. You can create groups from a security perspective. There are a bunch of things over here that if things like Organizational relationships, where users from other organizations can be managed, you can manage Roles and administrators, you can define your custom roles in here, you can define different levels for different users. For instance, a certain user can be a B2C user floor administrator, so this is fairly fine grain, and if you want to create custom roles, you would have to pay for Azure AD Premium subscriptions. Okay, now under Enterprise applications, Enterprise applications is a specific kind of a multi‑tenant application. What I mean by that is an Enterprise application is something that perhaps some other organization has set up for you to use. Okay, what I mean by that is, let's see, if I click on New application over here, you see that there are a whole bunch of applications over here, some of these names might even be familiar to you, like Docusign, DropBox, Google Suite. So imagine that your company buys a subscription to GoToMeeting, but they want the sign‑in to GoToMeeting be controlled by our Azure AD, which in turn could federate to ADFS, which is part of your on‑premises Active Directory. So this is how you can manage that, right? You can also choose to surface up an on‑premises application through something called this Application proxy, or if there's an application that meets certain criteria, as in, let me show you, that it supports SAML‑based sign‑on or password‑based sign‑on, you can add it directly here as well. So it doesn't necessarily have to be over here, as in, you know, available for all users. If there's an application that is specific for your org, but you're interested in using it, you can set it up over here. Azure AD also supports SCIM. SCIM is a standard that is specific for, say, identity management products, and it allows you to manage, you know, users, roles, etc.,so if you have a product that needs to sync its users and groups, let's say for an example, with Azure AD, you can do that using an API, which is the SCIM API. So Automatic User Provisioning using SCIM, this is where you would set that up. Okay, let's scroll to the left. Application proxy, as I mentioned, is a way for you to remote an application from on‑premises onto the cloud. There is a lot of detail here, I won't have a chance to going to every single one of these, but again Conditional Access is something where, you know, depending on rules, you can enable or disable certain applications, for instance, you can say, hey, you know, we're going to look at your IP address, which surfaces up as a claim, and based on that, we will enable or disabled your access to a certain application or even during certain hours. There's a lot of detail inside of Azure AD, it's a big topic, but let's skip to the parts that we are interested in as a developer. And as a developer, the one that you'll be most interested in is this part here, App registrations. So let's click on that. So under App registrations, you would click on this New registration button, and here you would define any application that needs the service from Azure AD to be able to sign in and out. So you can click this New registration button, for example, and here you can define the name of the application, what kind of account it can work with, so users only from this Azure AD, any Azure AD, or any Azure AD and live accounts. And then there are other details that I'll be talking about throughout this course, like what is a redirect URI. So depending on the kind of application, you may want to specify a redirect URI. I already have an application over here, let me click on this and show you what it looks like. Here you can define certain details, like this client ID, also known as App ID, it is very, very important. You'll find me using this Client ID over and over again when I'm writing different kinds of applications for Azure AD. Tenant IDs are GUID that represents this Azure AD. Object ID is a GUID that uniquely identifies this Azure object. So, I want you to not confuse the Client ID with the Object ID, okay, these are different. For our dev purposes, the one that is important to us is the Client ID, and sometimes a lot of people also call it App ID. The reasons for these two names are historical, as the protocol was evolving, people used these names interchangeably, so it can get confusing, but remember App ID, Client ID, same thing. Then there are a whole bunch of other things like App ID,URI, so if your application supports an API, then you want an App ID URI for it to be uniquely identifiable. Then there is this thing called Redirect URI, where if your application support some kind of authentication, where the tokens need to be sent back to your application, then where are we sending them back to, to this URL. So you can define these Redirect URIs inside of this App registration as well. Actually, that's under the Authentication section, where you can define, you know, one or more than one Redirect URIs. And then you can have a logout URL, you can have different kinds of tokens enabled, etc., etc. There is a lot of detail here, and I'll be walking you through many of these aspect in this course. Similarly, you've got something called as API permissions, what can this application do, right? So you register this application, now here this application can call Microsoft Graph under two different kind of permission levels, for example, or perhaps the application itself exposes an API protected by Azure AD. So this application that you're writing perhaps accepts an access token and would like that access token to be validated. So that sort of configuration goes in here, including defining custom scopes or what applications can access this particular application. So there is a lot of detail over here, and every application has got this thing called manifest, where there are a lot of other configurations that you can do that don't actually surface up in this user interface. So this is a brief overview of what Azure AD is, something that we'll be using throughout this course. Obviously there's a lot more detail, but for the purposes of this course, this is what you need to know.

Azure AD vs. Azure Subscriptions
Now let's talk about another important topic, which is Azure AD versus Azure subscription. This is an often confused topic. Remember that Azure subscription is something you pay for and Azure AD is free. There are premium versions off Azure AD, which add more features, but the basic Azure AD is free. So these two are connected, but they're different. Let's understand how. Okay, so you have an Azure AD, right? This is sometimes called as an Azure tenant as well, and a user authenticates to this Azure AD. Now this user may be an organizational account or a Microsoft account. Microsoft account, also known as live ID. So organizational account is something that is usually set up by our administrator, maybe it is backed by your ADFS infrastructure, whatever the case may be. And a live ID is what you would use for this Skype or Xbox or something like that. My point is, one way or another, this Azure AD knows about this user. Now remember, there are other Azure ADs in the world, so this orange Azure AD recognizes this user, but this user may have originated from another Azure AD. For instance, this user may belong to the blue Azure AD, okay, and it appears as a guest account in the orange Azure AD, and there are any number of permutations and combinations you can think of here. Of course, the user could have also originated from the Orange Azure AD and is a local user for this Azure AD. Okay, so you understand how users are, right, so users can be in this Azure AD, or they can be guest accounts, they can be organization accounts, or they can be Microsoft accounts. Clear? Now let's talk about subscriptions. Inside of this orange Azure AD, we may have no Azure subscriptions, that's certainly a valid way to have an Azure AD. Or let's say you have one subscription. Why one? You can have two subscriptions or even more. So in an azure AD, there can be 0 to more than 0 subscriptions, many. Okay, so there is a one to many relationship between Azure AD and subscriptions. But again, remember that this user could have been an external user added into this Azure AD and this user has access to subscriptions connected to this tenant. Similarly, this user may have access to other subscriptions in other Azure AD tendencies. You following me? So what I'm trying to say here is that one Azure tenant can have many Azure subscriptions and one Azure AD user can have access to many subscriptions and also access to many subscriptions under many different roles. So this sort of flexibility really allows us to manage user subscriptions in so many different ways, and I'll just give you a couple of examples now. For instance, you could have a local employee. So you're Azure AD contoso.com and this employee is user@contoso.com and you have two Azure subscriptions, they are for production and for development purposes. Another possibility could be that you have a consultant who belongs to some other Azure AD. Let's say you've hired a firm, your company has hired a firm, and that particular firm has an employee that is of their firm, but to you, they are a consultant. And now that consultant has been granted access to two subscriptions in your tenant, let's say development and production, but in addition, they have access to another subscription in their own tendency called customers, let's say they use it to work with all the customers, or perhaps you want to say that this consultant has no access to your production environment, they have access to only development and they don't subscription. You can see that there are lots of permutations and combinations you can use over here, and basically, just makes things very, very flexible when it comes to multiple companies, multiple users working together or even within one company you're trying to set up things differently for billing, cost perspective, etc.

Summary
Let's end with a little summary. In this introductory module, I talked about what can you do with Node.js in Azure? And under that, I talked about the various concerns that you're secure oriented or security‑minded application may have. Specifically, what I'll be focusing on is identity management and secret management in this course. Then I gave you a brief introduction to what is Azure AD, which is something that we'll be dealing with a lot in this course, followed by a very important topic and an often misunderstood topic, which is Azure AD verses Azure Subscriptions. Assuming that these three topics are very clear to us, let's dive into our next module. We will see some code starting with services and microservices. I'll see you in the next module.

Services and Microservices
Introduction
Now let's talk about services and microservices, starting with an overview of what are we going to talk about in this module? I'd first like to talk about what are we actually going to build here so we have a common understanding of what we're driving towards. As a part of that, I'll talk about permissions in Azure AD and how they affect your Node.js application. Then since we're talking about services, I will talk about permissions, authentications, specifically as they pertain to services. We will get familiarized with an OpenID Connect flow called the client credentials flow. This is the flow you use when you have a service talking to an API. Finally, we'll solidify these concepts in our mind with a few demos where I'll take you through the various steps necessary. We will register an app, we will add a secret, and we'll grant some permissions, and then we will call, well, you can call any API, but I'll use an out‑of‑the‑box API that's available in the Microsoft ecosystem, and that's called Microsoft Graph. Again, the concepts here are portable. So if there's any other API that is protected by Azure AD that you wish to call, you can use the same concepts shown here to call any API you wish, but I'll be using Microsoft Graph as an example. And then, we'll finally round it up with a little discussion around microservices.

What Will We Build?
Starting with, what are we going to build in this module? Well, what I intend to build is actually very, very simple. I will have a service, service is a headless process, something that doesn't have a user interface. And then I have an API. In my example here, I'm going to use Microsoft Graph as an API. And what I intend to show here is that this service will be able to call this API, and it'll be able to do so securely. So this API requires authentication, and this authentication is validated by Azure AD. So both the service and the API are something Azure AD knows about. So we're going to set this up in this particular module, and we're going to use this as an example to learn a lot about writing this in Node.js and in Azure AD. As I mentioned, the service, we will write this in Node.js. Now, I'm not going to, you know, go again deep into Node.js‑specific concepts like how to write a service, I'm going to keep things simple, like, you know, you could run a service as a Docker container or as a function, you could run it however you wish. My focus here will be around the authentication parts. So what's peculiar about a service? Well, it's a headless process. In other words, it has no user interface; therefore, it has no opportunity to ask for permissions. So the service obviously is going to need some permissions to be able to call the API or it'll be able to call just anything, right? So it's locked down by permissions, but it has no opportunity to ask for those permissions. How are we going to get around that problem? And yes, we're going to call an Azure AD‑protected API, specifically Microsoft Graph. So we'll need to somewhere, somehow grant our service the ability to call Microsoft Graph as a granted permission, so we're going to see all that in action, but these are the concerns we need to keep in mind. The API, as mentioned, the API can be any Azure AD‑protected API. You could author your own API as well, and later on in this course, I'll show you how to do exactly that. But, as of now, I haven't covered about how to write an API protected by Azure AD, so for now, we will simply use Microsoft Graph, which is an API that Microsoft has written and has made available to us, we'll simply call that.

Permissions in Azure AD
Now let's talk about permissions in Azure AD. Now remember here I'm talking about application permissions. I'm not talking about user permission, so please keep that in mind. If you're familiar with OpenID Connect and you've heard the word scopes before and you understand what the scopes mean, I have some good news for you. You already know what permissions pertaining to applications means. So permissions in Azure AD as far as applications goes is the same as scopes. It's an authorization tool. It is how you allow an actor X to call an API Y to do Z. In other words, API Y, let's Microsoft Graph, has got a number of facilities. I want to read the user's mail. I want to read the user's profiles. These are all scopes Z over here, and X is our application. So we want to be able to say that X can read mail, but it cannot read the user profile as an example. So it has permission to do A, but not B. Therefore, those are defined as OpenID Connect scopes. See the thing is these blue lines you see over here, think of those scopes. And whether it's a user calling an API or a service calling an API, one single API can expose many such permission levels. For instance, you have the ability to read data, but not write data. They can be two different scopes, AKA permissions. So my user must have the rights to write data, right? So somewhere we need to set all this up. Similarly, my service needs to be able to have the ability to read data. Somewhere we need to define this permission. Azure AD has two kinds of permissions. One is delegated permissions. Delegated permissions are where the user's identity is important. So they're used by apps that have a signed in user present. So delegated permissions can be further classified into two categories where the permission must be granted by an administrator, as in this delegated permission requires admin consent. Or the user may grant the consent directly. So depending upon, you know, perhaps it's a sensitive API, so the admin must grant consent, or maybe the user can grant consent right? Then you have something called as application permissions. These application permissions are used by applications that don't have a signed in user present. Example, background services, exactly what we're talking about in this module. So services need application permissions, okay? So these application permissions, generally speaking, require admin consent, and they require consent ahead of time. In other words, when I'm setting up my service and I'm saying that my service can call user.read in Microsoft Graph, then before my service calls that particular API, it needs to be granted that permission by the administrator. So the process of granting this permission is called as consent, okay? So I'm consenting certain application to do something, okay? So there are three kinds of consent in Azure AD. First is a static consent scenario. Static consent scenario has been around with us for a while. It is tied to OAuth really. And in static consent scenario, your app needs to specify all the permissions it needs in the app's configuration in the Azure portal ahead of time. So let's say that my application needs mail, calendar, contacts that I need to specify, that I need to have access to all those three in my app ahead of time during the application registration in Azure portal. Dynamic, on the other hand, dynamic content is where an app can request for permissions any time it needs to, and the user can grant or deny such permission as well. So this gives you a lot of flexibility. But where it becomes challenging is that now your application has to worry about the user denying a particular permission or the user not having the ability to say yes to a certain requested permission. For example, certain permissions may require an administrator. And that's where the third kind of consent comes in, admin consent, where an administrator has pregranted consent to some application being able to do something. So again, as you can imagine, that static and dynamic, both of them require a user to be present. So when we talk about a service, we're talking about admin consent. So what kind of consent do we need for a service? Well, we will need an application permission, and we'll need to pregrant it permission using admin consent.

Service Authentication and Permissions
Now that we understand what permissions are and what permissions we need, now let's talk about service authentication and permissions together and let's see how that affects our writing the application. So again, just a little recap, what kind of consent do I need for this service? I will need application permission and I'll need to grant it admin consent. Okay, why? Because I don't have the opportunity to grant consent at runtime; I have to do it ahead of time. So the steps we need to follow over here are first we need to register our application inside of Azure AD. You may be thinking, well, don't I need to register the API as well? Well, yes, you do. But we're going to call Microsoft Graph, and it's already registered for you. So, if it was a custom API, then you'd need to worry about that, but here we have Microsoft Graph, it's already available for us, so our application, as in our service, needs to be registered as an application in Azure AD. Why? So Azure AD knows that such‑and‑such application depends on me as an Azure AD to provide authentication services. Next, we will need to create a secret for that application. Why do we need a secret? Because for our service to be able to securely call the API, in this case, Microsoft Graph, we need an access token, and we will get the access token using a specific OpenID Connect flow called as the Client Credentials flow. Now, please remember these three words, Client Credentials flow, because I'm going to talk about this in detail momentarily. Client Credentials flow depends on a secret; that secret can be either a password or it can be a certificate. Finally, I'll need to also grant permissions. Okay, so my application, which is registered, needs to be pre‑granted permissions. Why pre‑granted? I already mentioned this, because my service doesn't have the opportunity to ask a user for permissions, so as an administrator, I need to pre‑grant these permissions. And once all that is done, then I just need to write some code, do Client Credentials flow, get an access token, and call the API. Easy as that.

Client Credentials Flow
So what is this limb Credential flow that I keep talking about? Client Credentials flow is the specific OpenID Connect flow designed for headless processes. When we talk about OpenID Connect, you're going to hear this word tokens a lot. There are three main tokens you need to know about. Id_token, which has the user's identity. Who is the logged in user, right? The id_token tells us that. The second token you need to know about is refresh token. So to call an API, you need a different token called as the access token, but the access token is short lived, usually one hour in Azure AD, it's configurable. But what happens when that token expires? An hour later, right? You get another token, which is called as the refresh token. And the refresh token can be used to get a new access token, okay, without prompting the user for credentials again. And finally you have the access token. The access token is what you would put in the authorization header when you're making a call to the API and the API can validate or invalidate your access token and grant or deny you access. Now, in Client Credentials flow when we talk about a service, there is no concept of a user sign in. So the only token we need to worry about in Client Credentials flow is the access token because there is no user identity and there is no point of, you know, renewing a token using a refresh token because there is no user sign in required. So Client Credentials Grant, underneath the scenes, is actually just a simple POST request that returns an access token. What does that POST request look like? If you are using password‑based authentication, it'll look a little bit like this. So you would make a POST request to a certain endpoint, okay, slash token authorization endpoint, that's what it's called. And you would pass in the app ID, also known ass client ID. This comes from your app registration. The scope to your API and the specific permission/scope you're asking for. You'll need to pass in the credential, which is the client secret password over here, and you'll need to set grant‑type client credentials. The reply to this will be an access token. This same protocol also works for a service principal. So when a service principal needs to make a call, it can use the same mechanism that it can pass in a client ID, which is the app ID, also known as the user name for the service principal and the client secret, which is a password. And then if an API is protected by standard Azure AD RBAC, role‑based access control, it'll be granted or denied access. Client Credentials Grant can also work with the certificate. Again, it's a simple POST request. The only difference is that you specify a client assertion type, so that value is hard coded to the value you see here on the screen and in the client assertion, instead of a password, you send a different assertion, which is a JSON web token that you'll need to create and sign with the certificate you registered as credentials for your application. The result in all three of these is an access token. Using that access token, you can make calls to the secure API.

Register an App
Enough theory. Let's see this in action with some demos. In this first demo, I'm going to register an app. Why? So Azure AD knows that this app depends on my Azure AD for some services, authentication, calling an API, whatever. Let's see how we go about registering this app. Now that we're writing a service, which we'll use Client Credentials Flow, the first thing we need to do is register that as an application in my Azure AD? Why? Because Azure AD is not going to provide authentication services to your application unless it knows about your application. So to register the application, go to Azure Active Directory, go to App registrations, and click on the New registration button. Now you may or may not see something like this over here. This is just an application that I had registered earlier. So click on this New registration button, and let's go ahead and fill this form. It says, The user‑facing display name, so I'll just call it ClientApp, and I'll keep it single tenant. Now, for Client Credentials Flow, I don't need a redirect URI, So let me just click on the Register button. That's it. My application is now registered, and these are the details that I'll need shortly. The client ID and the tenant ID.

Add a Secret
Now that my app is registered, I'm going to add a secret. A secret, in my case, will be a simple password, you can also do a certificate, and it is using this secret, I'll be able to make a Client Credentials call. For Clients Credential flow, I need the following details, I need the client ID, and I need the tenant ID, but I also need a secret, so we're going to go ahead and create a secret under this Certificates and secrets area. But before I do that, let me open Notepad, and just save this client ID because I'm going to need it shortly. So client ID, let's go ahead and put this here client ID, in my case, looks like that, your GUID will obviously be different, and the tenant ID looks like this. Remember the tenant ID is for your entire tenant, so all the applications I will create will share the same tenant ID, which will be different from your tenant ID. Now let's go ahead and create a secret. So, in order to create a secret, come to the Certificates and secrets area, go ahead and click on it. And the demo I will show will use a password‑based secret, although it is definitely possible to do certificate as well. So I'll go with New client secret here, and I shall just give it some descriptive name, I'll just call it mysecret, Expires in 1 year is fine, and click on the Add button. Now once the secret is created, it'll be shown to you only once, so go ahead and copy to clipboard, and go ahead and place that secret somewhere where you can retrieve it later. So that is my secret, that's my client ID, that's my tenant ID. Congratulations, your application setup is more or less done, with the exception of granting it some permissions, we'll see that next.

Grant Permissions
My app is almost set up, but nowhere have I yet specified what can the app do. So, I wish to grant my app certain permissions, as in my app should be able to do X, Y, Z in Microsoft Graph. Let's grant it some permissions. Next, I'm going to grant my application certain permissions. Now, the API that we wish to call is Microsoft Graph, and Microsoft Graph has got a lot of sub‑APIs with a lot of permissions that you need for those APIs. Now, Microsoft Graph is very well documented, just Google or Bing for the following words, Microsoft Graph reference, and I'm sure you'll find it. So, the permission that I care about, remember, as I'd explained earlier, is that for Client Credentials flow, this would have to be an application permission. So, every application by default, if you registered through the portal, will get this delegated permission called User.Read, which is basically saying under the logged‑in user's identity, allow the user to read the user profile. Okay, but under the guise of the logged‑in user, there is no logged‑in user here, so we're going to need an application permission. In order to do that, I'm going to click this Add a permission button. Let's go ahead and click on it. Now you see over here that there are a lot of possibilities here. Okay? And you can also choose other APIs that are not published by Microsoft. I'm interested in a Microsoft published API called Microsoft Graph. Go ahead and click on it. Later in this course, I will also show you how to create your own APIs, and then once you learn how to create your own APIs, perhaps you should try calling that API through Client Credential flow afterwards. For now, go ahead and click on Microsoft Graph. You see, there are two kinds of permissions, delegated permissions and application permissions. And as it clearly says over here, that for a daemon or background service, which is what Client Credentials flow is for, we're going to need application permission. So go ahead and click on it. Now, here it shows you all the possibilities. So see, Microsoft Graph has a lot of sub‑permissions and sub‑APIs. There are a lot of APIs you can call through Microsoft Graph. So, I'll just pick one of them, so it's got a user, and let's just say read all users' full profiles. Sounds like something that an administrative task should be able to do, right? So I'm going to go ahead and click on it like this, okay? And click on Add permissions. Okay, now once you add the permissions, it says Updating permissions, and you should see this button over here, Preparing for consent. Now if I was to walk away from this screen right now and try writing my code and try using this permission, it will fail because I have basically just specified that I'd like this permission, but I haven't granted it yet, as you can see over here in the status that this is currently not granted for this tenant. So what I need to do now is wait a few seconds. It won't take long. In just a few seconds, this button will become enabled. So let's give it a moment. A few brief moments later, the user interface changes to like this, it says Grant admin consent for sahilmalikgmail. Sahilmalikgmail is the name of my tenant. Go ahead and click on this button. It'll ask me to log in as an administrator because only an administrator can grant admin consent. So, it is showing me this user interface. It will say this application, that's the name of my application, and it wants these permissions, and I will say, Accept. And, in just a moment, it says Grant consent successful. So at this point, my application setup is all done. So what did I do? Registered the app, and then I added a secret, then I granted permissions. Now I am ready to start writing some code. Let's do that next.

Call Microsoft Graph
My app setup is done. Let's write some code and call Microsoft Graph. Now, I assume that you're a somewhat seasoned Node.js developer, and you understand the basics of Node.js. So, I don't need to tell you what node ‑‑version means or what npm is; I assume you already know that. I wanted to show you the versions I'm working with. Although the code that I'm writing is so simple, I think it'll work across many versions. So, this directory currently is empty. And I'm using Windows and PowerShell. You're welcome to use any other suitable OS platform, prompt, whatever you wish. Okay, let's go ahead and create myself a Node project. As you know, npm init ‑y is going to create a simple Node project for myself. Once this is installed, let me go ahead and create a file structure here as well. So I went ahead and opened that particular folder in Visual Studio Code. You're welcome to use any other editor you wish as well. Now, in here, I'm going to create a few files for myself. First, let's go ahead and create a file called settings.json. What is the purpose of settings.json? Well, this is where I will store things like the client ID, my tenant ID, et cetera. So, let's go ahead and populate the structure of settings.json as well. So my settings.json is going to look like this. Now, I will fill these details momentarily; I'll basically grab them from the Azure portal and I'll come back here and fill them. Let's also go ahead and create a new file here called index.js, this is where my actual code will go, and I also intend to install a couple of packages. So, let's go to package.json, and let's go ahead and modify this a little bit. So, let's give it a start command, and the start command will simply be node index.js, and let's go ahead and add a few dependencies. Now, I'll be making lots of HTTP requests, so I'll say I would like to take a dependency on the request package. And the version, let's just pick the latest one. Let's just go with this one. And another package that I like to use with request is called as request‑debug. Now, request‑debug is nice because it allows me to actually examine the requests that are going back and forth, so let's go ahead and take a dependency on that as well. Okay, looks good. Let's come back to my PowerShell area, or Terminal, whatever you may be using, and let's run npm install. Let's give this a moment to finish. Okay, that's easy enough. Once this is done, you should see a folder here called node_modules. Again, if you're a seasoned Node.js developer, you already know this, that this npm install creates a node_modules folder, which has downloaded this request and request_debug, Node packages, and they have been stored in node_modules. Now, let's start writing some code. So, let's go ahead and go to index.js, and I'm going to paste some code and I'm going to walk you through it. So the code that I'm interested in looks like this. So, first, I take a dependency on this request object, okay, and I load up the settings from the settings.json file. These are in the same directories, so ./settings.json. Essentially what this gives me is that it gives me properties like settings.grant_type, settings.client_id, settings.client_secret because all of those are defined in this JSON file. Okay, let's go further down. Then, I'm going to uncomment this line over here, which essentially this will just write on the console the request that was sent out and the response that came back. So I can visually examine exactly what went over the wire and what came back. The most interesting part is right here, request. So, request options, let's look at options one more time, so options is what I'm sending, so this will be a POST request to this URL. So this is the token endpoint for Azure AD. We're sending it to settings.tenant, so we're sending this to the your tenants token endpoint. A contrast to this is /common. For a multi‑tenant app, you would use /common. We are sending an x‑www‑form‑urlencoded sort of request, and these are the details we're sending. This is as per the specs of Client Credential flow. Client Credential flow requires you to send information in this format. So we send this information. If our structure is correct and the permissions are there and the app is registered and we don't have any typos, et cetera, then we should not get an error. Okay, if we do get an error, then we just write it out. But if we don't get an error, we should get an access token back. I will decrypt this access token so I can show you exactly what it looks like. But once you have the access token, then it's just a matter of making this call. Remember, we're making this call under the applications permission level, so we can read all the users over here. We have already done grant permissions, et cetera, and then we make that simple get call, and if the results come back, so this function that you see over here, so if there's an error, we throw the error; otherwise, we just write on the console exactly what we got back from the server, as in this case, Microsoft Graph. So all that's left to do now is to populate the settings.json area. And remember, the setting.json area are these values. So the client_id, let me show you where I got that from. So, under your app registration, this client_id is what we care about, okay? So, client_id, go ahead and copy that, and put that over here. Paste it. Okay. Now, the client_secret is not something that you can grab from the tenant anymore because it'll be shown to you just once. So let's go ahead and copy this and put it here. That's the client_secret. Grant_type is client credentials, that's fine. Scope? Okay, this is worth mentioning. Every API is uniquely identified by an app ID URI, and every app ID URI has got the shortcut scope in front of it called .default. So if you don't define any scopes, you get .default, but even if you define scopes, when you set .default, and that's what you ask for, it will give you an access token for everything that you have permissions to. So that's what we want here. In Client Credentials flow, I would like an access token which has basically all the roles that I already have access to, so ask for a scope of graph.microsoft.com/.default. And the tenant name, where do I get that from? The tenant name, actually, well, an easy way to get that is just hover over this, and the sahilmalikgmail.onmicrosoft.com, that's your tenant name. So, let's go over here, back to my code, and give it the tenant name like this. Perfect. Now let's go ahead and run this. So let's go back to PowerShell, or Terminal, or whatever you might be using, and I'm going to simply say npm start, which will run Node.js index.js. So, let's go ahead and say npm start, and it ran really quickly, but let's see what it brought out. So, let's scroll up over here. Remember that request_debug is going to write out all the details for me. So, let's scroll all the way to the top, this is where I did npm start, and you see over here this is my request. So we made a request, a POST request, to that URL, that is the token endpoint. This is exactly what we sent. This is as per the Client Credentials flow logic. Okay. And this is the response we got back. This is what it looks like. Okay, a lot of detail in here, but the part that we're interested in is that it returned me an access token. This is what the access token looks like. Now, the access token has got three parts in it, and this is, what you're looking at over here, is a JWT token. JWT token is basically JSON serialized, but remember, access tokens standard‑wise don't need to be JSON serialized, so the thing is it's just the most common format for it, and everybody uses it. But there's a concept called opaque tokens as well, and sometimes Azure AD uses those as well. But in this case, and in 99% of the cases, you see JWT tokens, and a JWT token can be decrypted using the site called jwt.ms. And you see these three shaded areas are separated by dots; those are the three parts of your access token. So you have the header, the body, and the signature at the end. And inside of here, you see that there are a lot of details there. So, who was it issued by? Who's the audience for it? Issued at, this is Unix time. Not before, so not valid before a certain time, expires at certain time, so it's valid for one hour. You can reverse engineer it and see how long exactly it's valid for. A lot of other details over here, but this is the interesting part, that we have a permission called User.Read.All. This is the permission that we had given earlier. Right? So if we go back over here to Terminal, so using that access token now we make another request to this URL, we pass in this header, authorization Bearer space, the access token. And then if you go down here in the response, we get a lot of details again, so you see over here it's a status code of 200, which means success. And there are a bunch of other details here, like sometimes you may see, you know, like this caching guidance, or you may see throttling limits show up over here, et cetera. You even see things like where exactly did this information come from, like which server, for example. A lot of details over here. But the data that we're interested in is this, so odata.context, et cetera, et cetera, and it's got a big JSON object over here, which is basically giving me the list of all the users, along with their details and entire profiles that are available in this Azure AD, and then we simply console.login. So this is how you go about doing Client Credentials flow with your application.

Microservices
Now that you've seen how a service can call Azure AD secured APIs, let's talk a little bit about microservices. See, the thing is, the example I showed you was my service calling an API. Easy, right? Microservices, well, they are a different beast. They look a lot more complicated, right? You have so many tiny, tiny services all over the place and crisscross all over the place. You're calling so many things at so many different places. Think IoT scenarios, for example. Millions of devices deployed on the internet. Are all of them going to call Azure AD token endpoint for client credential flow? No, you'll most likely be throttled down by Azure AD, because Azure AD is going to look at you as a denial‑of‑service attacker at that point. So, how do we solve this problem? Imagine that you've deployed things into an AKS cluster and you've got lots of containers and they're calling each other. How do we solve this problem? So, your service calls an API, what you need to think of in terms of microservices is that you need to think of a trust boundary. I call the API, and then this API needs to further call something, my user or my service isn't talking to the internal API directly. You know what? Just skip client credentials flow over there. Just use peer‑to‑peer certificate‑based trust, for example, or even a secret or some other mechanism which doesn't require you pinging Azure AD multiple times a second. So, my advice there is that when you're architecting microservices applications, be mindful, client credentials flow is not something that you should be calling, the Azure AD endpoints millions of times a second. So, architect your applications accordingly.

Summary
Let's end up with a little summary. First, I walked you through what are we going to build in this module, basically a service that calls an Azure‑AD protected API. Then I gave you a brief overview of permissions in Azure AD. While I talked in context of services, the concepts applied to nearly anything you do in Azure AD. So in further modules, where I talk about web applications or APIs, over there, permissions become very important, and the same concepts apply there. Then I talked about how do those permissions specifically apply to service authentication. Then I talked about the specific OpenID Connect flow that we used for a service, which is the Client Credentials flow. Once we understood the theory well enough, we went into some demos. First we registered an app, then we added a secret, granted some permissions, and finally called an Azure AD‑secured API, in our case, Microsoft Graph. And then finally, I gave you some architecture advice as far as Microservices are concerned.

Node.js Web Applications
Introduction
Next, let's talk about Node.js web applications, of course, in context of Azure Security, Azure AD, et cetera. Before we even dive in, let me just start with a little preface here that, you know, I know this course is about Node.js, but a lot of concepts that I'm about to talk about here are generic. Yes, the code we'll be writing will be in Node.js, but the concepts equally apply to whichever platform you're interested in, Python, .NET, whatever you wish. Okay, let's dive in. Starting with a little overview, what am I going to talk about in this module? In this module, first, I will conceptually talk about how web application authentication works at a high level in this new modern authentication world. Once we understand that, then I'll introduce you to three common protocols that we run into, which are WS‑Federation, also known as WS‑Fed, for short, SAML, and OpenID Connect. And you might be thinking, but isn't SAML a token, or is it a protocol? Yeah, I'll be talking about that as well. Then, I'll be familiarizing you with the Node packages that we will generally speaking use when implementing any of these protocols with Node. Then, we'll dive into a demo. We'll see using some code, actually an application authenticating with Azure AD, and I'll be using Express.js, although the concepts are equally applicable to equivalent platforms. Then we will extend that web application, and we're going to call an API on the user's behalf. Again, because we don't have an API written yet, we'll do that in the next module, I'll simply call Microsoft Graph as the user and demonstrate how calling an API works.

Web Application Authentication - Overview
Let's start with an overview of how web application authentication works in this modern auth world. So there are some key tenets that you need to keep in mind. When I say web application authentication, this kind of application is always accessed from the browser. These kind of applications are also referred to as confidential client because they will usually store a client secret of the server side. Because it's on the server side, you're confident that it won't be leaked. So they are called confidential applications because they have the ability to store secrets. All of these applications generally will rely on third‑party authentication. So my application will use Facebook for authentication for example. That is an example of third‑party authentication. Of course, in this module, I'll be showing you how to do that using Azure AD. Again, the concepts are portable to any identity provider. The main point being that once this application has authenticated you, and the third‑party application has given your token, your application has validated you, then you establish a session. That session is between your web application and the user's browser, so the lifetime of that session is entirely under your control as standard web‑based concepts apply there. I want to familiarize you with some terminology that I will be using over and over again. First is I'll be using this word service provider a lot. Sometimes I'll call service provider a relying party. They're basically the same thing. This is the application providing the actual service, and this is the application that needs authentication. So, for example, let's say I make a web‑based version of MS Paint, and you need to sign in using Azure AD to use MS Paint. Then in that scenario, my MS Paint web application becomes the service provider, and, as I mentioned, sometimes it is also called as the relying party, or RP for short. Another terminology that I'll be using a lot is identity provider. The identity provider, well, this is the entity doing the actual authentication for me. So if I have a username password to provide, I'll be providing it to the identity provider. So, again, if I'm writing a web‑based version of MS Paint, which relies on Azure AD for authentication, then MS Paint is the service provider or relying party, and Azure AD becomes the identity provider. So how does this work at a high level? At a high level, you have three entities here. You have the web application, which is the service provider, you have the identity provider, and you have the user. The important part here is that the user needs to be able to HTTPS preferably, so HTTPS to both the service provider and the identity provider. This whole thing is built on a bunch of Get, Post, Redirect, etc., no matter what protocol you pick. Yes, individual protocols will dictate what goes on in that Get/Post request. But this is at a high level how it works. The important part here is that at no point there is any direct communication between your service provider and your identity provider. So you don't need to open any firewall ports or anything like that. The important point here is that the user needs to be able to access both of these. So, again, some key tenets of this kind of authentication, number one, there is no direct interaction between the service provider and the identity provider. No direct communication. This is important because now if you want to support 3, 4, 10 different identity providers, you don't need to open 10 firewall ports. Second, no prior knowledge as in when a user lands on your relying party, at that time, there is a list off identity providers that the relying party supports. For example, either the relying party can authenticate using Azure AD or Google Identity. It is not until the user provides some information about themselves, as in maybe a username, let's say, not even the actual identity, so they have not authenticated yet. Or for that matter, you could simply show the user a list of identity providers you support, and the user picks the identity provider that they can provide. This process of picking the identity provider, whether automated or not, is also called as HRD, home realm discovery. Similarly, the identity provider also doesn't have any knowledge of the inner details of the actual service provider. So Azure AD doesn't care if you're writing MS Paint or the next version of a big ERP system. Authentication is authentication. Third, this entire process is asynchronous, which means that once you land on the relying party and you are redirected for authentication, at that point, the relying party can pass some state to the identity provider, which the identity provider will simply return back. Other than that, the relying party doesn't really remember what kind of authentication requests came to its shores. It doesn't maintain any state. So it is when the redirect comes from the identity provider is when the relying party sort of hydrates the state, and it knows what was going on at that time. So the important tenet here is that the relying party won't even know if the authentication will ever complete. And that's okay. So you don't build any state into the relying party. The same applies for the identity provider. The identity provider is not going to remember that these three applications have signed into me. The identity provider simply validates credentials, but it can maintain a session for single sign‑on purposes, but it doesn't care who the single sign‑on is for. So these three key tenets are important in any protocol. But what are the common protocols in use for web application authentication? First is WS‑Fed, which is one of the older protocols. Second is SAML. And the third is OpenID Connect. And let me dive into each three of these one by one.

WS-Fed
Starting with WS‑Fed. WS‑Fed is short for WS‑Federation, and this came into being around Windows Identity Foundation and the old fashioned Azure app fabric, also known as ACS. So the way this works is that the user lands upon a website. This website says hey, you're not authenticated yet, but here is a list of identity providers I support. The user picks one of them, goes to the identity provider, provides their credentials to prove who they are, and then it gets a SAML 1.1 token that it plays back to the website, and the session is established. So inside of Azure AD, if you click the Endpoints button, you'll see this pane appear on the right. And the highlighted two endpoints pertain to WS‑Federation. Specifically, the Federation metadata document allows you to automate the setting up of relying parties, and the WS‑Federation sign‑on endpoint is what will actually do the authentication for you. When a redirect occurs to the identity provider, WS‑Federation protocol dictates that the following parameters be present. Actually, the only parameter that's really required is is the wa parameter, which is telling the identity provider what are we asking it to do? The rest of the parameters are probably something you'll end up using anyway. So after authentication, who do you reply to? Where do you send the token to? That's the reply URL. What resource URI are you asking authentication for so the identity provider knows who's asking for authentication? That's wtrealm. Wct is timestamped, so it is usually used to prevent replay attacks. And wctx is context as in, let's say that I'm on a, in my relying party, I land on a deep link. And after authentication, I would like that deep link to work, right? And I want the application to remember certain context. So that state, I would put that in wctx context. The state is simply just returned by the identity provider. The identity provider doesn't really care about it otherwise. It just needs to return it. Now this SAML word, SAML stands for security assertion markup language. And there's some confusion around it because it's both a token and a protocol. Let me explain. So here in WS‑Fed, we get a token back, which contains the identity of the user, and that's a SAML 1.1 token. Again, this is for WS‑Fed. There is also a SAML sign in protocol that I'll be describing later. That SAML sign in protocol works with SAML 2.0 tokens. Clear? Or is it frustrating yet? So SAML the word is used both for tokens and for protocols.

SAML
Speaking of which, now let's talk about SAML, the protocol. This protocol is used for web application sign in. Well, pluralistically speaking, it can also be used for web services, although that's out of context for this course. But in the context of web applications, here is how it works. Again, the user lands on a website. The website says hey, you're not authenticated. Go to this identity provider, provide your credentials, and you get a SAML 2.0 token back. Isn't this very much like WS‑Fed? Well, it is. But there are some key differences here. Obviously the protocol is different, but also it supports a different flow where the identity provider can initiate the authentication for you. Starting with what parameters does the SAML protocol support? First is a SAMLRequest. SAMLRequest is just a Base64 encoded XML document. Here's a bonus tip. The link you see at the bottom of this page, you can go to that link and decode that XML document. What happens in a SAML request is that the relying party can say I need the following claims. So it's a little bit more flexible. And then the identity provider will perform the authentication, and it'll send you back those claims. Similarly, the RelayState is the state as in context, which the identity provider just needs to return. The request is signed, so the signature is contained in the Signature query string, and SigAlg is the signature algorithm used to sign the request so it can be validated by the identity provider. As I mentioned, SAML supports multiple flows. First is the service provider‑initiated or SP initiated floor, which is a SAML login flow initiated by the service provider. It's typically triggered when the user tries to access the service provider itself. So I access the web‑based origin of MSPN directly. And then MSPN redirects me to the identity provider. Okay and it could even be a deep link within MSPN. And again, I'm using MSPN just as an example, but really any service provider. The second example is IDP‑initiated or identity provider‑initiated. What this means is that the login flow has been initiated by the identity provider itself. So basically, you sign into the identity provider directly, and then you're redirected to the application where the application simply signs you in because it got a POST request with a valid SAML token.

OpenID Connect
Next, let's talk about OpenID Connect. Now I'm talking about OpenID Connect, but I will also talk about OAuth and OpenID Connect here. Inside of Azure AD, you will hear this word v1 versus v2 apps a lot. Now OpenID Connect and OAuth as far as authentication is concerned are very, very similar. OpenID Connect is just a more formalized version of OAuth where they've defined their must contain user identity in a basic user profile and the locations of where that information will be. When we talked of v1 applications in Azure AD, they supported OAuth. They did not comply with the OpenID Connect standard. The v2 apps support the OpenID Connect standard. So today if you're writing a new application, you should always use OpenID Connect because, hey, standards are good, aren't they? When working with OpenID Connect, you'll come across the word tokens a lot, and, specifically, there are three different kind of tokens that you need to know about. One is the ID token. The ID token is the identity of the user. It's got a basic user profile inside of it. Now I'll tell you that there is a /userInfo endpoint that an identity provider must support, and that gives you the same information that's contained in the ID token. Next is a refresh token. Refresh token is a long‑lived token, long‑lived as in like six months, and the duration is configurable in Azure AD. Refresh token is to get another token, called as the access token. So using a refresh token, you would get access token for the specific resource you're interested in. Why do we need a refresh token? The reason you need a refresh token is because the access token is short lived, one hour by default in Azure AD, again, configurable. So when the access token expires every hour, you don't want to ask the user to re‑authenticate over and over again, right? So to prevent that re‑authentication, you can silently renew the user's access token using the refresh token. So when we talk about OpenID Connect on web‑based applications, we use a specific grant called as the auth code grant or also known as auth code flow. Let's understand how this works. Here there are four different parties involved, the user obviously, the web application, which the user is trying to sign into, and any OpenID Connect‑compliant identity provider, like Azure AD is, will support two endpoints, which is the /authorize endpoint and the /token endpoint. So let's see how this flow works. The user will somehow ask to be logged into the application. Might be clicking on a Login button or maybe just the user accesses the application and the web app says, Hey, you need to log in. At this point, the user is redirected to the authorize endpoint. Here the user performs authentication, enter password, MFA, or whatever it might be. Now, here maybe you'll be asked for consent. Why maybe? Because if you haven't already granted consent or the administrator hasn't done it for you, you'll be asked to consent. Once the user consents, at that point, a code is sent back to the user. Again, this is all happening over HTTP redirect, so this happens very quickly. It's not like the user sees it, but if you look at the query string, you'll see it there. This is also called as the authorization code. Now using this authorization code and the client_id and the secret, so these three bits off information are played back to the token endpoint. And from there, you will get back an id_token and an access_token. Notice I didn't see refresh_token. The reason I didn't say refresh_token is because in OpenID Connect, if you want the refresh_token, you have to ask for it. It doesn't give it to you by default. So in this process of requesting the tokens, you have a choice of specifying a scope. And if you specify a specific scope called offline_access, you will get a refresh_token in addition to the id_token and access_token. Now once this id_token reaches the web application, the web application can now validate this id_token, and a session is established between the user and the web application. And this is how auth code flow works.

Node Packages
So now that we understand the theory, I didn't talk about Node.js at all, did I? Well, all the concepts so far were portable to any platform, but now let's see how we can implement all this in Node.js. It's actually very easy. This is what you need to remember, Passport. Okay, now, currently, this is the latest, greatest best library for authentication when it comes to Node. I'm sure as time progresses, either this library will evolve or better options, or rather say, other options will appear. But currently, at the time of recording this course, this is a pretty good library. The way Passport.js works is that it's got various strategies. At the time of recording this course, there are like more than 500 strategies available. But the ones that we're concerned about are as follows. Naturally, there is an npm package, called passport. If you wish to do either wsfed or saml, you can use passport‑wsfed‑saml2. If saml2 is all you care about, then you can simply use passport‑saml. If you wish to target a generic OpenID Connect endpoint or auth provider or identity provider, you would use passport‑openidconnect. But if you are interested in Azure AD, then you would use passport‑azure‑ad. Now since Azure AD is OpenID Connect compliant, you can use either passport‑openidconnect or passport‑azure‑ad. I will tell you, though, that passport‑azure‑ad will make your life a little bit simpler because it offers an easy path to move from v1 to v2 apps, so I'm going to use passport‑azure‑ad for my demos.

Demo: Web Application Authentication
With all that background, let's dive into a demo. I'm going to demonstrate a simple web application authenticating to Azure AD, and in this, I'm going to use something called Express.js. Now, if you are a node developer, you already know what that is. But the concepts I'm about to show you are not specific to Express.js, they are quite genetics. If you wish to use something else, you're welcome to use that as well. Now there is a lot of code in this demo and I didn't want to write every bit and piece in front of you, plus, I assume that you are somewhat familiar with Node.js already, but let me walk you through the structure of this project. I promise you, you're not watching the me write code, but you're not missing anything here either. This is the structure of my project. It's a simple Node.js based project. Let's start with package.json. This is my entry point, node app.js. for those a few who are familiar with Node.js, but just by looking at these dependencies, you can probably tell that this is an Express.js app, right? So I have some basic packages over here like express‑session is important because I'm going to need session at the end of this, this is a Web app, after all. I've added references or passport, I have something for logging, etc. This is playing with a lot of Node.js. Now the real code is in these two files, app.js and config.js. And in the views folder, I have three different views over here, index, layout, and account. Okay, index is the home page. Layout, as the name suggests, let's just actually click on these. Indexes, basically, hey, if there is a user or there is not a user, it gives me the login link, otherwise, it gives me two links, one to go to /account and the second to go to /logout. These URLs are handled in the app.js file. I'll show you that code momentarily. Account.js is basically saying hey, if there is no user, than show the /login page, as you can see over here, otherwise, or rather, the login link, otherwise, show all the claims for the currently logged in user. Okay, so the user properties available to us, this is being innocent in using the render method, as I'll show you in app.js in a moment, and this is how it looks like. And we'll show the logout link at the bottom. Layout, as the name suggests, well that's just a layout of the entire page, right? Okay. Now let's go to config.js and let me make some space over here. So the two files I'm concerned about now are config.js and app.js. At the very top I have some secrets, or rather, some variables that I have already put in the value for the tenantName and the tenantID. Now, how did I get the tenantID? I've walked you through how to do that in the previous module where I talked about client credentials flow. Now there are some properties here, this big, huge object that you see over here, these are the various configuration values that I need that I'm going to pass in to app.js. Now what is interesting, though, here is some important properties I will walk you through. Like, for instance, I'm saying well this is the clientID, okay, so that's the appID, clientID that comes from up here, we'll populate that in a minute. We can get the identityMetadata from this URL over here. This is an anonymous access URL. You could just visit that, it'll give you the configuration details of that particular identity provider. Here, were saying that we will only accept post, which is more secure than get. Here, we're saying that we are asking for the auth code and the id_token. Okay. This is the redirect URL. So when authentication occurs, at the end of authentication, Azure AD is supposed to pass the token to that URL there. So obviously we'll be listening at this URL as well and that is somewhere inside app.js. Actually, Passport Azure AD just makes all that easy for us. And you can scroll through the rest like I have a client secret over here, you need that when you're asking for tokens. We should validate an issuer in single tenant apps. This not a B to C application because B to C also uses openID. This is Azure AD B to C, but the actual URLs will change, the token endpoints, etc, those will change in B to C. So they automate all this for us. I can just say true and it will start it in the correct URLs. The issuer is important when we're validating the issuer, this is our issurer, and so on and so forth. Cookie‑based session and nonce, etc, we have to specify all those details. And then I have a logout URL as well. So what happens when I hit logout? Well, I have to log out of this web application, right, but that's not enough. I also have to inform Azure AD that this user is now logged out. So this URL, okay, this is the Azure AD URL, so we go there, we do the log out, and then we redirect back to localhost 3000, which is this application that is running over here. Now, let's go to the main code over here, which is app.js. So all this is pretty simple. These are the various requires that I depend on. This is logging, it's going to log out to console. That's simple enough. Now let's scroll further down. So I load the config and then I create a variable called OIDC strategy. Now passport‑azure‑ad gives me two strategies, OIDCStrategy, as the name suggests, is open Id connect strategy is for web applications, and BearerStrategy, which I'll show you in the next module, is for web APIs. I mean, it's really as simple as that. This code allows me, with some configuration, of course, which is further down, this code allows me to set up a web application that understands openId connect. Simple as that. Now, this code that you're looking at from Line 29 through Line 51, there is plumbing code to find the current user and set it in the user object, request.user object, etc. Then there is passport.use new OIDC strategy, and this is where I specify all the details and this is where I'm telling passport that I want to use OIDC strategy, openId connect strategy. So all those details are specified over here. Let's go further down. So this is basically what happens when authentication occurs and then we simply start configuring it. We add the various middle name, we set our rendering engine, and then this is where authentication is set up. That's it. Passport.initialize, app.use passport.initialize, app.use passport.session. So along with this configuration information and this line over here, passport.initialize, passport.session, that's it. Your authentication is now set up. Now I just need to write some plumbing code to handle the roots. Remember these roots here, the account, index, and layout? Yeah, so let's handle those now. So those are pretty simple. I have a method here ensureAuthenticated. So basically, if the user is not authenticated, redirect to /login. Okay. At the root, I render index at /account, I render account and I pass in the user object, which I render out as properties in the account object. At /login, here things got a little bit interesting, at /login, I make a call to passport.authenticate and I'm passing in somestate here, this is not necessary, it just just comes back to me after authentication, right, but this starts the authentication process. When authentication finishes, this line is called our auth/openid/return. Now we have a choice of whatever we wish to specify here. The only criterion is that this must match the reply URL and this must match our Azure AD app configuration, which I have not done yet, we'll do that shortly. So remember this reply URL is very important, it needs to match whatever is here in your code. Okay? And then finally, logout is going to perform log out, which is config.destroySessionUrl and then we listen on port 3000. So now our application is running on localhost 3000. So all that is left to do now is for me to register an app and populate these values. Let's go ahead and do that. And I'm going to go into my Azure portal and I'm going to click on this New registration button to create a new web app. I shall call this MyWebApp, you can make it single tenant or multitenant, it'll work in either scenario. I'll go with multitenant. You know the difference between these two is single tenant means users only in my tenancy, multitenant means users in my tenancy and other Azure AD tenants. So I'll just go with this, and the redirect URI, I'll leave this blank so I can show you where to populate it later, but of course, you can supply it right here, if you wish. So I'll go head and hit Register and wait for this application to get registered. Okay, It's done. Now let's go to Authentication. Okay. Now, let's go in and populate the redirect URI. The redirect URI must match what you specified in your code, so I'm going to copy/paste this. Why? Well, I'm afraid of copy/ paste errors. So let's go ahead and populate this here, so paste like that. Okay, we'll hit Save in a moment, and let's go down here since we are requesting ID tokens, let's go ahead and check this checkbox for ID tokens. Okay. Make sure that is checked and that looks good. Hit Save. That's it. My application is now set up. Now I'm going to go to Overview and I'm going to grab this client ID, the tenant ID I've already put in my code, so I'm going to go ahead and grab this client ID, come back here, and paste it here like this, and the client secret, I'm going to create a new client secret just like client credentials flow, same process. So go to the Certificates and secrets area, go down here, create a new client secret, give it a meaningful name, and then once the secret is shown to you, remember, save it somewhere because they're only going to show it to you once. Go ahead and paste the client secret here. Perfect. Now let's go ahead and run this application. So I'm going to say npm start. This will run node app.js, which will run my application. Okay. The first time you run this, it'll ask you to allow access. Of course, I'm going to say yes and it's logging stuff over here. That's good. Looks like my application is running. So let's open the browser window and visit localhost3000. Okay, and I'm going to hit Enter and the logging should be scrolling over here when I hit login so let's do this. Let's align these windows like this so we can see the logging on the right. Now, go ahead and click the Log In button. Here you go. So this is consent. Okay? I did not grant consent to this application earlier so the first time it is asking me to grant consent, now consent on behalf of my organization because I'm administrator. So let's go ahead and hit Accept and it looks like that. Okay, so it looks like I'm logged in now because now I see a different user interface over here. And actually, you know what? Look at this, all this stuff that got written out here and look at the accessToken. Now what I have been given over here is an opaque access token. This access token is not a date WT access token, but with this access token, I can call a special /user info endpoint. There is an article I've written on the Internet, just search for my name and user info endpoint, you'll find out exactly how to do that if you're interested in that. But now that I have this access token, I can choose to call user info endpoint, but I also have the user in context. I'm going to click Account Info and this writes out the details of the currently docked end user, and this is how web application authentication works. So now I can then log out, but if I log out, it'll also logged me out of the Azure portal so I'm not going to do that, but I encourage you to say launch this in private mode and hit Log out and to see how log out worker works. It'll destroy the session and it will log you out of azure as well. So this is, generally speaking, how web applications are written in Node.js for Azure AD.

Call an API on the User's Behalf
So now that we have a simple web application working and authenticating the user, we can see who the logged in user is, now let's call an API on the user's behalf. What exactly are we going to do here? So, again, now we will have three entities. Well, the identity provider is there, so other than that, we will have the user, we will have the web application, and behind the scenes, we will have a web API and the API we haven't written yet. So for my demo purposes, I'll use Microsoft Graph, although the next module we will write an API as well so we can replace Microsoft Graph with our API very easily. The way this is going to work is that the user signs into the web application, and then the the web application is going to make a call to Microsoft Graph. We're going to pick an API in Microsoft Graph that needs the user's identity to be present, and you'll be able to see that under the user's identity through the web application, I am able to call Microsoft Graph or, for that matter, any API that I care about. Let's see how.

Call Microsoft Graph as the User
So let's dive into a demo. In this demo, I'm going to expand the previous web application I had written, and I'm going to call Microsoft Graph as the user, and I'm going to demonstrate that Microsoft Graph understands who the calling user is. At this point, I have a simple web application working that allows me to sign in as an Azure AD user, and it shows me the user's profile. Wonderful. But now we're going to enhance it. We're going to enhance it so this web application can make a call to an API, and that call will be made under the user's behalf. So you see here that your application already has access to a delegated permission called User.Read. Feel free to read more about these permissions and the various things Microsoft Graph supports. I'll just use this out‑of‑the‑box permission, but you're welcome to also click this Add a permission button, go to Microsoft Graph, choose Delegated permissions, and you're welcome to try this example with any of these endpoints and permissions. See, User.Read is already there for me, but you could say, User.Read.All, for example. Okay? Now, when you do that, and if you add a delegated permission, just remember to click this Grant admin consent because it won't work unless you grant consent, right? But I'll just use the out‑of‑the‑box permission that's already available for me, and we're going to make some minor changes to my code here where I'll be able to make a call to Microsoft Graph under the logged‑in user. So, notice that I've already made some minor changes. I've added a new view called callapi.ejs, and I've added an href to it, like that. Why? So we can access it easily, that's all. Then go to callapi.ejs, and here what I'm expecting is that there will be a variable called body, and I'm rendering it out. That's it. Right? Easy, okay. Wonderful. So, somehow I need to callapi.ejs and I need to populate this variable body. What am I going to populate it with? I'm going to populate it with the return value from Microsoft Graph. So now I need to enhance my code in config.js and app.js so I can make a call to Microsoft Graph under the logged‑in user's guise. So, what changes do I need to make? First, I need to add an exports.resourceURL over here, because now when I request for login, in addition to the existing scopes that I was asking for, I will also specify a resourceURL, I'll say, when you send me back tokens, include permission for graph.microsoft.com. Wonderful. Let's go to app.js now and start making some interesting changes over here. The first change I'm going to make in app.js is that I'm going to take a dependency on a Node package called request. Request just makes it very easy for me to make https calls or http calls, and in order to call Microsoft Graph, I will need to make such a call. Okay, that's easy enough. Now, the next change I have to make is I look for when I'm starting the authentication process, so let's go down here where I hit the login link. It should be here somewhere, right there, and I am going to pass in the resourceURL right here, resourceURL. And the value in passing in here is config.resourceURL. If you remember, this value was https://graph.microsoft.com. Easy. Now, I have asked for the token, okay, and I have a resourceURL, and I have written all the code necessary to perform the rendering. All I need to do now is use that token to make a call to Microsoft Graph and then render the callapi view. Okay, how do we do that? It's very easy. This block of code does that. What is this block doing? We are calling /callapi here. We're ensuring that this API, this view, is callable only if the user is authenticated. If you remember what this method does, if the user is not authenticated, it redirects you to the login page. If the user is authenticated, then we make a get call to this URL. Notice it says /me, and this is going to return my profile, the logged‑in user. It doesn't say which user, it just says the logged‑in user. So if this returns me the logged‑in user's profile, that means the call was done on the behalf, or under the permissions, of the logged‑in user. Okay? Then I pass in an authorization header, like this. That's my access token. Now, this time you'll see that the access token is actually a JWT token. We'll decrypt that, see what that looks like. And then the results, I simply render them in the callapi view, and I pass in the variable body. And if you remember, callapi.ejs was simply rendering out the body. That's it. Let's go ahead and run this. Let's go back to Terminal and run npm start. Okay, so my application is running. Let's open a new tab over here and visit localhost:3000. Let's go ahead and perform Log In. Okay, I'm logged in. Let's see what Terminal is showing me right here. Okay, that's nice. Notice the access token now. It looks slightly different, doesn't it? Let's copy paste it. Now, be mindful, see where it ends. It ends right here. Okay, let's go ahead and copy this and come back here and go to a site called jwt.ms to decrypt this access token, paste it here, and we expect three sections here, so that looks good, I didn't make a copy paste mistake. It's a JWT token, and notice that the issuer here is my tenant. The audience this token is for graph.microsoft.com, which matches my resourceURL, and these are the details over here, and this scope claim is User.Read. These are the scopes/permissions that I have access to, right? So, those are the details in the access token. My access token looks very nice. Let's come back here and now click on Call API, and this calls Microsoft Graph, and it renders out the logged‑in user's details. And this is how you go about calling an API from a web application on the user's behalf.

Summary
We covered a lot of ground in this module. Let's look at a quick summary. I first gave you an overview of what web application authentication looks like. I explained the three important protocols you need to know about, WS‑Fed, SAML, and OpenID Connect. I'm sure you'll run into either of these three in your day‑to‑day work life. Then I explained the Node packages we'll be using. Then we saw a quick demo of a web application authenticating to Azure AD. Then we called an API on the user's behalf. And finally, we saw that as a demo where we called Microsoft Graph as the user. Now so far, I've been using Microsoft Graph. Why? Because I didn't have a custom API I could call. What's nice is that I am totally capable of writing an API protected by Azure AD as well. Azure AD supports that scenario 100%. And actually, that is how Microsoft Graph is written, it's just a multi‑tenant API. So now, in our next module, I'm going to show you how you can author APIs using Node.js and Azure AD. I'll see you there.

Node.js Web APIs
Introduction
So far in this course, I have shown you how you can use Node.js to create headless applications using Client Credential flow. Then I showed you how you can create web applications where we called Microsoft Graph because we didn't have an API. Now, we're going to write an API protected by Azure AD, and we're going to call that API using the code that we've already written in the previous module, which is the web application. Let's dive in. Starting with an overview, what am I going to talk about in this module? First, I'm going to talk about how exactly does Web API authentication work? Well, I'll be talking in terms of Azure AD, but you know what, it is OpenID Connect‑compliant, so the concepts are universal. Then I'll be talking about scopes and consent. This is an important concept that you must understand when you're authoring or, for that matter, consuming APIs. The reality is you've already seen this a little bit in action when we called Microsoft Graph, and you gave the user.Read permission, that was an example of a scope, but how do you go about defining it on scopes, and let's understand this topic very well together. Finally, some demos. First, I'm going to set up a Web API and it's permissions, or scopes, inside of Azure AD. I use permissions and scopes interchangeably because Azure AD does that, but the right word is scopes, if I was to be puristic to the standard. Then, we're going to set up or author a secure Web API. So here onward is where the code becomes Node.js specific, and we're going to write the code in Node.js, although the concepts again are universal,. so you could port these concepts to say .NET, Python, whatever you wish. And then finally, we will call the Web API, and you can call the Web API in numerous fashions, but what I will do is that I'll pick up the project from the previous model, module where we called Microsoft Graph, and we're going to modify that project to call our API that we will write in this module. Let's dive in.

How WebAPI Authentication Works
First, how does web API authentication work? So at a high level, you have some code calling the API. Now this some code can be a native app, can be a mobile app, can be a headless process, can be a web application, it doesn't matter. An API doesn't really care who is calling it. What it cares about is that it receives a valid access token. So this access token is sort of like the key that opens the door to the API. Let's understand what this access token looks like. The access token, generally speaking, is sent in an HTTP header, specifically the authorization header, and the string value of it looks like this, bearer space and the access token. So Azure AD will mint the access token for you. You go through a flow asking for that access token like we did in the previous module for Microsoft Graph. And then when you get the access token, it is either an opaque or a JWT token. Now at the time of recording this course, Azure AD almost always will return you a JWT token. The only exception to this currently is that when you call the user info endpoint, you do so using an opaque token. But for the most part, we call a JWT token. Now one other important point about an access token is that it is short‑lived. What I mean by that is that it is, well in Azure AD the default time that the access token is valid for is 1 hour. So 1 hour later, you need a new access token. But this is an important thing for you to know because access tokens basically mean that there is no instant sign out across multiple applications, right? See what I'm saying here? So if using a banking application and you had signed out on the server, okay the authorization server, but the access token is still valid for an hour. And an hour isn't long enough time for you to transfer a lot of funds as a banking app, right? But the reason I bring all this up is because hey, an access token is valid for an hour, architect around that. So the question is currently Azure AD is built around the idea of validating an access token on your server, not in Azure AD. So how does validating an access token work? But before I dive into these details, let me just say you will almost never write this logic by hand because there are libraries available for nearly every platform that do this for you. However, I think it is important that we understand what those libraries do. We're not black box programmers, right? So the first thing is that your application needs to query something called as that JWKS URI and get the JWK keys. So you'll see that when I write my application code, I'm going to point to something called as a well‑known configuration URL. And that is a simple HTTP URL, which gives me all the configuration information for that OpenID Connect provider. And inside there, a property called JWKS URI allows me to retrieve these keys. And these keys, your application is supposed to downward them and cache them and keep them fresh periodically. Why I bring all this up is essentially at a high level you need to know that to validate an access token, your server, the one that is hosting your web API, needs to be able to make an outbound call to Azure AD, specifically that JWKS URI and the well‑known configuration URI, right? So in an air gapped firewall environment, it's not going to work. Second, we decode the token. Now JWT tokens have three parts separated by dots and the strings that are separated by dots are simply Base64 encoded strings. So you can easily decode them. There are websites to do that. Like jwt.ms is a very popular website that does that. So there are three parts there, header, body, and signature. And you need to next validate the signature so you know that the access token hasn't been tampered with or that somebody just didn't mint their very own access token, not even talking to Azure AD and are trying to get access to your API. So you verify that this is an access token that is not being tampered with. And finally, you verify the claims. Is the user calling me allowed to access this functionality, do they have the necessary provisions, is the access token still valid, etc.

Scopes and Consent
Now let's talk about another very important concept called scopes and consent. So we have some piece of code calling our API, right? Well actually, there's a little bit more nuance to that. This API may actually expose multiple permission levels, or scopes. So these scopes could be like you're allowed to read, but not allowed to write. like, you know, there was a user.Read and user.ReadWrite, right, for Microsoft Graph, those are examples of scopes. My point being that the application and the user must be granted access to a particular scope before they can call it, right? So, as I walk you through the demo, I'll show you how you can define scopes in your API and how you can grant access to certain scopes. Generally speaking, granting access to a specific permission, or for that matter, scope, is done by clicking that Add a permission button. When you click that button, you will see a user interface, something like this. This is for Microsoft Graph, but, you know, it'll show you the scopes of the API you're adding permission for. You see that scopes are grouped in two different groups, Delegated permissions and Application permissions. Application permissions are the ones that don't have a user identity, and delegated permissions are called under the guise or behalf of the user. And application permissions are always granted by administrator, delegated permissions, depending on the permission, could be an admin permission or a user‑level permission.

Set up a Web API and Its Permissions
Now let's dive into a demo. In this first demo, I'm going to show you how to register a WebAPI in Azure AD and how to go about setting its permissions. Let's see how. Altering a WebAPI protected by Azure AD is actually very simple. Remember, this is something that does not have a user interface. It just exposes an API and will accept an access token and will validate the access token. If the token is valid, it'll give its functionality. So how do we go about registering such an API? So an API is registered as an app. I'm inside my Azure AD, and throughout this module, I've created this ClientApp, and I created this MyWebApp. And this was client credential flow. This was a website. Now I wish to create an API. Now first off the bat, let me just say I could have just reused this MyWebApp and made that an API because an API is a website if you think about it, right? And I could definitely do that, and then I can also have a client call the API. But what I wish to be able to do is that I want to actually demonstrate through the whole thing full circle. I will actually have the MyWebApp, which we had authored in the previous model, call the API that we are going to register now. And I could have reused MyWebApp for this purpose, and the advantage of doing that would be that I wouldn't have to grant permissions because an app can always call itself. But I want to demonstrate the permissions part as well, so I'll go to the New registration button, and I will register a new app. Let's call this MyWebAPI. Clear enough? Let's go down here. Now an API does not need a redirect URI, so I'll simply say Register. So this MyWebAPI is now registered, but it's not an API yet. It's not exposing an API yet. So we need to tell Azure AD that we intend to expose an API. You do that right here, Expose an API. Now please don't be confused. It's not like this app registration is actually exposing the API. It's your actual code that will expose the API. Here we are merely telling Azure AD that this particular application will expose an API. So under App ID URI, now this will certainly work, but it's not really intuitive, so this needs to be a unique string that uniquely identifies your API in the entire universe, not just your tenet, but in the entire universe. So the way I like to go about this is that I like to prefix this with my tenet, and this is actually a very common standard. So https://sahilmalikgmail.onmicrosoft.com. And let's call it server. And click on Save. Now, I have added this API, but before I can grant anybody access to call this API, I also need to add a scope. Well, let me show you what I mean. In a new tab, I'm going to open portal.azure.com again, and we're going to navigate to Azure Active Directory, and we're going to go to App registrations. And here I'm going to look at MyWebApp because now what I want to do is that I want to basically tell Azure AD that MyWebApp is capable or is allowed to call MyWebAPI. So if I click here and go to API permissions, so granting API permissions is like when I granted access to Microsoft Graph earlier, now I'm going to try and grant access to my API. Go to My APIs and nothing. So I'll go back to my API, and I'm going to add a scope. Click on Add a scope, and I'll just call this myscope, very descriptive and creative, right? But this would be like admin, read, write, specific to your application. These are the permissions your API exposes. Admins only permission would be the equivalent of an application permission. But I will make it Admins and users because I want to demonstrate the user's identity going all the way to the API. And even this is a delegated permission, but an administrator can grant this as well, so I'll just give it some interesting description like this. This is just to sort of help out the user as in what are they granting permission to? And I'll say Add scope. So the scope has been added, and the string is very, very important. Let me hover over this. This string is going to become very important very soon. We'll get to this in a second. But let's go back to my web application, and I'm going to try and grant permission again. Go to My APIs. And now I see that this MyWebAPI is something that I can grant permission to. So I'm going to select this and say what scopes. So not every application can access every scope. But here I will say that my web app can access the myscope, select it, click Add permissions, and wait for this consent thing to get enabled. This'll take just a moment. And a few seconds later, this Grant admin consent button is enabled. Let's go ahead and click on this. And as an administrator, I'll go ahead and provide consent. This is what I'm granting consent to. It shows up here. That's a good sign. Click on Accept, and consent has been granted. So at this time your API has been registered, the API is exposing a scope, and the web app is configured to call that particular scope. Next, we will actually write the code for the API.

Author a Secure WebAPI
So now that I have set up both the API and the client for the API in Azure AD, let's go ahead and actually write that API and run it locally on our machine. Now that my API is registered in Azure AD, now we can start writing some code and here is where things become Node.js specific. Now of course, you could have written the API in any language you wish, .NET, Python, whatever you want, but since this is a Node.js specific course, I'm going to write this API in Node.js. And again, passport‑azure‑ad is your friend. So you see over here that I've taken a dependency in certain node packages. If you're a seasoned node developer, these should appear very, very familiar to you, Express.js, Morgan is for logging, and then Passport is what we are going to use for our API authentication purposes. I also have a, here I have a file called server.js and this is where the actual logic of my API is. Notice that I've already done npm install so I have node_modules populated. So let's dive into server.js and see what the actual code looks like. So the important thing that you're looking for here is something called a BearerStrategy. If you remember, that in a web application I used OIDCStrategy. Here, I'm using BearerStrategy. So now let's scroll down further and see how exactly are we using BearerStrategy. So we pass in certain options, okay, in which I need to pass it the identityMetadata, so this is basically this interesting URL. What happens is that it is from that URL that it'll download the important details of the identity provider, including certificates, because when an access token comes in, that access token has a signature and we need to verify that signature and the verification is done using a certificate that you can download from here. So the application will automatically cache that certificate, if it changes, it'll update it, which means that whatever server your application is running on, that server needs to be able to access this URL. Okay? So it can't read behind a blank firewall, so that's important, please keep that in mind. And but all this download and validation, all this tough logic is actually made simple for us by passport‑azure‑ad anyway. Okay, So the audience over here is this https sahilmalikgmail on microsoft.com/server. Where did this come from? Let's go back to my API registration here. Okay. That string, the app ID URI is the audience over here. See that? Okay. It's making sense, right? Now, I will go over here to the overview part off the MyWebAPI and I will copy/paste this client Id, also known as app ID, and here I'm going to place that over here. Now, this is being passed in as options to passport‑azure‑ad, we also need to define the issuer and logging level, etc, and then let's go down here, see what else are we doing, and this magic line code, Line 26, is basically saying we want to use BearerStrategy. Congratulations. Now you are supporting an API. Here, I have enabled CORS, so I just said allow everyone. This is not an Azure AD specific concept, but this is basically saying that allow cross origin requests, requests are originating from other URLs. Since this is an API, that makes sense. And I have exposed a URL of /admin, and any request coming into /admin, it's simple, we'll just call it over get to keep things simple, but any request coming in must be authenticated. Okay? If it is not authenticated, you should get back a 401. And how are we authenticating? We simply say passport.authenticate. That's it. That's how simple it is. And if authentication succeeds, then we look at look at the name claim over here and we send back the value of the name claim. Effectively, what this means is that the API will reply saying I think such and such user is calling me. Okay? So if I log in as Sahil Malik to the web app and the web app calls this API under the behalf off Sahil Malik, the logged‑in user, then this claims name value should be Sahil Malik. Easy enough. So this sort of proves that the user's identity is going all the way back to the API. Okay? And then we simply listen on Port 5000 and this is how my API works. Let me go ahead and run this code. So we're in the server project. Let's say npm start, actually I didn't define an NPM command, so I'll just say node server.js, but feel free to define an NPM command, if you wish. And my API is running. Let's try and test it. Now, it is possible to actually go through the whole auth code flow, what a web app would have done. Or for that matter, you know, you can try any open Id connect flow because an API is an API. An API cares about the access token, it doesn't care what flow you used to get the access token. But I'm going to keep things simple and I'm going to call this API without authentication. So localhost5000/admin, hit Enter. What do you think will happen? Unauthorized. Why did we get unauthorized? Because we didn't pass an access token. This is just a simple HTTP request. So next, I'm going to go to the other project from the previous module that I had and I'm going to modify this client web app project, which was earlier calling Microsoft graph, okay, but now I'm going to modify it, and I'm going to have this client web app now call my custom API, the one that we just wrote. We'll see that next.

Call the WebAPI
Now that we have the API running successfully, now let's call it. Now, I'm going to call it from a web application, but theoretically, you should be able to call this API from anything. In the previous module, I had authored this project clientWebApp, and I had used this clientWebApp to call an API that Microsoft has given us, which is Microsoft Graph, and I had demonstrated calling Microsoft Graph under the user's identity. Now, I want to sort of show you that you're first class citizen when it comes to programming in Azure AD, so you can author an API just like Microsoft Graph. In fact, that's what we've just done in the server project. So what I did is that the server project is still running, you just saw this, and it's giving me an unauthorized if I don't pass an access token, but now I'm going to go to the clientWebApp, and I'm going to make some minor changes to this clientWebApp so it can call my API. So first, the rendering logic, let's make this a little bit simpler. So, rather than this big JSON thing, I'll just say just write out the body, okay? Just because we're not sending a big blob of JSON back, so let's make it simpler. Okay, next change, in config.js, the resource URL, instead of graph.microsoft.com, this will become the App ID URI of the API that I'm trying to access. Do you recognize this string? This is the App ID URI of the API that we just wrote. Next, let's go to app.js, and when I'm making the call, instead of making the call to graph.microsoft.com, I will make a call to where my API is running. And yes, I'm running this on HTTP, should be HTTPS, but this is development environment, and if this API was running inside of Azure, for example, you could have used that as well. So the URL would change, but the rest of the details are exactly the same. That's it. These are the changes we need to make. So let's go back to PowerShell, and let's make sure that we have done an npm install, looks like we're all set, and let's just say npm start. I think I have a start command here. Yes, I do, node app.js. And now my web application is running. So now in a new tab, I will visit the web application, which can successfully call my API; I hope, if I haven't made any typos. Let's go ahead and hit Log In. Okay, the fact that I see this tells me that I should have a valid access token to call my API. Now, this token is valid for an hour, so hurry up. Well, an hour should be enough, right? So, copy paste this access token, and let's try and decrypt it and see what it looks like. Again, to decrypt it, go to jwt.ms, go ahead and paste that access token here. Again, I see three sections as expected. Actually, I ended up copying the refresh token as well. Oops, my bad. So let's grab only the access token, carefully this time, and where does it end? Right there. See, refreshToken. So, I copied too much because I did ask for a refreshToken as well, so I'm getting one, that's as expected. And I copied this up here. Okay, that's better. Now let's scroll down here. This is a JWT token. It is for this audience. It is for that issuer. But here's the interesting part, look at the scopes. These are the scopes my application has access to. If I had more than one, they would all show up here, the ones that have been previously consented to. Now, let's come back to my application and click on this Call API button. And remember, Call API is going to call, well, it's going to call my API. So let's go to the PowerShell window that is running my API. I'm going to dock this to the right so we can see what happens when I click on that. So remember, this is a partial output of the server, the API. Now I'm going to click on the call API button, and it says name Sahil Malik. So this sort of proves that the identity of the user logged into the browser from the browser to the web application all the way to the API, and the API thinks that that's the user that's logged in. So this proves that my identity went all the way back to the server. And as you can see over here, as this output proves, that these were the claims that were validated, and, yes, the identity of the user went all the way back to the API. And this is how you go about authoring an API. Now, I leave a little exercise for you. What I want you to do is the client credentials application that we wrote in the services module, I want you to modify that client credentials code and call this localhost:5000/admin. Try it; see if you can get it to work. Remember that an API is, an API is just an API, it just wants an access token. The things you have to worry about there are how to get an access token; well, I've shown you how to do that in the Client Credentials flow, but you may have to think about the user's identity there because there is no user's identity. Maybe you'll need to add an application scope. Try it out, okay? Let me know how it goes

Summary
Let's end with a little summary. In this module, I talked about how web API authentication works. Once we understood that, then I talked about scopes and consent. Then, we dove into a few demos to solidify our knowledge, and first we set up a web API and its permissions. Then we authored a secure web API backed by that Azure AD registration that we had just created. And then finally, we called the API by simply modifying some code from the previous module, which was a web application. So instead of calling Microsoft Graph, we're now calling our API. Now at this point, you have a pretty good understanding of how Azure AD can help you write secure applications. In the next module, I'm going to talk about another very important tool that Azure has given you, which is a concept of managed identity and key vault, which can also help you write secure applications in any platform, but certainly Node.js as well. I'll see you in the next module.

Managed Identity and Key Vault
Introduction
So far, the emphasis that I've had in this course is around authentication, authorization, the various facilities that Azure AD gives me, but we all know that any application has another very important headache to worry about, which is how do you manage and securely access the secrets and all the necessary baggage that comes with it? It is for that purpose that we have a facility inside of Azure AD called Key Vault, and another very important concept called managed identity. Both of these, well, they can be used independently, but they work very well together as well. So in this module, I'll be introducing you to both of these concepts, starting with a little overview. First, I'll be giving you a good introduction to what is Key Vault so we understand the place, and need, and facilities that Key Vault gives us. Then I'll explain you what managed. Identity is so we understand where it fits in the Azure puzzle. And then once we understand both of these, I'll dive into a few demos. So I'm going to create an application that uses managed identity to access a secret stored in Key Vault, and I'm going to break that down into multiple steps. First, I'm going to create an application that has a managed identity. Then we will set a key vault and some permissions on the key vault. Actually, it's called access policies, same as permissions, where I'm going to grant the app that I created in the previous step, and I'm going to grant that app to be able to access secrets. And then finally, we're going to demonstrate accessing the Key Vault using managed identity. And, yes, the last step is going to be specific to Node.js, but like a lot of things in Azure, everything over here is cross platform.

An Introduction to Key Vault
Starting with a little introduction, the word is Key Vault. Well, if I had to define Key Vault, a simple definition of it could be that it is a place for you to securely store secrets, keys, certificates, etc. Yes, it has a lot of other details, like monitoring, access policies, etc., so let's understand it a little bit better. Key Vault, at a high level, lets me do four things. Number one, it lets me manage secrets. So, if I want to securely store and tightly access control things like tokens, passwords, certificates, API keys, or any other secret, Key Vault is where I can do that. It can also be used as a key‑management solution, where I can create and control encryption keys, so I can use that to encrypt data. Key Vault can also be used to store certificates, or even provision, manage, and deploy public and private TLS/SSL certificates that you can use with Azure or other resources. Key Vault allows me to store secrets backed by HSM, or hardware security modules. So these secrets can be protected by either software or FIPS 140‑2 level 2 validated HSMs. Some other characteristics of Key Vault, Azure Key Vault is provisioned and managed in the cloud, but remember, its access is controlled via access policies, which are tightly tied to Azure AD identities, and it is accessible via SDKs or REST APIs. This means that while the customers, or users, or clients of Key Vault can be anywhere, you can be assured that the secrets are safe in a Microsoft‑manage cloud. In other good news, access to Key Vault is fully monitored. That means you have full knowledge of when these keys, and secrets, and certs are being accessed, and how the policies of accessing them are being modified. Key Vault is a first‑class citizen in Azure, and it is fully integrated with Azure. It is usable for nearly any Azure service, and it enables a lot of scenarios in Azure, example, encrypting a virtual machine disk, well, that's backed by Key vault, or your custom application saving secrets, and nearly anything else imaginable. My point is that Key Vault is something you can rely on, and it works very well with many other Azure services. And like I'll show you later, I think it's a perfect pairing with Manage Identity, like wine and cheese, peanut butter and chocolate. Okay, back to Key Vault. It is also platform agnostic, so whether you're a Java programmer, .NET, Node.js, Python, Azure CLI, PowerShell, well nearly anything, you can use Key Vault from it.

An Introduction to Managed Identity
Now let's talk about managed identities. So the thing is, an identity is a very useful thing. Why? Because you can do things on behalf of an identity. So I run a process on my computer. It's running as an identity, as in the user that double‑clicked on notepad.exe, for example. It would be nice if such a concept can be extended to the cloud as well. And actually, you know, we frequently do that. When I talked about application permissions or delegator permissions, the delegator permissions are on behalf of the user, right? Similarly, application permissions where you grant permission to an application would be nice if the application also could have an identity. Identity allows me to monitor who did what. So you have traceability. Well, who read this document, who modified xyz, all of that, who did what? The premise behind that is that the who part, right? The identity, who did it. So identity is a very useful thing. Finally, if you have identities, you can allocate permissions. You can say such and such of the identity is allowed to do x but not y. This wouldn't be possible if the caller didn't have an identity. And I think I think I'm preaching to the choir. You've been developing for a while, so you use these concepts already in many applications, right? But then you also know that identity is also a headache because with identity come credentials. You have to manage those credentials, right? So you keep them secure, and we say we should MFA everything, but we also know that MFA isn't a cure‑all. MFA, multi‑factor authentication, by definition means that the identity now becomes interactive. That means it's not testable, it's not headless, etc. So our other option is to use some form of a password, but we all know passwords are insecure. The point is, managed identity gives you the best of both worlds. It gives you all the benefits of identity. You can do things on behalf of monitor, you can allocate permission, etc., but you have 0 credential management headache. Managed identities, an identity that resides in Azure, and you can assign it to Azure resources. You never have to manage the credential for that identity, but you can use that identity for various things. So how does managed identity work? Well, it's quite simple. You have an Azure resource that wishes to access another Azure resource. The caller, you just give it an identity. This could be a system‑assigned identity or a user‑assigned identity, but at the end of the day, that resource gets an identity, and the other Azure resource will now know that such and such identity is accessing me. So using standard RBAC, etc., I can grant or deny such access. So there are two kinds off managed identity as I just alluded to. The first is system‑ assigned identity, which is enabled directly on the specific Azure instance. So let's even as your function, you want to give it an identity, you can say it's either a system‑ assigned identity or a user‑assigned identity. When you give it a system‑assigned identity, Azure will create an identity for that particular instance of that Azure service, and the credentials are provisioned onto that instance. The lifecycle of that system‑ assigned identity is tied to that particular Azure Service instance. Example, if you give an Azure function, a system‑assigned identity, then when you delete that function, that system‑assigned identity goes away with the deletion of that Azure function. In contrast, you have a user‑assigned managed identity in which you create a stand‑ alone Azure resource first, and then you create an identity next or you can with these auto sequence if you wish, and then you can assign that particular identity to one or more Azure resources. So the advantage here is that you have full flexibility on how the identity gets created, how it gets assigned. It even gets assigned to more than one Azure resource if you wish. But the lifecycle of this identity is managed separately from the Azure Service instance. So deleting the service instance will not clean the identity for you. Both have pros and cons. I'm glad I have both these options. How does managed identity work? Well, at the heart of it is Azure Instance Metadata Service Endpoint or IMSD for short, or actually, IMDS, Azure Instance Metadata Service. The way this works is that inside of something that runs in Azure, this can be a container, a function, functions behind the scenes are containers, or a virtual machine, etc., something that is managed identity compliant, let's say. It allows manage identity. On that particular running instance, you will have an internal web service or token endpoint that looks like the URL below. That URL is a 1 69. URL, which means it is accessible only within that particular running instance, container, a VM, whatever it might be. So any code that is running on that particular Azure instance is going to interact with that endpoint, perform the authentication process, and the good news is at the end of it, you get a token. This is your usual access token, and using this access token, you can access other services. This access token, like most other access tokens contain information about the user's identity. Now, before I dive into a demo, let me describe to you what I intend to build. So at a high level, I already mentioned that this is how managed identity works. You have an Azure resource to which you grant an identity, which called another Azure resource. Easy. I'm going to model things on exactly this model. My caller will be a Node.js App Service on which we will give a system‑assigned managed identity, and then I'm going to use it to call Azure Key Vault and access a secret there. So we'll need to deal with various things like set up the Key Vault, set up the permissions, set up this App Service, give it a managed identity, and then write the code to use that managed identity to access that Key Vault. Great, now let's dive into some actual code.

Create an App with Managed Identity
In my first demo here, I'm going to create a simple app service application with managed identity, and I'm going to do so with Node.js because this is a Node.js course. But remember the concepts here are universal. First, I'm going to create a simple web app, and then we'll enable managed identity on it. But, you know, I'm going to create multiple things as a part off this particular demo. So let's go ahead and create ourselves a resource group so we can clean things easily afterwards. So everything that I'm doing here can be done using Azure CLI as well, but I'll do everything through the portal. So let's go ahead and create a resource group. That looks good. And click the Create button, and now my resource group has been created. Now let's go into this resource group, and I'm going to add a resource. And let's go ahead and select web app like that and click on the Create button. Now you should be using this template, at least at the type of recording this course, because this template is more generic. It allows me to pick what platform I wish. So I'm going to specify Node.js in a minute. So I'll put it in this resource group. Let's give it a name. Hmm, what? Let's call it sahilnodejsapp because this needs to be unique, so sahilnodejsapp. This checkbox means that is available. Runtime stack. Okay, so here I will pick Node.js because we're talking about Node.js. And even though Node 12 is in preview, Node 12 itself has been released, so I'll go with this. And let's go here. Let's pick Linux as the operating system. Feel free to put this in any region, but I'll keep it in the same region as my resource group. And here this particular Linux plan, let's give it a better name. Let's call it mylinuxplan. Hit OK. And I am going to change the size of it because this is just a demo, and I'm cheap. I'll go with free. For managed identity, it doesn't matter. Even the free version supports managed identity. So just a quick review. We put it in the test resource group. We gave it a Node.js app name. This is code, not a Docker container. Although it'll work with Docker container as well. The runtime stack is Node 12, and we're going with Linux. It'll work with Windows as well. I put it in East US. The plan is mylinuxplan. It's free. Review and create. So optionally you can have monitoring and tags as well, but it's not pertinent to my demo. So I'm going to click this Create button. It says submitting deployment, deployment in progress. And in a few seconds, this particular web app will be provisioned for me. So let's wait for this to finish. And in just a few brief moments, my deployment is now complete. I can click this Go to resource button, or I can also access it from the resource group. So go to Test, that's the name of my resource group, and in here I should see mylinuxplan. Give it a few moments. My Node.js app will also show up here. There you go. Now let's go ahead and click on the Node.js app, which is the app service. And on the left‑hand side, there will be a setting for identity. Go ahead and click on that. Now the steps I'm showing you over here, even though I'm doing them in an app service, remember, the steps are identical to any service that supports managed identity. You see, there are two different kinds of managed identity. You can choose to create a user assigned identity or a system assigned identity. For this demo, I'll go with system assigned identity. Choose On and remember to hit the Save button and hit Yes. Now just by doing this much, I have now given this particular app service an identity, a system assigned managed identity. And it has an object ID behind the scenes. There's a service principle, etc. But the thing is, you don't need to worry about the credentials of all of that, etc. This identity is now ready to use.

Set up Key Vault and Permissions
Now that I have a managed identity set up, next, I'm going to set up a key vault. In this key vault, I will create a secret, and I'll also create access policies with some permissions. Now my first Azure resource is set up, which is this App Service with a system assigned managed identity. What I'm going to eventually do is have code running here called a key vault. So now let's go ahead and set up a key vault, and we're going to grant this particular managed identity access to a secret in that key vault. Let's see how. So I'm going to click on the Create a resource button here, and I'm going to type Key Vault like that. Click on Create, and like most of the Azure resources, it will give you a little form to fill out. And, remember, I am doing this through the portal, but everything I'm showing you is automatable. You can do it through pipelines, Azure DevOps, GitHub Enterprise, ARM templates, Azure CLI, PowerShell, whatever you wish. Here we go. Let's give it a name. So sahilkeyvault123. How does that sound? So this needs to be unique. So this checkbox means its unique. Why does it need to be unique? Because we access it using DNS. Again, let's go ahead and put this in East US. It doesn't need to be. It can be in a different datacenter, but I'll keep everything in one datacenter. Pricing tier, either standard or premium. For my demo, I don't care about HSM backed keys. The steps I'm showing are identical in both. And, next, you can modify the access policies right here, but I'm going to create it and then modify the access policies. Either of the steps is valid. So let's review. Looks good. Yep, sahilkeyvault123. Let's remember that name. You can choose to tie it to a particular network. I'm not going to do that. But to have added security, you can do that. Now click on this Create button, and let's wait for this key vault to get permission. This is going to take a few seconds. In a few brief moments, your key vault is ready to use. Click on the Go to resource button. Again, you can access it from Resource groups or All resources as well. Now once you can access it, it should look a little bit like this. You can manage key secrets and certs here, and you can manage access policies from here. What I'm going to do, I'm going to create a secret. Now I'm going to show you secrets, but, again, the steps are identical for keys and certs as well. So click on Generate/Import. I'll go with manual, and let's give it a name. I shall call it mySecret, how intuitive, right? And let's give it a value. And I'm not going to tell you what the value is because when we run the code, you'll see the value. So I've given it a value. Content type is optional. You can set an expiration date, activation date. We'll say it's enabled. Click on Create. There you go. So this has been created. Now notice that in key vault, it'll maintain like versions, etc., as well. That's very nice. So mySecret is ready to go. In order to be able to access it, I need to fix the access policies. So let's go into Access policies. Now as you see, this sahilmalik was the administrator here who created this key vault. This person seems to have access to everything in this key vault, but the sahilnodejsapp currently has no access. So we need to add the access policy for the Node.js application. How do we do that? So here you see there is an Add Access Policy link. Go ahead and click on that. So Configure from template, this is optional, but it makes things easier. So I'm basically going to say that whoever I'm going to assign permissions here will be able to manage secrets. If you want to see the details of what they're able to do, this is what they'll be able to do. For instance, I may want to be able to say that this user can only set or delete but not read, or this user can only read secrets. So I have very fine‑grain control over here, but I'll just leave all of them checked. Next question. Who can access? So here I'm going to say select principle. And, remember, I had created a managed identity for sahilnodejsapp. So if I scroll down here, I should see both service principles, managed identities, and users that I can grant permissions to. So here I'm going to search for sahilnodejsapp. Here I already see it. Let's go in and pick that, Select, and click on Add. There you go. Just remember to click this Save button. And now this key vault has been set an access policy on that allows the managed identity for sahilnodejsapp to be able to manage secrets on this key vault.

Access Key Vault Using Managed Identity
Now that we have both our Azure resources set up, as in the app service with the managed identity and the Key Vault, and we've set up the access policies for that manage identity as well, now let's write some code to access that Key Vault using that manage identity from a Node.js app. At this point, I have an App Service provision tied to an App Service plan. This App Service has also been given a managed identity. In addition, I have a key vault with one secret in it. The managed identity for this sahilnodejsapp has been given the rights to manage secrets in sahilkeyvault. Next what I'm going to do, I'm going to write some code inside of sahilnodejsapp. We're going to run it in the cloud, and then we'll be able to demonstrate that the code running inside Node.js app can read secrets from sahilkeyvault, and it can do so because we've set that access policy. So let me show you what that code looks like. So the code, well, it's actually very simple, so I took the liberty and set it up for you. I've already done an npm install. And in order to deploy this code, there are various ways to do it, but I'll use the simplest possible way, which is I'll use a local get _____ repo, and I'll push that into the cloud. Okay, so let me show you what the code looks like. First, let's look at package.json. So there's a script called node index.js. I have only one js file here, and that's basically where all my code is. This index.js file is an express js application, and it will basically expose a simple URL on root, and when you call that particular you URL, it will attempt to read Key Vault, it will read that secret under its managed identity, and it will return me whatever value it can read. And to do that, I have taken a dependency on two packages at azure/identity and at azure/keyvault‑secrets. Okay, now let's dive into index.js. So if you see inside of index.js, as you can see up here that I have taken a dependency on Express, KeyVaultSecret, and Identity. Simple. Then I have also given it two string values, which is a Key Vault URL. Let me show you how I got this Key Vault URL. So if you go into your Key Vault in the Azure portal, the DNS name that you see over here, sahilkeyvault123.vault.azure.net, that is my Key Vault URL. The secret name is the secret name that I'd set earlier. So if you go into Secrets, mysecret, so that name over there I need to set that in code over here. Okay, let's skip over this part for a second. Let's dive down here. So essentially, what I'm doing is that on port 8080, I am listening. Easy enough. Now if I run this locally, it's not going to work because locally, I can't get a managed identity because the manager identity runs in the cloud. However, I'll tell you that inside off this particular node package there are concepts that allow you to create a chain credential, which says, hey, if a managed identity, this line here, is not available, then fall back to another identity. And a very convenient one is actually an Azure AD app registration because that also has a service principle, and you can use that to get an identity when running locally, but managed identity when running in the cloud. So here's another advantage of managed identities that they allow your code to run locally or in the cloud without any code changes or config file changes. Okay, now, this code that you're seeing over here is designed to run in the cloud only as in that it'll get a managed identity for cloud only, and here's how it works. So I say, get the credential, which is identity.Default.Azure.Credential. Just that one line is going to abstract all the nonsense that, you know, call the IMDS endpoint, etc. It is going to abstract all of that for you, and it will get you the credential, which is the managed identity. Then I use a client to client for the key vault. It's KeyVaultSecret. So this client new KeyVaultSecret.SecretClient, give it the URL, and supply it the credential. Then I get secret, which returns me a promise. Then I tried to read the value secret.value. If I get the value, I write them out. Otherwise I send back an error. Easy as that. This is how simple my code is. Now, I'm going to deploy this code into the cloud. So to deploy this, let's go to my App Service. Here you go. Go to Deployment Center, and there are various choices of how you can deploy this. You can use any of these. I'll go with Local Git. So basically, the code that is running locally, I'll turn that into a Git repo, and I will use that to deploy to the cloud. And I'm going to go with App Service build service, so select that, continue and click on Finish. What this is going to do is it is going to give me a Git wrap URL that is specific to this particular App Service. Go ahead and copy/paste this. So let's get this carefully, Copy, Okay? Now, I am going to save this in Notepad, and I'm going to save more than one thing. I'll tell you why in a second. I'll also need deployment credentials, right? So this particular Git wrap was protected by credentials. I'll just use the credentials they're giving me here. So the user name looks like this. And the password, I really wouldn't want to be typing this, looks like this, so copy/paste is key. Okay, now, let's come back to my terminal, and I'm going to turn this into a Git wrapper, and I'm simply going to say git add. And now let's go ahead and hit commit here. Okay, wonderful. Now this is a Git wrapper. Now, in order to push this into Azure, I'll need to set a remote over here to this URL. So let's copy/paste this URL. Okay, and I'm going to say git remote add azure, and give it that URL. Hit Enter. And now I'm going to simply push it over there, and that'll start the deployment process, git push azure master, hit Enter. It's asking me for credentials, as expected. Let's provide it with the credentials. Copy, paste, and, copy, paste. Okay. So it didn't make a mistake in my credentials. You should see something like this. It is deploying it. It'll build it. It'll show me the output here, but actually I can trace this output up here as well. So come back here as you see where the first commit is now being deployed. Now, before we start testing it, I'll tell you that once this is done, I can click this Browse button and access it, but you need to do one more thing. Basically, in the cloud, this is running as a container, which will try and ping it on port 8080. You can see all of that in the log. So if you go down here, there is a link for Log stream. It'll actually show you what it's doing behind the scenes, but I'll tell you that you'll need to make a minor change here. So look for a link here called Configuration, and this step is specific to Linux. So go to Configuration, click on New application setting, and give it a name. This name is, it's a magic word that you need to remember, WEBSITES_PORT, and the value will be 8080, and hit OK. All set. Now let's go back to our Deployment Center. Oh, I need to save it, very important, thank you Azure. So update the web app settings. Now let's go back to Deployment Center, and it says Success. You can look at the logs over here. Here you go. And actually, you can also look at detailed logs from terminal right there. Okay, Now let's access it and see what it gives us. And unfortunately, I get an error. Well, I must have made a mistake, but see the error over here. Since we're writing out the entire error message, let's see, I'm making a request to sahil123keyvault.vault.azure.net. Hmmm. Let's see what's wrong. So if you go back here, go to All resources, go to, I think I made a mistake. So this is how you can go about debugging this as well. So the DNS name that I picked was wrong. And this gives me an opportunity to show you how I can push updates now. Right? So let's go ahead and fix this. Okay, it's sahilkeyvault123 not sahil123keyvault, sorry. Let's come back to PowerShell, and, again, I'm going to say git, let's remove caps lock, git add . git commit ‑ m "Second commit". Okay. This is not Unix so I have to do it sequentially. So, like that, git commit "Second commit" and git push azure master, and now, again, in Deployment Center, where is the Deployment Center? Under All resources. Let's go to my Node.js app. Under Deployment Center, I should see the second build get kicked off right here. So let's wait for this to finish. You can look at the logs here if you wish, and in a moment it tells me success over here. I can verify that from here. So looks like it worked. And now, I'll come back here and I'll hit refresh. Hooray. As you can see, this is the Key Vault value that I'd put in, CanUSeeeThis. Let's go into All resources. Let's verify that that is indeed the value. So going to Key Vault, go into Secrets. This is mysecret. Okay? Here, show secret value, CanUSeeeThis, and this is how access to Key Vault works from an entity that has a managed identity.

Summary
Let's end with a little summary. In this module, I introduced you to Azure Key Vault. Then I introduced you to managed identity. And while they are separate products, I explained how they worked very well together as well. You're welcome to use them independently also, if you wish. Then we had demos. I showed you how we can create an App Service with managed identity. Remember, managed identity applies to more than just App Service so the concepts apply to VMs, containers, whatever you wish. Then we set up a key vault with access policies on it, and then, finally, I showed you via code how you can access that Key Vault using managed identity. And this brings us to the end of this course. Writing secure applications is a big responsibility, and I have no doubt that the things that I covered in this course are nearly not sufficient to cover a big topic like security. But as far as Azure is concerned, I hope I did a good job explaining you the facilities that Azure has, as far as Node.js is concerned, to allow you to write secure applications to various facilities that Azure AD has, how you can use manage identities, and how you can use Key Vault. I hope you found this course useful. Thank you for watching, and I'll see you next time.
