Learning to build an API with Node.js can be overwhelming since there are so many options. In this course, API Design in Node.js Featuring Express & Mongo, you’ll follow Scott Moss as he builds example APIs in Node.js using the Express.js framework. You’ll start with a brief intro to Node.js and Express. Next, you’ll explore RESTful APIs in Express, how to add middleware, and methods for testing your API. With those fundamentals covered, you’ll move on to important topics such as data modeling, authentication, security, and deployment. By the end of this course, you'll have developed a fully functional API with Node.js, and will have the skills to build your own APIs. You'll see just how easy and fun creating APIs in Node.js can be.

Node.js
Node.js Refresher
Introduction So let's just hop right into it then. Everybody should have the link for this. So these are going to be like our notes or like our slides. I don't like to use actual slides because I'm just like worn out on slides so I just make a website with the notes on it and that's what we're going to use and this will be here forever. I'll probably have to README on the GitHub, README so you can look at it. So this where we do our learnings and then we'll have an app that we'll be building and then as far as the app, the repo is going to be here. If you haven't got this, go ahead and fork it or clone it or whatever your process is for getting your repos. Cool! So also I want to let you all know that if you have a question here on site, just ask me. Don't feel like you have to wait until the end. Just like I want to see you open, ask me as many questions as you want. Don't feel like you're slowing me down and online if you're joining us, just hit up Mark with a K on the channel and just ask him and he'll either answer it himself or he'll ask me. So just feel free to ask as many questions as you can. If you think I made a mistake or if you didn't quite understand what I said, this is, you know, don't let it go by, just totally ask me. Great! So what are we going to be doing for these next three days in this workshop? Well, like I said, it's going to be around designing APIs with Node and Mongo and how all that works. So not only are we going to be learning how to design this stuff, but we're also going to be building it, of course. We're going to learn how to test it and we're going to be deploying it, which makes sense. It wouldn't really be fair if I showed you how to design an API and now how to do the rest of that stuff. That just wouldn't be fair; I wouldn't be setting you up for anything practical. So you should have some experience with JavaScript. I hope everybody here knows JavaScript. If you don't know JavaScript this might be painful for you unless you're just or you know, you have tons of experience on the backend and you can get the backend concepts and maybe just work your way through JavaScript, but you should totally know some JavaScript. A little Node experience wouldn't hurt either. If you're brand new to Node and you have no idea how Node works, that's fine, we can get through some of this stuff, but some Node experience would be great, but by the end of the workshop you will have built and deployed an API for a blogging app that has authentication. So as far as like the application itself, you will not be building that. We've actually built that on another workshop. So that's built for you, the frontend, the client; you'll just be building the server part for it. So don't worry it or don't worry about, you know, messing around with the actual web app. We're going to be building that. Cool! Any questions so far? Alright, so let's just do like a quick refresher on Node. Who in here has experience with Node? Let me see hands. Okay, a little bit, a little bit, none, okay. So we're going to do a little bit of a refresher on it. So I'm just going to walk through some examples and talk about some of the things that are different and what it is and then move on from there. So Node. js is basically a way just to run JavaScript outside the context of a browser. That's it. That's all it is. It's not a server framework. It's just I want to be able to run JavaScript outside of this. That's what Node. js is. It's using the same v8 that Google Chrome is using or I mean actually Node is using like a different version of v8, but it is v8. So we can use Node for many things now like tooling and servers because we can run it outside the context of the browser, just like you would be able to do with something like Python or Ruby. So to get started, if you have Node installed you can just type in node in your terminal and you'll get a full JavaScript REPL. So what I mean by that is if you go into your terminal with Node and if you just type in node here, you now have a REPL here. This is JavaScript, alright. So you have a full JavaScript REPL here. So if you want to be able to or it's the same thing if you went into the console inside of Chrome, minus the browser API stuff, the browser-specific things. So that's how you know you've got Node working. Like I said, but note this is just JavaScript, but it's not in the context of the browser. Oh, by the way, if you see like spelling errors and stuff right here, I'm really bad at spelling so just like forgive me right now like that, but yes, so it's just JavaScript, but it is outside the context of the browser so most of the browser APIs do not exist in Node, right? Like I can't come into Node and start doing things I would expect in a browser like oh yes, I need to do a document. query selector, right? Like that's not going to work. Document is undefined, right? So this is not the browser, this is just JavaScript outside the browser. So those APIs aren't there. There are some that are there that are that are very useful like console, that's still there, console. log, console dot all that good stuff. All that's still there, but a lot of the other stuff isn't so just remember that. Yes? A question came up, is there a way to add the browser APIs to Node. js? There are polyfills out there that will mock some of this stuff and in some cases some libraries because Node and because of this whole universal JavaScript thing where people want to run JavaScript on both the server side and client side, some code actually needs those things mocked out. So yes, there are mocks there, but realistically you wouldn't even need that stuff. You wouldn't need it for execution. You might need it for like a library to work. Like for instance, I saw something the other day, there's this animation library that they used that's like expecting these window or these browser APIs to exist and if they don't it'll error out on Node. I would never use them in Node, but it needs to be there in order for it to run. So sometimes you have to mock this stuff out, but people are getting to the point where they're being more aware of where their code is going to be run so they define their libraries in something called a universal module definition which will allow their JavaScript to either run in the browser in Node and in any type of like module format, whether that's AMD or CommonJS. So that's the newer way to build your libraries so that's like the thing that are people are starting to do now, but if you download something that isn't like that, something that's like attached to the window and you try to run it in Node, you're probably going to get an error so you can chase the errors and figure out the polyfill yourself or you know, just convert it to Node yourself and see what happens, but yes, there are some polyfills that do exist, but people are moving away from that. So if you were to install Node you will also notice that you get something called NPM, which if you look at it you might think it stands for Node Package Manager, but it actually doesn't. It doesn't stand for Node Package Manager. I actually don't even know what it stands for. So it's not Node Package Manager though, so I think this is like a pun that the npm people came up with, but it's not Node Package Manager, which should be it. So the NPM is actually a really, really good package manager though as far as like handling dependencies. In fact, it's probably one of the best that I've seen, not even just like related to JavaScript, but like just in general. So it's kind of like if you ever use Homebrew or something like that, it's very similar to that, but just in my opinion a lot easier to use. So the way NPM works, like I said, it comes bundled with your installation of Node, it uses this file called package. json to store like metadata about your packages and what packages your package may need. So like it just reads that file depending on the command you give it and that's how it knows what to install, what to uninstall, what to update, it's just a file. So yes, NPM is the standard. There really aren't any other package managers you would use with Node, but they are two separate entities. NPM is its own entity, Node is its own entity, they just happen to be working together because they just work that way. So yes, you'll see a lot of everything we do as far as dependency management will be through NPM. There are other package managers out there like Bower and stuff like that, but Bower is a Node module that you have to install with NPM and that's more for client-side dependencies. So it's still all through NPM. So all third-party modules when downloaded will be placed in the node_modules directory by default. So we use NPM to go download something. If there isn't already a node_modules directory at the root of our application, one will be created and that's where all of our Node modules will be placed by default, in a node_modules folder.

CommonJS
So Node uses CommonJS for its module loader. Anybody here know what CommonJS is? A module loader? How did you know? Yes, it's a module loader, that's exactly what it is. It's kind of funny because when I first heard of CommonJS and I looked at the syntax, I was like oh, it uses require. Wait, isn't that RequireJS? No, it's not. RequireJS is actually AMD, but CommonJS is what the Node folks decided to use as their module loader because they had to because if you think about it, when you run JavaScript, you know, on the client, how do we tell other JavaScript about other JavaScript? Like how do we associate JavaScript files together on the client? Script tags. Script tags, right? So you have an HTML file and you have script tags. There's no HTML file, there's no DOM on Node so there needs to be a way of associating these JavaScript files together in these modules so they needed a module loader so they chose CommonJS, which in my opinion was a really good choice. There are some differences between CommonJS and AMD and now the new ES 2015 module, which is completely different than all of them, but CommonJS was the one that they chose a couple years ago when they made Node and it's a really good choice. So using require, we get access to built-in and third-party npm modules and of course, the modules that we make. So here's a little code snippet of how that actually works. So if we were inside of a Node file and I'll show you in a minute, we can just do it from the terminal, this is how we would get access to a built-in node module. We would just say var, whatever you want to call it, equals, and then use the require function and pass in the name of that module. In this specific example the path module is a module that's built into Node and if we get a little more fine detail, we know that this is either a built-in node module or a module that we downloaded and that's because we didn't have to prefix it with a. / and if you don't prefix your names in the require, that means what happens is Node is automatically going to assume that it's either a built-in node module or it's belonging in the node_modules folder. If you put a. / in front of it, it's going to go like oh, this is a module that you made somewhere in this directory, let me go and find it, and I'll show you what that looks like in a minute. So this is an example of a built-in node module that we did not have to download. It's already baked into the Node path. Here's an example of one that we downloaded. So this is like we npm installed lodash, which is an alternative to Underscore if you've ever used Underscore. js, it's the same thing and this is how we require. It's the same thing. We just require the name of the package, which is lodash and we don't have to put a. / in front of it because it's installed in a node_modules folder. So we don't have to do that. Anything that's in a node_modules folder, you don't have to. / in front of it, but for this one, which is the module that we created in a separate file, we have to put the. / in front of it, otherwise Node is going to assume or NPM or yes, Node is going to assume that it's in the node_modules folder or that it's baked in internally, which is not the case. So it just wouldn't be able to find it if we didn't do this. So you put in the path that you place in here is relative to the file that you're requiring from. Also note that I didn't have to put. js, I didn't have to put an extension name on any of these files; it assumes that it's JavaScript by default. So you don't have to put. js. It knows, I mean, what else would it be? It might be JSON or something else, but by default it's going to be js. So you don't have to put the extension. If you do put the extension, it's not going to break, but you don't have to. Any questions on that stuff? Okay, so above are some examples of how to access node modules using CommonJS. So this is how we would access them and here are some examples of how we would expose them if we were to create them. So these are like two different files, but here's the one file. So we would use, oops, it should be exports, not export. I forgot to put the s there. So we would use the exports keyword here, which would allow us to expose. Yes? There's a question on how does Node know where the node_modules folder is? The node_modules folder will always be on the root of the application, thanks to npm and if it's not there, it'll recursively look for it. And I guess the followup to that is, yes, how does Node know where the project root is? How does Node know where the project? Ah! Good question. Yes, so I'll get to that, I have an example for that. So yes, we'll use the exports, which just came out of nowhere. So in Node there does exist this type of thing like globals, kind of like in the client where you have everything attached to the window or everything in some type of global space. There does exist some concept of that in Node and that's because in Node actually what's happening is when you make a file in Node, it's actually wrapped in an IIFE. So it doesn't matter what file you do, this is what Node does when it executes your file. So your actual code would be in between here and then what Node does is it gives you some globals, something like module. It also gives you exports, it gives you like dirname, which is the directory name that it's in. All that stuff like that, so and then now you have access to those variables inside your code which will be in here. So every file is wrapped in one of these, it's held in closure. So if you want to see what that looks like, it's literally in the Node source code. You can go check it out; it's exactly how it is. So there's a couple other things in here like, well there are a few other things in here, so yes. So that's how we get access to exports and module. exports and dirname and all that global stuff because it's attached that way. So using the exports keyword we're able to export individual things. Just attach it to the exports object and then now we can require it. It should be exports, not export, and then alternatively we can also do module. exports, which is just like I'm just going to expose this one module here. Exports is like, exports is an object that we can attach different pieces of our code to. Module. exports is the entire object and we're defining it differently. So this is kind of the same thing whereas like exports, we're like let's put a setup function here, an enable function here, a ready function here and it's the same thing if we said module. exports, which is an object and then putting all these methods on it. So you can use whichever syntax you want; they both kind of do the same thing. Any questions on that? Okay, so using the exports object on a module, we can expose our code to be a required layer. There did pop up a question here; do you think Node will support ES 6 style modules in addition or replacing CommonJS style modules? That's a good question. I don't know, well I mean they're using v8 internally so when v8 keeps getting updated, so that's actually like a really debatable question because Node and io. js, it's this big divergence between Node and a different version of Node. A group of people forked Node and make something called io. js because they were tired of Node not being updated readily and not keeping up with security updates with v8 so io. js made it you know, their practice to keep everything new and start implementing ES 2015 features and then now there's news of io. js being merged back into Node and some of those features are coming along. Actually, in Node version 12, if you use use strict, you actually get some ES 2015 features, but not all of them. So because of that I would say that yes, they probably will support the ES 2015 modules because they're already showing support for the ES 2015 features that exist today so when that's going to happen? I'm not sure. They might have a roadmap for it, but yes, they definitely will get there if they get to rely on v8. A couple more popping in here. Can you, what are the pros and cons of module. exports versus exports? Yes, so module. exports, once you do that you cannot export anything else. So once you do a module. exports, you cannot in that same file do exports. this, that's it. Module. exports is the only thing that's going to export it. Using exports just means that when you require it in the next file, let's say we exported a lot of stuff on this module, then this variable myModule will always be an object because exports is an object. So if we said exports. setup, exports. enable, exports. ready and then we just require this file config. js, this myModule would be an object that has a. setup property, a. enable property, a. ready property, whereas if we use like module. exports, we can set this file to be whatever we want. So we don't have to put an object here. We can say, well, let's just put the number 3 and then when we require it this value would be 3. So using exports, there will always be an object when you require it. Using module. exports, it'll be whatever you export on module. exports. Can you assign a single value to module. exports? Yes, you could put any value you want, except for you can't say module. exports equals exports, or I mean you can't say module. exports equals module, or I guess you could; you'd probably have some side effects, but yes, you could put whatever you want there.

Executing Node
Cool, so let's do a little bit of digging around with Node. So I just showed you how to run Node in the context of like a REPL in your terminal, but you can also run Node against a file. So I mean, who wants to write node in here? Nobody wants to; you can't even test this. So you probably want to write some JavaScript in a file and then execute it with Node. So the way you would do that is and I'll just make a file, you don't have follow along; you guys are going to start digging in in a little bit. So if we had a file, I'm just going to call it test. js and I do some, well let's do a console. log here. To execute this file, all I would have to do is go into the terminal, type in node and then the path to that file, which is test. I don't have to put test. js, I could just put test and it'll execute it. So there it is, the console logged heeeey. It executed it and then exited it; alright, so it's not running continuously. Alright, so anything that I do in here, that'll work. So as you can see, the console just prints out to the terminal pretty much the same way it would in the window. There are some differences, but just to show you that this is like real JavaScript, it's executing it. So that's how you would run Node against a file. Any questions on that? Can you make the text bigger, they're asking? Here or here? In your editor. There's, the editor. Okay, my editor, yes, sorry, I must have minimized it last night. Yes, there we go. Did you get the question on he's seeing some people using exports equals module. exports, what does that mean? Yes, so that's like a way to like safeguard yourself from not doing a module. exports and then doing an export somewhere else in the file. So by doing exports equals module. exports, that's like I'm just going to you know, keep everything safe, so I'm still only going to be able to export one thing and then I'm like guaranteed that sometime in the future I don't come down here and say exports, you know, exports. other equals like a value and then that would never get exported because we had a module. exports so it's just a way of like keeping yourself safe. You don't have to do it, but there are a lot of patterns of as far as like exporting and I'll show you some of the other patterns, but that's a pretty standard pattern and we see that a lot, but it's just a way of like making sure you don't try to export something later after you module. export and not have it be able to be required in another file and have some unexpected side effects.

Express
Now we're going to talk about servers in Node and how all that stuff works and how it got here, what is the tooling for that, frameworks for that and what we're going to be using and then you guys will be diving right in and actually doing some stuff. So Node actually has a built-in HTTP module. So again what I mean by that is if I were to come inside of a Node file and I were to say http and just log this for you just so you can see what that looks like and I were to run that, it's this huge object. This is built into Node. It's an HTTP module which allows us to create an HTTP server on an HTTP connection. So that's built into Node and we didn't have to download it. It's just how Node works, which is great because now that allows us to build servers, but there are some limitations with it. The problem is that the configuration and the amount of code that you have to write in order to have basic features is really, really overwhelming and at times very difficult and I know this because I've built servers with pure Node, without any frameworks and it's easy to do a lot. You definitely learn a lot about Node and you're forced to do things that, you know, like there are different things you can do in Node like streams and stuff, so you're forced to learn some of that stuff, but it's definitely very error prone, especially if you don't know much about like networking. If you don't know too much about networking you're definitely going to have some errors, maybe some memory leaks; there's a lot of stuff that's going to be going on so you've got to kind of know what you're doing if you're using that. So there are tons of frameworks out there that exist to help us abstract that difficulty away and one of the ones or one of the most popular ones and the one that we're going to be using is called Express. Other notable ones include Sails. js, Hapi, Koa, StrongLoop, which is actually built on Express, so is Sails. They're all built on top of Express, but Express is by far the most popular one and in my opinion the simplest one, but it's definitely not like I wouldn't say it's the easiest one, but I chose this one for a very specific reason. So Express is a framework that sits on top of Node and uses the HTTP module to make built-in servers in Node not so hard. There's still a bit of a configuration with Express so if you're expecting something like Rails, Express is not it. Wow, really? I really misspelled that. So yes, if you're thinking like are we going to have something like Rails where you're just like you know, Rails, generate this, do this. No, that's not Express. That's why I said there are frameworks that sit on top of Express because there's still so much configuration with Express that people have abstracted that out and built frameworks on top of that and then there are frameworks that sit on top of that as well. So there's a lot of abstraction, but Express I think is a good like a good common place to like start because you don't have to deal with HTTP module directly and all the nuances of serving static content and dealing around with URL parsing and stuff like that and you also don't have to, you know, you also don't get this magic of stuff just happening for you like you would with something like Sails or something like that. You've still got to do some grunt work, just a little bit though, not too much. Any questions on that? No? Okay, so Express has a very welcoming API that makes getting off the ground and building an API pretty easy in my opinion. Really Express from my experience and like using it a whole bunch of times, it's really just like a framework that has like routing and middleware and we'll talk about middleware. Yes, Mark? There's a question about Restify being similar to Express. Can you briefly touch on why you would use Express versus Restify? Yes, so if we were talking about Express 3. 0 versus Restify, I'd use Restify specifically for a REST API, but with the release of Express 4 and this new feature they have with sub routers, which we'll get into later today, Express is actually pretty good at handling or pretty good at allowing you to build a RESTful API. Restify is purely meant for like, I want to build a RESTful API and it's really great at that; in fact, it's way better than Express at that, but sometimes you need things like serving static assets or maybe you need your API server to also deal as a web server. So you are serving static assets, you're doing this, you're doing that. So in that case I would use Express, but Restify is definitely a good one if all you needed was like a RESTful API. So if you were just making an API for like a mobile application, Restify might be a good choice. I'm not sure how well it is maintained. I know Express is maintained very, very well so I can't tell you how well the people are maintaining Restify, but Express has been releasing pretty good, prettily heavily ever since it's been over to StrongLoop from TJ Holowaychuk so it's doing a really good job and it continues to keep going, but Restify is a good one as far as like API design in general, but still none of them are like Rails. You're still not going to get something like Rails. The closest I've seen to anything like Rails in Node is Sails. js and even that, it's not like Rails, but it's the closest. And there was one more question on LoopBack versus Express? Yes, so LoopBack is actually a framework that sits on top of Express. LoopBack is actually the maintainer of Express as well; if you go to the Express website right here, there's a link for LoopBack. LoopBack, they maintained Express and then they built this API framework on top of Express that just gives you a little more, it's more conventional; it does a little more stuff for you. You have a lot less setup. So it's a good choice, but I still don't recommend it unless you even know what Express is doing because when you get to LoopBack and you start messing around with middleware and stuff and you don't even know what middleware is and you don't know how Express is handling this stuff, you're going to be kind of confused so I still recommend starting with Express and then once you get familiar with that you could branch off and do LoopBack because a lot of the best frameworks out there on Node are built off on Express. So if you have a good solid foundation on that then moving to something like LoopBack or Sails is going to be pretty easy for you. It's just going to be like, it's just going to come down to if you like the conventions that they're forcing you to have, so that's what that comes down to. So it's convention over configuration whereas Express is more configurable and LoopBack and Sails is like more conventions. Cool! So what was I saying? Oh yes, so like I said, Express has a very welcome API. They take advantage of Node's Evented. IO. Does anybody not know what I mean when I say that, Evented. IO? Alright, so Node, just like JavaScript, their browser is single-threaded. So everything is evented, it's asynchronous. There's like an event table where things happen some point later in time and we can use callbacks to get notified about those things. So Node has an Evented. IO the same way and you can notify different pieces of your code about something that has come back from some time in the future. So Express takes advantage of that very, very well with the routing and as you see, it works very, very, very, good. So we'll see how that works, but Express allows us to register callbacks when a particular combination of HTTP verbs and routes are hit. So that's like the beauty of Express. It's literally just like a routing library with middleware and it allows you to set up verbs with routes and then when those routes and verbs are hit by a request, it'll run the functions you tell it to run in that order you tell it to run and that's all Express does, that's it. So Express is just one of many server frameworks out there for Node like I was saying. We're using it because it's the most commonly one used and its lack of strict conventions will force you to learn more about what is going on as we build the API.

Using Express
So here's like a little Hello World, getting started with Express just to show you how simple it is. I should've shown you some code of how this would look if you didn't use Express and you would've been like, okay, Express makes sense, but yes, this is how, this is a simple server in Express. We require, well first we npm install Express and then we require it. We make our app and then we set up a get request. So every method we place on this app or most of the methods are http verbs so we're going to use the get verb. So that means on any get request to /todos, run this function. Any post request to /todos, run this function, and then listen on port 3000. So now we can go localhost port 3000 and our server will be there. That's it, just those few lines of code and we had a server with two routes. Pretty simple. So yes, above is an example of a basic http server using Express. The actual, the req and the res that you see in these callback functions right here? They're short for request and response and they're just objects in the callback that we get access to and the callback that gives us so much flexibility and so much power, this is also the great thing about Express. You'll see this pattern in a lot of server frameworks on Node, this req and response type thing. It's very, very common in the middleware type of thing and we'll talk about middleware in a minute, but these two objects are very powerful and this is what you're going to be working with pretty much the entirety of the course is the request object and the response object and modifying and mutating them to get what you want and to send back appropriate responses from the appropriate requests. So on the request we have tons of information about what is trying to access our server through that request object and then using the response object we have tons of ways to send back a response. So here's a little more complicated example using like todos, right? Everybody has admitted to do that. So if we were to go a get request to /todos, if we wanted to send back the array of todos or a daily base query of todos, all we would have to say is just response. json and pass in that todos and that's it and then the client gets it back. That's all we would have to do. We could also say response. send, which would send it back as well and also converts to JSON, but response. json converts undefined and null to JSON, which technically isn't valid JSON, but it will cover it. So that's why I use JSON here. You can also do res. send, but this is all you have to do is just send back your JSON and it's like okay. When somebody does a get request of todos, take this array, convert it to JSON and send it back. That's what's happening. On the next line, a little something else is going on here. So if we do a post request, which means we're sending data to our server and we want to create something with appropriate middleware, again we'll talk about middleware soon, we get access to the actual object that the client is posting to our server by just saying req. body. todo. So the body property on the request and get the todo object. Now we have the todo that was posted to server, add it to our list and then just send it back. And I made a little note here about how req. json and res. send are pretty much the same thing with some small differences with the undefined and null. And then if we had some parameters in our url, we can access the parameters by doing something like req. params, which is an object of the parameters in the url, so in this case we have one parameter and we have given it the name id. So if we wanted to access whatever that was so anything after todos, that's going to be considered the id and we can access it by saying request. params and using the name that we specified up here, which is id. So we can get the id that the person passed in and we can find our todos and then send it back. So again, very, very simple. This is why I chose to use Express and as you can see, it's powerful, but yet it's very simple and you can also do this yourself without Express. It's a lot more work, but you can totally do it. Yes, Mark? Do you have to define one function for every request type? Do you have to define one? Well, you need some, you definitely need at least one function for each request type, but you can define more than one function for each request type and that's middleware. He kind of follows up with if he wants to do the same thing on both a get and a post? Hopefully you're not doing the same thing on a get and a post, but if for whatever reason you did do that, first of all you wouldn't be following res, but if you wanted to do that then you would just like abstract that thing out and either add it as a middleware or just call it inside this callback function, but I think the person who is asking that question is getting into middleware and we'll talk more about that. So yes, there's this concept of like shared functionality that you want to run on specific routes or an application or a stack of routes before you actually respond back to the client and that's called middleware so we'll see what that looks like. Oh, the next thing says middleware, yes. So Express uses middleware to modify and inspect the incoming requests. So what I mean by that is you could actually just think of this callback function as middleware and technically it kind of is. So really middleware is just a function that allows us to or that's going to be run in the order that we register with Express and its job is to do whatever we want it to do; it can use any code that it wants, but typically what middleware would do is like look at the request object, inspect it and depending on what we're looking for in the request object, it will either pass the execution to the next middleware in the stack or will stop the request and the response cycle right there and either throw an error or respond back to the client and it'll be like we're done, don't even go forward. You know, like if you don't meet these credentials, stop. You know, so you don't even get to go to this function and send a response back. So we'll see better examples about that later today, but middleware is probably the most powerful feature in Express other than the routing and that's really all Express is. It's the routing and it's the middleware, that's all it is. It's very lightweight. If you look at the source code for Express, it's like one page, it's small. It's really small, it's really easy. So yes, there are tons and because middleware is so powerful you could think of middleware as like the plugins inside of Express and because of that there's such a big community of third-party middleware modules out there that we're going to be using. Express 3. 0 had a lot of that stuff baked in because they were using something called Connect and they had a big reliance on this other framework called Connect and they got away from Connect, but they wanted the same stuff so they took out all that middleware and now it's like available third-party site, but we can still get the same stuff. So middleware from like parsing URLs to handling authentication, we'll be able to use that stuff and it just makes building with Express super easy and Express can also be a static web server. So we can serve static assets and trust me, it makes it so much easier than if you did it yourself. If you ever had to like just write a server manually and serve static assets, if you don't have any experience with that, it can be quite difficult like setting the appropriate mine types, reading files, dealing with buffers, stuff like that, you know, chunks. So it can be quite, you know, difficult if you don't have a lot of experience with that and Express just makes it easy and in like one line that'll handle all that stuff for you.

Exercise 1
Everybody has the repo. If you want to check out on step-1, if you check that branch out, you'll see a couple files in here. Let me get rid of this. You'll see a couple files in here. So you probably don't see Node modules and that's because you need to do npm install. So you should get in the habit of whenever you get a new Node repo, just run npm install from your command line. Just start doing that immediately, whenever you clone it, whenever you pull it, just do npm install. So what happens is when you run npm install, it goes and it looks at the package. json and it looks at the dependencies and then it starts installing these, all the dependencies with the appropriate version numbers. That's what npm install does. So that's how it knows what to install and then it'll create a node_modules folder for you and depending on what version of npm you have, you might have all your Node modules installed flat like mine are because I'm using npm version 3, but if you're using the previous version of npm, your Node modules will be nested. Because what happens is, let's say npm goes to install this module, body-parser. Body-parser is a Node module itself and has its own package. json, which also has Node modules so npm will install those too and then those modules might have modules, so it'll recursively install those modules so that's why you might have nested folders in here, but if you're using npm version 3, it all installs flat, which is good news for Windows users because I know Windows, it won't chase that forever. It'll start erroring out if it has to keep looking for those files. So they fixed that. It's just a bigger pain now, having to scroll through the node_modules folder looking for stuff, which you rarely have to do, but in the rare case that you do, it's a little more painful now. So that's what happens when you run npm install. So run npm install, get the Node modules working. If that's not working for you, let me know, but it should totally be working for you. So what you're going to do, if you look in the server. js there's a big todo in here and there's a JSON data object. So what we're going to be doing is we're going to be creating a basic server with Express that will send back the index. html file on this directory on a get request to the root. It should then send back JSON data on a get request to /data as well. So what that means is, one, I should be able to come in here and start a server on whatever port you want and when I start that server, if I navigate to that port in the browser, I should see whatever this index. html renders, which is just an h1 tag that says hey. And then I also should be able to go to /data and see this JSON data outputted. So now I'm going to show you what it actually looks like. So I'm going to check out the solution and show you. And I'm going to run node server. So I'm running my server. I'm going to go to localhost 3000, which is the part that I'm running on and there's the HTML page so we should that if we go into the root and then if I go to data I should see some JSON data there. So I'm going to use some hints on how to actually get past this because there's a little context. Let me check back out. So in server. js, first of all there's as module inside of Node called fs short for FileSystem and it allows you to read files. So remember how I told you to require built-in node modules using the require, literally using the require function? You can require a module called fs and it has a method on it called readFile that allows you read files. So there's a file called index. html. What you want to do is we want to go to read that file on a request to the root, on a get request to the root and we want to send that file back. So if you look at the examples in the notes it shows how to set up a route. It also shows you how to send a response. It doesn't show how to read a file though so that's the part you've got to figure out, and then for the other thing as far as like sending data back on a get request to /data, again if you look at the example, it shows you how to set up a get request to a specific route. It shows you how to send back a JSON response. The only thing you've got to send back is just this data. So those are the two things you're doing and also remember, you also have to set up, you have to have your server listen on a port. So by default if you didn't have your server listening to anything when I run this file, it'll just execute and stop. So I want it to be hanging, I want to stay on, I want to be listening on a port that I can navigate to and also in the examples in the notes it shows you how to do that as well. So if you have any questions on this I'll be walking around. Anybody online totally let me know. So you'll have to 30 minutes to do this and then we'll come back. Mark? There's a question on the flattened npm system. What happens if two libraries require a different version of the same lib? I haven't run into that scenario with npm 3 yet, but I know with the previous version of npm a little prompt will come up, or actually I think they'll try to resolve it themselves. I'm thinking of Bower actually, Bower will actually if you want a prompt. I think npm does a good job of resolving those, but if I had to guess what the behavior was for the flat one, I think it might take the later one, whichever one you installed latest. I'm not too sure though. I haven't run into that situation before. I literally just updated to npm like a week ago, but that's a good question. I would really like to know what happens, but I'm sure they thought of it and they handled it pretty well, but I can see having unexpected side effects if that were to happen, for sure.

Exercise 1 Solution
I gave everybody a little note before I handed it off to you and it was like look at the FileSystem module. The reason I told you that is I wanted you to struggle a little bit with asynchronous programming, but you probably would've found out soon enough that you didn't even really need it because rest. send file takes care of that, especially if you looked at the next experience and saw the solution. So you didn't really need the FileSystem, but you could've used it. If you did do it, you'd have to set the appropriate headers to get it to work, otherwise it will start downloading the file. If you went to the index page and started downloading that's because the rest. send file is putting in that content into rest. I'm sorry, fs. readFile is putting in that content in there. So you didn't really need it, but I wanted you guys to see how asynchronous stuff works and that was a good way I could sneak it in there and also kind of confuse you a little bit because it's going to help you learn. Also, you didn't really need it. Rest. sendFile reads the file internally anyway so let's just go ahead and check out to the solution and I'll show you what I'm talking about. So I'm doing rest. send file and I'm using __dirname. This is two underscores here and I'm so blind it makes it look like they're one, but it's two underscores and like I was saying before in the earlier talk, all your files in Node are wrapped in something like this. So this is where we get these globals. Everything is wrapped inside of this. It's wrapped inside of IIFE like this and we get access to module, exports, __dirname, console, all that stuff. That's how we're able to do. We can just call __dirname because it's given to us and execution time by Node, every file. So __dirname is just a current directory name, which in this case is going to be whatever the name of your directory is. In mine it's node-api. So whatever you name your directory, it's going to be the current directory name of the current file that you're in. So by doing that, rest. sendFile if you looked at the documents for it, which I'm sure most of you did, you noticed that it needs to take an absolute path to the file that you want to send. So I just put __dirname plus /index. html and you can also use the path module to resolve that safely so to deal with the trailing and leading slashes and get messed up there and because it is asynchronous, we have the option of putting this callback here to check for errors and do stuff, but you don't have to if you don't really care. If you just want to do that you can do it, but checking for errors is okay if you want to do something different. Here I just wanted to show you an example of how you can set the status code of a response and also send something back. It's probably not the best thing you want to do when you send on a request to an index. html page, but it's just an example of how you would set the status. So this is me saying, hey, I want the status code to be 500 and I want to send back this error. Again, you'd probably never do this on a get request to the root of your application, but that's an example of how you would do it. Any questions on this part? So internally rest. sendFile is doing the fs. readFile. I just wanted you guys to see how that works and see what that feels like. Do you have a solution using fs. readFile? I don't, but we could do it right now if that would be helpful. Will that be helpful? Anybody else? Okay, so what you would do is you would say var, oops. The first thing we need to do is require the FileSystem module and we just do that by fs because it's internal, right? And then I'm just going to comment this stuff out. And then what we can do is we can say fs. readFile. Is it camelCase? Yes, it's camelCase. So we could do readFile. We can also do readFileSync which will do it synchronously if you looked it up, but let's just do the asynchronous one and then that takes in the path to the file, which is index. html. It takes in a callback. This callback is a node-style callback and when I mean node-style callback, usually the error is an optional argument that we passed in if an error occurred while this function was executing and then a second argument is usually the content that you're asking for so in this case the file buffer, right? So let's just do this. I'll show you what this looks like. So if we console. log buffer on that and if start the server, and then I do a get request to that page, it's just going to hang. As you can see, it's just spinning right here because I didn't send a response back to the client so it's just hanging, but if we look at terminal we should see that buffer. So there's the file buffer. That's the index. html. It's not really what we want so we need to convert it. So we'll just say var html = buffer. toString. That'll convert it back to the actual content. By default it's going to do UTF-8 encoding. So that's the HTML and then we could say res dot, or actually we need to set the headers. What's the method for that? I can't think of the method to set the headers, we'll see in a minute. So res. send and we could just say html. It's setHeader. Oh, there we go, setHeader, thank you; rest. setHeader and we need to set the content type to text/html. So now if we do that, let me restart the server, we get the HTML. Does that include the indention string? The contents of the HTML file? Could you string the contents of the HTML file? No, is it or does this differ from creating a readStream from the file and backing it to the response? Yes, this is different. So good question. This question was is this different than creating a stream? This is totally different. So this callback isn't going to be fired until the entire contents of the file are loaded whereas a stream sends events as each bit comes through, right? So yes, it's different. Yes, so it's going to hold in memory until it comes back. So yes, a little different. Okay, and then as far as the other thing, getting the data, it was as simple as just saying, hey if I go to /data, rest. json the data, that's it. That's all we have to do. And then of course, listen on a port. App. listen takes a callback function that you can just do something inside of it. So that's why when I start the server you see this on mine, listening on port 3000, otherwise it just looks kind of weird when you don't log something. Like if I just stop this and I just run the server, I don't know what's going on there. It's just nothing happening. So it's a convention, at least what I do is always just log something. Cool! Any questions on this stuff? Yes? There was a question they kind of were discussing in chat, but what's the best way to handle errors on your routes? We'll get to that. Good question. Good, good question. The short answer is middleware. Middleware is usually the answer for all the stuff so great question. Cool! So before we go on I just want to walk through some of the things we did during the solution and talk about some things we can do to make it better and tools we can use and go into a deeper understanding of some of this stuff. So one thing we've already noticed is that every time I made the change to the server, I had to stop the server and start it again. It's kind of annoying. So if you don't have experience with Node or if you don't know what this, what we can do to get around that is we can npm install, you could do i for short and then /g for globally, nodemon like that and that's just like Node, except for it's going to restart our server when we make changes to the file. So if you don't have that globally installed, I highly recommend it. So what that would do is allow us to come in here and say nodemon and then just like we do with Node, server. js and then run it, and you get all this other output and stuff, but then now what happens is when I just come in here and just hit Save on the file, it'll restart the server. It won't restart the browser. You've still got to refresh the browser, but it will restart the server. So this is a good one. This is what we're going to be using from here on out. And what was the install command again? The install for that is npm, oh where did it go? Did I pass it? Oh, I'll do it again, I never executed and that's why. It's npm install -g for global nodemon, m-o-n. Thanks. Yes. Great, and I just want to also come back to this callback syntax here. When we get into the data modeling with Mongoose and stuff, we're going to see a lot of this so I just want you to get really comfortable. If you don't really have a good level of comfort with callbacks, you definitely will after this workshop so get used to callbacks. We'll switch over to something called promises, but in Node in general because it's asynchronous and it has an event loop, everything is going to be in this pattern. So most of the stuff in Node files is error content pattern where error is the optional first thing. So most of the time Node you'll always see this on a first line of a function, if error do this. You'll see that like almost every time so get used to these patterns and as you're developing in Node you should follow the pattern, too, so people know what to expect.

REST APIs
Getting RESTful
Introduction So now we're going to be getting RESTful. Does anybody want to give me their definition of REST and not what the acronym stands for, but what it actually means? Yes? Do you have your hand up? Oh, no. Ah, I thought you were raising, but you were, I was just stretching, I wasn't really raising my hand, although you were like this. Anybody? I know people have some meaning of REST. There's no wrong answer because REST is kind of, I mean there's like a fifty-page definition on it so I think whatever you're thinking of is probably right. So I just want to know what you think about it. Nobody? Alright, so REST is not a framework, like you can't just npm install REST. Actually, do you know what? You probably could npm install REST. I'll take that back, but it wouldn't be what you think it is. It'd be something else because nobody, I mean the stuff that's on npm these days. But yes, it's not a framework and it's not a standard. It's not like an HTTP protocol. It's not like something that's baked in. W3C would never, you know, talk about REST. It's not a standard in the web, it's just a way that we came up with. So the modern web is mostly built around REST and as far as the acronym, it's just short for representational state transfer. I think that's what it's short for. What does that actually mean? We'll get into that, but the basics are that it should be stateless and what I mean by stateless, I mean when I access a web service like a server or some other client or whatever, when I make a request, that request should be stateless, as in it shouldn't pass around information about previous requests and stuff like that. It should be asking or it should be a doing a request that's entirely fresh and entirely stateless from the previous one or the next one. So completely stateless. Use HTTP verbs explicitly. So, Express uses the verbs for everything as you saw app. get and app. post. Those are the HTTP verbs. REST uses those verbs explicitly. And then they expose a directory-like URL pattern for our routes. So what I mean by that, if we go look at what is it? Now actually this is a really bad example on this one, but when I say directory structure it'll make more sense as we start building the URL, but the routes for our requests should follow kind of like a directory structure leading to a resource and you'll see what that means in a little bit. Ah, that's horrible spelling, and also it's to transfer JSON or XML, mostly JSON in nowadays, but XML is still around. So, that's usually when I think about REST, that's what I think about, those four things. Stateless, using the verbs, directory-like URL pattern for the routes, and emits and consumes JSON and/or XML. That's it. There are some smaller details that I encourage you to read up on if you want to get really good with it, but yes, I would say Rails probably made REST very popular, but REST is definitely the thing, you know, comparing it to other things like SOAP and other standards out there, REST is the thing and can do the same thing as those other different types of paradigms. So there are a ton of tools out there to assist with designing of your RESTful API. I mean, there are startups whose job is to give you tools to help you design and document an API and then even those tools will go as far as grabbing your API documentation and creating your API server for you, just for mocks, not for production. So it's very important. It can be very tough modeling an API so there are tools out there that help you with that. We will not be using those tools. One, our APIs are not going to be that complex, and two, you still need to learn how to design an API yourself and get going with it. So we won't be using some of those tools, but they do exist. If you get to the point where you want to abstract some of the basic stuff away and you get a good feeling of what REST is.

Anatomy of a REST API
What we're going to do is we're going to create an API to consume some data bout lions. It's just internet cats. So first we should determine what the actual resource looks like and we can model this in JSON. When I say resource, I mean what does the actual lion look like, because we're going to be making this thing that consumes lions. What does a lion object look like? So we need to model that first. I'm just going to show you what that looks like in JSON. So this is what our data is going to look like. So it's going to be an object that has a name property, an id property, a pride property where the lion pride belongs to, and then a gender property. So that's what a lion looks like. So this is us modeling our resource or our data. So that's like the first step because everything is built around how your data is modeled. So it's always good to start off modeling your data first because if you do that last, you're going to run into some problems. So definitely model your data first and know what your application is going to be working with and what it's going to be consuming and that's going to help you out and it's going to allow you to build mock things up, you know, without having to wait on the back end to be built up because if you were a front-end developer and I gave you this JSON object and was like, here, this is what the data is going to look like. You could go like, okay, I don't have to wait on you anymore. I can just go mock this stuff out, right, because I know what the data looks like. Whereas if the back-end person didn't give this first and was like, I'm not doing the data until the end, then how do you as a front-end engineer know what to do or what the data is going to look like? So it's really great to start with this and it helps you out with the rest of the application. So this is a basic example of modeling your data. When you get into databases and stuff, of course it'll be more difficult than this and a little more work you've got to put in, a little more thought as far as like relations between models and stuff like that, but on the simplest level, this is all it is. We're just representing a JSON object of our lion. Any questions on that? Alright, so when you hear me say the term resource, this is what I'm talking about. So when I'm like protect your resources, how do we access our resources, the resources are the data. These are the resources, the actual data. So, next we should design the routes to access the resource. So following REST, we want to use the HTTP verbs. So the main ones we're going to be using are going to be get, post, put, and delete. Who here is not familiar with those HTTP verbs? Okay, so get request means I'm asking or I'm trying to ask for something. Post means I'm going to give you something. Put means I'm going to update something and delete means I'm going to delete something. So we've come up with a term for that and that's called CRUD. Create, read, update, delete or I guess destroy, not delete. It should be destroy, but the same thing. So we will be performing CRUD operations on the resource. So you'll hear that a lot. If you've never heard that before, I'm going to be using it a lot, you'll hear that a lot when we build the APIs and stuff. You want to perform CRUD on some type of resource. Create, read, update, destroy or delete because that's really what applications are about is doing that. So again we're going to diagram how that looks like as far as like the routes and what we expect when we do certain verbs on certain routes and what we should get back. So we're going to diagram that with JSON as well. So here is a JSON diagram of that. So how we read this is if I do a get request to /lions, I expect it to return all the lions and the response should be a 200 and its type should be application/json and it should be an array of objects. So going back to REST, this is like the url structure that I was talking about. Just by the URL I know exactly what resource I'm going to get because it's called lions. So I know that this is the lions resource because of the naming here. It's not that deep so it's not that good of an example, but because I know or because of REST, I say /lions and I know I'm getting the lions resource and because I do a get request to lions, I should get back all the lions and it should be an array of every lion and it should be JSON. So the next one is /lion/id. So here's the URL structure to get a little deeper. So all lions have an id. So here's that directory-like structure. So if we think about it as lions as an object, right, they have an id property on it. So /lions/id, that's the URL structure that I was talking about. So if I do a get request to /lions/ some number, it should return one lion represented by that id. It should be response of 200, application/json, and it should just be an object of that one lion. Is everybody following me here? Yes? I have a question. Are we actually defining routes into the current values or are you just kind of laying it out and this is what? I'm just laying it out; this is a blueprint. Yes, we're not doing anything right now, this is just a blueprint. Then I'm with you. Alright, cool, yes. Sorry, I just chose JSON because we all know JSON. Most people define their API blueprints in something called YAML or some other thing like that or even markdown, but I'm just doing it in JSON because we all know JSON, but yes, we are not defining anything. You will be defining something and this is the blueprint that you're going to use to define those things in a minute, but we are not defining it right now. I just walk through this blueprint to help you understand why and how I came up with this stuff. It just was at the top of my head and this is like RESTful stuff right here. And then if we do a post request to lions that should create and return a new lion using the posted object at the lion. So a post means I'm going to give the resource some object and I'm expecting the resource to create something with that object, and then I expect, after the creation I expect that object to be returned back to me. If you think about it that makes sense because think about if you're making a todo app and you type something in, you hit Enter and you made a new todo and it went to the server and it created it, but the server never responded back with the new todo. How would you update your UI, right? So you need the server to come in and go like okay, here's the thing that I've just created with its id. Because most of the time the database create the id for you and you need that in your UI for whatever reason. So the server should respond back with the thing that it just created after it created it or an error if it couldn't. So the response for that should be a 201 successful post. That's the HTTP status code for that and 200 works as well, but 201 is the actual status code for a successful creation, application/json and it should just send back that one line that it made. I don't need an id here because I'm not referencing something; I'm creating something. So I'm going to send you an object and just create the line for me. Put, I do need an id here because I'm referencing something. I'm trying to update something that exists on the server. So put, just like with the get one up here, it's going to take an id and it's going to update and return the matching lion with the posted update object. So what that means is you do a put request to the server with the id and then an object of the things that you want to update the lion. For instance, let's say you want to update the name and the age. So you'll post an object with a new name and a new age and then what I'm expecting to happen is for you to find that lion whose id matches the one that I asked you and to update those values of the object that I posted and then return the newly updated object to me as JSON, and it should just be one object. It shouldn't be an array. Is everybody following me on this so far? So this is just a blueprint. This is REST. This is, believe or it not, almost all the servers that you use now are just like this. If you've ever consumed any API it was probably like this or something close to it. Some people get kind of crazy with their APIs, but something like this. A good API that I can just off of the top of my head of that follows this pretty good is like parse. If you've ever used parse before, they follow REST like to the tee and they're really good at that. And then the last one is delete. So if you do a delete request to /lions/id it's the same thing. We need an id here because we're referencing an id on the server so it needs to find it and what I expect to happen is for you to delete it from the collection of resources and return that thing that you just deleted with a response of 200 and then just that one object. So that's the blueprint of all these specific CRUD actions we can do on one resource. Yes? Any opinion or use of patch versus put? I don't have an opinion. I don't know the differences well enough to have a really good opinion on the two things, so yes, I don't really have an opinion on that. I usually just use put. Okay, so now that we have our resources and our routes modeled out, we can actually start building this API with Express. So we're going to use this as our blueprint and we're actually going to build out these routes that serve these resources and there's going to be a little website on the front end that is going to consume this. So it's going to be expecting this, and then for extra credit, if you really know REST and you really want to get, you know, really good with it, you can allot query params on the get request to allow filtering and ordering of the lions. So what means is when I say query params, I mean like if I were to come in here and was just on the URL and I was like, yes, sorts by name or something like that and then you could do stuff like that. So that's also part of REST. So if you know how to do that, totally do that, but you don't have to.

Exercise 2
Now you'll notice there are a couple other folders in here. We have this client folder. You will not be working in a client folder. This is just like a static website that is doing some CRUD on the resource, but you will be working in the server folder, namely in server. js. There's a lot of stuff going on here. The first thing it says is, make this work, but as you can see, you're going to get a whole bunch of errors and you've got to free that stuff out, but I'm also doing some new things in here and I'm telling you what I'm doing. So before when we had to serve that index. html we had to manually read the file or we had to rest. sendFile. Express is smart enough to know that you already want to do that. So it ships with his built-in middleware called express. static, which takes in a directory, a path to directory and any request that comes to that directory, it will automatically serve it as a static asset and it knows what mine type to set it to based on the extension of the file name. Not only will it do that, but it will also assume that on the root of the directory that you give it there exists an index. html and if it does exist, it would automatically serve that on a get request of the root. So we don't have to set up a root route anymore to send back an index. html file, it should automatically do it. Yes? Oh, so you're saying that when we set that up, since we passed in client, it then maps all of the client HTML files to the same path that they're set up in that folder? Not all the HTML files. It specifically looks for a file with a name called index. html. If it sees that, if it sees a request from that, it will automatically serve that on the get. So it just sets up that one route? Yes, index. html, yes, just that one, not all of them. So if you've got like multiple templates in there? It's only going to do the first one, in that index, right? Yes, yes, it'll only do that index route. You still have to set the other ones. So is a quick introduction into setting up global middleware. So if you use this method called app. use, it allows you to pass in the middleware function and that function will just be executed in the order that it's registered. So let's say the server gets a request, let's say we do a request for the root. What's going to happen is that request is going to run through these three functions first and then to whatever functions you define underneath it because this is middleware. So this function was registered first, express. static. So our request gets run through this first and once that is done, it'll run through this middleware next, once that's done, it'll run through this middleware next and then it's going to run through the middleware that you're going to make or the functions that you're going to make down here. So express. static is going to serve our stuff for us. Body parser, I left some comments there. It's just going to make it possible for us to serve or to post JSON to the server. By default Express doesn't know how to handle JSON so we need to either figure it out ourselves or we could use this middleware called body parser which will make it easy for us and it's going to attach whatever we post to the server, is going to be available on request. body. So inside of those callback functions on the routes if you just console. log request. body, you'll get the object that you posted or put to the server with this middleware. And then down below you'll see what you have to do. So you need to make REST routes to perform CRUD on the lions. So you need to make all those routes in the blueprint that just defined here. So if you count, there are five of them. There's a route to get all the lions, there's a route to get one lion, there's a route to create a lion, update a lion, and delete a lion. So you're making five routes. The server's already there, it's already listening, it's already good to go. So let's go ahead and start it so you can see what that looks like. Oops, I didn't set that up. (Typing) Go do nodemon, close, so if you just run it and you open it up, you'll get this page right here that's just like a little form that says lions. You could type in a name of a lion, a pride of a lion, the homies type, and then an age of a lion and then the gender of a lion, and if you hit Submit, let's look at the console so you can see this. I want you to see what happens. If I hit Submit, it's going to error out because you didn't define those routes yet. It's like oh, I tried the post of this, but I got a 404. It's also getting an error right here, token C. That's like a JSON error because it's trying to parse some JSON that doesn't exist so that's why that's freaking out because when this page loads up it does a get request for all the lions and that doesn't exist either. So it's still breaking. So you need to define those routes. Once you have all those routes working, when you come in here, this is what you should see now. So I'm going to check out to the solution. Oh, I think you add the stash. Thank you, yes, I didn't see that. (Typing) Cool! So the solution should look something like this. So if I start typing in some names here, classman, hey hey pride, age female and submit, it submits it. Then if I refresh the page, it should still be there because it's saved on the server, alright? And you could also test that by going to the routes, right? Yes, so I went to /lions I should see that one lion in here or there. Where's the data being stored? So there's any array called lions right there, that's our database right there. Oh! Yes, if I restart the server, it's gone. Yes.

Exercise 2 Solution
So this stuff was already here for you. I talked a little bit about body-parser and how we needed to be able to post things and put things to our server. Lodash is just a utility library very similar to underscore. We don't need it, it's just nice to have this stuff. I also talk about the syntax here, the app. use. We're going to talk a little bit more about it after lunch when we get into middleware, but it's just a way for us to register middleware on an application level because this object right here, app, is our web application when we say. use, which really what's happening in the background is this. There's like an array somewhere like appMiddleware, it's a stack and every time we say app. use, it pushes in the function that we're passing into this array. So express. static is a function that actually returns another function. So it's returning a function that looks like this and we're going to get into middleware as well. I just wanted to give you some context. It's just returning a function that has a request, a response and this next function right here. I'm not going to talk about the next, but that's all it's doing and eventually there's just tons of these functions inside of here. It's a stack of middleware and it runs them in order of registration whenever a request comes in. So that means when we do a get request to /lions, the first thing that request does is it runs through this middleware, then it runs through this middleware, then it runs through this middleware, and then finally it comes here. So that's what's happening when I say app. use. So every request that comes through our application will run through all these functions first before they actually go to where they ended up being registered. So that's global middleware. Again, I have a whole section that's talking about this so we'll get into it so you can save your questions until then, but I just wanted to give you some context. So then we have our database right here, which is just an array, and I put this id right here. If you notice, when you start creating stuff, you actually need an id because if you looked at our notes for our blueprint, all lions have an id. So I put that id there so you can increment it every time you create a new lion. It starts off at 0 and every time you make a new one, increment it. So as far as like the get or the getAll is what I like to say because we're getting all the lions, it's as simple as just saying rest. json lions. That one as pretty easy, you just send back all the lions. Just send back the array. Again, if you look at the blueprint, that's what it says. It says send back an array of objects. That's it. Those objects are the lions that may or not be in there when we call it, but it's definitely an array and that's where the lions will be. So the next one is the get 1 by id. So the way we did that is I'm just using lodash here. It's a quick utility method to find any object in the lions array that has an id property whose id matches this id so req. params. Params is an object on the request so as I talked about earlier, that gives us access to the actual parameters on the URL by the name we defined them as. Because I put id here, the way I reference it on the request object is with the same name. So if I change this from id to like thing, then it'll be thing here, too. Yes? So for mine, id came in as a string? Yes. With lodash does it automatically parse the int or? No, it does not. Okay. So there are two ways around that. One, you have to parse in on find. So you have to put parse int right here or you would only set the id as a string. You would increment it first and then set it as a string, which is what I did. Okay, what incremented first? So like right here? So I first increment the id, which takes it from whatever number it is to one more, right? And then I set lion. id equals to that id plus a string. So I'm coercing the number to a string by adding it to a get the string. So how does that work in the route above? This? So this is a get request. So when this comes back in, this id is already a string because I set as a string on the post. Right? So let me walk you through. Oh, oh, you're saving all your lions as strings now. Yes, they're all strings, yes. Gotcha! They're never saved as a number. They're never saved as a number. I use the number for the id, but then I immediately coerce it to a string. Okay, that makes sense. So yes, then I just say rest. json, a lion or an empty object. You don't have to put the empty object here, whatever you want for your API. I mean, you could just put undefined or whatever. The empty object is probably not the best thing to put here because then you have to check to see if the object is empty on the front end. So it's probably not the best thing. And then post is, if you look at the blueprint that we made and go back to it, it should create and return a new lion using the posted object as a lion. So the first thing we need to do is get the reference to the new lion that we're trying to create that we posted and that's going to be on req. body and that's because I left some notes on the body parts that say anything that we post or put to the server will be available via req. body. And that's what the lion is. It's whatever we post to the server using AJAX. Whatever the object is, that's req. body. Yes? So my req. body came in as JSON. Is that some magic that Express is doing for me? There's a couple of things. So one, I'm using, on the front end I'm using the window. fetch polyfill, which is the new thing inside of the browser. So the browsers are getting rid of XHR requests or AJAX. They're getting rid of, what is it? XH and just they're getting rid of that. XMLHttp requests and they're doing fetch instead. Yes, so window. fetch is the new AJAX. Oh, so it's just a different method name? It's like AJAX. It actually uses AJAX on the inside, but it has a promise API so you can do like. fetch,. then, it does that stuff. So that's what I'm using and that one will take an object and convert it to JSON and send it and then request or Express does the opposite. It'll take the JSON and convert it back to an object by the time it gets back to you. So by the time you access req. body it's a JavaScript object. It was created or actually I'll just show you the source code you can see the full stuff and app. js is some crazy file, but where is at? Where is it at? Oh, so it's sent as type JSON? Yes, here's the object. Yes, this is the object that gets sent. It's an object so it's got a name, a pride, an age, and a gender property on it that I got from the form and then when I send it, right here I say application/json and I'm stringifying it, just in case, even though I think window. refresh does it for you, either way. It's a new standard so I didn't really know, I just stringified it anyway. Okay. Yes, I stringified it and then Express did the opposite, it parsed it and attached it to req. body. Okay, but if we didn't have that header, it would've been text? This header? Yes. _____ I'm not too sure. I'm not too sure exactly how window. refresh works. It might assume that it's already json. Okay. It's probably smart enough to do that, I imagine, but if not it doesn't hurt. But, yes, where was I? Oh, yes, here we go. Yes, so we get the lion on req. body because that's whatever we attach to the body. I increment the id by 1 and then I set the lion's id equal to that id, but I coerce it to a string as we talked about earlier because as you could imagine, you have a problem if this was a number, but it's actually req. param as the id would actually be the string even though we set this as a number down here because we converted to JSON and take it back it's still a number and then lodash would fail because like oh, there is no thing with an id of number 1. There's something with the id of string 1. So it would break. So that's why I coerced it to a string here. And then I just add the lion to our database, just pushed it in there and then I send the lion back because we're expecting it to come back, right? Because if I don't get that back, I'll show you what happens. So if I don't get that back, we're going to have some problems. So say I come in here and I make a lion, Simba, Lion King, oops. I'll give him an age and I hit Submit, you see how it posted on the page here? That's because the server sent me that back, but if it didn't send me that back and it was like okay, thanks, I created it, then I would never be able to post this new thing on a page on create. Then I'd have to ask for it. I'd be like okay, dot then, on the side of the client, now give me the lion back. There'd be an additional request. Do you see what I mean? I'd have to do another request to get it back. I can just get it back on the same request. That's why it's important to send back the resources you created on post, right? So to illustrate that again, if I go in and I've got or if I was just like rest. end, which I think we can still do in Express, If I just did that, which restarted the server and then I would come in here and I would do this again, and I submit, nothing. I actually got an error. It's like unexpected end of input. Alright, so it's important to send back that resource because if you created it you're probably going to need it so just send it back.

Exercise 2 Solution, Continued
The put, a little trickier, a lot of stuff going on here. So put is, if we go back and look at our blueprint, it should update and return the matching lion with the posted update object. So what that means is, one, I'm expecting an object to come in from the client with some properties that I need to first find a lion with a matching id and if I do, update the lion with the object that I was given. So I'm doing a few things here. One, first, I'm going to grab the update, which is on req. body. So that can be an object with any property on it that we want to update the lion with. So the name, the pride, the age, the gender, pretty much anything but the id. And then just for a safety check just in case you tried to update the id, I'm just going to delete the id, just in case you try to update the id. So we don't have things with the same ids and stuff like that. You don't want to change the id. The database is in charge of id stuff. So I deleted the id off the update object just in case you put that there. You don't have to do that, but it will fix some errors. And then what I'm doing is I'm just going to search to see given the id that you sent me here, if that lion exists in our database, which is just an array so I'm using the findIndex method of lodash, which takes in an array and then some object. If it finds an object in that array that matches the specific parameters, it'll return the index of it. So that's how I'm able to say, hey, is this index of and this lion, does it exist? I mean, if it does not exist then just send nothing, just stop, just don't do anything, don't even try to update, it doesn't exist. If it does exist then this assign thing is just like an extend. Extend those two objects. So take the update object with the new properties on it and extend it on the old object. Does anybody not know how extend works? It's just merging two objects. So it's going to merge the object on the right to the object on the left and then it's going to return the object on the left. So it's like, yes, if you found the lion, which is referenced as the lions array, this is an index right here, this is a number and this is the object that they sent on a put request. Merge those two and send it back. So this right here is updating it inside the array and it's giving it to us as a reference to return. So it's doing the two things in one line. Yes? There's a question on what's your view on updating the UI with the new item instantly on the client and then like rolling back if the server does return an error? Yes, so if the server returns an error then you definitely want to roll back. So the way you would have to handle that, that's a good question. That's definitely client-side related. So the way you would do that is, so this is the thing that I'm using to update with the post. You would come down here and use something like. catch if you're using promises. And you'd say oh, okay, on. catch, you know, handle the error here. So yes, if the server responds back with an error then obviously you wouldn't update the UI. The server wouldn't even send back the object that was created so you couldn't even update the UI if you wanted to because you wouldn't even have the object. So yes, definitely don't update the UI or don't add any type of object there until it comes back. It'll probably show an error message or something like that or whatever you want to or gracefully try again if it's a specific error message. Cool, yes, so I send back that updated lion and then just listen on the port and that's it for the solution. Any questions? Did you make a delete route? Oh yes, actually I saved the delete route so we could do it in person. Yes, so any questions on this? No? Okay, so the delete route, yes, I wanted to do this one in person. So if you haven't found out already all we have to do is just use the http verbs like get, put, post, delete. So app. delete we know is going to be /lions/id, function and we're going to take a request and a response. So the first thing we need to do is find the index. So what I'll do is I'll just grab this up here and I'll do the same thing I did before where if we couldn't find the lion just do a rest. send, just don't do anything else. If we did do it then we need to splice it or I'm sorry, lions. splice at that lion index 1, and then do a rest. json or actually I should save the reference first. So var deletedLion equals lions lion, then splice it and then send it back. So that's the deleted route. So first I'm going to find it by index. If it doesn't exist, don't try to delete anything, just stop. You could think of, you could only respond once inside of a function and once you respond, you can do no more execution. It's almost like a return statement. I mean, the JavaScript is still going to execute, but you cannot do another response. If I do rest. send here and right below it's like oh, rest. json, it won't work and in fact, Express might even throw errors like, you already did that. You already tried to write the head. You can't write it again. So just remember that. You can only respond once, in any stack. So even if I had a whole bunch of middleware here, I could still only response once, not per function, but per request. You can only respond once. Yes, so that's delete. Any questions on this stuff? Yes? I've got two questions. The first one, sometimes you see like these object responses where they have like all this other data of like what was the response 200 and you know, other things that they tag along. Right. Do you think that's a good idea? Is like a best practice or is that just some people? You mean like have the server send back all that stuff to the client or are you saying? I'm saying that I've seen in some APIs that they put more properties around their requests. They don't just return the objects you changed. Right. They'll add some other attributes and then you can see like change object is one of them. Oh, I see what you mean. So like, you know having the API, you know, send back a more informed resource? Yes. _____ Well, I mean that's kind of like a couple things. One, the resources are probably a lot more huge than our simple lion resource so there's tons of more made-up properties on that object, and then two, they probably like an API as a service so they need to send specific information like maybe specific things. Like maybe you're hitting pagination and they want to show you what page you're on or what cursor you're on. So yes, depending on the API, you will see different things, yes, but like if you're building an API for your application you probably won't have a lot of that stuff, right? Because you're not building an API as a service for other people to use, you're just building it for your applications so you'll probably only send back only what your application needs, you know, to cut the weight down on what's being sent across the wire. Okay, that makes sense. And then my second question is if we were pushing this to production on our put route, would we validate the fields that they're trying to update? You know, they could add any fields onto our extend? Right, and that's where the database is going to come in on our schema. We're going to do validations there, but that's like the last place you do validation. You should be validating on the front end. You should have JavaScript validate before you instance to the server first. Oh, but you wouldn't validate in the route, you'd validate in the database? Yes, I validate in the database. I'll let it try to save and have the database do its validation, which is way more powerful than something I could probably write, alright? Yes, more efficient. Right, that makes sense.

Middleware
What Is Middleware?
Introduction So how does everybody feel about the last exercise we did as far as like going through this blueprint and actually making the routes? Now if you didn't get finished, that's totally fine. I'm not so worried about if you actually finished it as I am about you understanding what you had to do and what needed to be done. Alright, so if you knew the gist of like yes, I need to make a route that does this, I'm just having a hard time messing around with the syntax or the nuances of the framework, that's fine. That can be resolved easily by me coming around or a quick search, but the hard thing to know is what you're actually doing. That's the part that I'm trying to teach you. So this process I'm showing you right here is like a very similar process on a very small scale of how you would design an API, right? So start with the resource, start with the routes that access the resource and what they do, and then go ahead and implement that. That's like a very low level and it's super low level because we don't have a database or anything like that, but even with a database it's very similar to this. Cool! Any questions on this stuff before we move on? One quick one and we haven't spent a lot of time on it, any thoughts on you know, naming of things or plurals versus singulars and stuff or guidelines to follow? Are you talking about routes? Yes. Yes. I haven't read the 50-page or 100-page spec on REST, but I'm pretty sure that if you follow REST to the tee the resources should be pluralized. Okay. Yes, pretty sure. And is there any or for someone that's a little bit more green in this area is there some reference that you'd recommend or does anyone know if they're listening to the stream, if you went hopping on chat, that'd be awesome. For RESTful stuff? Yes, just in general, yes. There's endless stuff. I couldn't recommend one that I feel comfortable with because there's so much stuff out there, but yes, everywhere. You've just got to find one because if I googled it it'll be 1000 pages. Thanks! Okay, so now we're going to talk about middleware. Anybody want to tell me their definition of middleware? I kind of got into it earlier, but don't look at it, and tell me what you think it is. Dun-dun-dun. Nobody? Yes, what is it? Kind of like setting utility classes to help express to the deriver? I like that. Set a utility class that helps Express do dirty work. I like it. Anybody else? No? Okay, so what you were describing is what middleware would do, that's pretty much exactly right. It's definitely going to help Express do some dirty work, but middleware is the backbone of Express. So I was telling you that Express is really just two things. It's a routing framework that allows to have like events. Really what it does is it sits on top of the HTTP module and it sets up these events because Node has this like eventing system. The HTTP module fires off events depending on what request comes in. Express listens to those events and registers callbacks that fire to specific routes that they use for regexes and then for each route that's registered it'll keep a stack of middleware, which is just an array of functions that it will call in order before it calls the last function. So middleware, when you hear me say middleware, it's just a function. That's all it is, it's just a function. When I say middleware, I'm talking about one function. So middleware is a function with access to the request object, the response object, and the next function. So the next function is a function that when called will go to the next middleware. That's why it's referenced as next. So you'll do some stuff in a function. Maybe you'll change the request object, maybe you'll delete this, maybe you'll query database here and then when you're done, you'll say next and it'll go to the next function in the middleware, which could be the last function or another piece of middleware that you created. So in our example, this right here. So this is global middleware. So express. static is a function that returns another function. So like I said, this is a function that returns another function. So like this, var result. This returns another function. So we're putting result in here. That's what's happening like this. And then result is a function that looks like this. It kind of looks like this. It takes in a request, a response, and then next. That's what result looks like and then it'll do some stuff and then when it's done, it'll say next and then when it calls next it'll go to this one. And this will do the exact same thing. It'll do some stuff and then it'll go next and this will do the exact same thing and it'll do whatever it needs to do its job and then it will say next. And then it'll come down to our routing and then whatever route that actually came in, it'll hit that one. So when it says next, it's was like okay, now I'm going to go here to this piece. Yes? So is it just like a series of callbacks that we chain together? That's exactly, that's all it is. It's just a stack of functions and it won't go to the next one until you tell it to. Gotcha. So that's pretty much what middleware is. So middleware can run any code. So it's like I said, it's just a function so it can run any code that you can run anywhere else, so a database call. It can make a call to another server, maybe even send a response back to the client. It can do anything that we did in any of these callbacks here. It's just a function. We can do whatever we want. That's why we have this middleware that, oops, let me go back. That's why we have this middleware up here that we downloaded, or express. static, which serves the static assets for us or body parser that encodes the URL, or bodyparser. json that takes everything and converts it to JSON and puts it on the body for us. It could whatever it wants, as long as it follows a few simple rules. So it can do whatever it wants, but like as far as like changing the request object and response object, but it at least must end the request response cycle or it must call next. If it doesn't do one of those then your server is just going to hang. So if you don't believe me, I'm going to show you. So I'm going to say app. use. I'm just going to make some middleware right here. It takes in a request, a response, and then next, and then I'll run it as I'm going to say console. log first middleware, alright? So I'm going to start the server. It's on port 3000. So as soon as I make a request to it it's going to run the middleware. So let's just go make a request on port 3000, I'm going to refresh. Okay, so you can see it's hanging. It's still loading. If I go back to the terminal, middle middleware locked. It didn't go anywhere else. It's just sitting there because I didn't say next or I didn't do a response so it's just like, I'm just going to sit here until I time out. Alright, so you have to make sure you do that inside your middleware. So to fix that I could just say next, which will go here or I can just send back a response back to the client and it'd be like oh yes, okay, yes, in the cycle, which would not go to next. Does everybody follow me there? Can you set middleware after a route or it's done once you hit that routing step? Can you set middleware after? Like you clean up after a route or something like that? You can set, as long as you, so all these routes here are all actually middleware, too. So all these have a next function, too. Every route, we just didn't use them. There's a next function here. So when you call next inside this route it will also go to another middleware, unless you responded The reason we didn't put next here is because we were responding. So we couldn't say oh yes, respond and then go to next because actually two things are going to happen. One, there is no next. There's nothing after this in the middleware chain, and two, we already responded so it's just going to break. But yes, you could theoretically. So if you had this route set up and you wanted to go somewhere after this, you just need not to respond, but then technically this wouldn't be a route handler, it's just be middleware, right? But we're going to get into like how to use middleware in different places and like controller methods, but yes, you could. These are all the same thing. As long as you call next, it will go to the next thing in the stack.

Types of Middleware
Now we're going to talk about the different types of middleware in Express 4. So we're using Express 4. 0, which is really awesome, but there are five different types of middleware in Express 4. There is third-party middleware, which is like body parser and this stuff or the stuff that we npm installed, this third-party middleware. There's router-level middleware. We haven't gotten to that, but we'll get to that later today actually so we'll get into router-level middleware. There's application-level middleware, which is what we've been using this entire time, which is this because it's when we do the app. use, we're saying this entire application instance is going to use this middleware right here. It doesn't matter what router, it doesn't matter what. Whenever a request comes in, it's always going to run through here first and then it's always going to go through here second and it's always going to go through here third, no matter what. No matter what middleware we put down here on another file, another file, it's always going to come through here. That's application-wide middleware. So body parser is a third-party middleware and it is also registered on the application level so it's both. Then there's error-handling middleware. So error-handling middleware is pretty awesome. So the way that works is again, it can also be application wide or router level. We'll talk about router level, but the application or error-handling middleware is a little different than regular middleware because it is a function, just all the other middleware, but it takes in one extra argument and that's an error as a first argument. You actually have to put that there. If you don't put that there, Express won't think you're making an error middleware. It'll just be like, oh, it's just a regular middleware. So if you put error request response and then next, now Express knows you're doing errors. So how do we actually trigger this? I'll show you. So I'm just going to say console. log error, or actually I just need to change the color and it's going to say log and I'll do another one up here so we can see. (Typing) So what we can do is let's say for instance in lions we triggered an error. Instead of doing a response, we can just say, do you know what, do next and throw an error. So new error, nope. Alright, so if we do that, by passing this error into next, we're saying, one, go to the next thing in the middleware stack, and two, it's an error. So that's going to trigger our error-handling middleware. Does everybody see that? So we're going to run this and I think I actually had to move this above this, but let's see. We'll see. So we're going to run this and then I'm going to go to, what was it, /lions? Yes, so I'm going to go to /lions in the browser. Cool! Oh, wait, I forgot to put in next, right? That would help. Let's try that again. Cool! So there we go. Nope. (Typing) Actually, I don't think it's actually triggered; let me go, let me see. No, this actually didn't trigger on middleware, it's just like logging nope. Yes, it's just doing this. So I think if we want to trigger our middleware we would have to put this below the stack. So we would have to put this down here and then now if we called next it should trigger our middleware so let's try that. Port 3000, nope. There we go. So now it's triggering our middleware because do you see how I had to change the order of that? Because I defined, at first the error middleware was up here and this route was down here so when I called next, there's nothing after this route. These routes are not after this route, they're different routes, they're like siblings. They're not after. The chain starts up here. Here's the first middleware, here's the second middleware, here's the third middleware, and then each one of these could be the fourth. They're siblings. It depends on what route you hit, but they're just siblings. And then the fifth one is down here. Yes? I've got two questions. The first one, with this error one, does the spelling of error matter? NO, you just have to put anything in here, you could do whatever you want. Okay, so how does it know if it's the error and how does it know if it's an error middleware or just a normal middleware if it doesn't look at the spelling of the first param? I'm guessing what they do is they check the length of the arguments. So if you dropped off next, it would think it's a normal middleware? Quite possibly. Let's check it out. I am not sure about behavior, but we'll check. So many tabs. Okay, yes, it did. It did know. It freaked out. So you need all those in there. So you need four of them? Yes. Okay. I think it says in the documentation why. Okay. I just don't want to tell you and be wrong. Okay, and then my second question is are we able to access the middleware array and like programmatically drop some middleware or like you know, snap one of our middlewares up to the top or something like that? No, not by default. You could dig in and maybe if you want to, do stuff like that, but by default there is no. You write it in the order that you want. I haven't been in a situation where I needed to do that. So again, the reason I had to move this down was because the stack of middleware starts off as one, two, three, and then any of these routes is going to be the fourth one and then the fifth one is this one. So this is error middleware. It's got all these four arguments in here and this is how you handle errors. So instead of like in every single route, you'd be oh, like, if error, throw error, and you could just say next and define your error handling and this is where you'd like post to your error handling service, maybe log to a file, or whatever you do with your errors, you would do it in this function right here. So you'd just do it in one place. Yes, Mark, you had a question? They're saying so whenever you use app. use that's middleware? Yes, that's global. App. use is setting global application middleware, yes. That means I want this app to use this middleware globally. And how do you decide what function goes where, like is the error always at the end? Yes, so the other ones are kind of arbitrary, I mean there is some ordering. Like for instance express. static, you'd probably want that to go first before you set up your API routes. So for instance, let's say we had a file whose path was /lions, that was the file, but we registered this route up top before express. static. What would happen is, when that file for /lions comes in, it's going to do this instead, when in fact it should've gone to express. static instead of the /lions file. So you want to do express. static first to get all the files. So the ordering does matter there. The URL stuff, as long as you do it before your API because you need this before your API, and then as far as the error handling, yes, error handling should always go last at the end of the stack because you want to be able to reliably call next in one of these callbacks up here with an error and expect your error handling to pick it up and the only way to guarantee that is to make sure that it's registered beneath it. So this is simple now, but when we start getting into multiple files, you might lose track of what's registered where, but I'm going to show you how easy it is to keep track of that, too, because right now everything is one file top to bottom. We can see what's first, what's last, but we're going to have multiple files with multiple routers with multiple middleware stacks and those routes will have their own middleware stacks, too. So it gets pretty crazy. So Scott, do you have to put next err in every route? No, so for error-handling middleware you absolutely have to put these four arguments. So how does the error get to it? Right, so how does error get here? Yes. So what happened was I threw an error. So if I did a get request through /lions I'm going to call next, which means go to the next middleware in the stack. So forget about the error right now. Don't worry about the error, but I called next, right? That's automatically going to look in the stack to see like what is registered next and it's not one of these; these are siblings. They're not lined up next after each other, these are siblings. So the next thing in the stack is actually this, right? And then now if we go back, I threw in error, an object with type of error, which is passed in right here. So that's where that came from. Mark? Could you use app. all and declare the error handler before the routes? And then he's saying, I'd like to keep all the Express configs and middleware in a separate config file? Yes, we're going to get into that. I agree, I definitely like to keep all that stuff in a separate config file; that's definitely the best practice, but app. all is, you could use app. all, but that's for something else, but you could totally do app. all. App. all is like I want to run, I wouldn't put error handling in app. all, but you could do that. App. all is like for any request that comes in, or I'm sorry, for any verb on this route that comes in, do this. So app. all is like this. App. all, right, and then you can define a request here or like a URL and then you could run a function. So like for any verb to this route, get, put, delete, post, run this callback. So it's a little different than doing app. use. I think you can also not use the route, too; you could just do something like that, but then that might be closer to app. use, but still it's not the same thing. It's not what it's meant to be used for. It's like I want to set up some common functionality on across all the routes. So for instance if I wanted to do a log on all the requests to lions, I could just come in here and say request response console. log lions and then responsively make sure I call next. Now what's going to happen is it's going to go here, here, here, and then because I went to /lions it'll go here first and then it'll go to the appropriate one. So we could test that. So let's get rid of that, res. json. I'm just going to do nodemon. So now if I go back and do lions, something is broken. Oh, I forgot to do next again. Next. There we go. Cool! So now if you go look at it, well why is this thing, oh there we go, sorry. Yes, so it logged the lions and then it kept going. It looks like it logged it twice for some reason, I don't even know why. Cool! Alright, so back to the middleware notes, so that was me going off on a tangent of error handling middleware and then there's built-in middleware which is like express. static. So Express used to have tons of middleware built in like body parser. All that stuff was like built in and then they broke off from Connect 4. 0 and took it now. So now the only thing that's built in is like a few things, express. static; I can't even remember the other ones, but there's only like two or three or four useful ones that are built into Express now and if you want to access them, they're on the Express object. But express. static is the most useful one. So whichever type of middleware, whichever type you use, it's the same thing. It's still a function with the exemption of the error-handling middleware, which has to have that error argument, but every other type of middleware, it doesn't matter how you use them, third-party, router-level, application-level, error handling built in, they're still just a function.

Middleware Examples
So here are some more examples of different ways to use it. So here's one piece of middleware that I highly recommend you take note of. You will be using it probably in the next step. Morgan. Morgan will log all the requests in the terminal as they come in. So that's a third-party middleware where you npm installed it and then we required it. Here's an arbitrary piece of middleware called checkAuth and we made it and you know we made it because there's a. / in front of it. That means it's coming from our files and it's a piece of middleware that we made. So we globally set up morgan app. use, and then here's an example of like actually placing middleware on the route itself. So you can also do that. So this is application level. This is like a route level, not exactly router level. We'll get into router level, but this is like a route level. So when I do a request to /todos, first run this middleware and see what it does. This middleware can respond back to the client with like a 401 unauthorized, sorry, or it can say, oh yes, you're good; I checked the database, next, and then come here. Alright? So we can put as many comma-separated middlewares as we want right here. We can also just pass in an array of middleware right here, too, and it'll work the same way. It's pretty convenient. So, you had a question? So how do you stop the request response cycle? You either have to send a response so rest. whatever, throw an error or yes, one of those two things pretty much. Okay. Yes? So if you're going to cover it later just stop me, but like the app. uses are procedural, right? So if you have separate files and you break them up, is it really load dependent on which one loads first? That will be the app. use that gets run before each route? Good question. So app. use is procedural and if you break them out to different files, luckily for us the require method is synchronous. So at whatever time you require that file, so like let's say we put some app. uses in here, right? We pull a few in here and right after maybe the third one we require the file with other app. uses. Then all those will get run and then the ones beneath that require will get run. So it's all synchronous, so it's still going to be in order and luckily for us require is synchronous. So yes, it would still guarantee that. Good question. Any other questions on this stuff? On this example? Mark? You might've answered this, but can you pass an array of functions as the second param of app. get? Yes. Yes, I answered that. I think there's a note right here that says it, too. Oh yes, an array of middleware. Yes, so you can pass in an array of middleware, too. One note though on this because this is kind of confusing, that I said middleware is a function, but I'm just going to show you. I think it's better to show you. So right now the way the middleware or at least third-party middleware is written is that you notice that they're always invoked, like we're always executing the function, right? That's executed, that's executed, this is executed. Right, but what value is that returning? Remember I said middleware is just a function. So if you thought about it then you would know that these methods are just returning middleware, right? So this is a common pattern for us to be able to pass in options to our middleware to expose to our function. Right? These are higher-order functions. So I'll just show you. So let's just make our own so you can see what I'm talking about. Var options and it's a function that takes in some options, okay? And what we want to be able to do is to, well let me put it up top. What we want to be able to do is to come down here and say app. use and then options and then pass in some options like this, like name hey. We want to do something like that, alright? So that's why this function takes in options, but because it's middleware it must return a function. So that's why this is where we would do it. So now this is the actual middleware function that's going to be executed, right? So now I can come in here and say next, but now I have access to these options that the person passed in, right? So this is like a higher-order function here. So that's why you'll see this a lot, but I don't want or I'm telling you this because sometimes you might see it like this where it's just like options with no invocation, right? It's like that's my middleware. I don't want to throw you off your game. The reason that's there is because instead of having that, it's just like that instead. That's the only difference. So this doesn't return a function. This function is the middleware whereas before it was a function that returned the middleware function. So I recommend when you start writing your middleware, pick the pattern that you want and stick with it. I choose this pattern because most third-party middleware uses the same pattern. And this pattern is also a closure. Right, it's a closure. So just take note of that. So we'll use third-party and built-in middleware a lot and we'll also be creating our own middleware. So I'll just give an example of what creating our own middleware looks like and here's another example. So app. use. For instance, maybe you want to check to see if they supplied the correct secret word before they went on so you'll check the secret word and see it's catnip. If it is catnip, next you may proceed. If it is not, set the status to a 401 and send a message that says Nope. Alright, and then that will stop, that won't go on to the next one. So it's simple stuff. So this middleware can do whatever you want. This is like a great place to do things. Any questions on middleware? So what is middleware again? Anybody? It's like an array of callbacks? This is a function. The middleware is just one function. Yes. Yes. It's just one function. It's just a function.

Exercise 3
Alright, so now what we'll do is check out the step 3 and I've got to do a stash. Oh, there we go. Yes, if you check out the step 3 and go into server server. js, it's got a lot of stuff going on here. So your objective is to use a new method on the app called params. So using app. params we're going to abstract some common functionality we've been doing this whole time. So if you notice like on our CRUD routes, every route that has the id property we had to find the todo with that id. It's a bit of a piece of common functionality. We can use like a middleware function to do that first before it gets to that route. So by the time that route runs we can just access request. lion and get the appropriate lion without having to look for it. So that's what we'll do with the app. params and I'll show you an example of that. Actually is it? Yes, it should be params or is it param? Let me look. I don't even know. App dot. Okay, it's param. It's param. No pluralized, okay. So you'll use app. param here, which will look for anything. This function is going to run if it detects a URL that's using a query parameter with the given name so if we hit the URL that has /id, it's going to run this because it's id. If I change this name to, you know, thing then this will never run because we don't have a /thing here, but if I said, oh yes, now we do, then that will run. Oh! So the param method, that's built into Express and it's wrapping around use, right? I mean, it's adding middleware, right? It's adding middleware, that's exactly what it's doing. It's adding middleware and so what it does is it gives you the request and the response and the next and then it gives you the value of that id, that's a fourth argument right there. So it gives you the value. So what we can do inside of here is fill this out and find the lion based on id. So previously what we were doing, where we doing this? Oh, I commented it out, so yes, if you were to look at the last step we were doing it in this app. get lions id. We were finding the lion by that given id and we would do that exact same thing, but here and we would attach the result of that to req. lion. So by the time I got inside of here, if I console. log req. lion, I will see the lion object. Yes? Okay, that would reply to anyone that's got the id param? Yes, it would apply to any single one that's got the id property of it. That's very cool. Yes, so by the time I come in here, if I just say what's req. lion, it'll tell me. So this is a great place to do like database queries on a parameter. It's like oh, here's the user id, let me find the user first before I pass it off to the actual function and attach it to the request object because it's just an object. So attach it to the request object and remember to call next. So that's one thing you'll do. The next thing you'll do is you're going to create a middleware function catch and handle errors. Register it as the last middleware in the app. So I showed you how to do that, but make sure we have that to catch and handle errors and then the third thing you're going to do is create a route middleware for the POST /lions that will increment and add an id to the new incoming lion object of the req. body. So what I mean by that is if we go look at the post, this one right here, I took away the functionality of incrementing the id because on post we increment the id. Instead of doing it here, let's just make a piece of middleware and I already gave it a name, updateId, which is like here. So if you fill out updateId, you should have it increment the id here, right? And attach the actual update object or the new thing to the body. So if you look at req. body inside of this function you'll get the lion that we're posting to the server; it doesn't have an id property on it. Increment the id right here on line 19 and add it to the req. body and then call next. So therefore by the time we get to this post, I can say, oh yes, the lion is req. body and I already know it has the id property on it. So those are three things you're going to do. And I noticed, I literally just told you the last 2 minutes ago I was going to use this syntax for the middleware, but I'm using this syntax. If you want to change it, you can change it, but don't get freaked out if you see that it's not doing this because it's only doing that because I'm just returning or I'm not returning a function here, it's just the function itself. Cool, so everybody do that and we'll have 30 minutes and we'll get back. There was one quick question. Yes? Can you or why would you recommend morgan versus bunyan for logging? Oh, just because I just use morgan and that's what I've always used morgan. That's what I've always used. I think bunyan is awesome, too. Morgan worked for me so I kept using it. I don't recommend either way. It's just what I've used so if you want to use bunyan, use it. It might even be better. The id we are passing in app. param is hiding the other id variable in the closure or what's up with that? Is hiding the other id variable? I'm not too sure exactly what it's saying, but let me see. The id that we pass in here is hiding the other id in closure. Oh, this one. Oh, I see, I see. Oh yes, because the names? Yes, so the id here is not referencing the id outside of here, which is fine because we're not incrementing the outside id in this param anyway so it's fine, but if you want to call it something else you can call it whatever you want here, otherId, if that makes you feel better.

Exercise 3 Solution
For app. param, again this is going to, because first we actually registered app. param before we registered these routes, which is great. That's adding it to the stack earlier. If we put this below the routes then it wouldn't work regardless so we add it before the routes and then we have, it's looking for the parameter of the name of id and then it passed our value as a fourth argument here, right? And then we do what we did before. We just find the lion with that id. If it's the lion, attach it to req. lion and then call next. If not, then just nothing, just send it back to the client like oh, that's not a real id. So I mean you set the status code as something else, but yes, just respond back to the client. Don't even go next. The next one was create an error handler. So this is actually wrong because it needs to be down here. Boom. So error handler is just like we did last time. It's a middleware function that takes in that required four arguments with the error the first one and then just sends back an error here. Scott, what is it sending back on line 71 there for the error? Oh, that's actually misspelled, thank you, I didn't notice that. That would send back a syntax error, or actually I would throw a syntax error on the server. Well, that I never hit that either and I didn't know how to. Yes, it didn't hit it because it was up here. If you move it down it should hit it now. So if you move it down and throw an error in one of your routes like maybe throw an error in param or as long as you pass an error into next, it will hit this. If you just throw an error, it won't hit it. It'll just throw an error. And can you explain again why it matters if we move that down? Yes, so imagine this. Let me show you this. So I'm going to make an array of middleware and I'm just going to call it cbs for callbacks, right? And what happens is when we say app. use, we're registering callbacks inside this array. So the first one we do is we put morgan in there because that's the first app. use, the second one is express. static, the next one is the body parser and I'm just going to put bp, the next one is the other body parser and I'm just going to put bpp, and then app. param, I'm just going to put param, and then after that we have all these routes here which have specific verbs on them so they are not on the same level, they're more like siblings. So I'm just going to put routes here because they're all inside of here, right? So the get, the post, the delete, the put, they're all inside of another array. They're like siblings. They're on the same level. So morgan is first, this is second, this is third, this is fourth, this is fifth. Any of one of these can be sixth, alright? And then the error messaging is down here; that's the seventh one in the stack. So then the error handling. So now when we're inside of one of these routes or even inside a param, if we call next on one of these with the error in it, it'll go here. Whereas how was it before when it was up there? Yes, it was up like here. So if we were to call next on one of these routes there's nothing out there, it just wouldn't do anything. There is no next. It would just hang, probably, or I don't know what Express does in that scenario. And that was because you were using next to kind of funnel the error? Yes. If we did something like new error it would get caught anywhere it showed up in that stack? Yes, so if you just like, you know, anywhere. If you just come in here and are like, yes, throw new error, this works the same way it works in every JavaScript scenario. It will stop the execution of JavaScript and throw an error. It will stop everything, but we're not handling the error, right? We just don't want to throw an error because now, I mean this is bad on the server. I mean on the client this okay, right, but on the server this is bad because now the entire server is going to stop and shut down, right? So now everybody that's connected to your server is done because one error threw. So you don't want to just throw this error all willy-nilly like this. You want to capture it in a place, right? And then maybe if you have a very well-built API, you're probably logging your errors or sending them off to some error report service, right? And having to do that every single time, like if we were doing some long calculations here like a dB query, we'll get into databases, but if we did like a dB query on all these functions here, every dB query has a chance of throwing an error, we'd have to check for the error, do our logging, do our error reporting in every single one of these functions or we can just say, if an error just go to next and then do that one time here. Right, let me make a better example. So let's say we have var loggError, it's a function. Oh my gosh, come here. So loggError is a function. It doesn't do anything, just assume that it's some function we use to log our errors. What I'm saying is right now this is trivial. We're not really doing anything in our calculations that might throw errors, but just in case we do throw errors like in database queries or whatever, like I don't know, let's say db. query, this is all hypothetical, but db. query and it may get back an error, it may get back the result. What I'm saying is instead of having to do something like this, oh, if you know error, you know, what was it, loggError on every single one, right, then we have to bring loggError into every other single file because we're going to start making routes on other files. We have to make sure that we bring this everywhere we go, right? Everywhere we're going to expect an error we have to bring this with us. So we have to require it everywhere we go. Instead of doing that we can just say if err next err and then come down here and say oh yes, loggError and then now because we were inside of one of these routes and we call next with an error in it, it's going to go here. Okay, what if there was something in-between line 27 and 28? Oh, good question. So there was something else here. As long this something else is not an error handler middleware it'll skip it. Right? And we know it's error-handling middleware because it's got these four arcs. So if I put like another error handler middleware here, but you can do as many error-handling middlewares as you want with err, response, or I'm sorry, request, response, next. It'll run this one first and then inside of here I can do, like maybe you might have one error middleware that logs it and then it'll call next and it'll send it out to another middleware that will send it off to a server somewhere and then you call next, and then you have another third error-handling middleware that responds to the client. So you can have as many middlewares as you want and just keep calling next and it'll keep going, but you just have to make sure you pass in an error object to the next to trigger the error middleware. So like for instance, this one might do something and then if I wanted to go to the one right below it, I just need to make sure I call next and pass in the error and it'll go to the one below it. If I just call next without the error, it won't go to the one below it. It just won't. There's nothing after that. Yes? I think they're discussing like up on line 40, let's see, Rob is asking, why is he using response. send instead of using next err request response? Let me backtrack so I make sure I'm on the right line, hold on. Yes, that's the only thing. Okay, line 40, oh yes, my lion there was there messed up. So yeah, maybe it's now, you were doing a response. send--I think Oh, right here? ---maybe on 30--yeah. Oh, maybe on 30, yes. Oh, so why I am doing a response. send instead of what? Instead of like a next error request response. Oh yes, so like I said, you probably don't want to just or I was saying you probably want to set a different status code here or do an error. That's definitely more appropriate. I just did this just to end the request response cycle, just to be sure that nothing's going to happen, but yes, in a real API you definitely want to like either throw an error or send the appropriate response header for, you know, resource not available, which I forgot what status code that is for something, but yes, you want to do that instead. So yes, you could do that in the next error. So you could say, oh yes, you know, instead of that I'm just going to say next and like, you know, a new error. Yes, you could do that. The important thing to remember is that you just need to make sure you end the cycle, but yes, in this situation I would either just set the status to the appropriate header and send back a response or I would call next with an error, but I wouldn't just do rest. send. Good question. Okay, so that's the param, that's the error handler, and then there was one more thing, oh yes, and that was this one, the updateId. So the updateId is a middleware function and all it does is at first I'm checking to see if they didn't already put an id property on there. If they didn't, I'll increment it and then I'll just attach it to the body and then call next and that's it. I guess you didn't have to do the if check. I guess if you just, yes, I guess you really didn't have to do the if check. This would override the check that I had last time. So yes, you could get rid of the if and it'd be better probably, but the important thing is, I'm just adding an id property to req. body and then calling next. So what happens is now when you do, where is that callback? Right here. If you do a post request to lions, first it's going to call updateId, which then will grab the req. body, which is the object that the client sent to us, attach an id property to it and then call next, which will come back down here and then run this function. And now this lion property has an id property on it, which is req. body. So I could just push it in there and send it back.

Routers
So routers are awesome. This entire time we've been using the actual like Express application for our router, which works great as you can see, but with the introduction of Express 4, they introduced like sub routers or just application routers in general. You could think of a router as like a piece of routing functionality and its own middleware stack. So right now we have this application level middleware stack. So everything in the application runs through this, but with the router, we can isolate an entirely different set of rules as far as middleware and routes and isolate it completely separate. Think of it like as a component of routers. It's like its own little server inside of a server. It still uses its parents' middleware, but it also has its own middleware that nobody else uses and you'll see as we start routing and as you start writing it, how that makes sense and why it's amazing. So this is why I was saying that Express 4 is actually a really good contender as far as writing your API, whereas Express 3 was kind of limited because they didn't have that and you had to put everything on the app and it was just like, oh, okay, okay. Express 4 is a lot better at it because you can do these mini routers. So yes, we can now have more than one router in our application. Think of a router as a module with its own routing and middleware stack and functionality. It's like having a lot of those apps that have their own stack in many places. This is great and allows more fine-grained control over our resources, also great for versioning our APIs. So routers can set up routing and that's why they call it routers and middleware the exact same way as we talked about with the app. So everything that we've done here works exactly the same way with routers. It's literally the exact same thing; they're just not on an application level. They're just on like a local level. Ah, a super typo. A router is a little different than the entire app as previous examples because the entire app comes from the invocation of Express and we still control like global middleware and configuration and also it will also set a routing for other routers we made. So what I'm saying there is like the app right here that we got from Express is still going to set up all this global middleware and it's also going to set up the routes for our sub routers as you'll see in a minute. So we still need this app, it's still going to come in handy, otherwise we'll be writing a lot of boilerplate code. So a good pattern is to define routes on the global app or a router and pass control to another router that has its own config. So what does that actually mean? So this is the pattern something like we've been doing before. We have Express and we make an app, right? We've done that. The new thing is this. So now what we do is we make a new router and we say express. Router where it returns a router instance. And then what we can do is we can do the same thing we do on the app. I'm going to say when somebody does a get request to root on this router, just res. send the todos, but right below it on app, I'm saying app. use /todos, todosRouter. So this is called mounting. So what I'm doing is I'm mounting this router to this URL. So when anybody does any requests with any verb, get, put, delete, post, to this URL, use this router. So I'm going to walk through what happens. So let's say I do a get request to /todos. Okay, so I do a get request to /todos, it comes through here, it comes to app and it's like oh, here's the first middleware. oh, /todos, you want me to use this router, great, let me go up here. So it comes to this router and it's like oh yes, I did a get request and this route right here, this slash, is not actually referencing the route slash, it's referencing the root of this router, which is todos. So when I say todosRouter. get root, I'm actually saying app. get /todos. So the root of todosRouter is whatever was mounted on it, right? So if I were to put like /id right here, the full URL would be /todos /id. So this will not trigger if I did a get request to just root. It will trigger if I did a get request to /todos, which is the root of this router. And so if you were expecting a get of an id you would call in that id? Yes. Alright. Exactly. You'd put a :id right here and that would be /todos /id. So I want you to start when you see this as a URL, start thinking of it as root. That's what that means, root. It doesn't really mean slash. It means what's the root of this? So the root of the todo router is whatever it was mounted on, which was /todos, that's the root. Okay, so then it will run this. So again, this todos router, it can do everything app can do. It can say todos. use, todos. all, todos. param, todos. post, put, delete. It can do everything. You could also pass in middleware here, too. It's the exact same thing, but as you can see, we get to separate different paths to different routers for different resources. It's like okay, so if we hit this resource, just load up this router. I mean app doesn't even care what this thing does anymore. It's just like you take care of it, I don't even care, but if app had some middleware up top here, that stuff would still run through the middleware first before it comes to here and then it would run through this thing's middleware and then it would go here. So that's why I say global app controls global middleware. So if there was more middleware up here it would still go through there first, unless we assign this app. use before this middleware, right? So if we put app. use /todos todosRouter and then we put apps middleware underneath it, then it would never go through that middleware. It would only go straight to the todos router, but if we put apps middleware up top up here, then it would go through that middleware first and then come here. So it's all about positioning, just like the example I gave with the array and how all that stuff lines up. It's the same thing. Any questions on the sub routing? So again, we're going to start using the sub routing. It allows more flexibility. This has its own config, it's got it own stuff. This is actually really powerful. I was really excited about this. I almost gave up on Express a while back until they came out with this and I was like, finally! So this is a really, really great feature, but I guess you really wouldn't know it unless you were using Express 3 a lot, but this is a great feature and so we're going to use it.

Exercise 4
So we have a new objective. So if you look at this one, if you go into server, server. js, the file we've working out of, first you'll notice there are two more files and there's a lions. js and there's a tigers. js, right? There's two more files. So the todo at the top at the top it says mount the tigers route with a new router, Azure Automation, just for tigers, exactly like the lions is below. So if you go down here, I have the apps middleware and I do a mounting right here and I'm like okay, if anybody does a request any verb to this route, use the lion router. So where did the lion router come from? Well, let's follow it. Lion router right here. It's being required from the lions file. So let's go into the lions file, boom! The first thing I did was I made a lion router. This is all filled out for you. You will not be working in this file. I made a lion router and then the rest of this stuff is the exact same stuff we had on the last example with the only change of getting rid of app and attaching all the functionality to the lion router itself. You see that? So I make a new router by using the. router method on Express. Instead of using app. param and app. get, I'm using the router. param, router. get, router. post, and then at the very bottom I need to export that router. Therefore I could require it in server. js. So this is all filled out for you. So that's where that router came from. It was exported and then required. So what I want you to do is go into tigers. js, which has absolutely nothing in it but some comments and do the exact same thing as we did in lions. It's the same thing. I mean you could just copy the same CRUD if you want to, but I want you to get the router to work. Lions and tigers are the same thing. They have the same resources. They do the same thing. The only difference is one is called lion, the other one is called tiger. I just want you to create a new router, add the CRUD to the router and you can literally copy the same CRUD or replace lion with the word tiger, and export that router. And then make sure we mount it over here.

Exercise 4 Solution
This was an example into how or getting a little bit into like organizing our application using sub routers and sub modules and what not in Express, just a small layer of abstraction here. So there were some nuances of literally copying over lions or actually let me check out the solution. There are some nuances because one, there were like some typos in there with like todos. I thought I cleaned those up, but I guess not, and then there was, step 4, there we go. Are we on 5? No, we're on 4. We're on 4, okay, okay. Yes, there are also things like requiring lodash and stuff like that that you have to make sure you get right, but I think what we can do is we'll start at server and this was already here for you so we're already requiring the lion route. So you have to fix, or the tiger route, I'm sorry. You had to resolve that error, which was just meaning just export something in tigers and then we need to just register it. It doesn't matter what order we put this in, here or here. It doesn't matter, but if we put it up here then now we don't get body parser, but bodyParser. json for tigerRouter. If we put it up here we don't get these and so forth. Yes? There's a quick question. As you go through this, they were just kind of wondering can you show how you check the API as you're going to make sure it's working? They're just confused about that. Do you just like use HTTPie utility and manually test the results? Good question. So because there is no UI for it, right? Yes, so I mainly just use HTTPie and I just test it from the command line. So let me see. I'll start it so you can see what it looks like. So I'll say nodemon server/server. js. So I'll launch it and then what is that? Port 3000? So now I'll say HTTPie localhost:3000/tigers and that's how I test my get request. So this is what I got back. I got back an array. So I mean, you could use curl, you could use Postman. You could use whatever you feel like. I like HTTPie. It works pretty good. You can do things like, was it POST, I think, or maybe --POST? No, POST. It's just POST? Yes, okay, and then you just say what you want to post like name equals tony the tiger or something like that and then you can just post things. Yes? So you would use the Postman? Yes, I used to use Postman religiously and then I just got sick of having to switch from the terminal to another application so I just use this, but Postman, if I was going to use a GUI, I'd use that, it's awesome. Just make sure when you use Postman that you are posting JSON data and not form data and it's text and it is type of application/json and not the type of text, otherwise you will get unexpected results. By default it defaults to form data. So just make sure you're not doing that. But yes, that's how I test API. It's just a lot faster for me to do it that way, just boom, boom, boom. Yes, question? Is there a way to require a module in your server. js file that makes it available to all other required modules? Is there a way to require a module in a server. js file to make it available in all? So anything that you attach to global, so that's another variable that we get inside that IIFE that I was talking about that this file is wrapped in. Global is another variable, it's an object. If you attach anything to it, you can access that in any file without requiring it. So if I said global. config equals this object, now anywhere else inside this environment I can just type in config and it will give me that object. Even in, let's see, this file or actually yes, even in this file. So because it's global it's in the global space now so now I have access to it everywhere after this. So now if I go into like lions. js and if I looked at config, it'll be the same object. It wouldn't throw an error. So I could say config or I could say global. config. Whatever I want to say, but either way, global is like the window of Node, but it's like an anti-pattern. The only time I've seen global work and was like was okay with it was with Sails. Sails. js uses global to set up config and models and stuff like that and I kind of liked it there, but in other places I'm not really a big fan of it because then you start getting lazy and you're like, I'm just going to put lodash on global and I was going to put everything that I require twice on global so I do require twice, and then the next thing you know you have a file that's got like 100 requires in it, that's all on global and it's like what's the point of CommonJS now? So I don't recommend it, but yes, you can do that. That's the only way to do it and that's because again, all the files are held in a closure with an IIFE. Cool! So yes, we register the tigers and then over here like I said, it's the same CRUD. The only difference is you just do a change of tigers or lions to tigers and I had some todos in here, change those, and then I think there was another error with like this require not loading up or for the lodash and also there's also one more thing. If we go to server. js inside the error handling, this is going to catch like the signature error. So if you don't log the error, you're never going to know, like if your server breaks, it wouldn't tell you. Your server would just break and you wouldn't even know what happens. So you should probably just log this and you can say error. message. So that'll log the error so now you know what it says. Yes? And saying send error there, is that correct or is it send err? There might be, or is there is a send error? Well, I mean, no, I'm sorry. I meant the parameter is spelled out error. Oh, thank you, yes, yes, yes. Sorry, yes, you're right. That carried over from the last branch, yes. I thought you meant there was a send error and I was like, hey, they added that now? That's legit. You could make it. It's just, because you could modify the response object, too. So like if you wanted to, you could make a middleware that's like, oh yes, app. use, make a middleware that creates a response. send err and it automatically knows what to do. So you can call that anywhere. So you could do that, too.

Error Handling
Alright, so before we move on I'm just going to make a small optimization to show you guys. So now that we have these mini routers and we could've done this on the app, but I think it makes more sense to do it here, is in places where we have the same URL like /id, /id, /id, we have that /id three times and then we have root root twice. I can clean this up a little bit by using the. router or the. route method and that exists on an application instance and a router instance. So I can say tiger. Router. route. That's a function that just takes in a path. So in this case the root and then like I say, on. get just do this. Do that on. get and then now I can just get rid of that and then on post do this and I can get rid of the post. So I'll come down here and say. post and put that in there. And then I can do the same thing for the other route, which is id. So tigerRouter. route /id, which has got like three of on there, right? And then that's got a get, which is this one and get rid of that and it's got a delete, which is this one. Go to that. (Typing) And then one more, which is the put and we can get rid of that. So just clean up some code. Same functionality because they share the same route path so I can just use the. route method. So only route the route once. A little bit cleaner. So you can also do this on app. So if I went to app I can also say app. route. It's the same thing. They work the same way on routers. So yes, so again, I'm saying so if any request comes in for root and it's get, run this and if it's post, do this. If any request comes in for root/id and it's a get, do this and if it's a delete, do this, if it's a put, do this. It's just a shortcut. So we saved a little bit of keystrokes there. Any questions on that? I'll go ahead and push this up to you in the solutions so if you want to pull it down. (Typing) There's a question on kind of finding and tracking down some errors. Yes? They're asking how would you track down to report an error on an undefined method? For example, if you didn't require lodash in the lion router, you used a get request lion will fail, but the console just indicates a 500 error? Yes, so the fix that you have to come down, so I said in server. js, you need to make sure you log your errors here. That's why that wasn't working. It would show the error like, oh, couldn't find module lodash or something like that. So if you would just log this err. message, that's going to fix that. So by default it will show that. That's Express taking those synchronous errors and it's just like not doing anything with it. So yes, just log your message here, but if I had to find or like track an error down, this is a good entry into like I guess debugging in general with Node. So let's just talk about that for a second. It's worth mentioning. There is a Node debugger. (Typing) Hold on. Is it Node debugger? I forgot. I haven't used this so I don't even know how it is. Is it node-debugger? No, wait. Oh node debug, debug. There it is, yes. So node debug server/server. js and that's going to run your code in debug mode. It'll immediately stop at the first line and this is kind of hard to use, like you can step and go through the next line and stuff like that and it's all through this terminal interface. This is okay. I don't know anybody professionally that uses this. I cannot recommend it, but if you wanted to, you can get busy with it, but mostly they'll use, if they use a debugger at all, would be node-inspector. So if you want to use this you need to npm install globally node-inspector. It's a global thing and then node-inspector will take the path to the file and what happens is if you run that command, it'll give you this URL to hit in your browser. So you'll grab this, go to Chrome, paste that in, and what happens is it'll load up where it's supposed to. It looks like it didn't really load it up. It's supposed to load up. So if you see it looks like Chrome Development Tools here and it'll run your Node. js through Chrome Development Tools and you'll have the same stuff. I'm not sure why it's not loading. It loaded up the GUI, but it's not actually loading up our files and stuff. Let's see, no. It says loader is not there. So yes, if you do choose to use it then you would need to use node debugger. Me, personally? I just console. log everything and I've been doing that for like 2 years with Node and I haven't had a problem with it. So that's just my opinion. To me, it's just faster, but yes, there does exist a node inspector that will do this. This is not part of Node. It's a third-party module that's supported. So yes. It's used in WebSockets to like do debugging for you. I'm not sure why it's not working. I think it has something to do with the fact that we're trying to debug an Express server and not a static file. I'm sure there's like a different flag I need to pass in for that, but like I said, I don't use debugging, I just console. log everything.

Audience Q&A
You can use WebStorm or IntelliJ for debugging. WebStorm or IntelliJ for debugging? I wouldn't know that because I don't use those, but that might be a reason why I should use them, so that sounds awesome. Yes, they're the best tools outside of node-inspector. Nice! I did not know that. Great! I'm probably going to check it out tonight then. Yes? So in a real-world example like the reason behind using routing is to reuse some of the code or what's the main reason behind routing? The reason, are you saying the reason behind like making these sub routers? Yes. Right, so it's just to abstract away a piece of functionality, right? So like now we get to abstract different resources completely away and they have their own configuration. So that's the sweet thing is like they share some global configuration as in like server. js. They share this configuration, but they also have their own configuration that's specific and unique to them, right? And we're not polluting other resources with that configuration. So just the fact that it's abstracted out, which is really great, which I think just leads to all types of benefits as much as like working with different people in the same project. Now you can work on different things simply separate and not have to worry about waiting on this person, right? And also, yes, so maybe you're doing very unique things with this one thing. Maybe for lions. js you're writing it in ES 6 and it's using a different version of Express or maybe it's using a different version of a database or something like that. It's doing something different so you need to completely isolate it and then register it later. So things like that, it's just like having an application in an application has just many benefits. Yes. Any other questions? Mark? I think Tom was just saying he'd mentioned the response on finish for middleware? The response on finish? I'm not sure what he's referring to. Maybe I thought he meant for you to bring that up, but I'll check with what he was saying and then somebody else was asking, where is this morgan thing being used? Oh, yes. Morgan. Server. js, right here. So if you go look, I'll just show you. If I run the server. Oops, it's already running. It's over here. There we go. So the server is running. Let me clear the output. There's not output right now, right? There's nothing here. I just cleared it, but the server's still on and if I go to the app, I refresh, and I look at the output, all the stuff that's being logged in the terminal, that's morgan doing that. Morgan is logging this. If we get rid of morgan we won't see anything. Yes? Is there anything that will log the request as well as the body of a post or a put? Because that tells me the call is made, but not actually what got pushed across. So there are different levels to morgan. If we got rid of dev we can see what happens. So let me see. I'll get rid of dev. Oh, it says it's deprecated. It looks like you've got to do something, I don't know. So but yes, if morgan doesn't do it, then yes, you can make your own, right? So you could just or what you could do is you come in here. Actually, let's just do it right now. We'd have to make sure we're after the body parser so json is there. We'll make a new request right here, right, and we'll make a new middleware and we'll get the request and the response and next and you said you want to log the request and the response? Well, the body of what's coming in. Okay, so the body. So we'll say console. log the body and then we could just say req. body and then we could say next. There we go. So now when we do something, there it is, the body. So if I post something, the body. Alright, there you go. Yes, so it's super easy to make yourself with middleware. Any other questions? Yes? Somebody had posted a while ago a snippet of middleware that console logs how long each request is taking, but morgan is doing that for us, right? Yes, morgan actually tells you how long it's taking. And that's what all that is in there? Yes, it'll tell you how long it took. Okay. They're asking what theme you're using in sublime text? Oh yes, so theme is seti, s-e-t-i and color scheme is let me see. Alright, so let me see. We should just have like every teacher that teaches. Their stack. Their list of like theme and config and all that stuff because it's like if someone's using vim, it's like what extensions are you using? Someone's like what plugins are you using? Yes, so the theme is seti and the actual color syntax is Brogrammer. So you're an official Brogrammer. Oh, I just downloaded it yesterday because it looked cool, but another one that I like is Glaciers and the one that I had before this and it was really good. It's not on here now, but yes, that's where I had Brogrammer, yes.

Audience Q&A, Continued
Any other questions? How can we use ES 2015 with Node? Wow, that is an amazing question. So if you want partial support and if you're running Node 12, you could just at the top of the file use use strict and you'll get partial support as in like you know, you can do const and you could do let and var, well var is ES 2005. Yes, so you could do that. If you want full support then you need to transpile. So then you've got to pick your flavor of transpilers. You're probably going to use Babel for a transpiler, but then for tooling, Grunt, Gulp, Webpack, whatever tooling you want, but yes, you pretty much just have to transpile it and then the sweet thing about is because Node uses CommonJS, as far as like compiling or if you wanted to use like the 2015 import syntax, then you're pretty much money on there because import is going to compile down to CommonJS, which is great. The browser as you saw yesterday we had to use something like Webpack or JSPM to mock CommonJS in the browser or SystemJS whereas Node. js does use CommonJS so we don't have to figure that hard part out, but yes, you'd have to use a transpiler and then a build tool to use that transpiler or just use the transpiler from the command line like straight up from the command line, I'm just going to run Babel. You can install Babel as a command line tool and run it there if you want to. Once you get it set up, is it pretty painless? Yes, once you get it set up it's pretty painless, depending on what you set it up with. I would say the easiest one in my opinion to set it up, I mean Webpack is the easiest, but then like Webpack bundles it all and you don't need a bundled server file, but I mean you could. Gulp is probably the next easiest. I wouldn't recommend using JSPM with Node. JSPM is more for a client-side, although you can use it with Node and I have used it with Node. It's really complicated because JSPM like I said, it resolves URLs not relative to the file that you're in, but relative to where you tell system. js is the entry point. So this wouldn't be like /lions, it'd be like if our entry point was node api it'd be like server/lions. So that doesn't compile down to CommonJS very well. So like you get some really crazy and wonky stuff with that and if you're not really comfortable with JavaScript then you probably want to stay away from that. Cool. Any other questions? Nope. Any other questions online, Mark? I think we're caught up. Is there a specific version of Node to have the ability to use let and const? Yes, so if you're using, let me see what version I'm using. I'm using 12. 1 and I'm pretty sure I can do that. Let me double check. I'm trying to run Node and I'm going to use strict and then I'm going to say const me = me. Yes, that works. So I'm using 12. 1 and it works fine. Let you = you, okay, so it doesn't like let, but it likes const. So again, Node is using v8 so whatever v8 is bringing in as far as ES 2015, that's what Node has and then it's also like not on the same version as v8, it's a little bit behind. So it's just going to take a while. So if you want full support, definitely use a transpiler, which will give you everything. Cool. Anything else? Is iOS, io. js a drop-in replacement for Node? Are we doing anything in this course that isn't supported by io. js? It's totally a drop and replacement. Everything we're doing in this course will work exactly with io. js. You could just switch it right now and it will work. If you want to use io. js right now, it would work totally the same way. Nothing would change. So yes, you could totally do it. We're not doing anything you won't be able to do there. Can you explain module. exports? Yes, so let's make a new file. It'd be easier if I just show you in a brand new file. So let's say I have three variables. Var, mod1. I might be only getting values so I'm just going to say var mod1, mod2, and mod3. I've got three variables and I want to find a way to export all three of these so that I could require them somewhere else. So let's go through some different strategies doing that. So I could just say exports. mod1 = mod1 and so forth and so forth. Exports. mod2 = mod2, exports. mod3 = mod3. That'll attach them to an object. I could also just not put var here and just say exports. mod1 = something, exports. mod2 = something. So exports has to go along with your require call? No. I'll get to that. So if we do this exports here, this will allow us to in another file, so this is another file down here, in another file we'll be able to do, and imagine this. This file is called hey or mod. js. This is mod. js. Then another file and app. js, they're right next to each other. I can say var mod = require, the name of that file, which is mod. js. So I'll just say mod. That is going to equal an object with mod1 on it, mod2 on it, and mod3 on it. That's because I attached them to exports and exports itself is an object. So when I say exports this, exports dot this, exports dot this, it attaches it to an object. So now if I want to access those modules, I would have to say mod. mod1 and mod. mod2. So is exported supplied by Node? Yes, it's supplied by Node. So again if this IIFE right here that's on every single file in Node, so we have module, we have exports, yes, we have dirname. Okay. Yes, there we've got all that stuff, it's all in there and there's also a module. exports, which is not exports. So this is exports. So the way I think of this, everything that's on exports, just think of exports as the thing that you're going to require. So just you ex and when you use the exports keyword in one file, that's going to be referenced as whatever variable you called it in ex file. So this is exports right here now. This is now exports. We just called it mod in this other file. So you see, it's the same thing. This mod is this object exports; it's just an object. So now we can say mod. mod1 just like we said exports. mod1. It's the same object when you put things on exports like that. By using the exports we're allowed to export as many things as we want out of this file. Module. exports does something like this. So say we want the same behavior. We want to export an object, but we want to use module. exports. So module. exports means nothing else is going to be exported from this file. This is it. This is the only thing that's going to be exported from this file and it can be anything we want, an object, a number, a function, whatever we want, but it's going to be the only thing that we export from this file. So if we want the same behavior we do the same thing. Mod1, mod2, right, and then mod3. Oops, and that'll give us the same thing below. This will still work the same way. This will still be an object and we still have these properties on it, right? And that's because we actually made it an object. It's whatever this value, it's just an object. If I was like, oh, you know what, module. exports is a function now, which we will do later on. So module. exports is a function. Okay, this is no longer an object, it's a function and I can like, because it is a function I can just immediately invoke it like that because it's a function. So this thing took in some args like nums. I can just pass in some nums here, or I can just say okay, var fun equals at and then call it. Does that make sense? Okay. Any other questions? In the sub router, for example the tigerRouter in tiger. js, can you attach a middleware like tigerRouter. useMyMiddleware? Yes. You totally can. You could do everything you could do in app you can do here. The only difference is it would only work on this router and children of this router. Like if this router used another router it'll work there, too. So if you had another router somewhere else, let's say we required another router and we're like oh yes, hey, tigerRouter, we want you to. use anything that comes into /tigers /other, we want you to use the other router, and then if we had some middleware up here on tigerRouter, some middleware, then now the other router uses that middleware, too because it was placed before it. If we placed it after it, then it won't use it. Does use it, doesn't use it.

Testing
Testing in Node
(music) So if you want to check out to step 5, yes, that's it, we'll hop into testing, but before I set you loose and actually start writing some tests for the lions and tigers API that we built, let's just walk through what testing is and how it works with Node and Mongo and the different types of testing and what we're actually going to be testing and stuff like that. So testing is actually pretty simple in Node, in my opinion actually from testing other languages and other environments and Node is pretty straightforward compared to other things like, for instance, writing tests for Android or something like that. Node is actually pretty simple. So unit tests are very similar to how you would test in the browser, minus the DOM. So if we were going to unit test our JavaScript here with Node, it would be the exact or pretty much the exact same thing if you were unit testing in the browser without the DOM. So like for instance, if you were writing tests for a browser code, I don't know, 4 or 5 years ago before Karma came along and all that other stuff you would, you know, use Mocha or Jasmine, well probably not Mocha, but something like Jasmine that will generate like an HTML file for you where you loaded up all your specs and loaded up all your source code, loaded up all your dependencies and then you opened that file in the browser and then you would run the test suite through there and have a nice UI, right? And then Karma came along and it was like, oh, we can do it from the command line now and we'll just pipe it into a browser, but as far as like the experiences like writing the test itself, it's pretty much the same and that's mainly due to the fact that it's still just JavaScript. So unit tests are somewhat the same minus the DOM, which probably makes it easier because there's no DOM, it's just pure function. Integration testing is where we actually start testing like the API and what it does when we hit those routes, right? So unit testing is testing specific, you know, units in our application, like this function should do this, this object should have this, stuff like that. Integration testing is like alright, we're just going to test the API from actually hitting this route to seeing what the database responds with, right? That's where we're going to do integration testing. So yes, we're going to do integration testing mainly because the code that we've written so far, we haven't written a lot of code. Actually, most of the code that we have written is part of Express. So if we start unit testing we'll just be unit testing what Express is already doing and that's already well tested. So we'll just be doing integration testing to see what our API responds to when we throw different parameters at it and what we expect to come back to. So any questions so far on that? Yes? Is integration testing a synonym for BDD? Behavior-driven development? I wouldn't say it's a synonym. It's part of BDD, but I definitely wouldn't say it's a synonym. BDD is more than just integration testing; it's just BDD is like a style of testing, right? So TDD is like test-driven development where like you're going to write some tests first. It's like red/green refactor with TDD. Write a whole bunch of tests and then have the tests tell you what code to write to get them to pass. BDD is more like oh, you know, we expect this thing to happen so we're going to like write a test to dictate this entire behavior, but yes, integration testing is part of BDD, but they're not the same thing. Integration testing is a type of test, BDD is how you write tests. Great! So a good practice with Node and Express and integration testing from what I've witnessed is if you export the app before you're starting it, so like in our application that we wrote yesterday, we were at the bottom of the file down here and we were like app. listen. Alright, we'll listen to some port or something, right, and that's how you start the server, but when we're testing it, a good practice is actually just to instead of listening to the server right there on that same file, is just export the app so it can be required somewhere else and I'll show you why that makes sense. But the big reason is really so that our tests can actually use that app and all the routes on it to make assertions and go ahead and start the server for us. So if we just export the app before starting it, we can actually just run the tests without having to start the server manually. We just have the test do it for us. So what I'm saying is like we'd set up our routes like this and then at the bottom we would just export the app. So that also implies that we'd have to make another file that would import this and start the server, of course, which is, you'll see is actually pretty good. Once you see we'll start making a pretty sophisticated API and that's a good practice as well. Any questions on that? Does that not make sense to anybody? Why I think exporting the app is a good idea? We want to expose our entire server application to our testing framework. So if I export it, I can do that. You can also just start the server, too and then export the app. There's nothing wrong with that, but I would just leave it up to my test to figure out what it wants to do. Like maybe the test wants to start the server with a different port or a different configuration, stuff like that. So strategies for actually testing our API are pretty simple, too. It's exactly how you were testing it yesterday. So if you're using like Postman or HTTPie, alright, you were coming in here and you were doing something like, you know, http and localhost to your port and you'd be like /tigers, right, and you'd do like a get request to that and you want to see what comes back. You actually just, that's what we're going to do for the test, but you visually looked at what came back and you're like, ha-ha, that worked! That's exactly what I expected it to be. you looked at the headers and all stuff and that's exactly what we're to do to write the test, it's just that we're visually not going to be looking at it, the test is going to be looking at this stuff. So we can use a combination of frameworks like Jasmine or Mocha, an assertion library if we don't have one. So if we use Jasmine with an e, it should be there, Jasmine has an assertion library built into it, but if you use Mocha you have to provide your own assertion library. So we'll be using the combination of that stuff and then we're going to also use something like SuperTest. This is a framework that's built on top of a framework. So there's this requests framework for Node that's called SuperAgent. You could think of it as like the AJAX for your server and that's pretty much what it is. It's like the AJAX for your server. It's actually built by the same person who made Express. So it's this thing called SuperAgent and on top of that there's this thing called SuperTest, which allows us to test our application, also built by the same person who made Express. That's why these two work so well together because SuperTest is made to work with Express. So that's what we're going to use. So we're actually going to use Mocha, Chai, and SuperTest to perform integration testing on the code that we wrote yesterday. So here's an example of what a test will look like. So the first thing we can do is we require our app and the reason we can do that is because we exported it up here. This is why we exported it because now we can require it. So now we have our application, our server, require supertest. Mocha is already loaded up and then we're just going to just write our test suite. In this case we're talking about todos. So we describe our todos. We make an assertion here. It should get all todos, alright? So we make a request to our app. It's a get request to this URL. We're going to set some headers here and then we're going to make some assertions right here. So we expect the content type to pass this regex which is a JSON. So we expect the content type to JSON. We expect to get a 200 back from the server and then done, we also get to inspect this response object right here. This response object is what the server sent back. So now we can go ahead and make assertions on that. So now I can say, oh, I expect the response. id toBeDefined, and then done. So this is an arbitrary test. So you could do stuff like this. You had a question, Mark? A couple came up here. If using a testing module, should we put that in our dev dependency instead of dependencies? If using a testing module, like Chai? Yes, yes. So if you're using anything related to development or testing, yes, that should be in your dev dependencies. So the way you would do that is when you npm install. So if you were going to npm install something for testing, you say npm install and then you could do -D or you can do --save-dev and then the name of the package, and that would save it in your dev dependencies. So yes, if it's for testing, it's definitely dev dependencies because your app actually doesn't need it to run; it's only there for testing, but you don't need it to run so you save it in dev dependencies. Good question. And the next one was, on testing frameworks, could you comment on the benefits of using something like Mocha Jasmine versus something that gives you less for free like Tape? Oh, Tape is actually pretty awesome. I just started using Tape like a month ago, but I don't know it well enough to recommend it and I didn't really know its benefits until I used Mocha and Jasmine for so long, but as far as like Mocha and Jasmine, Jasmine was the first one and it's like the full suite. Jasmine is the one that was like, yes, we're going to write tests like this, describe it and all this cool stuff. We're going to supply you with an assertion library. And then Mocha came along, written by the same person who wrote Express or I think he's more than one person to be honest, I think there's a group of people with the same name, but he came along and they were like yes, we're going to write something just like Jasmine with the same syntax so it's familiar for everybody, but then we're not going to require them to use all the built-in tools. We're going to allow them to use whatever they want. So Mocha is just like Jasmine, except it doesn't come with an assertion library, a mocking library, and stuff like that. So you've got to go get your own. So if you want the full suite, use Jasmine. If you want to use your own third-party stuff, use Mocha and then as far as Tape, I prefer Tape these days. It's actually my go-to now. Another one rolled in here right at the end, too. When we're running the server in the workshop, the program will use all the modules in both dev dependency and dependency, but when in production it only uses modules in dependency, is that right? That's not entirely true. It depends on what environment you deploy in. So like for instance, let's say Heroku. If you deployed Heroku, by default Heroku will run npm install production. So it'll only install your dependencies inside of dependencies, not dev dependencies, but if you're here and you run npm install, it's going to install every single dependency whether it's dev dependency or a real dependency, and you can also tell it or you can force it to install which ones, too. So that's not entirely true. It depends on what platform you're going to, but you can always override those commands, but that is the reason why those two differences exist so you can figure out which ones you want to install. So I wouldn't say that that's guaranteed, but by default, yes, that might be the behavior on some platforms like Heroku, but again you could override it, but yes, we'll talk about environment variables and how to trigger those things in a minute. Cool! So yes, here's a basic test. It's doing exactly what we would do. We're going to make a get request to this URL and we expect all this stuff to be true, or to be whatever we make it, whatever we say here.

Node Environment Variables
So a small little note. Now that we're talking about tests it's worth mentioning, gosh, such a bad typo, mentioning environment variables. Environment variables, sorry. I was reading the typo. Environment variables and how we can use them. There exists a process. env object globally in Node. So I'll show you what that looks like. So again, going back to how Node handles files, I'm just going to comment this stuff out really quick so you can see. So again, there's an IIFE around this entire file, right? Everybody knows that means when I say IIFE? Immediately invoke functional expression? So there's an IIFE here that's creating a closure and again we get like console, we get all this other stuff, right, and then there's also process. That's another one. There are so many args up here. So process is the actual process that you're running in. So what we can do is we can look at that process and I'm just going to show you what it looks like. So if I just do that, node index, here's the process object. It's all this stuff. A whole bunch of stuff, and this is everything about the environment that we're running in on my current machine. This is the process that this node is running on when I executed this file. So there exists a process. env which is short for environment, right? And this is the stuff, oh let me clear the console. There's so much noise. There we go. So here's the process. env and you could think of this as like the object that's going to hold all our environment variables, right? So here are all my environment variables and all these secrets and stuff on here that I shouldn't be showing. So that's our environment and this is where we're going to be telling Node about hey, you're in production or hey, you're in testing, or you're in development, oh and here's the secret for your application. Here's the Facebook secret for OAuth. That's how we're going to pass in those environments and every application we deploy to allows us to do that using environment variables. Every environment variable that we pass in binds to process. env. Right? So if I were to say, let's say node index. js or I'm sorry, hold on, export HEY= hey and then node index. js, duh-duh-duh, did it do it? Yes, it's at the bottom. It's at the bottom? Oh, yes, there it is so there it is. Hey! So I made an environment variable and put it there. See that? So that's how we'll do environment variables. Any questions on that? Can you go back to line? Which line? This one? Before this? Where you actually did that command line. Oh, the command. it, that? So yes, if I say export and do like this assignment, that's creating environment variable and then putting this colon here is like I'm going to write another command on the same line. So if that's an object of you know, environment variables, then that also means you can set environment variables, too. So you could say process. env. whatever = whatever you want and have it also set environment variables. So it's two-way. Cool! So yes, the process. env object is globally a node and the one useful property on that object is the one that's called NODE_ENV. So the convention for environment variables and I'm sure this is just not in Node, but just in general is to capitalize them all, like all caps and underscore CamelCase, well I guess it's technically not CamelCase, but yes, separated by underscore. That's the convention is to have your environment variables look like that, but this important one is NODE_ENV and this is what we use as Node developers to determine what environment we're in and its value can equal testing, development, production, something like that, but that's like the convention. Yes, Mark, you had a question? Yes, do you recommend putting or declaring environmental variables in a start script like Upstart or putting them in a separate env file? So that all depends on how sensitive those variables are. If they're like secrets or tokens, you definitely don't want to do that because then they'll be checking the source control and then once they're on GitHub, even if you check them back out, they're there forever because GitHub does hooks. So somebody has built a server that listens to every single hook on GitHub. So it doesn't matter if you put it on there and get rid of it, it's there so do not put secrets in the file. If they're not sensitive, a start script is fine. A separate file is great, too. There are node modules. There's on actually called ENV that kind of does this for you. If you have a build system, incorporating it with Gulp is actually really cool, too. So there are a lot of ways you can do it and then it also depends on like what environment your application is going to run in. So like if you're talking about deployment then what you would probably do is the service that you're using has probably a GUI where you can just type in your environment variables right there inside the actual admin panel of your deployment, like AWS allows you to do this, Heroku allows you to do this. So you don't really need that file, but locally yes, you'll probably need that file, but we're going to talk about how to get around checking that into source control when we get into the production part tomorrow.

Exercise 5
So now if you go into step 5, you're going to notice some small differences here than where we left off yesterday. The first thing you'll notice is there's this new file index. js. Does anybody know the meaning of index. js inside of Node? Do you know? That's awesome! Anybody else know? Is that convention? It's a convention and it also has like an actual meaning in Node. It actually does some different, it behaves differently than every other file. It's kind of like index. html. Remember when we wrote our server, we had that static server yesterday and I was using the express. static and I pointed to client and it automatically served index. html because that was the name of the file? Well, the convention is kind of the same in Node. If you have a file by the name of index. js inside of a directory, you could just require that directory and it will automatically give you the index. js of that file. So it's a good practice to have like index. js be the root or the entry point to a directory or to a module. We won't be doing that because it's kind of confusing. So you'll be seeing something like this a lot in our code server. So it's like going into the server folder and grabbing server. js whereas if we didn't name this server. js and it was just called index. js, we could just say go into the server folder and it will automatically grab the index. js. Yes, so new file, index. js. Yes, you had a question, Mark? He's asking if you use process. cwd current work directory to resolve paths? I wouldn't use that directly. I would use a module that's built into Node called path to do that, which does a better job of doing it. So path require path. I would use this module instead of process. cwd, but if you wanted to do the manual approach and use the current working directory yourself, you can totally do that, but also note you have dirname, too. Oh, that's the full path though. So yes, I would just use path, which does a better job than cwd, but cwd is true, it is valid. So yes, we're requiring our app here and then we're listening for it, that's all we're doing in this file. Index. js. That's all it does here. And so then if you go and if you file this file to server. js, this is pretty much what we built yesterday. Nothing new here. All it did was just take off the listen and export the app. But what is new is the spec. js and it's a testing file and there's one test in there that is testing the get request to all the lions. Your objective is to make the test for the other four CRUD routes. So we need a test for DELETE, we need a test for UPDATE, we need a test for PUT, and we need a test for GET ONE. So GET ONE is /lions/id or /tigers/id. So only make those CRUD tests for one resource. So either do it for lions or either do it for tigers, don't do it for both. If you want to do it for both, go ahead, but it'll literally be the same thing. You'll just copy it twice with a different URL. So it's up to you. So just do it one time. I started off with lions so you can finish off with lions for the rest of the test if you want to. So again, you're going to be making tests for DELETE, UPDATE, PUT, and GET and if you forget what those things should be doing, if you scroll up to our notes that we did yesterday, it tells you right here. This is what should happen when we make requests. Alright, so I wrote the test for this one. If I do a get to lions it should return all lions with a 200 with an array. That's what this says here. So if we go look at what's happening here, if I get all lions, it should return 200, application json. That's exactly what it says right here, application json 200, and expect rest. body to be an array. That's exactly what's happening here. So if you forget what you should be testing for, just read this JSON file. It'll say exactly what you should write tests for. As far as, so here's a little bit of clear-up on some confusion that might come up. This. expect here is not the same as this expect here. They're the same word, but they're two different things. This. expect method belongs to request, which is actually SuperTest. So SuperTest has a. expect method where we can expect headers and stuff, but this expect right here is from Chai. You see the difference? This is a method called expect, this is a function called expect. They just happen to have the same name. If this is confusing, you can just change the name of it. So in fact, I might even just do that just so people, come here. Actually, I'll change it down here. It's too many expects. Chai is some kind of parsing utility? Chai is an assertion library. It has, so I'll show you what it is. I can show you better than I can tell you. So Chai is an insertion library that is specifically made for tests. It gives you this nice syntax to make assertions about objects inside of JavaScript and test them and it has like three different flavors. So you can use the assert or you can use the expect or you can use should. They all do the same thing, it's just a different syntax, whichever one you like. I like expect so I use it. So the documentation for it is here. So it's kind of like reading English. Like I expect food to deep equal this object. So stuff like that. So you can look that up. It's pretty simple, that's why I didn't even bother mentioning it because it's really simple. So Mocha handles the HTTP stuff and Chai handles the dirty work, so to speak? Good question. So Mocha or actually SuperTest handles the HTTP stuff, this thing right here called SuperTest, which is request. Mocha is handling the stuff like describe and it. Mocha is actually running the test. Mocha is the thing that's going to run the test, which gives us these globals like describe and it. That's where these words come from. If I were to run this in Node, if I were to run this file in Node, it'll break, right? If I said node server/spec. js, it'll break. It'll say, describe is not defined. That is not a word in JavaScript. Nobody knows what that is. If I were to run this again Mocha it would work because Mocha gives us describe; it's a global inside of Mocha. So yes, Mocha is running the test, which gives us describe and it. It gives us the structure. It's the framework. It's the testing framework. SuperTest is actually calling our server and Chai is actually making the assertions, right? So speaking of, in order for you to actually test this, everyone needs to npm install globally -g Mocha if you don't have that already. So you need to have Mocha globally installed on your computer. So make sure you have that. So again, you need to npm install -g for global Mocha. Most of you might have to pseudo this so if you need to pseudo, pseudo. But yes, you need Mocha. You had a question, Will? No? Let's see, he's asking where in the testing process do you consider load testing and is that more of an integration type test or would you consider making it part of your Mocha tests? I would, you could, I mean I guess you could write load testing inside of Mocha, but I think there are way better tools that exist out there than writing. I mean Mocha and Jasmine really weren't meant to be doing load testing. Load testing is more of, you know, an architectural level thing. It's not more of like internal, I'm going to test this server type thing. It's a little different. I mean, you could do it. I mean, there's nothing stopping you from just doing a set interval and just throwing stuff at Mocha or throwing stuff at your server here, but there exist better tools for that so I wouldn't really handle that here. And then somebody mentioned that in the notes you're using. done in code samples or using. end as the last line; is there a difference? The notes are using. done, hold on, let me see. It looks like I probably got confused on something. Dot done in the notes. Oh yes,. done is wrong, don't use. done. It should be. end. If you use. done it's going to break. I think I just made a mistake and put. done because Jasmine and Mocha have this done callback here that you have to call an asynchronous test and I just mixed the names up. So yes, don't use this. I'll delete this so it's not on here, but yes, in the actual app, it's right,. end is right. So speaking of that, because this test is an asynchronous test, we have to tell Jasmine and Mocha when it's done and there are a few ways we can do that. We can actually return a promise which is newer in Jasmine and Mocha, but we can also just use this callback function they provide. I just called it done. So whenever we're finally done with the test, just call done. If you get rid of this and you try to run the test, alright and I'll show you what happens, I'll just do it right now. So if say mocha server/spec. js, it's timed out. It has a timeout, a default timeout of 2 seconds. So after 2 seconds it was like, oh, nothing happened, I'm quitting. That's because I never called done, but if I call done, then now it'll say, oh yes, passed, your test passed, you're good. So make sure you call done in those asynchronous callbacks. Cool! Any questions for this stuff? So you have Mocha to run the tests. I think the notes are in here, it tells you type mocha server server specs, but again, that's the command. You run it. That one test that I wrote should be passing for you and then you should be writing four other tests for the other CRUD routes. So that means we need to write a test and we hit the URL and it should delete something and we should also write one that will update something. Oh why did I put, I meant post, not put an update. It should create something and then also get one. So if you're thinking like wait, how do I delete something if nothing is there? That means you probably before you delete it you need to create something first. The same thing with the update. So before you update it or put it, you need to create something, too. So those are going to be a little tricky. There are a couple ways you can do it, but I'm curious to see how you do it. But yes, you can't delete anything if nothing is there and you can't update something if nothing's there and then you also need the reference to the id to delete something. So if it is there, you need to get the id of it to pass it on the URL, right? Because that's how our API looks like. If we go to our API on, I don't know, let's just look at delete. Delete is expecting an id here. So is put expecting an id here. So not only do they need to exist, you need the ids to reference them, too. So like I said, there's a couple ways you can do that. There's some hacky ways, there's some right ways, but just know that you can always do more than one request inside of an it block. Remember that.

Exercise 5 Solution
So I'm aware that there are going to be tons of differences of how people tested this and this is great because there are so many ways you can do it. Some people starting using before and beforeEach and maybe even after and afterEach. Some people used promises. Some people made multiple requests inside of one it block. Some people did nested describes or mini describes. So there are so many ways you can do this; there's not one right way to write these tests. So I'm going to show you the solution that I have, which probably is not one of the best ways, but let me stash this or commit this actually. Alright, so let's see check out step-5-fix. So the way I wrote it was I just did nested requests for things that needed resource to be there already. So as far as like creating a lion, the way I created a lion is, well this one was pretty easy. You just create a lion. So you make a post request. If you didn't find out you had to use the. send method and you can send json to the request. So I'm just putting in a lion here. Mufasa, evil lions, and then application/json, expect a 201. If you put 201 or if you put like 200 and you got back a 201 and it still passed, that's fine because they're both passing status codes. If you did something like 400 or something, that's supposed to change it. And then inside of here I'm just doing a basic type test. It's like expect this to be an object. It's a really silly test. You could probably write better tests than this and you should, but again this is just an example of how you would write tests. So like for instance, you would write tests to see expect or you know, first I'll say var lion or Mufasa. Is that how you spell his name? Mufasa? Whatever, if anybody knows how to spell his name. And then you'll say, you know, mufasa. name. to. be. So these are better tests, right? You actually make sure that this stuff is the way it should be or you can just do equality check. So you can say expect Mufasa to be, you have to make this object somewhere else like var lion = that and then come down here and say send the lion and then expect mufasa to equal, this is deep equal lion. So then we're checking to see if the objects are the same, right? If you use eql, that won't work because it'll literally do like object equals object, which is false. There are two different objects. They're both objects, but they're two different objects so that wouldn't work whereas eql would do a deep equals, which means like just check to see if they all have the same properties and the same values and then call done. So if we run that, let's see. Oh, you can just run npm test to run test and oh, I guess I didn't update the package. json for that. Let me see. Yes, so in the package. json in the test script you can just say what you would normally put, which would be mocha server/spec. js and run npm test. Oh, it looks like the id is wrong. Oh yes, the id is wrong because it gets changed to a number on the server. So I guess that really wouldn't work, right? So I'm just going to get rid of that one for now. And then as far as deleting a lion, we need a lion there in the first place, right? So I guess technically we do have one because we just posted it to the server and that's great, but I don't have this lion's id. I didn't save it because first of all it's in this it block up here. So I don't have mufasa. id. I need that id to send a request, although we can probably assume that it's just one because of the first one. So we can just put one there, which is okay, but it'd be better if we had the id. So what I did first was I made a new lion, like alright, I'm just going to send the lion there and then on that response, grab the lion and do another request that deletes that lion's id and I'm just going to expect rest. body to deep equals the lion that I sent, which will probably fail too, because the id, well it passed. Everybody see me there? So I just made a request. I created one first. I got the id of it and then I sent it. Like the other way you could do is like you could just do a before, right? So like in Mocha and Jasmine, inside of a describe you can use before and beforeEach and the way this works is it's a callback function that will run either before all the its or before each it, depending if you use before or beforeEach. So I could say, oh you know, beforeEach it, just go ahead and make a new lion, right? So I could just make a new lion in here, but then I have to play with the closures a little bit because I need to be able to reference that lion. So I need to say you know, createdLion and then down here I have to update it every time. So I don't like messing around with closure so I decided not to do that. Any questions so far? Yes? A couple came up here. How would you do some negative integration testing? Negative integration testing? I'm not sure exactly what that is. That's the first time I've ever heard negative integration testing. I'll see if there are a couple seconds and I'll see if he adds to that. Okay. Any other questions? I guess for like request failing? Oh, if request failing? Or name no longer equals after update, so I'm not sure. Still not quite sure, but I'm guessing what he's saying is like for instance if you were testing to see if this user had access to this URL you would expect it come back as a 401 or something like that, then yes, I mean you would just type in the appropriate status code and then you would just do some assertions on the response that your server sent back. So like if you were to trying to access this resource and you expected to get a 401 and you expected to get this certain error message back, it's the same thing. I mean, it's no different. It's the exact same thing. You just have to make sure you expect the assertions that your server is sending back. It's no different. Any other questions? We're caught up here. Okay. Yes, so and then that was delete and then update is pretty much the same thing. You need to create a lion, grab the id, and then you also need to send an object to update something with. So I sent an object with just updating the new name and now I just want to make sure that the new name got updated when it came back, which it did. Right? So I created a lion with a name called test lion and then when that came back, I grabbed that lion's id and then I wanted to update it with the new name, that's called new name, and then when that comes back I'm going to inspect to see that it equals the new name. Great! Any questions on that? What about testing preconditions like checking that the lion exists before deletion? Checking the lion exists before deletion so let me walk through that. So let's go back to deletion. So here we deleted it. We want to see if the lion exists before, well, so if we posted the server and we created a lion, we have the lion and then we deleted it. So I mean, you mean testing this lion right here? I think that's what he's talking about. Well, I mean yes, you could test this lion, but this test is not for creation. This test is for deletion so that's why I didn't make the assertions here. I think that's what the person's talking about; I'm not sure, but we're just testing whatever the server responds to. So if you want to be able to test more things then as far as integration tests go, you're only going to be able to test whatever the server responds to. If you want more fine-grain control of what is actually happening then you have to write unit tests. Oh, in the update. Now I made a put so in the update I made a post to create the lion and then down below here I made a put request to update the lion. There's a question of can you have a function that runs before any test? Yes, you could have a function. So all you have to do is go to the top describe in your test and put a beforeEach. So I'll put beforeEach here. This will run before every single it. Alright, so if I say console. log right here then I could run my test. That should run before every single it. Yes. Hey, hey, hey, hey! So just go to your top scope and do a beforeEach. Cool! Well, it looks like I forgot one, a get1, right? There should be a test for a get1. Yes, but that was pretty remedial. I could write it, but I'm not going to write it unless people want to see me write it. It's just going to be the same thing as get all. It's going to be like create one and then get one. So I can do it, but I think you guys get the point.

Testing Q&A
I'm curious. What are some other strategies that people used? Anybody use something different? No? Everybody did it exactly like this? I doubt it, unless you looked at the next branch. Because I know you used promises. I used promises. Yes. Who else did something different? No? They're just asking on line 5, the way you wrote lions, is that a style thing? On no, it was just, I don't know, I'm just picky about how this stuff prints out in the terminal and like if I get rid of it, it just didn't show up well enough for me so I just put brackets around it. That didn't show up well enough for me and I was like, well, I'm going to put brackets around it so it shows up better. That's it. Yes, this is a style thing. So that's why I put brackets around it and even then I'm still not satisfied with the way it looks so I might change the color of it or something. Which you could do. You could npm install colors and change the color of this thing to like yellow or something. This is pretty cool. So if I say require colors and then npm install save-dev colors, and then now when I run this it'll be yellow. Oh, that's cool. Yes. Yes? Is there a way to use test data like data stored externally for creating and asserting? Is there a way? Yes, there's totally a way to do that. We will get to that after we get to actually creating the API for the bugs. So yes, we will be using databases for assertions and having like a different test database versus a development database versus a production database and how to switch those off so you don't have to do it manually. Yes? Can you go back to the spec file? Yes. On line 12 there? Yes, this one? Yes, what is that second parameter? Oh, that's a regex. Alright, so yes. And then on line 13 it says expect and it just has the number 200? Yes. How does it know that that's a status code that we're looking for? Well, the only way I can think of that it knows it's a status code is because there is no other thing on this request that would just be a number and then a status code. So I guess it just assumes that because I can't think of anything else that you would put just a number in and it would be that. Like everything else has a key value pair or a content type, like headers, but status code is just a number. So I'm guessing that's how they know. And then prior to line 14, there's you go getting through the response to start abstracting json data, you have to be past line 14. Is that correct? You have to be in the. end callback, yes. You have to be inside of the callback. I could just get rid of all this. I don't need this stuff here. Oops, get out of here. I don't need any of this stuff here, except for that. I just can't, I don't get access to the response until I call. end. Alright, like if I didn't want to test or like for instance, let me show you. If I log, if I got rid of all that and I said console. log the response, I get all the stuff that I just got rid of. I get the status code, I get the headers, everything on the response is still here on the response. Right? Here's the entire response object and it's huge. So I can look at that too, if I wanted to get the status code and everything else, it's just those methods are as you can see, the object was huge. So those methods just test it for us. It's just being good? Yes. Any other questions? Cool. Alright, so that was testing. So more or less that's how integration testing is. Of course it gets more difficult when you start dealing with things like databases and like authentication and then you have to create fixtures and like mocks and stuff like that. So yes, it'll get more complicated, but as far as like once you get past all those details and we get to finally, I created my mocks, the database is good to go, all this stuff is here, my fishers are made and when you get to actual testing it'll be like that. It'll like make a request to the server and make some assertions on what the server responds back with. And then you have to clean up. Now I'll clean this stuff up. So for instance, like if we go back to our tests, if we were actually like posting to a database, just to ensure that the next test had fresh data that wasn't messing around with other data, we'd do like an afterEach and it'll be oh, afterEach drop the database or something like that. Right? Or afterEach, get rid of all the lions in the database. So we know that it won't interfere with the next test coming out to need it. That's why it's important to have a different testing base then a production database or even a development database. You should just separate those two. Any questions? There were a couple that came in. Let's see, a couple. In general, is unit testing Node code often done in real-world applications or do you mostly do integration testing? Yes, I definitely do unit testing in the Node world because I mean, quite honestly, you just don't use Node for servers. Node is used for a lot of things like tooling. I mean, some of the most popular tooling out there today is built on Node. Gulp and Grunt, they're not servers; they're all just you know, command line tools so they are nothing but unit tested. So you definitely will use unit testing, it's just like if you go look at the code that we wrote in for instance, go look at lions. js, all the code, all the functionality that we care about is inside of a callback. That's kind of hard to unit test. Right? Because this code doesn't even get run until this, until Express fires this and Express doesn't fire this until you start the server and hit the route. So it's kind of hard to unit test. So we didn't really write good code to be able to unit test. There's only one function in here that's not inside of a callback and it's this updateId and it's not even being exported. So we still couldn't touch it, we'd have to export it, right? So we really can't write good unit tests for our code. So integration tests were like our only option. I mean, we could write unit tests, it would just be, we'd get to the point where we start unit testing Express itself. We'd be like, alright, I'm going to write a unit test on this router to make sure that it has these routes. Then you're starting to get into what Express is already doing. Any other questions? And then the next one is, is it a best practice to write separate describe statements for just CRUD operations or should you get more granular? For example, it should respond to a json? Yes, you should be as granular as possible on your descriptions and I think you can use as many describes as you want. I mean, I don't think there's a limit on that because whatever is right for you, you can do it, but I would say if it makes sense organizationally then do it. This example here is not the go-to. This is not like exactly how you should write your tests. This is just how you write tests, but yes, I think it's going to differ depending on what you're doing. So yes, you can do nested. You can put another describe here and it will totally be the same and then if you put a beforeEach or an it in here then that is going to be scoped to this describe. So yes, you can do whatever you want. And then what's the difference between a mock and a fixture? A mock is like, so this lion is like a mock, alright? This is like a mock lion so mock data. A fixture is more like or a fixture could have a mock in it, but a fixture is more like, I don't even have the words to describe it. A fixture is more like you're mocking not just the data you're sending in, but kind of like the environment, too. It's like you want to make sure that this code is going to run exactly the same way in this certain environment. {00:50:15. 753 I'll get back to that question. I'm going to look up something better than that explanation. If somebody else has a better explanation that would be great, but if not, I'll look it up. And then the last one is, are there frameworks that support mocking objects? Yes, Chai does. So Chai has or it is a mocking. Chai mocks. Is it Sinon-Chai? No, it's not Sinon-Chai. It's just Chai. Let's see. The thing is that you have to download a plugin for it. Let's see. Oh, there are so many plugins for Chai, but yes, Chai definitely has a mocking library that you can use and that's what I use if I use mocks, but there are tons of other ones out there too that work very well. Sinon-JS is a popular one. Sinon-JS, how could I forget that one? Yes, Sinon-JS, yes. Cool! Any other questions? We're caught up here. Cool! Alright! One barely just came in. Oh, okay. When you run multiple tests, are objects destroyed before each test? For example, in this case if I run the sequence create lion only once, get update delete, will it work or do I have to create a lion for each test? Say that again? So I think when they say each test, I don't know if they're talking about each it block or each run through the test, I'm not sure, but if we're talking about each test, like if I run the test here and then I run it again, does the stuff stay there? No, it doesn't stay there because we don't have a database. So the server starts and then the server stops. So everything, all the lions that were held in that array in memory is gone because the server shut down, but if they're talking about do the objects get destroyed in between these different its here, no, because the server is running the whole time. So the server starts here, it's still running. Yes, I think the server is still running here because this request started. So yes, it doesn't get destroyed until you destroy it or until the server shuts down. Alright, sweet! So we got through testing. We will be doing more testing, but this is the first part of testing. How does everybody feel about testing? I feel good. You feel good? Good. It's really not hard. Express makes it easy for testing. I really like testing with Express. It's like it's almost fun in my opinion, especially if you have a good authentication system set up like JSON web tokens, that's really fun.

Organization and Configuration
Application Organization
Now we're going to talk about organization and config. So this is where we're actually going to start building the API and doing stuff and it's going to get kind of crazy. We're going to jump a couple steps and we're going to talk about how to really get the API going. So organization and config. Our API will consist of many different components, typo, to support the API authentication, static serving, etc. So when you hear me say the word API, I'm not just talking about the REST endpoints. This is actually really going to be like a web server that has an API aspect of it. So we'll be like serving a site or actually maybe I won't. Maybe I won't serve this site, but it definitely will be doing authentication. So we'll have authentication, authorization, identification, and then the API, but what actually makes up the API portion of the server, right? So if we look at our code we can kind of figure that out already. We know that in our server. js we have middleware, we have these routes, we have these routers and then we have these CRUD operations here. Alright, we can break that down to different components of our API. So the API is really just a collection of resources with models to define how the resources look and then we have controllers to access those resources and routes to let the controllers know how. Wow, all these typos are really hard to read. Know how to run and expose our API. What if they like have an editor go through your whole thing? Yes, that would be great. Before we lost the course. Yes, we should totally do that. There's like at least 100 typos in here. I don't think there's 100. Yes, so resources which are like the model so like our lions, our tigers, those are our resources, those are our models. And then we have controllers that define, that give us access to the models. Those are the things that are going to interact with the models and then the routes are the things that are going to call the controllers. So the controllers are the callbacks to the routes and the controllers themselves interact with the models. So we have our routes here that our client is talking to, we have our models over here, and then right in the middle are our controllers. Our controllers are like okay, I'm going to wait for the route to tell me to do something and then I'm going to go talk to the model and come back and give it back to the client. So the controller is sitting right in the middle. Does that make sense? And we've been doing that this whole time. So it's nothing different. So we have our servers or I'm sorry. Here's our routes. It's like boom, go to lions. Go to lionRouter, great! And then we set up these routes here. So here are our routes. This callback function right here? This is like our controller. That's the controllers, this function and what's happening in the function. And then as far as the models, it's just this lions array right here. So we've been doing it the whole time. Our controllers are the thing that's doing CRUD operations on the model. So right here. We're adding to the model. We're deleting. These are all our controllers right there that are interacting with the lions model, that are reporting back to the routes or the requests. So we have our routes, our controllers, our models. So a model is just a blueprint of what our resource may look like. So again, yesterday we were talking about that, right? It's just a blueprint of what our resource is going to look like and that's what a model is or somewhat. So just like blueprints or just like the blueprints we made in the JSON above, the controllers are the glue between the routes in the models and like I said, we've been using controllers and routes the whole time. So MVC is a classical like organizational pattern especially for the servers. We're going to take a service-oriented approach instead. So we're not going to organize our application in like a traditional MVC pattern where it would be like something. Like in our server we had a folder for our controllers and a folder for our routes or a file for our routes and then a folder with all our models. We're not going to take that approach. The approach we're going to take is more of a service-oriented approach instead. So instead of grouping our code together by type, like all controllers go here, all models go here, all routes go here, we're going to group them together by feature, by functionality. So it's like everything to do with a lion goes here. Whether that's a controller, a test, a route, a model. Everything about the lion goes here, everything about the tiger goes here. Alright? So we'll bundle the resources, routes, controllers, models into one directory and test to. So that looks like this. So in our API folder we'll have for instance a todos resource. It has its own model, its own controller, and its own routes. So that's pretty much it as far as organization and then we have other things like a config folder where we store config stuff, maybe a utilities folder where we store utility functions to help us out and maybe an authentication folder to store authentication stuff, but the important thing is just how we organize the models, the API.

Configuration
So on the configuration though we can use process. env. NODE_ENV like I was saying before, that variable to tell our application what environment it's running in and the possible options we use as a community are going to be some variance of these three, but usually these three. So it's either you're in testing, development or production. By default you're in nothing. So you have to set that default yourself so it's a good practice, or at least in my opinion, to just set it to development by default. So just assume you're always in development until you specifically change it from production or testing. So those are the common ones. So depending on the env, we can change things in our app like database URLs or toggle logging on and off. That way we don't have to go in and erase every single, like oh where's that console. log? Let me go find it and erase it. We can just turn it off with an environment variable like turn off all logging, right? We can also set and reference other environment variables. So if I wanted to get this secret token for Facebook so I can have it work on my authentication scheme, we could do that. Write environment variables. So instead of searching everywhere for these values to change, so for instance if I just sprinkled these values all the way through our server, right and then now I had to go change them like if I was alright, logging, you're going to be enabled if NODE_ENV is production and then in another file I did the same thing for logging and in another file I did the same thing for logging and now we're in testing. So right now I've got to go and change all this stuff, it'd be great if we just put this in one place, right? So what we're going to do is we're going to have a config file. Just one file that sets up all these variables inside of our application and we'll pass and that file is just going to export an object and we'll just pass that object around in our application and that's going to tell our application about what it can and cannot do and what certain values are and what they are not. So depending on the NODE_ENV, we can require other config files in and merge the two together so our app can use it. So I'll show you what that looks like and why that's important. So here's our config file. It might look something like this. _____ You had a question? The question is why are we using service-oriented instead of MVC? Good question. There really isn't a specific reason other than, one, I really like a service-oriented approach. It's very familiar if you've built on the front end with things like component or with React or Angular or anything like that, web components, it favors that and Node is actually moving toward that. So there's just a big push for different types of real-time applications with Node. So using things like Falcor or GraphQL or even like using Flux architecture on the back end, it just makes more sense for us to reason about our application in this way, but there's definitely nothing wrong with the traditional way. I still see that happening. So frameworks like Sails. js still use that. There's nothing wrong with it just like there's nothing wrong if you're on a front end and you wanted to organize your code, like put all my JavaScript in this file, put all my CSS in this file, put all my HTML in this file. There's nothing wrong with that, it'll work, but in my opinion it's a lot easier to just have everything that belongs to something in one place. That way I don't have to go look a million places for it. It also allows me to, if I just want to not use that feature anymore, I can just go to whatever is using it and comment it out and it will still work and everything will still work, just not that feature. Whereas if I wanted to turn it off in another approach, I have to go in many different places to find where it's being used and that can be kind of hard. So there are pros and cons for both approaches, but I think this is a better approach and because Express has those mini routers, it kind of encourages you to set it up this way. Any other questions on that? Great! So we have this config object. So it looks something like this. We'll have like env, which is like what environment are we in? So remember I said by default NODE_ENV is nothing so you should set it to something, and that's what I'm doing here. So env is either going to be process. env or development. Logging, I don't know, maybe turn it off by default. And we have some secrets. We'll have a GitHub token or a JSON web token secret or something like that. So this is just an example of what a config file may look like. It's depending on what your app needs, but the very important things that we use throughout our application, we'd store in a specific file. Notice I didn't hard code the actual secret GitHub token in here or the secret JSON web token in here because this file is going to be in source control. So I didn't hard code it in. It's going to be passed in through the environment. Alright? But I also don't want to go around every single file and have to write this out. Oh, I need the GitHub token. Let me write process. env. GITHUB_TOKEN, I don't want to write that out. Right? So I can just say just give me config. secrets. githubToken, which is actually just as long, right? But at least I know it's in one place. So the part that I was talking about as far as using the environment variable to load up different configurations? This is really cool, I think. This is a practice that I learned. I can't remember where I learned it, but I adopted it and I went with it and I really like it and I'm starting to see a lot of people use it, too. We can use this approach. You could think of this config object as the base config. This is the config that it starts off with, but depending on the environment will load in a different config object that will override properties on here, right? So depending on what the NODE_ENV is, whether it's development, testing or production, will have an equivalent file. So this is config. js and then we'll have development. js and testing. js and production. js and because those names of the files line up with the name of the environments that we're in, we can just use the environment to require the appropriate file. That way we don't have to guess which file to require, right? So we can just way require the process. env. NODE_ENV, which could be testing, development, or production and since we have the testing. js, development. js, and production. js, it's going to require one of those files depending on the environment. Alright, just like this. So you can put variables inside of a require statement. So it's like I'm going to require whatever the environment is. So this might be require testing. js or require production. js or require development. js and that itself is going to be another object just like this that has different properties on it and maybe some of the same properties. Maybe it will overwrite logging to be true. So in development we definitely want logging to be true. If we write a log, we want to see it in development. So maybe in development. js it will say logging true and that will overwrite this, alright? So then we do that and then what we do is we just merge them. So actually, now that I think about it, assign probably wouldn't work here because it doesn't go all the way deep. You'd probably need something like _merge, but you get the point. We need to extend these objects together. So the way this works, or if you don't know what assign or extend and how that works, so what happens is every argument after the first argument, every object, it'll take it and it will merge the properties onto the object on the left. So I can put as many objects as I want over here and it will just keep putting them on this object and then return it. So that's like env will take precedent over this config and it will overwrite properties on it and then it will export it. So now our application now has this new object with all these properties on it and we can use these flags or these values in here to do things in our application. Any questions? You're going to see this and you're going to do this. Okay. So, for our blog application, which is what we're going to be making, the server part at least, not the front end; the front end is already made. We made it on Monday and Tuesday. We can start thinking about what resources we would need to make and start putting out the resources. So, think about like models, models, controllers, right? So we can plan out the routes so that we can start organizing it. So for the resources we'll be using just very minimum resources. We're not going to get too involved with this API. So as far as resources go, we're only going to be using three. We're going to have users, we're going to have posts, which are the actual blog posts themselves, and then we'll have categories that we can organize our posts, like this post has this category. It's like a simple blog. So it's the only resource we're going to use and we're not going to get too crazy. There are so many things. We can have tags and we can have all different types of stuff in the blog, but we're going to have users who can create posts. We'll have posts that belong to users and have many categories and then we'll have categories that don't belong to anything. So knowing what we know about REST and API design so far, we know that we will be creating CRUD routes for these resources using middleware and routers, just like we did with the lions and tigers. So we have our resources. We know we will create CRUD routes and we know for sure that there are at least five CRUD routes we'll make for each one of these resources. So if you just do the math, that's 15 routes and we know that just by that. Will we ever use all those routes? No, but it's nice. We should probably start with them and then we'll take back some. For instance, we don't want the ability to go in and create users. Right? You don't want to go ahead and just start making users, you need some type of authentication for that. You need to sign up or be invited or something like that. Like you can't go to somebody's Wordpress blog and say I'm a user now, I'm going to start writing posts. You can't do that. You've got to be invited, right? Or you have to be the creator and then there's different rules and stuff. So yes, but we'll start off just assuming that we'll create all CRUD routes for these things. So yes, we'll use middleware and routers to tweak and configure those and then we'll model the resources later. So don't worry about modeling the data, alright? We don't need to do that right now. All we need to know is that we have these resources, they will have CRUD and they definitely need those routes so we can actually start writing code for now, but we'll model the resources after we get done with this and we'll talk about Mongo and stuff. So but now, that's all we need to have the resources so we can get started building out the skeleton files. So knowing what we know about organization and configuration and the resources we're going to use, that's enough information for us to go ahead and start building out the scaffold version of our API. So we'll have all the files in place. They might not be doing anything yet, but we'll have it all in there. Does that make sense? Okay, any questions on this because I'm about to tell you what you're about to do? Yes? They were kind of discussing the mock and the fixture and somebody mentioned that when you were talking about the lion that you created, in his opinion that wasn't a mock, that that was a fixture where a mock is used more like an API call that rather than waiting for it to complete you would just mock the API. Yes, that's also true. Yes, that's true. I think they're loosely used. I don't really think there's a right answer and that's probably why I couldn't come up with a good one because when I think of mocks, I guess I'm thinking more of like on a front end of using something like Angular and like mocking dependencies, but also at the same time that does make sense, like you're mocking API calls and you don't want to wait for them. So yes, it's really hard to determine. Those are some of the loosely used terms in our profession, but I like that explanation. So that works very well in our context.

Exercise 6
So if you would join me on step-6, boom! There's a lot of stuff going on here so I'm just going to walk you through it before I set you loose and explain to you what you're really going to do because there's a lot of stuff in here. You know, if you want to look at some of this stuff, I encourage you to, but a lot of stuff in here we won't be touching. So notice that a lot of stuff has changed. We now have this, well we had the server folder, but now inside the server folder we have an API folder, a config folder, a middleware folder, and a utility folder. A lot of stuff. So let's just walk through it. The first thing I'm going to do is look at server. js or actually just look at index. js and see what changed. So index. js has got some stuff in here and there's nothing you're going to do in here, but I got a lot of comments on what's going on and what's changed and why I'm doing certain stuff. So really what's happening in here is I'm just requiring this config. We'll talk about config later. We talked about this on the last step, why we exported the app. I'm doing the same thing, just importing the app like we did on the last step. This logger thing, we'll talk about that in a minute, and then I'm just listening on the server. The only difference is before we hard-coded the port in here. This time we're getting the port from whatever the config says the port is. So again, this is why it's nice to have this config object that we don't have to guess what's going on. If we just put config. port there we'll leave it up to the config to determine what the port is and that can be dependent on some hard-coded value in the config or some process. env. port or whatever, and then the logger, we'll get to it in a minute. It's just a wrapper around console. log that can be turned on or off; that's all that is and it changes the colors and stuff for you. So then we're go into server, server. js and this is where it gets kind of confusing because a lot of these patterns we haven't seen. I talked about this pattern before, but I haven't really gotten into it. It's a very small file, but it's actually doing quite a lot. So just like before, we have Express, we have our app. This is a router. I didn't call it apiRouter because it just seemed redundant, but that's a router that we've made before like a lionRouter or a tigerRouter, it's just the API. That's a router. And then this part is actually interesting. So you'll notice I'm not setting a variable over here. There's nothing to the left of this and that's because I don't really need to. It's not returning anything, it's just a function that's doing something. So if we go look at it, middleware appMiddleware, it's doing what we already know. It's just setting up global middleware and that's all it's doing. It just takes in an app and sets up global middleware on it. That's it. It doesn't return anything and that's why I don't have a variable to the left of it. It's just like if you give me an app, I'll set up some middleware on it and that's it. So that's why that's there. So you can imagine all this just being over here. It's the same thing. Nothing has changed. I just put in another file. It's the same thing. If I left this here it would work exactly the same, but we only have three pieces of global middleware. In a row application you'd probably have like 15 so that's why I took it out. Maybe it's a premature optimization, but you will have just more than just three more or less. So I took it out and did that instead. So remember, this require is going to require whatever this file is. This file is a function, right? This is a function right here. It's a function so I'm immediately invoking the function and satisfying its arguments, its signature, which is an app. Everybody follow me there? How it's just a function? It might be easier if I just did this, if I said var setupMiddleware equals require and then not do that and then down beneath I'll say setupMiddleware app. It's the same thing. I just didn't feel like putting it on two lines. Alright, so let's go back. There's a question on convention. When would you use relative path versus absolute path in Node? Are there any kind of rules for it? Right, so relative path for all require statements, absolute path for file systems, anything related to the file system, I'm pretty sure it's absolute paths and then I think that's about it, from my experience. There might be some more other stuff out there, but mostly anything dealing with the file system is probably absolute paths and it'll tell you. It'll log an error like that's not the real thing. And any piece of code that's interacting with the file system once, absolute paths two probably, in my experience, unless the developer is nice enough to not require that. Alright, and then right underneath that I'm just like alright, let's set up our API. So just like before, we don't need that. So just like before where we were mounting the tigers and the lions to the tigerRouter and the lionRouter, I'm doing the same thing. I'm mounting any request to /api to use the API router. That's what I'm doing. It's the same thing. So just like we had before, we had lions, so any request coming to lions use the lionsRouter, that's what we had. It's the same thing. If anything comes in for API use the API router. Alright? And then I'm exporting the app. So your first task in here is to set up some error handling, some global error handling. So remember, error handling goes after everything else so I'll just come in here and set up some error handling so when we call next inside of this router somewhere, it'll happen in here, of if you want, because everything is encapsulated inside this router, you could also set up error handling on this router's middleware stack and it will still happen. So it's up to you, but the reason I say put it there is because if we add another API down here, you know, it'd be nice to have it in one place. So it's up to you. You could put it here or you could put in the API. Everybody follow me so far? Okay. So now if we go into api, on the root there's api. js. Again, I said I'm not using the index. js pattern because it's kind of confusing, but I probably would in my application. I would just put index. js inside of here and that way I don't have to require api/api. I can just require api, but we're going to stick with this naming convention for now. So inside of here, you're going to do a lot of work in here. So here's that router, the api router that I made, but all this router is doing is setting up three other routers. So it's mounting /users/categories and /posts, which are the resources I said that we were going to make and it's expecting our routers to be placed here, just like with /lions and lions tiger or lionsRouter, just like we have here where we're saying /api pass it to this router. It's doing the same thing as like, alright /users, pass it to this router, /categories pass it to whatever router is going to go here. It's the same thing. So if you go look at the respective folders, the resources, you'll notice that there's a routes file for each one of them with a router. Right? So there's only one thing and it's already going to export it. So you've only got to do one thing to get it over there. Everybody follow me on there? The routers are already made. They already have their initial get functions so they don't error out when you go to them. So you'll be doing that and then the last thing you'll be doing is in the config folder. So the config folder, there's a lot of crazy stuff going on in here, but I'm just going to walk you through. So config. js is the root of the config folder. This is just like I was talking to you about in the example as far as like what the config object is going to do. So we have our config object, put some properties on them. These properties right here? Dev, test, and production? This is just me storing the name of the environment variables so they're uniform because some people like to use tests, testing, dev, development, prod, production. They use different terms so I'm just like if I just call config. dev it'll be whatever this is going to be. I don't even know what it is, it's just going to be this, alright? So it's just a way for me to keep things uniform. So I've set up a basic config object. This port right here. This is a convention. When you deploy this, it's probably going to, the port that you're going to listen to is probably going to be this environment variable. I know Heroku does this, I know AWS does this. It's going to be process. env. port, or if that doesn't exist then it's 3000. If you don't believe me, when you start the server just do an export before you start it. Export port = and then put some number. That'll be the port that you'll be listening to and it will log it here. It'll say on that port, config. port. Sweet! So config. js and then right here I'm just setting up the default environment. So I'm like alright, process NODE_ENV is going to be equal to whatever it is if I set it outside the context of this application like through Heroku or AWS on a command line, or it's going to default to whatever config. dev is, which is development. So remember I said always default to development, just assume you're always in development unless you explicitly say you're not. So that's what that is. That's why I have these streams here because I could've just typed in, yes, just type in the string development. There's nothing wrong with that, but like I said, sometimes these things, people mix these names up. So if we had to use development somewhere else, I just didn't want it to be confused. So I'll just put config. development and you don't need to know what it is, just know it's config. dev, and then I just set up the env. So I put an env property on this config object that's equal to whatever this is, which if we don't set it, it'll be development. So this might be development as well, but it could also be production, it could also be testing. It's just so I don't have to type in process. env. NODE_ENV every time I want to see what the environment is. I can just can config. env. Cool! So all that's done for you. So what you're going to do, there's this big paragraph right here. EnvConfig is nothing right now, this is a variable, but if you look on line 26 you've got some context as it's happening. We're doing this merge. This is definitely an object because we just set it up here and we want to merge this object onto this object, but the problem is this is not an object, it's nothing. So what we need to do is depending on whatever config. env is or whatever process. env. NODE_ENV is, load up the appropriate file and assign the value to envConfig so that the merge at the bottom actually works. So again, what's happening here is that we have a base config in this file. This is the base config and depending on what env we are in, we then merge those objects. Oh, I'm sorry. We're going to conditionally load up another file depending on what env we're in, right? So if you look, there's a development. js, there's a production. js, there's a testing. js, right? And if you notice, they're the same names as this, development, testing, production. So depending on what environment we're in which is going to be development by default, it's going to load up one of these files, which also is exporting an object. And this object is going to be merged in with this config object and it's going to override its properties. So if these same properties existed on any one of those other file's objects like development, this object takes precedence and it will overwrite whatever is here and that's only because we placed it to the right. That's how merge works. If I put another object here then all of its properties will be merged onto envConfig and all of its properties will be merged on the config. That's how a merge works and it'll recursively go down and do that. So that's how this should work. So now if we go back to server. js, or I'm sorry, index. js, the very first thing our server does is requires config. So the first thing it does is it runs config and it sets all that up. It'll set up the environment, it'll set up all the secrets, all the logging, all that stuff, good to go so that's the first thing we do. So that's why we have to do that merge and have to export it. So there's one more file in here. This is just something I wanted to show you guys. This is a wrapper around console. log that I made so you can do logging, just to show you like why or how cool a config file is so we can conditionally turn off logging or not. So this file is just a logger that wraps console. log. So I have a noop function that is short for no operation. This is a function that does nothing; it's a common pattern in JavaScript. Sometimes you need a function that does absolutely nothing. In this case we do. So what I'm doing here is I'm saying this variable consoleLog, if config. logging is true then set its value equal to console. log. This is a trick that's just going to return a function with the same context or it's going to be noop. So this is either going to be console. log or it's going to be a noop, but it's definitely going to be a function and then log, all it does is it does some trickery. It'll take in all the arguments that are passed into it and iterate over all of them. If it's an object, it'll convert it to JSON and change it to purple, all the strings. If it's not an object, it'll just still change it to a string and change it to purple. That's all it's doing and then it'll just call console. log with the arguments or noop. This is either console. log or noop, you don't know, right? So there's some funky JavaScript stuff happening here. This might look new to people who don't have a lot of experience with JavaScript, but that's all I'm doing. I'm just wrapping console. log and adding some color to it, making everything look pretty, making all the JSON indent right, change the instance from an object, because if you console. log an object in Node it'll just say, eventually it'll get tired of logging everything and it's like, oh, this is an object. It'll just say object and it won't even give you the properties on it, but if you turn it to json it will. It'll be like oh, here's everything, but then it's just like one long string. So I indent it so it looks like a regular object and then I make it purple so you can see it. Cool! Everybody got that? So if you run it, if you run it right now, npm start, oh yes, it's going to break because this stuff isn't here. So it'll break because you've got to add that stuff, but once you add that stuff, you'll see like how the logging works and all that stuff. Actually, I can just do it right here. If I go to index. js, if I say before the app or I've got to come up here, if I just said logger. log heeeyyyyy, I don't know. It's just breaking. It's not even going to let me do that. So yes, you've got to fix that. Cool! Any questions on what you're supposed to be doing? If you're lost, like for sure tell me. I want to make sure I explain it to your correctly. So to recap, you'll be messing around in this config. js and making sure you load the right file and then inside of api. js, getting these routers in here.

Exercise 6 Solution
So the solution for this is, for mine at least was let's just look at config. js. So here's my solution for config. js. I did a lot of error checking and stuff in here just to make sure that this merge happens correctly. So what you could've done was just really like required the file, which would give you an object and just put it there. That'd be great, but it's a lot of edge cases so I'm checking for those edge cases. I think I'm still missing one and then I'm looking at it. So what I'm doing here is I'm doing a try-catch. Anybody not know what a try-catch is? Alright, just to go over a try-catch, it's like everything between this try block, I can just put any type of JavaScript that I want there and then what's going to happen is if JavaScript detects that an error has been thrown in that try block, it's going to allow me to handle that error inside this catch block. It's going to be passed as an argument. So if there was like a syntax error here or a reference error or whatever type of error, an error that I threw or an error that came from something else, it's going to be caught right here and then I could do whatever I want here and then the server won't stop. It won't stop the server from executing because I caught it with my own try-catch. Do you see what I mean? Like we could check that out here. I'll just do it in Chrome. I'll go into Chrome and this is really painful to write in, but if I was like try, you know, and then throw new error, ooops, right and then I say error, or I'm sorry, catch and I grab the error here, right, and I can be like 1 plus 1, right? So after you throw an error you expect the execution of JavaScript to stop, but because I did a try-catch it should still do that 1+1. Alright, so if I do that and it still executed 1 + 1, even though I threw an error, as soon as I caught the error myself, right? Whereas before, if I were to say throw new error and then try to do one plus one underneath it, it wouldn't run, right? So if I said, if I had a function that says var and let's just say error or err is a function and all it does is the first thing it does is throws a new error, right? And then right underneath it, it tries to do 1 + 1. They're talking in chat that if this is config related, wouldn't you want the server just to stop? If it's config related, would you want the server to stop? Probably, maybe, you probably want the server to stop, but yes, you know what? I guess it depends on how sensitive the things are in your config and they probably are very sensitive. So, probably. The other alternative is like to put all the sensitive stuff on the main config object so that way your server could still run, even though it couldn't require the appropriate file, but then of course you still would have hiccups in the different environments, but this is specifically for development so this isn't like keeping production and testing in mind. This is like to help ease development, but you could do it on the other side and it's like, well, I want to enforce that you always do this. So it's kind of however you want to do it. Yes, does everybody get me? So now I threw this error. I didn't catch it and then I tried to say, oh now do 1 + 1 and it was like, no, I caught and there's an error here, right, but the try-catch above allowed me to continue to go, alright? So that's try-catch. So it's like try this code and if there's an error catch it here. So what I'm doing is, the thing that I'm worried that might error out is this require statement because there's a lot of stuff going on here. This could be wrong, I don't know. Hopefully it's not because I'm using these actual names here, but it could be something wrong and there might not be a file. Like if config. env ended up being Snickers, there's no snickers. js and then this would error out. If you try to require something in Node and that file doesn't exist, it'll throw an error. So that's why I'm trying to catch this error. And then down here I'm like, so even if it did find that file, I want to make sure that that file actually exported something, like I want to make sure it didn't export the number -1 or the number 0, which is a falsy value. So it's either going to be whatever it is or it's going to be an object. I can even test if I want to make sure that it actually is an object, right? So you can get even crazier with it, but just testing that and then if it does throw an error, just default to an object so that way the merge still works because merge needs an object. So that's why I did this try-catch. You probably don't need it, but just it just catches some edge cases, and then down here I'm just merging them, too. So grab this object and stick it on here. So the one that we would grab because default is going to be config. dev, which is development, that's going to be the development. js. The only thing in here is logging is true. We definitely want logging in development so I turned that on. So that's for the config and then as far as like the API, all I'm doing is just requiring those routes or those routers inline. What you probably might have done is like you required them up here, saved them into variables and then passed them down? You could do that, but I'm not going to use them anywhere else, I'm just going to require then inline and save some keystrokes. So if you've got all this working then what you should be able to do is now my server is on and I should be able to interact with it. So if I type in http, I'm using HTTPie here. If you want to use Postman or whatever or curl or whatever your flavor is, localhost 3000 and then I left a note in one of these files about like the actual routes. Where did I leave that note? It's api user. Api users, I left the note? Or maybe I didn't. I left a note about like how to figure out where the routes are and maybe it's not in here. Okay, so somebody tell me what would be the URL if I wanted to do a get request to categories? What's the URL? Because if I go to categoryRoutes it's just like slash. So that means if I go to slash, so if I do a get request to this, I should get categories or even that, right? No, you don't. Nope, cannot get 404. So that's definitely not the URL, but that's what it says right here. So what's the actual URL for this thing? _____ Right, so we've got to take a step back and we've got to see what's using this router? So let's walk backwards. So we'll start here. So this route, remember? Remember, I told you don't think of this as slash, think of this as route. This is the route. So this is whatever the route is. So we've got to go figure out what the prefix is or the parent is so we'll back up on it and that's api. js and then for categories it's /categories. Oh, okay. So here's /categories, got it, but wait. You're being exported, too, so we've got to go figure out what's using you. So we'll back out of this, right, and we'll go to server. js and we'll see /api. Alright, so the real URL for categories will be /api /categories and that's it. So /api /categories. Mark? And I don't know if you want to handle this now or not, but on line 10 of server. js it says to set up global error handling. Can you give an example of how you'd do this? Oh, yeah. Also, they're asking can you use. / here? Dot slash. No,. / is for file paths, which are different than URL routes. So I wouldn't use. /. We're not trying to access a file. We're trying to access a URL, but yes, global error handling, I think I forgot that one. So the way I would do that, so when I say global I mean for the entire application. You would have to do that in the middleware stack so I would just do it down here. So I'll just app. use, right? You should probably write this in another file. Actually, that's what I'm going to do. So I would go to middleware. js. I'll make a new one in here and I'll call it error or err. js and it'll just be a function. Module. exports equals our error, our response, or our request, and then next, and then what I would do is just for now just say console. log err. message and then I would send back a response, res. send or res. status. You probably don't want to do this. I'm just going to do this for now, just a generic 500 server error and then app. use, I'll import that in here, which is in middleware/err. There's a question on what's better requiring on top and passing in the variable name or in the router? There's no better or worse. It works the same way. I mean, the thing or the only thing about is if I'm going to use the variable in more than one place then I'll require it. If I'm only going to use it once, sometimes what I'll do is like for instance, I'm only using err once so I made a variable for it, but I could've just required it here. It's whatever is more readable for you. It might be better just to require everything up top so it's all uniform, but the requires are not asynchronous so it's fine. It's not like ES 2015 where you absolutely have to import everything up top. So yes, err. Actually, I'm just going to switch that around to use a different pattern where it's like this instead. (Typing) There we go. So then in here I could just do err. So that's how we set up global middleware. So you could put this here, you could put this in api. js or wherever, but that's how we do it, but where was I? Yes, so that's the URL for categories. So if you follow me again in server. js. So if I go to /api, go to this router. Okay, I'll go to that router, and then if I go to /api/categories, go to this router. Okay, I'll go to that router categories, and then on the route for a get request do that. Okay, got it. So if I just do /api/categories, oops, I guess I should start the server. Oh wait, did it freak out? Middleware/err and server. js. Oh, I forgot the e in middleware, there we go. Npm start. Cool! So that's right and then now if I go to api/categories, there we go. Okay, true. That's categories, right? And just to show you that that's categories, if we go and change this to ok _meow_meow, that's categories. And it's the same thing for all the other resources. So users, same thing; posts, same thing; anything else, nope. Everybody follow that? Any questions? No? And then as far as like triggering the error middleware, so let's see how that works. So if I come in here and I say next and I'm just going to put a return here just to make sure it doesn't try to do anything, return next, new Error, alright? So if I do that, that should go down to the stack all the way to this and make sure I made that right. Yes, that should go all the way down there and do that so let's check it out. What was that request for? It was this. Oh, categories? Okay, so let's try categories. Hmmm, oh there it is, yes. So, yes, it's working. That's error. message right there. Alright, so if I go back to server. js or error. js. That's err. message, right? So I'd be like this is the error. Let's try that again so you could see. I'll clear the console. Do a request. This is the error. So it's totally working. I just did err. message and that's why it looks funky. Just put error and you'll actually see the real error. There it is, messed up, or if you want to see like the real, real error then you put err. stack, then you do that and then you get the stack trace. Cool! Alright, any questions on this stuff? I thought this stuff was kind of cool. I thought how everything just came together as far as like oh, just plug this router up and you're guaranteed to have this get request or like how the config can turn stuff on and off depending on the environment and load up different files. I think that's pretty cool.

Mongo
Mongo Introduction
Now we're going to start getting into Mongo and actually saving data and messing around with that thing and figuring out how it works and how to connect it to our API and get things going. Before I get started, were there any questions about what we already covered before lunch today, that you might've missed and that you might want to ask now? Nope? Well, alright, let's get into Mongo. So does everybody have or who doesn't have Mongo installed or hasn't tried it? Tried to execute it? Tried to run it? Because if you didn't, you might be surprised that it probably doesn't work. Okay, good so far and hopefully everybody online who's tuning in has downloaded it and installed it. Great! So Mongo is a NoSQL document store. Who here wants to give me the definition of NoSQL? Not meaning SQL? That's right, it's not SQL, meaning it's non-relational, right? It's not a relational database. We don't get those guarantees, those fixed-width columns and stuff like that. It's just a document store, meaning it's just a basket where we can throw stuff in. That's pretty much what a document store means. We don't have to model our data and we could just throw JSON in it and ask for it later. That's Mongo. It's like just give me some JSON, I'll save it and then I'll get it to you later when you ask for it. That's pretty much what Mongo is. We need a way to persist our API data. So we'll be using Mongo for that, obviously. So it's actually pretty simple to set up and use. Hopefully everybody like I said, already downloaded it. Note that it's not the best database or option for every situation, just like anything else out there, but for the sake of this project it's perfect and it's going to be great for what we're using it for. So if you have Mongo installed then you can type in this command, mongod or mon-god or so people say, in the terminal window to start the database. So like if we go there, open up a new shell and type in mongod and hit enter you should see this, something like this. Pretty much like on port 27017. So if you're on Windows you might have to use the execution path a little differently, but when you execute it and you don't see this and it's not hanging, you get an error and it just stops, then you didn't do something and something is not right. So if you don't have that then you didn't try to run Mongo and it's not working. So this just started the Mongo database on that port on that server, so everybody should have that. The next thing is we can also interact with Mongo that we just started through what's called a Mongo shell that it ships with and is actually pretty awesome. So to do that we can open up another window with Mongo still running, it's still running over here, we can open up another window and we can just type in mongo with the d and if I spell it right, it'll say something like this. It'll tell you what shell version you're on and it will automatically connect to like some database, usually test is a default and this is kind of like a REPL. We can do JavaScript-like things in here because Mongo really runs off JavaScript and it's built with JavaScript and we can do JavaScript things. So this is how we can interact with our Mongo. So for instance, if I wanted to see all the databases that I have, I can type in show dbs and it would show me all the databases and their sizes on my machine. I had like 30 and I had to go delete them all because I had some other databases on here. So these are the three databases on my machine. There's a whole bunch of other stuff you can type in. You can just type in mongo --help and it'll show you all the types of stuff. So yes, that's the Mongo shell where we can do JavaScript-like things in here and interact with that database. Show dbs is just one thing, show all the databases. Cool! So once you do that, it will connect to the test database by default, which you saw when I did it. So now we can use JavaScript to run queries against whatever database we connect to. So what we're going to do is an exercise and if you have Mongo running and everything, you can all just do this with me together on your machines as we're going to create our first collection. So a collection is like a table. Just think of it as like a place where Mongo is going to store alike things. So it's kind of like a table. It's like I have a collection of people, I have a collection of dogs, a collection of todos. It's like varied data pieces. So it's like a group of data that is modeled same-ish. Actually, that's not a typo and I actually meant to spell it that way, same-ish so that should be a word. So let's just do this together. So the first thing we're going to do is we're going to make a database and we're going to switch it to at the same time. So to do that we could just say use and then whatever the name of the database that you want. In this case I'll call it puppies. So by saying use puppies, I am going to make a database called puppies and then now I have switched to it inside the REPL. By the way, when I say REPL, I mean read, evaluate, print, loop, REPL. So I made a database called puppies. You can name it whatever you want. Now if I say show dbs, I guess it won't show it until I close it and open it back up, I guess. Let's see, it's still showing it, but I guess I had to put something in it, but it's there. So we're going to say use puppies. Sweet! The next thing I'm going to do is I'm going to create a collection. In the example it says todos, but it could be whatever you want. This example just has todos, but it can be whatever arbitrary string that you want. So to do that you use db. createCollection, camelCase collection and then just pass in a string. So I'm going to make a collection called toys. And then you'll get this thing that says, OK, and that means it did it. Alright, and then to verify that you could say show collections and then you should see the collection that you just made right under system. indexes or indices, indexes, whatever. Everybody got that? You made a collection, it said OK, and then you said show collections, and then it showed you the collection that you just made. Cool! So then we're going to insert a document into that collection. So a document is like an instance of a collection. It's like the actual thing, the data that we'll be doing. It's the resources that we'll be using in our APIs, the documents. So we're going to insert a document so we just say db. the name of our database and in my case it's called puppies. insert, and that's a function, and you can just pass in an object here, whatever you want on it. So since this is, or I'm sorry. Not db. puppies, I'm sorry. The name of the collection, in this case toys, db. toys. insert and I'll give it a name. It's a yoyo, dogs like yoyos, and a color, it's red. And if you hit Enter, you won't see anything. It won't say anything, it'll just go to the next line. If you got some output and if it's an error, then you probably messed up. If it's not an error, then you're probably good and we'll figure it out right on this next command. So the next command is we're just going to query that collection to see what's in there. So to do that the easiest way is to db. the name of your collection and in my case, again this is toys and I can say. find with no arguments. I can execute that and it should spit back all the documents in that collection, which should just be one. Everybody see that? Has everybody been able to just query their document that they just saved? Also, if you're on Mac there's this program called robomongo, which is just like a GUI for Mongo. So you can connect to it, go in there and here's my puppies database. I can go to collections and I can go to toys and then I can see the toy that I just made right there. So this is a GUI that you can use. It's called robomongo, robomongo. I'm not sure if they have it for Windows or not, but it's definitely on Mac and it's free. They do. Okay. So that's like an intro into Mongo. I don't know how much experience people have with databases, but I mean that's pretty easy to save something in a database in my opinion. We don't have to worry about, you know, migrations and stuff like that. You just throw some data in it and ask for it later. That's why I chose this database for this exercise because it's pretty easy to get started with. Okay, here's just like a walkthrough of what we were doing. So by saying the keyword use followed by the name of the database we want, like I said, Mongo will switch to it if it exists. If it doesn't exist, it'll create it and switch to it. So run those commands one by one until we get the stuff.

Using Mongo with Node
So this is great and we'll use the Mongo shell in the terminal to do stuff, but honestly we won't be using the Mongo shell in our API. That would not be fun, right? So we need some type of JavaScript driver to access Mongo. There is a native driver that we can use that will work fine, if you just npm install MongoJS you'll get the native driver and it pretty much allows you to do the same stuff we just did in this shell in our JavaScript files, which like I said, is pretty easy, but it gets even easier and there really aren't a lot of options here. What we'll be using is an ORM or I guess in a NoSQL context an ODM. Anybody know what an ORM is? Does anybody not know what an ORM is? So ORM is, you could think of it as just a library that helps us talk to the database. That's all it is. It's like a library in some language that'll allow you to talk to the database with your preferred programming language. It's short for object relational management. (inaudible) There we go, yes. So Mongoose is the most popular one for Mongo and it's the preferred one. It's actually like I think the official one now. It's like the thing. So Mongoose is the one that we'll be using. It is not made by the people who made Mongo. It's an open, third-party ORM. It was actually made by, who was it made by? Automatic, the people who own WordPress. So they're the ones who made it and it's super awesome. It has a really, really good API, one of the best APIs I've seen on any ORM in JavaScript. So Mongoose will abstract things away. It also adds supports for things like promises, allows us to model our data with schemas because remember I said, oh, so many typos. Remember I said up here, Mongo is a NoSQL database and we don't need to model our data; we can just throw stuff in it. So we don't really need schemas with Mongo. Like as you saw, I just threw an object in there. I mean, I can just put anything that I want in here, any properties. Like if I wanted to put an array of here, you know, nums, that's fine. It'll put it in there. It doesn't matter, alright? It doesn't care. Mongoose adds those features so we can care about stuff like that. So it'll allow us to develop these schemas just like you would have inside a relational database and allow us to establish relationships with our models and so much more. So like if you ever use a relational database you have different types of relations, right? You have one-to-one relationships, one-to-many relationships, many-to-many relationships, right, inside a relational database, which will determine how you store these references on different tables or even joined tables in different situations like many-to-many and stuff like that. So we're able to do that with Mongoose, but just note that Mongo doesn't care as we just saw. Is everybody following me there? Okay. So here's an example of how you connect to Mongo using the Mongoose and it's just this simple. You require Mongoose after you npm installed it and then you call mongoose. connect and then you have to use this mongodb protocol whereas typically on an URL you have like http or whatever. Well, when we connect to a database it uses a different protocol and that's the MongoDB protocol. So we'll put mongodb there, ;//localhost. We don't need a port. It doesn't matter, you can zip through the port and then the next is the name of the database that you want to connect to or create. So just like when we said use whatever? If it existed, it'll switch to it, and if it doesn't exist, it'll just make it. It's the same thing that's happening here. If you give it a name to database, if it exists, it'll connect to it and if it doesn't exist, it'll create it. And that's how you connect to the database, that's it. So now with that we are now connected to the database and we're able to start doing queries and doing all types of stuff. Any questions on that? So mongoose. connect, that's it.

Exercise 7
So we have a small exercise, if we check out to step-7. It's another small one. (Typing) Let me open that up. There we go, okay. So in step-7 there's a new file in the route and this is called dbTester and with this file what we're going to do. Oh, let me silence my phone. There we go. This file is completely outside of the application we've just been working on all morning. It's a separate file and that's why I made it on the route. It's just a way for us to play with Mongoose and Mongo and get familiar with it. All you need to do in here is just you need to connect to a database so the below will work. So once you connect to a database, the stuff that's happening down here will be able to work and we can verify it. So what's happening below is that we're creating a new schema and making a todos collection with a todos model. So they're seeing the collection in the model. The model is like the representation of the actual resource that we're going to be creating or consuming in our API. The collection is where that model is stored in the database. So we're making a todos collection with a todo model, alright? Just like if you use backbones, the same stuff. We then create a new todo. So once you connect to the database, if you go back in the Mongo shell or terminal or robomongo or wherever you're looking at Mongo, switch over to your database and query it. Query it there to see if you find the todo that's created below, and also make sure that mon-god is running, so mongod is running inside of a terminal, otherwise none of this will work. So make sure you have Mongo running, connect to the database up here, and then go look at it, whether that's in robomongo or whether that's in the Mongo shell. Connect to that same database in your preferred method and make sure that when you query the todos collection, that's the name of the collection, pluralized, lowercase, that you see this todo that we created.

Exercise 7 Solution
Cool! So what that looks like is connect to a database. I'm just connecting to todos and I'm just going to change it because that's the name of the collection as well so I'll change it to something else like puppies, alright? So if we run this file, let me make sure I clean this stuff up. Alright, and you'll say boom and like alright, this is what I created. And then what we can do is go over to our shell and I'm just going to say use the name and then now what happens is if you didn't hear me when I told you what collection it was, the way you would figure that out is if you were in this file and we had this mongoose. model. It takes two arguments. Well, actually it's a getter and a setter. So if you pass in a second argument, it's assuming that you want to create a model. If you exclude the second argument, it's assuming you are trying to reference a model. So it's a getter and a setter. So we're doing the setter. We're creating a model and the way that works is the first argument is the name of the collection you want to make. It doesn't matter what name I put here, Mongoose is going to lowercase it and pluralize it. So if I put in, I want to create a todo model, or a todo collection, it's actually going to create a todos. It's going to lowercase and pluralize it so I just put it in there like that. And then the second argument is the schema, which is the one we made up here. So we're going to talk about schema and this stuff on the next step so if you don't know what this stuff means, don't worry about it. We're going to talk about it and that's why I didn't actually write it, but that's how you know what a collection is because that's the name of it right here. And then we're creating one and then we're logging it. So that means if we come back over here and we say or we switch to our database and we say db. and you could just say show collections, too, and it'll show you the collections. There's todos right there. Db. the name of the collection, which is todos. find and that'll give you all of them. There should be like two or three in here by now because I restarted it. Oh, it's just one, actually. So, just one. There it is. And if you're using robomongo, you can come in here and go to your database, your collections, and it's right there. Sweet! So a little more on that like conversion here? Like even if we had something like something that ended in a y, I would -ies it. That's cool. Yes, that's really cool. So if we had like puppy. Yes, puppy, it'll turn it into puppies. It's trippy, right? Yes, so remember that. To avoid that I just try to avoid things with y, but we have a thing called category and it has a y in it so yay! But we won't really be messing around with the lower-level name of the collections in the driver anyway so it's kind of irrelevant, but just to let you know.

Data Modeling
Schemas
So data modeling. So now that we have our scaffold built out and we built out the routes and we have the router working, we had our config set up and we had some utilities with middleware, the server is running, everything is good. Just now we need to plug in some actual data and the controller to that data. Remember on the last step we set all that stuff up? So now we just need to replace the stuff that we have in here. So if you go look in here, we're doing nothing but sending back an ok. We need to add in some models and some controllers in here. So the first thing we need to do is before we do that we just need to figure out how our data is going to look like, but before we do that we need to figure out how to even model that data. So we can use schemas in Mongoose to add structure and validations to our data. So Mongo does not need schemas, though. Remember, again, Mongo the database itself doesn't need schemas. You can just throw whatever we want at it. Mongoose gives us the ability to define those schemas and those blueprints to rationalize about our data and have certain guarantees and validations and lifecycle checks and stuff like that. That's Mongoose, that's not Mongo. We also need some sort of relationships with our data. So for instance, users can create posts and posts have categories, alright? So if a user can create posts, that's a one-to-many relationship. One user can have many blog posts, right? But a blog post only belongs to one user and a blog post could have many categories, alright? And a category can belong to many posts. So that's a many-to-many relationship. So if you've ever dealt with databases in SQL then you kind of know what I'm talking about and if not, it's not that important. This is not a database class, this is not a class on Mongo. It's a class on building an API and this is just a small part. So you can use whatever database you want. I just want you know that's how you should think about the data and that's how we're going to think about it. So Mongoose makes the setting up of the relationships actually pretty easy. If you've ever dealt with a relational database then eventually it's like whatever, it's cool. You normalize it and then eventually you probably denormalize it later on, and you probably break stuff, but what happens is Mongoose actually makes it easy. There are no join tables and none of that stuff like that. It's just references. So here's an example of modeling a todo resource. I had a little comment. So we require our Mongoose. The first thing we do is we make a new schema and the way we do that is we can just call new mongoose. Schema with a capital S and that's a function that takes in an object. This object is our blueprint. So whatever properties we throw on this object, those are the properties we're saying that we can use. Whatever properties we put on this object, it's the same thing we were saying up here. This is us modeling our data up here. These are the properties that can exist and that's what we're doing down here. So that means we want a completed property on this resource and its value type is a Boolean. Alright? So either it's real or false, and that's not something, alright, if you know JavaScript, Boolean is not something, I mean that's not something Mongoose or Mongo gave us, that's just a Boolean, alright? Everything in JavaScript is an object and a Boolean is no different. So that's the Boolean. We can also add validations. There should be a comma right here, by the way, but we can also add validations to an object or to a property and the way we would do that is if you wanted to just add more than just what type the property is, you have to use the object literal as the value and then you can like add more properties on it. So we also want a content property on a todo. So a todo says whether it's completed or not, true or false, and then the actual content of the todo, the message or whatever. It's type is string. So that's exactly like saying completed Boolean when you put the object right here and you say type String, it's the same thing, but we don't have to put type Boolean up here because that's the only thing we're doing. We're not doing anything else with this property right here, so we just say Boolean, but we want to do something else with this property down here so we have to make this object literal. We have to say hey, your type is going to be string and then the validation that we wanted is it has to be required. So we put required true. That means you cannot save a new document, a new todo without specifying this and it has to be type of string. So if you don't pass in a string to the property content as you're trying to create a new one, Mongo or Mongoose will throw an error. It'll throw a validation error and it'll tell you where, too. It'll point right to it. They're asking if there was a date type? Yes, we're going to get to all the types right below this and yes, there is a date type. So, the next thing we need to do is kind of what I talked about in the last step is we made a new schema and now we need to register the schema with Mongoose so we can tell Mongo about it and the way we do that is we use the mongoose. model method, which I told you is a getter and a setter. The first argument is the name of the collection that we want to make and the second one is the blueprint for that, the schema object. So remember, it's going to be lowercase and pluralized. It doesn't matter what you put here, lowercase and pluralized. And then the actual thing that it returns is the actual model that we'll be using inside of our API so when we want to query the todo model, we'll be using this thing over here that got returned. So it makes sense to export it because we'll be requiring it everywhere else. So usually you'll see a pattern where this thing is just module. exports = mongoose. model and it'll just skip this line right here. I just did it on two lines so it's easy to read. Any questions on that? That's like a basic blueprint. This is valid, except for this comma is missing here.

Schema Types
So above is a small example of a schema with Mongoose, but those are the basics. Here's a tour of a whole bunch of other types we can use in the schema. So this time we're going to make a dog schema. Alright? Same thing, new mongoose. Schema. Here we have a name for the dog. It's type is string. It's also required and we also want to enforce that it be unique. So there can be now two dogs with the same name. So if you try to save a dog with a name whose type was string, but then there already existed one with that same name, with the same string, it'll throw a validation error or unique error. Unique also accounts for null values, too, but because we put required true, we probably won't run into the error. You will have that error, like if you didn't put required true here, but you put unique true and the first dog you saved didn't have a name because it's not required, the next dog you saved didn't have a name, it'll throw a validation error because you already have one dog who doesn't have a name. So you can't have another dog who doesn't have a name. They're the same thing. The absence of no name is the same thing. So they're not unique. You can get around that though by saying like sparse true and stuff like that, but by default it will say that. Another type is date. So when the dog was adopted, it's going to be a date. A good practice, too, is like you could put defaults to. So you can add a property here just like we put these properties on this object we can say defaults to, you know, date. now or date. whenever and put a date in there. Another type that we saw was Boolean so does he have his shots, true or false? Another type is a buffer. If you've ever used Node extensively with file systems, there exist things as buffers, like when you read a file, right? If I come in here and I say node and I say var fs = require fs and I say fs. readFileSync and I want to read the /package. json, right? I get this buffer, that's the type of buffer and if you just want to turn it out to the string you just say toString and we get the actual file. So buffer is also a type. CollarCode, I couldn't think of why a dog would have a buffer so maybe it has a high-tech collar on, I don't know, but buffer collarCode, I don't know. Age type is number, right? Of course, we need numbers. You can also do validations here. It's min, it's 0, its max is 30. If you try to save a dog with a number not in that range it'll freak out. This is where it gets kind of interesting and you can see the flexibility of Mongo showing through Mongoose because again, Mongo doesn't care. Mongoose is trying to allow us to do what we want, but like still have some structure, but you can start to see that shine through here is when we have an array. So when you have this array you can do all types of things. So when I say toys, it's type of array, I could just put an empty array there and move on. Can you just bump the font up? Oh, bump the font up? Yes. Is that good? Okay. So if I say toys is type of array, I could just move on just by putting an array literal right there, but I can also blueprint how the data in that array is going to look like as well and it can be exactly like I've been doing up here. I have the same rules apply. So I can say, you know what? I want toys to be an array of objects and all those objects must have a name property on it and the name must be unique and they also must be, you know, this and that. You can do that inside the object. You can also put in another schema in here. So you can have nested documents. So you'd be like, oh yes, I have a toys schema somewhere else and that's what going to go inside of here if you do that. You can also just tell Mongoose, oh, this is going to be a type of mixed. So you can tell Mongoose we'll get to types in a minute like elicit types, but you can say, Mongoose, I just want this to be a mixed bag of types. I don't know what it's going to be. It might be a Boolean, it might be an object, it might be a string, I don't know. It's just going to be a mixed bag, or you can leave it blank. So it's up to you. It all depends on how you want to query your data because like I said, Mongo doesn't care. So because it doesn't care and Mongoose is giving you the flexibility to whatever you want, it really all comes down to like how are you going to query your data? Like what do you need when you ask the dog and that's how you know what you want to put in there. There are, you know, database type things like common things that you don't want to do, but for the most part, it's whatever you want to put in there. Nested objects looks like this. So if you want a nested object, you'd say the property and use the object literal just like we did up here like with name, but this is not a nested object. This is just me defining the name. So up here I'm saying I have a property called name. Its type is of string. It is also required, it is also unique, but I'm using these object literal brackets, right? But down here I'm also using the brackets, but you notice there's no type here. I'm not saying type anywhere. I'm saying, oh state must be a string, city must be a string, zip must be a number. What I'm saying here is that location is an object and it has a property on it called state who's type of string and a city property whose type is string. So it's a little different, although it looks the same and that's because I'm not putting up type right here. It's implied that the location is of type object because I'm adding new properties on it that aren't keywords in Mongoose. Like I didn't put the keyword required here. I didn't put the keyword unique here.

ObjectId
And here's the interesting part as far as like relationships go. If you're a SQL person or a relational database person, you'd probably be like oh yes, it's not really relations, but this is how it works in Mongoose. What we can do is if we want to set up relationships between two models, we can just associate the id just like you would in any other database. It's just how it works. So in Mongoose the way it works is we give it the type of ObjectId. ObjectId is ids, they are ids in Mongoose. They're called ObjectId. So if we say, oh yes, we want the dog to have one owner, so it's type is mongoose, schema. ObjectId and that means it's going to or it looks like a string of an id when you get it back from the database, but it's not. It's actually an object that converts it to the string and I want to reference the owner schema. So there exists in this database somewhere another model called owner. So when there's a string here, I'm telling Mongoose that that id is referencing some owner somewhere and then it's required. So you can't save a dog without an owner. The reason that exists and we'll get to it later is something called population and population is like you can say it's almost like creating a join at call time. So there doesn't exist a join table on the database like you would have something with SQL, but when we want to see who the owner is, we can ask Mongoose about it and it'll join it for us when we ask for it, but it will not persist in the database; it's not atomic. So we'll get to that later, but that's how you set up relationships. A lot of people I've talked to who, you know, kind of bash on Mongo and Mongoose and are like, well, you can't do relations and there's no such thing and I'm like, yes, you can. You could totally do relations; one-to-one, many-to-many, whatever you want. One-to-many. So any questions about that? Yes? They wanted you to clarify the difference between collection model and schema. Oh, yes, I guess that's a good question and I'm using them kind of loosely. So let's go back to dbTester. So a schema is the actual blueprint. It's like this is how I want my data to look. It's a blueprint for the data. The model is the JavaScript representation that we're going to be using inside of our API to access the document, which is in the database. The document is the instance that belongs to the collection. So you can think of like the model and the document as the same thing, except for the model is like what we're using in JavaScript and the document is what exists in the database that's part of an entire collection. So a collection is just like a group of these documents and a model is our JavaScript representation and the schema is the blueprint that defines the model and the document. Any other questions? Yes? Can you explain the ObjectId type? Yes, so ObjectId type. It'll make more sense when you actually see it, but when you see it you'll be like, oh, it's just a string, but it's actually, or no I could just show you. We made some stuff already. So the ObjectId type is, and I'll just open up robomongo because it's there and it's easier. So we'll look in puppies, collections, let's go look in todos. So right here. So in Mongo, everything that gets saved in the database, every document gets an _id property and that value is an ObjectId, as you can see right here. It says ObjectId. That's what an ObjectId is. That's what Mongo or Mongoose or Mongo describes as an ObjectId, but when you retrieved it from the database and you use it in JavaScript, it's just going to be this string right here. It's going to be this thing that's in actual quotes, but it's actually an object, but they convert it to a string so we can consume it in JavaScript a lot easier. It's just called ObjectId. Just think of it as a string though. Whenever you use it inside of the ORM this is going to be a string and you can do equality checks on it just like a string, but it's just good to know that it is an object in the database. It's an ObjectId. Scott? Yes? I know this is just a training example, but how would the dog schema know what owner is? Right, so it doesn't. So what would happen is when you create the dog you would have to, so that's a good question. So if we go back here, when we were to say, I want to make a new dog, right? I'm going to pass in all these properties on an object and then when you get to the owner property, you need to pass in the owner's id right there. That's how it would know. So if you were to look this up in the database, just like if you were to look this dog up in the robomongo and when you got down to the owner property, its value would be one of these. It'd be an ObjectId. So yes, you have to tell it. You have to save that dog with the owner's id and hopefully the owner is the person that made a post request to the server so hopefully you have the id. If not, then you just won't be able to save it because it's required. Cool! Any other questions? Is it faster to do finds on an ObjectId versus on a property in the schema? Yes, good question. So ObjectId is indexed by default. They are indexed. So if you want to do a find on some other property, it won't be as fast as the ObjectIds because they're indexed, right? So they can get to them a lot faster than having to do like some search across a collection or the entire database on like let me find all the puppies with this name. Yes, it'll come back relatively fast, but not as fast as if you were like find the puppy with this id. It's like constant time. It's going to go straight to that id and be oh, there you are. Alright, it's indexed whereas everything else is not, by default, but you can index whatever you want using Mongoose. So you can be like, you know what, I want to index the names, too, because you know what? They're unique, let's index these, we could do that, too. You could totally do that, but by default ids are indexed. Yes? Is there a max length on ObjectId? You don't create the ObjectId. The ObjectId is created for you when you save it. So you never have to worry about generating an id, which would be not fun at all. I mean, that would be really, that's a whole other thing in managing ids. So yes, you don't have to worry about that, it's created for you. You put an object in a database and when it comes out there's an id, just like the stuff that we've been doing this whole time, right? If we go look at the Mongo shell and we go to our database and we say db. todos. find here's an ObjectId on this todos thing. We didn't add that anywhere. We didn't add that ObjectId. Right? If we go look in the file, not once did I have a property on there that said ObjectId. I didn't put that there. When I saved it, it did it. It also added this version and all this other stuff here. So _id is the property. So also remember that, it's _id. So it'd be like todos. _id and not todos. id. If you're not used to it so yes, it's going to be _id. That's the id property. Any other questions? How would you go about creating an index? We'll get into that. That's a little more advanced and we'll get into that. I don't want to get into something that we don't need right now, but yes, it's not that hard. There are a couple ways you can do it and that's why I don't want to get into it, there's like three ways. And then I think there was a question on, so if you were creating like users in your database, would you actually make a field called id or would you just use the built-in _id field? I would use the built-in _id field as an id for every single model in my database, but it doesn't mean you won't have something else unique about let's say, a user. So let's say a user logs into your app with Facebook. Alright, and Facebook generates a unique token or a unique id and maybe you want to use that. You could also use that if you want to, but that doesn't mean you shouldn't use that ObjectId. I would use the ObjectId, but if you wanted to create your own, I guess you could, you could totally do that, but then again you'll be managing your own ids and indexing them and stuff like that, but there are times where you might want to use your own, but I would always just use ObjectIds. Yes? And then so there's a question, since we're running Mongoose in the application, this does nothing to stop us from interacting with the database elsewhere and screwing up the schema. Is that correct? That's exactly correct. So like if we had a schema in our JavaScript like oh, todos must look like this, if we made a todo with Mongoose, we couldn't save a todo without following this blueprint. Like we couldn't just be like, oh, I'm going to make a new todo and you know, put something else here, alright? That thing won't get saved because it's not part of this schema. But if you have the stuff, it will? Yes, but if I go into the shell or in robomongo it doesn't care about the schema. It'll just yes, it'll just write to it. Remember, that's why I say Mongo doesn't care about what you give it. It's Mongoose that's doing that validation and blueprinting with the schemas. So yes, you've got to remember that and I've actually run into times where that has come to burn me if you have a service-oriented architecture where you have these three services that are talking to the same database, but like this server is using the same model as this service, right? So how do you keep those things in sync? Do you write the same schema twice on both? It's kind of hard. So yes, I've run into that problem before and it sucks. Any other questions? Does Mongo throw an error if the data does not match the schema? It depends. If it's a validation, like if it doesn't match a required or a unique or something like that it will throw an error, but if you just add something that you did in blueprint, it won't throw an error. It just won't save that thing.

Blog Schema Representation
So now that we know a little bit about creating schemas and I say a little bit and I mean it's just a little bit, there's way more to this, but again, that's like a whole separate thing. I could talk about Mongo and Mongoose for a week. We know just enough to get started with our API. So now that we do know that much we'll use JSON again to blueprint how our resources are going to look, just like we did before. So remember, we've got three resources, users, posts, and categories. So I wrote some JSON down here to let you see what that looks like. So users, for now all they have are usernames, that's it, and they have to be unique. So here's an example of what a user resource would look like. It's an object with a username and a string. Posts? They have a few things, four things actually. So they have a title and if you just look at the value you can kind of figure out what its type is, right? This is obviously a string. It has text. So this is the actual text of the blog post. If you look at the value, it's obviously a string. Author property. So the person who wrote this. If you look at this, then it's obviously an ObjectId. That's its type is ObjectId. We have an array that's called categories and it's spelled wrong, but categories and it's an array, it's a type of array that has types of ObjectIds inside of it. So it's just an array of ObjectIds. So we went over that. So ObjectIds are this type, right? And we already told you in arrays you can put whatever you want in there. So looking at these blueprints, just looking at the data that will be spit out you kind of know what these types are and then for categories all it has is a name and it's a string, obviously, and it has to be unique. So a category is a name and it has to be unique. You can have more than one category of the same name. It doesn't make sense to do that. Usernames must be unique. Titles and posts, I guess they should be unique. You shouldn't have two blog posts with the same title. I don't know why you would do that. The blog post content, I don't think that needs to be unique; I guess you could. If you want to stop somebody from writing the same blog post twice with a different title, I guess you could do that, it's up to you, but then the two important ones are these are ObjectIds. And if you wanted to, you could go ahead and add metadata on there if you want to, you know, like last seen, updated at and created at, although I'm pretty sure Mongoose should put that stuff on there or at least I thought it did. I thought it put the updated or created app properties and stuff on there. I think it does. I don't think it's showing up in Mongo though. So looking at the actual values of the JSON above, we can infer what type of properties or what type the properties are when we're creating our schemas. So again, when we start creating these schemas and if you get lost and you're like what's this type again, just come look at the value and just read it. That's a string, that's a string, these are ObjectIds and these are strings. So any questions on that? Yes? We have a bunch kind of rolling in here. Okay. One question was about what about using things like node-uuid to namespace things? So I think his idea is instead of using the built-in ObjectId that they're using can you tell it how to format that ObjectId? I don't know the way of how you can tell it to format the ObjectId, but there's nothing stopping you from using node-uuid to attach another id to your schema and index that, so there's nothing wrong with that. It's weird because I had this conversation with like five people like a week ago, the same thing, and I want to know what their concerns are as far as like having another unique identifier other than ObjectId because I can't think of something that would concern me, but they obviously know something that I don't know so I want to know what they're thinking. So I would love to talk to that person who made that question. Any other questions? I think, I'm not sure I understand this one maybe, but can you specify a type ObjectId for a particular collection, like an author needs an ObjectId that belongs to a user document? So an author needs, well can you specify a type ObjectId to a what? Particular collection. To a particular collection. I'm not too sure if I follow and maybe I'm just over-thinking it, but a type ObjectId to a particular collection? They might be asking can you specify the types of a collection? Oh, no. So like a collection of authors. No, no, no. A collection itself is not a type. So the only types, so if you have all the built-in or most of the built-in JavaScript types, so string, number, Boolean, buffer, they're all built into JavaScript and then you have the types that are built into Mongoose which belong on the mongoose. schema. types object. There's ObjectId, there's one that's called mixed, which means a smorgasbord of any type, but I'm pretty sure you cannot say I want the owner to be the type of owner or something like that. The way you do that is you pass in an ObjectId with a reference to the collection that it belongs to, but you can't just say owner right here, if that was the question, I think. Can you add custom functions to your models? Yes, we're going to get there when we get to query so you could totally do that. Is there a possibility of ObjectId collisions if you have MongoDB running on multiple machines? If you have MongoDB running on multiple machines? If you had the same database running on multiple machines then I think you're fine. I mean, yes? If you want to change your scheme, is that it, schema, do you have to kind of re-spin all your current data into the new schema? Yes, oh I thought you were referring to the quote. I'll answer your question and I thought you were referring to the question I was talking about. So yes, as far as the ObjectId collision, no, if you have Mongo running on the same database running on multiple machines, like I guess maybe you, I don't know, you sharded your database maybe? Yes, that's what they're asking. Is that what they're asking for? Yes. No, you should be fine. So I don't think you'd have a problem with that, I've sharded. Because then they're thinking like if you're using that as your userId identifier if you have? Catastrophic, yes? No, no, you should be fine, yes. You should be fine, and then what you were saying is if you change the schema so you're talking about like a migration? Yes. Like, do I have to take everything out and put it back? You're like oh, my business logic changed. No, no, no, it's fine. It's just if you change your schema and you already have data that was using the old schema, right? It's not going to go revalidate all that stuff. It's not going to go and like oh, now this old data is not following the same validation, right? That may be good or bad, I'm not sure. Oh, it just sits there. It'll just sit there, so you've got to go. It's only data coming in that it validates. Right, right. So there's no migration. So you manually set up a migration if you wanted to. I mean, a good thing is to like have replication and you do stuff with the replicated set. Another question was they want to know if you've tried Orion DB and they'd like to hear your opinion on it. I haven't tried Orion DB, it's literally like number 3 on my list of things to do so I don't have any opinion on it other than like every time I list then it must be really good because I only put good things on my list so I want to check it out. I don't have any opinions. If anybody else has used it before, I would like to know because I heard it was awesome. Is that it? Are we all caught up? I think so. They're just mentioning MongoDB doesn't scale well horizontally so I guess you wouldn't be doing that is what they're saying? I mean, I guess you could say that, but it all comes down to like, yes, relatively speaking it doesn't, yes, I agree. But that doesn't mean it doesn't do it that well. It's just if you compare it to other things. It's not meant for everything, I'll just say that. I'm not defending Mongo and I'm also not pushing it down anybody's throat, but it's definitely not meant for everything.

Exercise 8
There's a lot of fun stuff going on in step-8. So we got rid of the dbTester file because that was just like a one-off file that we were using to test the database and now if you go to step-8 and you look in the API folder on each resource, there's a respective model file and we have to go ahead and design these schemas. Everything else is set up for you as far as like the exports. All you have to do is just fill out the actual schemas, the blueprint for these models. Alright? So any questions there? That's all we have to do and so as far as like what they look like, again the blueprint is in the JSON right here. So you can infer what types they are. As far as how to use the types, here's an example of here how to use the different types and that's what we've got to do for those models.

Exercise 8 Solution
User model, like I said all it has is a username. It's type is string, it's unique, it's also required. Done, right? So, if we wanted username to be or actually let's just keep username and let's say we wanted to also have like a first name or let's say we wanted to have like an address for the user, right? And we wanted it to be an object because somebody brought this up and it was like how does it know if it's an object or how do we know if this is a nested object or how do we know if we're just defining the type? Right? So if I had an address, what I want you to do now is going to be different from what's up here. This is just saying I only have a property and its value is a string and it's validated by this, but by coming down here and saying hey, I have an address and it also has a state property, just by doing that or I'll just say string, I'm now telling Mongoose that oh, address is actually an object and it has a state property whose type is string, just by doing that, but if I did this, type String, it now is like oh address is not an object and it's actually a string. You see the difference? It's the keyword type, that's what I'm trying to say. The keyword type is saying, look, okay, actually the address is a string whereas this is like, no, no, no, address is an object and it has a state who is a string and then for the state we can do, oh yes, it's a string or I'm sorry, and it's required and you could do all that stuff too, but then you're now defining like another schema almost and you could just have a state schema somewhere else and bring it in here, which would probably be here, nested documents. So you could do that. Also, the other thing is what if you wanted to use the type property for the property name? So what if the users' schema had a type name? Like it had a property called type? So it's like oh yes, it's type and I'll put string. That's not going to work because that's the keyword type. So a way to get around that is you have to use an object literal and then you have to put type again just like we did up top and then you'd say string. So that means I have a property called type whose type is string, if you wanted that, or just not use the word type for strings. You have a question, Mark? There was a question that came up. They were using nodemon and they kept restarting the server so is that actually or do they keep open like 10 concurrent connections? No, no. When it stops, when the server stops the database will stop, yes. And then the other one, should Mongo fields never reference Mongoose keywords? That's a good way to live. I've always lived that way and it worked out for me, so yes. I would not have my fields reference keywords just to avoid that. Just come up with another name, but if you absolutely have to use the keyword then I think the go-to is to do something like this. You give it the name and make sure you create the object literal syntax, and then you specifically say its type and then I think that will like escape any type of keyword reservation in Mongoose, but to completely avoid it just don't use it. Any questions on this one? This was pretty straightforward. So it's a user schema or I mean user collection, which will be users collection, get the schema and we export it. PostModel. This one was a little bit crazier. So string, I mean the title is a string, it's required and it's also unique. The text or the content of the blog, I decided not to make it unique. If you made it unique, that's fine. Type, string, require true. And then for author, that should not be an array. I don't know why that's an array. It should just be an object and its type is well let me put this on another line. There we go. Cool! Its type is going to be schema. types. ObjectId. The reason I put schema here because I already set var schema equals mongoose. schema, if you didn't do that then it'll be mongoose. schema. types. ObjectId. I just aliased it up here as that. So types. ObjectId is its type. Its reference is going to be the user collection that we made here. I guess this should also be required, too. And then categories is going to be an array of ObjectIds whose reference is the category model or the category collection I should say. We don't have to put unique here just like we didn't have to put unique here just because the ObjectIds are already unique, right? We don't have to specify that the things must be unique because they're already guaranteed to be unique because that's what Mongo does. It creates unique ObjectIds. If it didn't do that very well, I don't think we'd be using it today. It wouldn't exist and nobody would use it and that's like one thing a database should do very well is make unique ids. Cool! Any questions on what's going on in here? No? Okay. And then category model, pretty simple. It's got a name, string, required, true, unique and then register category. The one thing that I did want to talk about though in the postModel was like the different types of relationships that are going on. Alright, so I mentioned a little bit. So you know alternatively we could have done the inverse or we could've done both actually. So right now the PostSchema knows about the author who wrote it or the user who wrote it, but the user knows nothing about the post that it created. Right? So how would I know what post the user has written? If I wanted to go look at this user's profile and like alright, here's all the blog posts that this user has written, how would I know that? Does anybody know? Has anybody ever used databases? Well, the problem has to reference back to the user. Exactly. PostModel has a reference back to the user so I would just go to post and like, give me all the posts who has an author whose ObjectId is this, right? And it'll give me back all the posts. So the user doesn't need to know what post it made, but if I decided to do that, if I just came in here and I was like, you know what? You're also going to have an array of post ids, right? And you're going to be objects, you know, ref posts and you know, ObjectId. Right, so if I did that, does anybody know what that's called, what I just did? Inverse association? Inverse association? Yes, I wasn't even thinking of that, but yes, that's true. There's another term though that I'm looking for. Specifically like relational databases. Form key? Yes, I didn't think of that either. Bridge directives? It's denormalization, right? I just denormalized the data, right? It was normalized before because there was only one way for me to access a certain type of data and now there are two ways for me to access the same data. So now I can ask the users about where are your posts and now I can ask the posts about where the users are. So it's two ways to get the same data, right? So that's a common thing. People will like set up their databases and then when things get crazy they'll come in and they'll just denormalize it, right? So you could do that, but I recommend not doing this because let's just think about this. So if we just had one user in here who made 10 posts. Let's just think about that. A user made 10 posts and I came and query the user schema for that one user and I also want to populate all the posts. Populate means put all the posts. Get the references for these posts and actually place them in this array. It'll actually get the post objects and place them in here and if I did that and that's the only stuff I had in my database, just by asking that one user for all its posts, right, I have now just like pulled the entire database. That's an entire database, that one user and all its 30 posts is an entire database. The same thing could be said if I did the inverse. So if I got rid of this and I was on the postModel and I all I had on here or I mean, sorry, the same thing couldn't be said for this is because it's the one-to-many relationship. So if it goes on a one-to-many relationship whereas post is the many side and user is the one side, it's better to put the reference on this side so that way now let's say I have 30 posts in my database and only one user. If I go to the post, I'm like alright, I want to get this post and I also want to populate the user and I pull that down, I'm not pulling the entire database because there are still 29 other posts that don't belong to this user, whereas the other side, if I did do that it would be the entire database. Do you guys get what I'm saying there? Okay. It's a small thing, so just databasing in general and I just wanted to talk about that. Great! So any questions on the schemas that we made and the relationships between them? So again, we have a one-to-many relationship with the authors. So a user can have many posts, but a post can only belong to one user. Wouldn't you want a reference to category in the post? Would we want a reference to category? Would we not or would we? Oh, you have one there. I missed it. Yes, we have them there, yes. Inline. Right, yes. So we definitely want to put the reference to the categories in the posts and not the other way around. We don't want to put them here, right, because then it'll just be like you know, that would just be tough. Scott? In your JSON example for posts, you have an array of three object ids? How would you specify that in the schema that you could only have three? Oh, good question. So the syntax is very confusing there, right? And it's not only three, I just put three in there. It's an arbitrary number. I just wanted to show you. (inaudible) I just wanted to show you. That's a good point. That's very true. I just wanted to show you that it could be multiple, but it definitely isn't three. So when you have this array here and then you just place in this object that's describing the type, that means it's not saying you can only have one here. It's just saying that whatever goes in here must look like this. This is the blueprint for anything that comes in this array. That's what that means. So you can have as many as you want. Yes, good question. Any other questions? Yo? Can you do regular expressions in like it has to match this regular expression or the string does? Yes, you can do regular expressions. I'm not exactly sure how you do them on the schema, but you can do them in what's called like a lifecycle hook. This is just JavaScript, though. Can you write an expression? Yes, but I don't know like the keyword. I don't know if it's like regex, right, and then you say like some regex here, you know what I mean? Like I don't know the actual keyword here that would allow you to write that regex. I'm sure it does exist, I just haven't used it. If I were to do it, I would do the regex like at a custom validator. So Mongoose actually has middleware just like Express does and we could set up middleware to do things before things get saved or after things get saved or before they're created or after they get created, we could do things. So like before something gets saved I might run it through a regex and be like make sure it does this and if not, don't save it. So if you had like an IIFE on true there, that would work, right? If you had an IIFE on true? And you just returned true because, you know we can just write JavaScript, but can you reference the parent? Can you reference whatever the value of title is? Did you follow all that? No, I'm confused. So these are keywords in Mongoose, right? It's like these are custom validators that Mongoose has built into the schema and by using that keyword and putting true or false, it's enabling it or it is disabling it. Yes, I get that. I'll show it to you in a bit and you can give me what your thoughts are. I think exactly what you want is exactly what I was saying. It's the middleware because right at this time right now there is no value. It's just a type and we won't know the value until somebody tries to save it and at that time we want to check to make sure that it files this regex before it's saved. Yes. That's middleware. Gotcha. Okay. Yes, that is. We'll get into that when we actually start like doing authentication probably.

Querying
Querying Data with Mongoose
So Mongo has a sophisticated query syntax. I'm going to go through this one---actually, this one's kind of long. But I need to go through it. I'm going to through it relatively quicker than I normally do so we can get started with the exercise. That way, you guys can get out of here at a relatively earlier time and not be here all day. So I'm going to go through the notes relatively quicker so we can hop right into the example, which is actually going to be kind of tough. So Mongo has a sophisticated query syntax that is full of options. Actually, it has too many options for me to even list here. When I was writing this, I was worried about what to show you, what not to show you because there are so many things, and there're like five different ways to do the same thing. So I was like, I don't even know what's the best way. So there're just too many things to list, so I just listed the one that I thought was the simplest and the one that I use the most and the foundation of the rest. So using the Mongoose model, we have a few ways to ask Mongo about what data we want. So we did this before kind of inside of the Mongo shell where we did db. the name of the collection. find. That was the native Mongo implementation. This is the Mongoose implementation that just calls that internally. So when I say model, I'm talking about the name of the model, so this is the model. This thing that's getting exported, that's the model. So in this case, it'd be Post-whatever you called it when you required it. So this is the model. So Model. find is a method that we can call. And what it does is it could take a few things, but the most important thing is that the first object that you pass in is just like an object describing the stuff that you want to find. So in the cast of post, if we said, Post. find---actually, I'll just do it down here so you can see what it looks like. So down here if I were like Post. find, the object that I can pass in as the first argument is how---is going to describe the post I'm looking for. So I want to find a post whose name is---or title, sorry, whose title is whatever. So because our titles are unique, this is only going to return one. So then I can use a callback, which is a note-style callback which takes the error, a possible error as the first argument, and then a possible document as the second argument. So the document is the thing that's returned from the database. So then I would have that stuff. Alternatively, most of these Mongo queries return promises. So I could say. then instead. There's also another way to execute this, but we're going to talk about that later because that one's a little more difficult. But that's the basics of the find method. So the find method is always going to return an array even if it finds one, even if it doesn't find anything, it'll be an array. But if it doesn't find anything, it'll be empty. Nothing will be in an array. But. find always returns an array or an error. So above is a basic example of how can query Mongo for a specific model using the find method, we can pass in a query object to specify what we're looking for. The object is empty, so I have an empty object here, so that means we want to get every single thing on that model. That means give me everything on that model. Everything. I think you can even just not use the object. You can just not put anything in there. The second argument is a Node-style callback. In this example, it's a Node-style callback with either an error or the documents that're going to be retrieved. Most queries on Mongoose return a promise. And you can look at the docs, and they'll show you some stuff. So here's another utility method--ModelfindById. If you just give it an object ID, it'll find that one thing or not. So it'll either return an error, it'll return that document, or it'll just return nothing. No error, but it also didn't find anything. So this one's very helpful for those PUT, DELETE, and GET one routes because they all use the ID property. So if you want to PUT something, you need an ID, so you've got to find that thing first. If you want to DELETE something, you need an ID. So this method will come in handy for that, findById because we'll be given the ID on the URL. Yup? They're wondering why you're calling next if error is true. So, the reason I'm doing this, so this is going to be wrapped, this is a hint of, this is actually, this query's wrapped inside of a route callback so we have access to request, response, and next. So because this function is asynchronous, if we want Node to know about this error and we want to be able to catch it, we actually need to pass it in in next, whereas these errors we've been handling before were all synchronous, so they all were passed down through the chain, this is going to be a completely different call stack. So if you're familiar with Angular and the event it---you know, how it works, this function is happening in a completely different call stack than this execution of findById, so we have to call next in order to pass it down to our error handling or it just will never get handled. It's a completely different call stack. It'll just stop and break the server. So this is why the next is awesome. Where's next coming from? Would it be a name parameter or argument? Yeah, so it's, so all this is wrapped inside of one of these. I should've just written it, I just didn't feel like writing it. It's in one of these callbacks right here. So when you see these examples here, they're inside of one of these functions. That's why I'm able to call response and next. Sorry about that. Next is not coming from Mongoose. It's coming from Express. That's the Express's next in the middleware right here. So we'll be replacing all of this stuff with this stuff. So that's how you find an ID. That's how you find all of something. So those are two methods you will definitely be using. Here're a few ways to create a new document. There are probably more, but here are a few ways. So we can say var whatever equals a new model that we have, and then we pass in the object to create the new model. And then all we have to do is call. save on that instance, which also takes a Node-style callback with either an error or the document that got saved, and if we save it, then just send it back. Another way to do it is you use the. create shortcut on the actual model, which takes in the thing that you want to create or many of those things, and then a Node-style callback as well, same thing. And then the third way to do it is we can just say new model without passing in an object, and then add the properties using the dot notation, and then still call save. All three would do the same thing. The only difference is create is calling new Dog internally, and then it's calling save for you. It's just doing both, whereas we're doing it manually here. We're calling new Dog, we're adding the properties, then we're calling save. Those are three ways to create a method. You lost me. I lost you. Where did we get a function called save from? So new Dog, when you make a new model. Let's just do it in here. Is that the schema? Yeah, that's a model. It's imported from the schema? Exactly. Okay. So this is like one of our categories or our posts or our user. So you call a new user, a new post, it's going to return an instance. In this case, it's a dog. And now we can say dog. save. So it's like if I were to come back and say user. I deleted it, didn't I? Yes, so I can just say user. save. The instance of a model is called a document. And all documents have a save method on them, which is an atomic operation. So if you call a. save on a document, it will write to the database. It doesn't matter where that document is inside of Node, it'll write to it as atomic. So those are three ways to do the same thing. You can pick your flavor. So here's a way how to update something. So we can say, Model. findByIdAndUpdate. That's a real method. You'll notice that Mongoose's methods are actually pretty verbose, they say exactly what they mean--I'm going to find by ID and update. So if you give it an ID and you give it the object with the new property that you want to update to, what it will do is, first, it'll go see if it can find a document on this model with this ID. If it does find it, it will update these properties. And then an error callback. The thing to note about this, though, is this thing called UPSERT. So by default, if you do this, it will update the documents of these properties. But it'll also actually just update the documents to just be this. It will just literally be this, and all the other properties that were there before will be gone. So that's not what we want. So we want to use something else to get around that. So I'm not going to show you how to do that. I want you guys to figure that out. Unless you ask me when I walk around, then I have to show you. But I don't want to give you all the answers. It's just there's another method that allows you to do that. Or there're like two or three other ways to do it. If you literally looked it up, in like one second you'd find out. And then, of course error-style callback, same thing. So like I said, most of the methods look very similar. You start off with something simple like find. You pass in some type of query object, maybe an optional UPDATE object. And then there's a callback. So there are some advanced uses and features as well, along with performing methods on the model. We could also use the actual document to do things like I was saying before, so we were talking about the. save method on the document. The document also has like a. remove method so it can remove itself. So if you had an instance of a document and you wanted to delete it, you could just say document. remove, and it'll be like, Okay, I'll go away. And it'll either throw an error or it'll remove the document. So this is a quick way to delete something. There's also like a findByIdAndRemove or Delete to do those things as well. So, again, this is possible because actual documents returned from Mongo are not just objects but instances of a collection and have specific properties and methods that allow us to operate on it and for it to be able to write back to the database. So this is very important. The reason I emphasize this is because you're going to use this. You're going to have a document that's created somewhere else, and you're going to pass it to another function, and then you're going to figure out, How do I remove this thing? How do I delete this? How do I update this? And you're going to want to query the database again. You're going to want to say, I'll just do a Model. find and find the document again and do it here. But you already have the document there, so just be sure that---just know that you can do these methods on the document. You don't have to query the database again.

Populations
Mongo is no SQL database, so we don't have join tables. I was talking about this earlier. But we need a way of seeing relational data. So the solution for this is called population. You can think of it as a join table at call time. So what does that look like? So imagine this. We have a DogSchema. It has an owner, and its type is ObjectId. It refers to a person. Then we have a PersonSchema. It just has a name. So I make those two models. I make a Dog model, and I make a Person model. All this stuff we've done before. We've done all this so far. It's not new. And then what I want to do is I'll say Dog. find, which is giving me all the dogs, and I call this method called populate. And then I pass in the property on the dogs that I want to populate. In this case, I want to populate the owner fields. And then I call this method call exec. Exec is short for execute. It will either return a promise, which I'm using in this case, or it also takes a callback, a Node-style callback. So it's up to you. You can pass in a Node-style callback here, which is function, error, result, or you can just use the promise. I'm using the promise. So it's up to you. And then when I call. then, if I look at the dogs, which is an array, each dog on there, its owner property will not be an ID. It will be the object that the ID was representing from the person collection. So what happens is when I call populate on this owner, it's going to be like, Okay, let me go to the owner field, let me grab the ObjectId, let me go to the person's collection. Let me find the person with the ObjectId, grab that object, and stick it right here on owner. So now if you were to do dog. owner, it would be an object, and that object would be the person that owns the dog. So it joined them for you. It populated the ID field with the actual thing that it's referencing. That's why we have to put this ref here so it knows what collection to go match the IDs with. How many times does it query Mongo for a statement like that? How many times does it query Mongo --- Does it query once to get the dog collection, and then is it querying per dog filtered by the owner? --- I don't know exactly how they're doing it, so I can't really comment on that. But I think a naïve solution would be I'm going to do it once for every time, but I think they have a way around that. I'm sure they do some optimizations with the refs and the ObjectIds because they're indexed, and now they know where they are. I don't think it'll be that type of operation. That would be incredibly slow. So that's how you populate it. If you wanted to populate many fields, so if we had like another field up here that needed populating, we can just put a space after this word 'owner' and put the field that we want to populate there as well, and it will also populate that. Or you could also just do. populate again and call that. We also have fine grain control of what fields on the thing we're trying to populate, what do we want. So in this case, this is going to bring over the entire owner object. Well let's say, I guess the owner only has a name. If the owner had like three properties on it but all we wanted was the name, we could put a comma after owner and it's just like, just give me the name of the owner. So it would just send back an object with the owner's name and that's it, nothing else. So it's a little fine-grain control. So, again, there is so much to do and so many ways to do it with Mongoose and Mongo. Like I said, it's like another course on its own, so I don't want to get too deep into it, so I just shows you the basic CRUD things that you will be doing. So this will be enough to get you started with the basic needs of our API. And, again, remember because our API is RESTful and all the resources are the same, they all have the same CRUD routes, if you write these queries once with one model, it's the exact same thing for the other two models, just it's a different model. It's the same operations. Nothing's different about it except that when you get into things like populate. For instance, on the postModel, this is a little different because you have to make sure you populate these things when you call them, whereas like the other two don't have populations. They don't have any references. UserModel has no references. CategoryModel has no references. So they're pretty straightforward. This one, you just need to make sure you populate them. But they're still all pretty much the same, findById, find, get that, get that.

Exercise 9
So if you go look, there's a controller file, and it needs an API now. And they're like, a lot of them are already built out. I totally forgot that half of them are already built out. So you've got to go fill in the blank ones inside of the controller files. The stuff you're going to be working on, if you look in the API folder on each resource, there's a respective controller file, a lot of the stuff is already built out in there. You only have to fill out maybe two or three for each file. And if you want to get hints on how that works, if you go to the other resources file, it might be filled out in there, so just kind of see what's going on in that file and apply it to the other resource, and you'll get a fill. And once you complete this, the actual routes, you need to---we're going to save that for later. So, yeah. You're not going to be able to test this either because the routes aren't set up. So if you want to take a step ahead and test it, then you have to connect the routes, which is fine. You can totally do that, but you still won't be able to test this without setting up the routes. So just finish this. We'll come back tomorrow with the solution. And then that'll be that. Actually, I guess you could test this. You just couldn't test it with the API. If you want to test this, then you just have to manually run the code. Just like grab this query here and run it. Just make sure you're not calling like next inside of here because that's Express stuff and it would just break. So just like, Here's a query. I'm going to run it. Just like execute it and run the file, and it will totally work. Another good way you can do it is if like if you just make like another file on the root here, I'm just going to make another file. I'm going to call it dbtest. js. And then you can just require the models that you want and just start building queries in here and just execute this file once you're connected to Mongo. So you can do that too if you wanted to.

Exercise 9 Solution
So step-9, you had to implement like there was some missing CRUD routes in some of these controllers, like there may be three or four total. So any questions on that? Or maybe five, maybe three or four. Any questions on that? You guys did it, and then we left off, so I didn't really get a chance to talk to you why you were working on it, so if you had any questions on it, it's totally the time. Everybody got that? Super-perfect! So let's see what that looks like then. Let's just check out step-9. I guess if you had any questions, you could just check out to the solution branch, and then you would just find out, right? Is that probably why people don't have a lot of questions because they just looked at the solutions. I was going to ask you this, but then I looked at the solution, and now I kind of know. That makes sense. So I think this one was missing in the categoryController, the params. So, remember, this controller method here, even though we haven't defined the routing for it, that's the next step, based on what we do with the lions and the tigers, we know that there was this method on the router that we can use called params that will look at the ID or whatever parameter, and what we did with the lions and tigers, we would look through the array of lions and tigers to find the one with the right ID. And if we did, we would attach it to requests. It's the same thing we're doing here except we don't have an array, we have a database. It's the same concept. So exports. params is going to take the ID, and it's going to see if it can find it in the database first of this category. If it doesn't find it, I'm just throwing an error here. You can choose to do whatever you want. I'm just saying, If there's no category, get out of here. But there is. I'm just going to attach that category to req. category and call next. And then this function is just error handling on a promise. Any questions on that? So, again, that's me grabbing the ID, checking the category collection to find a category document with this given ID. If it doesn't find one, that means the ID that the client is asking for doesn't exist in the database. Maybe from between the time they got that ID and some time now, that category was deleted, so it doesn't exist, maybe they went to the block, and they clicked on, they were on the block page, and then they had it on their computer for a week. During that week, one of the categories got deleted by an admin. So they just went a clicked the button to go get all the categories and then this one didn't come back. So that's one of those edge cases. Or maybe they're trying to hack us and they put in some random ID. I don't know. But either way, it doesn't exist in the database. If it does exist, attach it to req. category and call next. So that's going to allow us to---so when we call next here because this params is like a middleware before the routes, it's going to go to the actual request that was called. In this case, the only stuff that we're using for IDs here is delete a category, update a category, and getOne category. So go to one of those depending on whatever the request was. So if the request was /api/categories/iddelete, then after it's done here, it's going to go to DELETE. If it was PUT, then after it's done here, it'll go to PUT. So hypothetically speaking, let's say it goes to getOne, which means just get just the one category. We already got the category up here. We already did the job. It's done. We already grabbed it. So all we've got to do when we go to getOne is just send back req. category. It's already there. Everybody follow me there how that middleware's working? If it's not quite there yet, when we get to the next step with the routes and when you connect them together, then you'll see. But it's exactly like what we did with the tigers and lions. It's nothing different except we just got rid of the array and add a database. We're just doing the same thing. Sorry if you're reiterating but --- No problem. --- on the promise completion there, the category parameter, is that just returned by the findById? Yes, so most, so I planned on getting promises during this solution, so I'm glad you asked it. This is a great introduction to it. So I've been kind of breezing over promises because I've been saving it for this solution as far as queries. So, yeah, who here has experience with promises? A lot of people. If you don't have experience with promises, we're going to go over it just a little bit. I'm not going to go into detail about everything a promise is but just the overall conception of what a promise is. Actually, what we'll do is let's go through the solution, then we'll break off and I'll talk about that because it's a little deep. I think we have some other questions. I don't know if you want to handle these now. Yeah, let's do it. Why do queries attach to exports? Because we are going to use them in our router on the next step. So they're being exported because just like lions and tigers, so you would have something like this, app. get and some router file like /, let's say lions. And then you have this function here, req, res, next. This is what we had before. This is exactly what we had. What we're doing now is we're not going to just place this function in here anymore. We're actually just going to put in one of these methods that we're exporting. So that's what we're doing. We're just defining those functions in another file. These are the controller functions. We're just getting rid of them, and we're defining them here in this other file. So we need to export them so we can import them on the next step or require them on the next step. And I think there's kind of a trail going on here in the chatroom, but why don't we use exec instead of then? Exec returns promise by default and is good practice with Mongoose. So if you come down here and you say. exec and you do. then, it's the same thing. Why did I use it? To save keystrokes. That's the only reason. But if we do. exec and then you say. then, it's totally a promise. If you don't want to use promises,. exec takes a Node-style callback as well. But I normally, I don't ever use exec, and I don't even use the built-in promises in Mongoose either. I use these and Bluebird, and I promisify the entire Mongoose library, which is a little advanced. So I just don't use exec. The promise library that Mongoose uses is actually not that good. It doesn't really follow the A+ promise specification that we'll get into in a little bit, so I don't really like it. So I wrap it in something else. And I think he's following up on that. Why aren't you creating a class and then export a class instead of exporting multiple times using export? It's one way of doing the same thing. So if you wanted to get classical and make a class, you could totally do that. Sometimes I do get functional, so I don't really like to do---I mean, there's nothing wrong with that. The reason I did it is it's the style that I chose to do. You could alternatively have just said module. exports and put all the methods on here, so params, and then what else do we have, get. You could have done this too. It's up to you. So maybe you don't really feel like writing key value pairs. You just want to write variables instead. So it's a stylistic thing. No big reason. It's just sometimes I do it this way. Sometimes I do module. exports. Anything else? Is that it? They're asking about hapi. js has validation for routes. Should we be doing any input validations like using Express validator? Yeah, hapi. js is pretty awesome. So, yes, there're different layers of validation. So, first, you should be validating on a client first of all. Have whatever form you're submitting from a client, that should do validation first. And then what you should do is when you get to Express, if you want to add an extra layer in between the client validating and the database validating, and that's like through a middleware, you can also do that too. There's nothing wrong with that. And we'll get into Mongoose and how it uses middleware too and how we can talk with that. So we'll get into that. But, yeah, there's nothing stopping from making like a middleware function that does validation. But that's probably not the best place to do it because middleware is more tied to routes, whereas I see validation more tied to models. So I would probably bake that validation into the models themselves and use the middleware that's provided by Mongoose, which we haven't learned yet, which we will today though. So any other questions on this? Again, it's the same thing we did before except that we're not modifying an array, we're querying the database. It's the same concept. Go find it. Yes? I've got a question. So I understand the line 18 exports. get because that's kind of like a handoff to the GET that's coming in from the request, but line 4 exports. params, where does that actually hook up? So these names are arbitrary. I just name them like this because there just happens to be---so what you're saying is, there's a verb called Get, so that's where that lines up. Where does params come up? Well, I don't know what step it's on, but if you go back to when we were doing the lions, we had an app. param. That's what I'm asking. This is where this hooks back. Do you have it hooked up here? I remember from lions. I don't see it here. The routing is the next step after this, that's step-10. This is step-9. If you look at step-10, you'll see it. You're about to do it after this. So you'll see we will use this. We haven't hooked the routing up at all. We're just defining the CRUD for it. I just named it appropriately because I know for sure we will have the parameters route because we have IDs down there. So I that we're going to have this, so I made it. That's why I can't figure out where it's hooked up to, it's an orphan.

Exercise 9 Solution, Continued
So this is my solution for the GET inside the postController because GET is just going to get back all the instances of the collection, but there's a little difference in how post works because it has relations. So we had to change it slightly different than what's going on with the other ones. So what we have to do is we can just call. find. I'm just passing in an empty object here, but if you just want to return back every single one, you don't really have to pass in anything. I'm just doing this just to be safe. But you don't have to. You can just say just find everything and post. And then I call. populate. And, remember, what populate does is it's going to go to the fields on this document who has the type---well, first what it'll do, it won't do anything unless you tell it what fields to populate. So when you call. populate, and you give it the fields that you want to populate, it will go to these respective fields on the document, and it will grab their object IDs because that's their values. And then it will go to whatever the ref sys, and it will go to that collection with the object ID, find it, and attach it to this field name right here. So what I mean by that if we go to postModel, and we look, I don't know why that's an array, it should not be an array, and we look at the author, and its ref is user, so inside of here when we say populate author, what it's doing is it's going to go here, it's going to grab this ObjectId, and it's like, Okay, what collection do you belong to? You belong to the user collection. Great, let me go there with that ObjectId, find the appropriate user, and attach it to this author property. And it's doing the same thing for categories. And because categories is an array, it'll go inside the array and get every single one of the categories and populate it. I don't know why that was backwards. That should be an object. That should be an array. And then I have to call. exec down here because populate doesn't return a promise, so I have to call. exec, and then I just send them all back. Any questions on this? The only difference between this and the rest of them is that we need to call populate. The rest of them are just like this. So I find them all, send them all back. But because we have to populate, we just want to populate them. We don't have to populate. It's just you probably want that data. Any questions? They're asking, so populate is to hydrate the model's relationships? Yes, that's exactly what it is. That's a good way of putting it at call time. But it won't persist in the database. So remember that. It's not like creating a join table that's going to be atomic and saved in the database. It's only doing that when you make the query and it virtually gives it to you. It's not like I'm going to make it and save it in the database for next time. It's only going to do it at call time. So, yeah, it does, it will hydrate the objects. Also, you might want to do a population in here inside the params on posts because this is going to be fired when we want to update a post, delete a post, or getOne post. So it might be nice to just populate in here too, so we probably can do that. So we can come in here and do the same thing. We can just copy that. This will be like, Yeah, just populate here too. Boom! So by the time we get into the delete or the getOne or the put, it's already populated as well. Any questions on that? And then userController, you had to do the getOne I think. This one is pretty straightforward. You just have to send back the user. And the reason we can do this---wait, does anybody know why we can just say for var user = req. user and send it back? Why can we do that? Anyone want to guess? Yeah. Because we added it in the params function above. Yeah, we added it up here because we know when you make a call to getOne, we know that you have to pass in an ID as a parameter. And if you have to pass in a parameter ID, then we know it's going to hit this one first. And if it hits this one first, then it's going to tie to our req. user, and then it's going to call next, which is going to come back down to getOne, which has req. user. The reason I had you do this first before the routing because I wanted you to think about this without having the routing tell you because if you looked at routing, it'd be easier to figure that stuff out. You'd just be like, This has ID. Here's the middleware. It's all in order. I wanted you to just look at these functions and try to figure out what order they're going to happen by looking at the context. So you could infer that by saying req. user that something inside of here is attaching to req. user, so I would just do req. user. There it is. Whatever's on the left-hand side. So this is what's happening first.

Creating Promises
I could've written a lot of notes and promises, but I think this is one of those things where you just have to show people. This is the way I learned. I've read on it. I have people---I've read tutorials and stuff, and it was great. But I really didn't start understanding until I was like, Alright, let me start working with this stuff. So that's what we're going to do. We're just going to go over some examples of promises for a couple of minutes until everyone feels like they're up to speed on them. So we'll just make a new file. And you can follow along if you want, or you can just look. I'll just call it promises. js. Lucky for us, the native promise is built in to Node, at least the version I want. So we'll just use that. But there are other third-party promise libraries out there that are pretty cool. So the thing about promises is, or the thing that they're trying to solve is say that we have a function called action. This is a very, very naïve example, but it's just going to show you what they do. And action takes a callback. And then on some time in the future, let's say 5 seconds, it's going to call that callback of some arg. And then we can just call action, pass in the callback. So if I run this, I should see---oops, get rid of that. I should see hey in 5 seconds. So if I run node promises. js, in 5 seconds, hey. So we have to use a callback for that. That's nothing new. That's how JavaScript works. It uses callbacks for its eventing system. Promises pretty much give us the same thing without having to use a callback. Instead of giving the function control, we take that control, and we're able to say, Alright, now we want to be notified about this, or notify me when this does come back. So we just get more control, and it's better for like when you have nested things. So if this callback took another callback, and that callback took another callback, eventually you have something that looks like an upside-down pyramid. It'll just go like this, and then they'll come back out like this. All these callbacks and callbacks and callbacks and callbacks. And you start running out of names for your variables. And then you've got all these closers. And you're like, Wait, which error am I referencing? You don't even know anymore. So promises were made because of that. There are other alternatives to promises that are coming out--generators, we have async functions, which are part of the ES7 spec, which are really awesome. There's a lot of stuff coming out, but promises have been here for a while, and they've finally made it native in our environments. So what we're going to do is we're going to refactor this---I'll go back, we'll refractor this example and use a promise instead of a callback. So the first thing we'll do is we'll just get rid of the callback argument. We'll get rid of the call to the callback here. And then what we'll do is we'll make a new promise. So a promise is, all it is is just an object that has methods on it. And these methods notify us about what's happening during this asynchronous operation. These methods will either let us know that the value that we're interested in has resolved or it errored along the way. That's going to make more sense as we write this. So a promise is just an object with notification methods on it. That's it. So to get started making a new promise with a new promise library, all we have to do is have a function that returns a new promise using the promise constructor. So we say return a new promise. Then this promise actually takes a callback. And every single thing that we want to be wrapped inside that promise, we just need to make sure we place inside of that callback. So that's step 1, is if you want to switch your function over, have your function return a new problem and have the body of your function be inside that promise's callback. Step 2 is to use the built-in methods that I talked about--resolve and reject. So, again, this is how we're going to let the promise object know what values we're interested in when the asynchronous operation has been done. So, for instance, if I call resolve, after 5 seconds have passed, I'll be able to get access to the data that I told the promise I want. If I call reject, what's going to happen is the promise is going to tell me that an error happened. I'll show you what that means. So inside this setTimeout, if I just say resolve('hey'), same thing we had before, just to show you what that's going to look like. Now what I would do is to refactor this function down here, all I would do is I would just get rid of this callback function, and now what is action returning? It's returning a promise. So it's not doing what it did before. It doesn't take a callback. It's actually returning a promise. I takes no arguments. So what I could do is because it returns a promise, I get access to a few methods, I could use. then. So that's what you've been seeing this whole time. When you see. then, that's because the function is returning a promise. And most libraries use this syntax because there's a specification out there called the A+ promise specification that specifies how promises should be built, and they should have these methods that do certain things. You have a question? They're just wondering generally, is a promise functional programming concept, or is it something that was invested for JavaScript? It was definitely something that was invented for JavaScript, for single-threaded environments specifically in JavaScript. But I wouldn't say it's a functional thing. There are---if you want to get hard-core functional, there are better alternatives out there like generators or stuff like that. We have observables. Yes, observables of course. How could I forget about? So I wouldn't say it's definitely something made for JavaScript, and maybe other languages have adopted it because it works for single-threaded environments. Sweet! So we can call. then, which also takes a callback. And this callback, this is going to take an argument. I'll just call it word. By the name of the argument, you probably know what it is. So what's happening here is, let's just walk through it, I'm calling an action, which is going to return this new promise, which takes a callback and is going to start this setTimeout here. After 5 seconds, we're going to resolve('hey'). So whatever I pass into resolve, after this 5 seconds, I have access to it inside of this then right here. So whatever is an argument inside of this resolve is now accessible right here. So if I console. log(word), and you see the same thing will happen. It's hanging, it's hanging. I should probably change it from 5 seconds, this is too long, then hey. So resolve allows us to ask our promise about something, so saying. then is like, Okay, so I'm going to call action, and then when it's ready, give me the data that I'm interested in so I can do what I want. So because of that, now we can store this in a variable. We can say var promise equals action. And then sometime in the future, somewhere else in our code, we can be like, Okay, now can you just give me what I'm interested in? That's the sweet thing about promises. So we can do that. The other thing is the reject. So let's say that we don't want to resolve something. We're just going to reject. We'll just say reject---actually, let's just say new Error. So the way this is going to work is that. then is going to give us the resolve property, the resolve data that we want. Depending on the library that you're using, this next method is different. But for the native promise one, it's. catch. So if we do. catch, we get access to the error that might have happened. So the way this works is either. then is called or. catch, but not both. It's going to be either/or. So I can do---the way you would do it is you would do. then, and then you also do. catch because both these methods return the promise itself. So we can just chain them. So what's going to happen is, Okay, I want the word, I want to console. log the word. This may or may not happen. We don't know. And then if we have an error, I want to console. log the error. This may or may not happen. I'm not sure. It's depending on what's happening up here. On line 4, I'm rejecting it, so we know for sure. catch is going to happen. So let's just run it. So after 5 seconds, we get the Error: nooooo. That's because of. catch. That's what's logging right here. I'm just going to change that. That's just too long. Let's just do 1 second.. Alright,. catch is firing an error.

Consuming Promises
So that's like the basics of a promise. So this is how you would make a promise. Now how you would consume a promise is that, again, because Node has this convention of the Node-style callbacks where everything is error or response, so what we'll do is let's refactor a common function that you would see in Node, something like reading the file system. So what we'll do is we'll save our file system equals require('fs'). And then what we'll do is we'll start off reading the package. json. You've got a question? You're stretching, alright. So we'll say fs. readFile, and we'll say /package. json. So read this file. It takes a callback, Nodes. callback, which means it's error and then the data that we want. We want to call that file. So this is asynchronous. This doesn't happen synchronously. So this is going to happen in the future. Does everyone know what I mean when I say that? If I put a console. log underneath this just to show you, after read file, and I'm just going to get rid of all this stuff down here so we don't pollute the space. And if I put a console. log in here, which one's going to log first? After read file. Right, after read file's going to log first. So what I can do to refactor this is I can also just return a new promise. But I have to wrap this fs. readFile in that new promise. So instead of doing something like console. log(file. toString), which is the actual file contents, what I would do is if I wanted to use this in a promise, I'd just make a new promise. I'll say fs, or I'll say readFile equals a function, and it returns a new promise. It takes a callback, a resolve, and a reject. It's got to be in that order. And then what I can do is I can move this stuff up. Just go ahead and grab it, bump it up right into here. Then all I have to do is now I can just do like an if statement or a return error. So I can just be like, Yeah, I'm just going to return if there's an error, then let's just reject the error. If there's not an error, let's just resolve the file, and I'll just do a toString. So it's going to be either/or. If there's an error, reject the error. If it's not an error and then we have this---if there's not an error, then it's resolve whatever the file is. So now when I do it, I can just come down here and say readFile,. then, and I'll have a file here, or I might have an error here depending on readFile returns. So now if I run this, it's the same thing, same output. Everybody see that? Everybody get that? If you don't get it, that's fine. This stuff is not easy. I promise it took me a while to understand. And this is just the basics. Most promise libraries have a hundred methods that do a hundred different things, which is ridiculous. But these are the basics. And then usually what you would do is you would have another third one that's rarely used, but I think it's very important. And it's usually called finally or maybe sometimes it's called done. But what happens on this one is this method will always get called no matter if there was an error or a resolve. So this is like a great place to update your UI if you're doing front-end stuff. So it's like, alright, make a call to the server, so what you'll do is, let's say there's a call to the server on the client. You start a loading animation here. And then you do. then, get the data,. catch, log the error, but. finally, I don't care if there's an error or not, stop the loading animation. So this is where in situations like that where it's always great where it's guaranteed this is going to call no matter if it resolves or not. Yes? You might get to this, but they're kind of asking, How would you handle nested promises and avoid the callback pyramid? That's exactly what I was about to get into. You just read my mind. Yes? So do you normally use the built-in library, or do you normally use something else like Queue? Well, the built-in library's brand new. It's brand new? Yeah, it's new as part of ES2015 spec. I used to love Queue. I still like Queue, but now I use Bluebird. It's probably the most popular, fastest one. But the new promise one is pretty easy. It has all the methods you need. Bluebird's has just a grab bag of more than what you'll ever need. Why do you like it better than Queue? It was trending. I wanted to use something new. It's faster. It's performance tested to be faster. And it had some methods on it that I liked. I just liked one method in particular where it can like promisify any Node-style callback, which I thought was pretty awesome. Well, so can Queue, but the syntax is a little weird. So any questions on this so far? Now we're going to get into nested callbacks and different tricks and stuff.

Nested Promises
So one thing to note here is that whatever you return inside of a. then is automatically wrapped in another promise for you. So what that means is that if I just return the value hey, I'm able to chain another. then on here because it returns a promise, and I get the value of whatever the previous promise was, which will be like a word, which is hey. So I can just console. log(word). So if I run this, hey. Whatever I return inside of a. then. I could return something else here, and I could do. then as well. That also means that I can also just return other promises in here too. So if I just wanted to return readFile again, and this time maybe it reads a different tile, I could do that. I could return a promise. I could return a regular value. Whatever I return here is going to be a promise. So that's how you would deal with nested callbacks and chaining of the promises. Just make sure that you return something of one of these. So a good pattern that people do is they would just define these functions, these callback functions somewhere else. So it's like readFile,. then(logFile), and then. then(sendEmail),. then(callHome), whatever. And then it'll be like, okay,. catch, now tell me what happened. So this is a pattern you'll see a lot where these functions will just be defined somewhere else. And what happens is these functions will consume the resolution of the promise before them. So whatever readFile resolves will be fed to logFile. Whatever logFile resolves will be sent to sendEmail. Whatever sendEmail resolves will be sent to callHome. And then if any one of these is an error, it'll immediately go here. So during the time of---let's say we readFile, everything happens, we resolve, and then we go to logFile. And then somewhere inside of logFile, it errors out. It'll skip these two and come down to catch, throw you the error. So this is a common pattern you'll see. Any questions on this? Can you have nested promises in each of those functions, or does it (inaudible). Yeah, it will change. It does? So if you have, for instance, let's make logFile. So let's say logFile was this--var logFile was a function that returned readFile, which is a promise, and then it had its own promise chain in here that returned readFile again. So what's going to happen is, first, we'd do readFile. That'll get resolved. It will then go to logFile, which will come into here. It'll do readFile again. That's going to resolve. It's also going to do readFile one more time. That's going to resolve. And then it comes down to sendEmail. So it will recursively go down that chain synchronously. So it pretty much turns your asynchronous operations to synchronous operations. There's also all. There's another one---yes, I was going to get into that. So any questions on this? Yes, Mike? They're asking when you're chaining all those thens, do you only need to call the catch once? You only need to call the catch once, but sometimes you want more fine-grain control about when these things happen. So, for instance, this. catch is going to happen if any one of these things errors out, which is great. But what if you want to know what happens if logFile errors out specifically? There are two ways you could do it. Maybe you could throw specific errors and check for the error types in catch. That could be okay, but let's say you didn't make logFile so you can't really define the specific error types. So what you would do is most promise libraries take a second argument, and that's what you'll see that I'm doing in Mongo. There's a second argument that you can pass to then, and that's the error callback. And that's optional. So it may happen or it may not happen. So if that then was resolved, it'll call this callback. If it was rejected, then it'll call this callback. That way you get notified about this promise. So it'd be like it just stopped execution right here, and tell me what happened. But you could just call. catch at the end of the chain, and it will tell you. Any other questions on this? One more thing I wanted to show you that is very helpful in the context of database queries is another method called promise. all. I think this is very helpful because if someone would have shown me this a long time ago versus me trying to figure out what it does, which wasn't great, so promise. all will resolve an array of promises, and it will wait until all of them are done before it goes on, which I think is very helpful. So it allows us to do things in parallel you can say. So if we have database queries that don't rely on previous queries, we can just run them in parallel, and then when they all come back, we can merge the data and send it. I'm just kind of pulling up the last. If you are doing the error callbacks, then you do not need the. catch, so if you're catching those errors on each one? Yeah, if you're catching errors on each one, you don't need the. catch. So let's say we have an array of promises. So we'll say var read, or we'll call it promises. And it's just readFile like three times because that's a promise. So we'll call readFile three times. So we have an array of promises because we know when we call readFile, it returns a promise. So we have an array of promises right now. They've been executed. But now what we want to do is we want to, we don't want to go to the next thing until all these things come back. So what we'll do is we'll make a new function, and we'll say var readAllFiles. That's going to be a function. And we'll move promises up there. And instead of returning a new promise, this is going to return Promise. all. So Promise. all is just going to take this array of promises, and that's it. And now we're able to call. then on readAllFiles. So now if I come down here, and let's just get rid of this promise chain. Let's say readAllFiles. then, and I say files, it's going to be an array of all the files in the order that they were arranged here. So if we run that, we'll see it's an array. Actually, I'll just put. length because that's really hard to see. So there're three things in the array, and as you can see, they're all that file three times. So it waited until all those promises came back, and it was like, Okay, here you go. And they might come back at different times. So this is why third-party libraries are cool because they have other methods to even add more functionality to this, like do the same thing for objects, or maybe don't go on if all things in the array don't resolve, or continue if one thing fails or stuff like that. There are so many different edge cases. I don't think the built-in promise library has spread built in to it, but we can check it. If it has it, I'll tell you about it. If it doesn't, we'll see. It doesn't have spread. So what spread would do is it would just spread these files into multiple arguments. So instead of sending back an array, it'll just be like file 1, file 2, file 3 in different arguments. It'll just spread the arguments. So that'd be like file 1 here, file 2 here, file 3 here. So that's what third-party stuff has that the built-in one doesn't. But as you can see, it's pretty simple. Any questions on this stuff? So the reason they made the A+ spec is so that you can use different promise libraries together, and you can be assured that this method will have the same syntax on it. That's why I might be able to use a native promise function call with a Mongoose promise function call because they're both following the spec. Or at least, I don't think Mongoose uses---Mongoose uses an n promise, which I don't think uses the spec 100%. But you can mix them up, and most third-party languages have a method that allows you to wrap another promise so it will work like Bluebird allows you to do that. So that's our foray into promises. Like I said, there's a lot more. I recommend reading up on it a lot more if you're going to be doing a lot of Node development. A really good practice actually is just to build your own promise library. It seems really hard, but it's actually just like a whole bunch of caching and callbacks and events. It's really not tough. There's a thousand tutorials online that show you how to build your own promise library. It probably would take you an hour to get some basic functionality. That's what kind of worked for me after I did that. You have questions Mike? A couple. Have you ever used fibers? I've never used fibers, but my friend has been telling me about it. So if anybody uses it and they have an opinion on it, that'll be great. And then are promises available in the ES spec? Yes, they are --- In native promises? --- yeah, they are so if we just type in native promises, I'll guarantee that's the first thing that'll pop up is the JavaScript one. Yup, right there. It even says right there, This is a new technology, part of the ES 2015. So it's right there. All the documentation is there. I think it's even built into the browsers now. So if I open up Chrome and I type in promise, it's right there. So it's built in to the Chrome now too. Any other questions on this? So will this be helpful? Should I check this in the source code for anybody who might need this? I'll do that. It'll be on step-9-fix.

Authentication
JSON Web Tokens
So what we're going to do now is we're going to talk about authentication, which I really like. I'm a big fan of. I'm not a security expert, but I like authentication for some reason. I don't know why. I just like it. I like that it sucks and it's really hard. And it just feels good when it works, and I always have people try to break my stuff. Like see if you can get in here. I built this one system one time before I knew much about authentication. I was just reading all these blog posts and tutorials, and I built this one system to the point where I couldn't get in myself. I didn't know how to get in my---I had to drop the entire database and all this stuff because it was so well protected I couldn't get in it, and I just wasn't knowledgeable enough to figure out what I was doing wrong. So that was pretty funny to me. So, there are many ways to protect your API. What's a typical way you would protect an API? Everything needs a header with some passwords or something, like a basic auth. So basic auth. That's one way. Any other way? I know we've got some back-end people here with. NET experience. How do you guys protect your APIs? Cookies. Cookies, exactly. I was wondering if somebody was going to say it. I know we know cookies in here. So cookies is probably the thing that people use for authentication, authorization, and identification. So that's like the thing. So you have your cookies, and then you'd have like a session store where you store your sessions, some key value pairs. Maybe you're using Redis. Or whatever you're using, you have some session store. Sorry, I really have something in my eye if you see me wiping up here. If it looks like I'm crying, I'm not. My eye's really bothering me for some reason. So you have cookies and a session store. And a session store is just like a key value pair of who's logged in right now so that we can---when they make a request, those cookies are automatically set on a header, and we can deserialize those cookies, match it against something in a session store and be like, It's this person. Hey, how's it going? That's what we normally do. And that works. There's nothing wrong with that. Who here has done mobile development with Android or iOS. Then you probably know that either you just didn't deal with cookies on an iPhone, or if you did, it was really, really hard. Not as easy as the web. So what we're going to be using is JSON Web Tokens, or JWT for short. It's pronounced jot, like j-o-t, but it's JWT. So JSON Web Tokens, or JWT. So JWT is an open standard that is heavily used. Here's a link I included that you can click on. And we'll be playing around with some stuff in here. But this is a website built by this company called Auth0 who are--- they have authentication as a service, and they do a whole bunch of JWT stuff. They have this really nice site where you can decode and encode and mess around with different algorithms with JSON Web Tokens and look at other libraries for other languages. It's pretty cool. But we'll be using JSON Web Tokens. Like I said, it's an open standard that's heavily used. So it's not like some corporate company came up with this. It's an open thing. It's collective. It's open source. So because we're using a token approach, we don't need to keep track of who signed in with the session store or have cookies. So there is no session store anymore. There are no cookies anymore. That sound dangerous to anybody? Yeah, that's what I thought too the first time. I was like, That sounds incredibly dangerous. That doesn't make any sense. Why would I do that? I want the server to be a source of truth, to figure out who's signed in and who's not. If I leave it up to the client, then they'll get me every time. But you'll see. So the JSON Web Token will be sent on every single request because REST is stateless, and we know not of the previous request because it's stateless. So we don't know who you were the last time you made the request. If you don't send us a token every single time to this protected resource, then you're just not going to get it even though we gave it to you a second ago. We gave it to you a second ago because you had your JSON Web Token. This request, you didn't, so you're just not going to get it. It's an easy thing--give us a token that works and is valid, and maybe we might even check that token to see if it's a real user, and then if you have the appropriate identification and authorizations, then we'll give you the resource. So like I said, the token---since we don't have a session store and we don't have cookies, anything like that, the token has to be stored on the client that is requesting the resources. So if the client was a web browser in this case, we would store the JSON Web Token on the client somewhere where it can persist. And that's probably going to be local storage. Local storage is the common---you guys know what I'm talking about. Open up the browser, and you click on Resources. All this stuff over here, local storage, session storage, cookies, application cache for offline applications, web SQL, which is like a database in your browser, the newer IndexedDB, I'm sorry, IndexedDB is the newer web SQL. So local storage is like a key value pair store for your browser. So this is where you would store your JSON Web Token. You give it a key, you give it a value. And it'll be there specifically for this browser. Cookie storage is kind of the same thing but not really. So that's where we would store our tokens, right on the client, put them right there, or at least that's where the client will store their tokens. The server doesn't care. The server doesn't care where you put the tokens. It's just like, I gave you a token, but if you want something from me, give me the token back. That's it. It's a handshake. Note, tokens can be used for OAuth 2. You can replace the tokens you normally use in OAuth 2 with JSON Web Tokens. They work the same way. It's pretty cool actually. And they're actually really easy to implement, at least in JavaScript. So, note, we will not be going over the algorithms behind all this stuff. So if you're some security person, and you really dig messing around with SHAs and how that stuff works and time and complexity and all that good stuff, we won't be doing that. I'm not a computer scientist. I'm not a security expert. We can talk about it, but we will not be going over that stuff in detail. Besides, this website right here, like I said, does a pretty good job of telling you all about that stuff.

Using JWT
So here's a basic example of some arbitrary code. This is not the actual code that you'll be doing. It's just like how it may look like in JavaScript. So say we have this user object---let me bump the font up; there we go. Say we have this user, wait, where'd it go, there we go. Say we have this user object, and all it has is an ID, _id, just like we have in Mongo. It's got an _id, that's it, nothing else on it. What we can do is let's say we have some library called JWT and it has a sign method on it. What we can do is we can pass it the objects, and we can pass it a secret. In this case, the secret is just the string that I made. Shh... it's a secret. Now what that's going to do is it's going to spit out a token. It's like, Cool, here you go. Here's a token. It's just a hash using, I think it's like a SHA256? What is it? We're using a SHA256, and this is going to spit back that token, which is some long, crazy string. So the bigger the payload, the bigger the string. So if there was more than just an ID on here, let's say I wanted to sign the entire user document, let's say this is Facebook, and we grab the entire user object, and we signed it. That string would be a couple of kilobytes, and then you pass that across the wire all the time. So you probably don't want to do that. So you want to just sign as little as you need. You don't just sign the entire user but just enough, I would say enough to identify who the request is coming from, which ID is perfect for that. If you have an ID, you can identify anybody, so that's why I put an ID. So that's going to spit out a token. And then later on in the future when that user who we gave the token to was like, Okay, now can I update my profile now? Here's the update. I want to update my profile. And, by the way, here's my token. So what that user would do is that client, they'd have their token. They'd take it from local storage. They'd attach it to the headers usually on the authorization head, the field, and the server would put the secret back in there with the token that this client gave them, and it'll spit back out the user object. It'll do the inverse. So now we'll get that user object, which is just an object with an ID property on it, and then it will look in the database for a user with that ID. And so, yup, the token this verified worked because if this was like a regular string, not a real JSON Web Token, this would break and throw an error like this is not even a JSON Web Token, or the secret was wrong, or it just didn't decode properly. Something's wrong. But if it passed and it went through here, now what we want to do is let's make sure that this is an actual user because then, again, we have those edge cases. What if the user signed up a month ago, and our tokens don't expire for two months. And then during that month, during that time between the month and this request here, we deleted the user or something like that. So now if we don't do this check, we're assuming that they're in the database, but they might not be in the database. So it's good to do this check to say, Let's make sure this is actually a real user. Or some person could have just got a JSON Web Token from this website and was like, Yeah, I'm just going to make a JSON Web Token, and I'm going to send it to your server. And that would pass this check because it's a valid JSON Web Token, but it wouldn't have a valid user ID on it that's in our database. So it's another check. Is everyone following me there? So if I just pass in the JSON Web Token, the server knows the secret. This should work, but that doesn't mean it's a valid user. Yeah, Matt or Mark. They're asking, What do you mean by the token is probably on the auth header? Can you clarify? Yeah, I will clarify. So usually what JSON Web Tokens will do, if you look at the spec for it, it's expecting the token to be on the authorization header. So usually when you send it from the client whether that client is an iOS app or a web app, a TV, a smart watch, if you're going to do HTTP requests, it's expecting, it's assuming that the token string is going to be on the authorization header property. You can also---I'm not sure if this is part of the spec or not, but it might be. You can also put it on the query string with the name of access_token. And that can also be the token as well. But usually this is looking for the authorization header. Yes? So when you do verify, could user end up being undefined? Or will it always have some value if it's a valid token or if it's an unknown token? Well, so this has to be a valid web token. And it has to have been signed with the same secret. So let's say somehow some person got hold of your secret, so they knew what your secret was, so they went on this website with your secret. They typed it in down here. Is that cool? I'm going to make a new secret here. How do you make a new secret here? And then I'm just going to grab this token and go to your database, do a request. What's going to happen now is this will work. So it's like, cool, that's a valid JSON Web Token, and it decoded properly because it was signed with the same secret. So it came back. It was great. If it was signed with a different secret, it wouldn't work. But it was signed with the same secret, so it is the same. So then it will spit back that object, which in this case is this object right here. But this object, first of all, it doesn't have an ID property on it. But let's say it did. Let's put an ID property on it. Now we have an ID. We put an ID property on this thing. Do you have to put quotes around it? Probably, yup. Or single quotes here. There we go. So now I put an ID property on it. But that's not a real ID in my database. So, that passed all this. It had the same secret. It's a valid token. It spit back an object. It even had an _id property that I can check here. But my database doesn't know who that user is so it's just like, Nope, never mind. It's like the equivalent of trying to log in to a website with an email that isn't registered. It'd just be like, We don't have that email. There's no email that exists, so you can't even sign in. That's what you're trying to here. You're trying to sign in with an ID that doesn't exist. You can't, we don't have that ID. Everything else is great except for the ID. So in our code, we would wrap that JWT verify in a try/catch or something? It wouldn't go down (inaudible)? Exactly. So you would do a try/catch there. But we're going to use libraries to abstract all that away so we don't have to. Yup, Mark? How do you expire the tokens? Do you just include a timestamp and the object you're assigning? Good question. So tokens can be expired, and that depends on what library you're using. We're going to get into that because we're going to do that in our code. But depending on what library you're using, in this case we'll be using JSON Web Tokens, you can just pass in an object that has a property on it that says Expires in minutes or Expires in seconds and pass in a number, and that's when it'll expire. So it's pretty simple. You just pass in an options thing that tells you. And then they're wondering if JWT is included in Node, or do you have to... It is not included in Node. We have to npm install it. It is not a default thing. And there's tons of JSON Web Token libraries out there. Again, this website right here, if you scroll down, for any language that you possibly might use, it'll tell you the library that you should use and what security issues that library may have. It'll go into the algorithm specs on that library if you're into that stuff. It'll tell you all the stuff. So for the one that we'll be using, it's JSON Web Tokens. It'll tell you how to install it too. It's like, Okay, this is how you install it as well. This is a really good resource for JSON Web Tokens. It's got every single library you can think of down here.

Usernames and Passwords
So the process is like this. A user signs up to access protected resources in our API. So that means they give us a username and the password. They sign up. On success, we create a new user in our database. So it's like, Cool, that username is great. It's not taken. Password matches our validations whether that's like a minlength or maxlength or whatever the validation was if any. Great, we created a new user in our database. You're good. So typically what you would do there is you'd now on a sophisticated system, you'd probably say, Now I'm going to make a new session and sign them in and sign a cookie and send that back to the browser. But what we're going to do now is, now what we're going to do is we're going to grab that new user's ID that we just saved in a database, and we're going to create a JSON Web Token just like we did up top. We then send that JSON Web Token back to the user on the response of sign-up. So when they sign up, they should expect to get back a token string. It's like, Here's your token. You signed up successfully, here you go. And then what that client's responsibility is is to save it somewhere that will persist so they can use it for every request. So they have to save it somewhere. And every time they make a request to the server for some protected resource, they have to attach that token to the authorization header or the query string or wherever our server says they need to attach it. In this case, it's the authorization header. It's up to you when you build out your back-end, but I think the spec is put it on the authorization header. And they have to do that on every single request when they want something. Just like a cookie is sent on every single request from the browser by default, you just have to send this too. And most sophisticated client frameworks allow you to automatically do things like that so you don't have to do it every time as well. I know Angular does. It's just you write an interceptor that's like, Every time I make a request to the endpoint, attach this to the header. That'll do it for you. So not only did we get authentication with that, we also get identification because the JWT has ID. So we get two things out of that. And if we had a role-based auth flow, we could also get authorization from that as well. Not only would we attach IDs on here, but we would attach the user's roles on this object too. That way we can get authorization on what they can and cannot do on different access levels. So with JWT as the method we will use to grant access to our protected, we still need a way to, excuse me, sorry, my eye is really bothering me. We still need a way to actually create users other than a simple POST request to the server. So right now the way we create users if you go look at our endpoints, just do a POST request to the user's resource with the username, and you create a user. It's not that safe. That's not what we really want to do. So we need a better way of doing that. So the way we'll do that is with a username and password. So we already have the username field that is unique. Let's add a required password field as well to help identify who a user may be when they sign in. So there are numerous problems around storing original plain text passwords in our database, if you have any experience with databases, so there're legal, technical, and moral problems around storing people's password in your database in plain sight. You're just asking for it if you do it, just saying. If you store someone's password as is in plain text on the database, you're asking for it. So instead we will store a hash version of a user's password. Note that sending plain text passwords over HTTP is not safe either, and you should be using HTTPS instead. We will not be using HTTPS. So just get over that for now. If you're like, again, a security person and you're like, I don't want to send this password over HTTP, it's okay. Nobody's going to hack us today. A couple of questions. If you use JWT, do you have to make sure you're in a browser that supports client-side storage? Yeah, you probably would. I mean, if you wanted to persist, yeah. You theoretically could just save it in cache, and then if you refresh the browser, you'd just have to sign in again. But, yeah, if you wanted to persist, if you want a good user experience where the user doesn't have to sign in every single time they come back, then, yeah, you need storage. But if you don't have storage, then the worst case scenario is that every time your app loads up or loses state, the user has to sign back in. So that's worst case scenario. But, yeah, you definitely need that. But most browsers do. Definitely the major browsers support that down to older versions. And, of course, mobile devices support that as well. And then they're asking, Are you going to hash and salt passwords? So we're going to talk about salting, but, yeah, we are. So unlike the encryption of a JWT, we can't undo the hash of a password. We can't say, Okay, here is the hash. Give me back the password like we can with a JWT. With a JWT, we're using encryption, and we're using this SHA, and it's just like if I give you back the token with the same secret, I expect the object that I encrypted before, whereas a hash doesn't really work that way. It's a one-way thing. It's like I'm just going to create a hash and that's it. And the only way to check if something equals a hash is to hash it again and see if the hash values matched, not the actual passwords. So we can't undo the password. This is why hashing is perfect for passwords. So in order to check to see if a given password matches a saved hashed password like on sign-in, which is exactly what sign-in is, sign-in is like, First, let me see if there's a username in our database with this. Great, there is a username. Now let me grab that user's hashed password in my database. Let me grab the password they just sent me. Let me hash this password and compare it to the saved hashed password. If it matches, then they are who they say they are. Let me sign them in. That's what sign-in is. So, again, using the same hashing function and the same password, we will get the same hash as we did on sign-up. There are further methods we could use to prevent attacks on our API and our database like creating unique salts for each user and storing the salt on the user to help prevent rainbow attacks. So we're not going to be creating unique salts, so we'll just generate the same salt for now. But, you could. In fact, you probably should create unique salts and store them with the user themselves so a hacker would just have to work a little hard to get stuff. But ultimately you can't stop anybody from doing anything. It's just going to happen. You can just make it harder.

Authentication with Middleware
So there are so many ways to do this password process with Express and Mongo. So many ways, I don't think there is a right way. You can make a middleware globally. You can put one on the route. You can put one on the router. You can just have a utility function that you require and use everywhere. There're so many ways you can do this one thing. But Mongoose allows us to teach our models and our documents new tricks by adding custom functions to them. And this is where we're going to do it because it makes sense to do it to me at least on the actual models because those are the things that are going to save the password. So instead of having Express or Node know about hashing passwords, I should just tell my models about it, like, Hey, you know how to hash the password. Hash yourself or check yourself versus like, Node, check this password on this model. This is like, Just check yourself and tell me if you're right. So to teach Mongoose about new tricks, there're a couple of ways we can do it. So when we have our schema object that we create, we can use the. methods property, and we can just go ahead---and that's going to be an object, and we can just make functions on it. This is like the equivalent of calling function. prototype. whatever. It's like adding stuff to the prototype of the dog. That's what methods is. It's like adding to the prototype because these functions that we're making, these instances, or these methods are going to be only available to the instances, not the dog itself. But only the instance of a dog. So just like. push on an array is not available to the array constructor, but it is available to array instances. So I can't say Array. push. Let me try to call it. That's not a function because push is not part of the constructor. It's part of the instance, so I can say give me an instance of an array and call push. And that'll work. So it's the same thing. That's what the methods object does. The inverse is the statics object. And statics is like adding it to the static property. So, again, if we're inside of methods and we console. log this, it'd be the current document. If we're inside of a static method, this is going to be actually the constructor, the dog. So that's the equivalent of doing this. So I just gave you an example of you can't do array. push because that's an instance method or prototype method. But what we could do, array has its own methods on it, like Array. isArray. That belongs to the array constructor, but it doesn't belong to the instance. So if I said Array. isArray, that doesn't work because it doesn't belong to the instance of array. It only belongs to the constructor itself. It's the same thing. So statics belong to the dog model. Methods belong to the dog instances. So if we wanted a dog to bark like, Hey, dog, bark, we'd put it on the instance. We'd put it on the method saying, Can you just go bark? If we wanted all dogs to be able to do something like I want all dogs to be able to---or I want to be able to find all dogs by their owner. I have that here. So I can make a new method on here, so I can say Dog. findByOwner. I give it the owner's name, and it'll find it. So I could do that. Any questions on that? Again, this is with Mongoose, not Mongo. Mongoose is allowing us to do this. So Mongoose, like Express, also has support for middleware. And middleware is perfect for validating, changing, notifying, etc. The same use cases that you would use in middleware in Express, but now we have middleware on our models. And this middleware, they tie in to the lifecycle events around the documents. So when I say lifecycle events, I mean things like I want to be notified before something saves or after something saves or before something is validated or after something is created or after something was removed. We can create middleware to attach to those lifecycle events, and Mongoose would notify us about it like Okay, hey, something's about to save. Here, you can do something about it quick if you want to. Or something just got removed. Do you want to do something? That's what it allows us to do. So we'll use middleware to hash our passwords before a user is created. I think this is an appropriate place to do it. Like I said, you can do this in so many places. You just have a function that you just call throughout your---you could do it inside your controller. I don't think it'd be the best place to do it, but you could. But we're just going to do it inside of our middleware. So the way middleware looks in Mongoose, so, again, on the schema, you need to do a. post or a. pre. So post means after this event, pre means before this event. And you can go look at the docs. They have tons of hooks you can hook into. So here's an example of me wanting to run a callback after a dog has been saved. So dog. post, so that means after dog has been saved, run this function. So any time a dog has been saved, and I think save only runs on create. It doesn't run on update. So if you updated something, I don't think that counts as a save. So what I can do is I can be like, Okay, assume that this socket is a websocket library, I can just send an event to the client who's like, Hey, I'm notifying you about a change so that way you're getting real-time updates whenever dog is being changed, whenever somebody else in the world adds a new dog to our database, all the clients get updated about it. Here's a new dog. So this is where you would do something like that. And then, of course, just like Express, you'd have to call next to go onto the next middleware. And just like Express, if you pass in an error object here, it will pass the error along and error out. Here's an example of how we can tie into a callback function before our model is validated. So if we set up one of those validations on our models like required, unique, minlength, maxlength, this will happen before Mongoose ties in to those validations. So maybe you have a validation of like what we were talking about yesterday, you were saying regexes, so you could do those regexes and stuff here. It's like, Alright, this is where I'm going to test---I want to make sure that it files this, or I want to make sure that it's all lowercase or something like that. So you would do something like this. And you get access to the document just by calling this. So when you say this, it will get the doggy. So then you're like, Alright, doddy. name. test this regex or. match this regex. And then, of course, you have to call next. If you don't call next, it'll hang. Any questions on that. It's like the same thing with Express middleware, it just ties in to hooks. So when you call next, it just goes to the next hook, not the next middleware that you made. It just goes to the next hook. So, for instance, pre('validate') runs before pre('save'). In pre('validate'), you'll do your stuff, you'll call next, then it'll go to pre('save'). You can do some stuff, and then it'll call next. And then it might go to post('save'), you'll do some stuff. So all three of those will run one time a document was saved. Any questions on this? Yeah? And so this is also running in our Express environment, right? It's not like this is running in some separate thing? You could see it right now. So that admit, we could tie some other code to that, and then when that gets admitted, we subscribe. Great! So now that we know that, we need to do a couple of things. So, first, let's check out to step-10. Question? Do we need to do input sanitization for Mongoose, and would you do it in the. pre. Do we need to do what? Input sanitization? So, again, that's something I would totally do on the front-end as well. So I would totally sanitize stuff on the front-end first, but then as a backup, yes, you would totally do it as something like, What are these middlewares exactly. Any time you need to check or alter or verify something on a model before it gets persisted to a database, this is the perfect place to do it. But, again, you also could do it in the middleware in Express. There's nothing stopping you from doing it there. I just think this is not the appropriate place to do it. This was a little while back, but is there a recommended npm module for handling auth roles? And Passport. js was brought up. Passport. js is definitely the go-to. That's like the thing. We're not going to use passport today. I use Passport all the time, but we're not going to use it today because I want you to just make it yourselves because it's not that hard to do it yourself. But, yeah, if I were going to use authorization rules in Node, I would totally use Passport. js.

Exercise 10
So the first thing you want to do on step-10, that's where we left off with the controllers, we just need to hook up the routes. So if we go to the API and go to the routes, all these routes are here, but they don't have their CRUD on them. So they need stuff like. get. And then we need to be able to call the controllers that we already have here and register the appropriate functions. So, for example, I'm just going to walk through one right now. So this is the categoryRoutes. So on a GET request to /api/category, I want to run the controller. get method, and I get controller up here because I say var controller = require, the categoryController. You typed request there. Thanks. So now I can run controller. get, which if we go look at the controller, it's right here. So that's why we exported these so we can require them here. And then we do the same thing for all the other routes.

Exercise 10 Solution
So the solution is actually very similar to what we did with the lions and tigers. That's why I walked us through that exercise on day 1 is because we built up to this. This is the exact same thing. The only thing that we did was that we just replaced---remember when we did lions and tigers, we actually started off doing the app. We had app. get and app. post and app. put. And then we refactored, and we had sub-routers, and we had the router. get and the router. post. And then we made a quick refactor and we used a router. route, which just groups current routes together. And the only thing that changed from that to this is that now the functions that we passed in to the lions and tigers are in the other files. That's the only thing that's changed. Nothing else has changed. They're just in another file now. And those functions as we saw in the last exercise do the exact same thing as the functions in lions and tigers did; they just interact with the database now and not an array of lions and tigers. So we just switched out two things, put them in another file, talked to the database. That's it. Everything else is exactly the same. So knowing that, if you were lost, you could've either skipped ahead and looked at this or looked back on the lions and tigers and saw how we did the routing and saw that it's very similar to this. So as far as requests to the root, we know that's a GET and a POST because we don't need IDs for that. To create this resource, you don't need an ID because you're trying to create it. So let's do a GET request to that. I'm sorry, a POST request to that. You don't need an ID. To do a GET request for all of them, you also don't need an ID because you want all of them. So that's why we register these two here because controller. get finds all of them. And then controller. post creates one. And then for the ones for the IDs, we know that if we want to get one, if we want to update one, or if we want to delete one, we need an ID. So that's why we register these here. And as you probably see now, that's why the controller methods were named the way they were named because they were going with their appropriate verb with the exception of getOne because there's no getOne verb. So that's that. And then for the param, there's a controller. params function that we can run, so that's why I passed that in here, so router. param. It's important that this is at the top. If this was down here, I can't guarantee that it will work the same because technically it is middleware, but I'm not sure if it's running off middleware or if it's running off an event I've seen in the ID because Express does eventing as well, like it'll fire this event for this route and this combination of verbs. So depending on how it handles that ID, the placing could be important, so if you need it to happen first, just put it up top. Does everybody get what I'm saying there? The reason I was saying I don't know about the placing is because technically this is going to be middleware. And what we know about middleware is that if it renders first, it will happen first. So that's why I say put it at the top. But also, it's expecting this ID property, and I know that these routes, the reason why when you call next inside of a middleware and it only goes to one of these and not all of them even though they're siblings is because it matches a combination of a verb and a route. It fires an event for that. So I'm not sure if it also does the same thing for this. If it did do that, then it doesn't matter where we put this, just like it doesn't matter where we put these. It doesn't matter what order we put these in because it only happened on a certain combination. So I'm not sure exactly how Express handles that, so just to guarantee, I'm going to put it up here. Yes? There's a question. This is from a little while ago, but is the reason we extracted the controller code into its own files instead of inserting them directly inside the route so that we can use that code elsewhere by other routes and controllers? For higher-level abstractions, yes. For the other reason, it's because if we go look at our controllers, these are actually pretty small. Realistically, you start getting into---if our models were bigger, which they are not, these controllers will be much bigger, especially if we started getting into---now we're caching, we're calling other services, we're doing other things. We do multiple queries, nested queries. This controller file could be hundreds and hundreds and hundreds of lines. And having that mixed in with the file that's also registering the routes is kind of confusing. And also now because these methods are exposed, I could probably test them now because they're exported individually. I still have to mock out the request and response and all this stuff. So we might want to build an abstraction around that. But now these things are exported, and I can test them individually as units, whereas if I just put them all in this file inside this callback, it's going to be kind of hard to test them because that callback never gets run unless that route gets hit, and I can't hit that route until I call it. And if I call that route, I might as well be doing integration testing and not unit testing. So there're a few reasons why I did that--organization, testability, and just sanity. Any other questions? So all the files look exactly like this. The only difference between the other routes and the files is the path to where it's getting its controller. Everything else is exactly the same. So if we go look at postRoutes, it's the same thing. It's just getting its controller here. Everything is the same. The code doesn't change here. So you might be thinking, I could just make a file or a function that's called createRoutes, and it takes in a controller. And it just sets up in a router, and it sets up all the routes on it. Yeah, you could do that because it's all the same. You could totally do that if all the controllers have the same property names, they all went to the same routes. Yeah, we could just make a function called createController somewhere else, maybe in utils or something, require that in here, and just say createRoutes and pass in the appropriate controller and the appropriate router, and you're done. You only write this thing one time. In fact, let's just do it so you can see what I'm talking about. So if we go into utils, and I make a new file called createRoutes, I can just say module. exports = function that takes in a controller and a router. And all it's going to do is this. That's it. That's all it's going to do. It's just going to do this. And then now what I can do is I can just get rid of this stuff, keep the exports at the bottom, and now I can just say var createRoutes = require, and then out API, or out a category, out an API, into utils, and then createRoutes. So now I can say just createRoutes, and it's going to go ahead and invoke it right here. It's just too long of a line. So I'll say createRoutes(controller, router). And then that's it. And I could do this on all the files. So if I just copied this, these two lines, went down here, got rid of all this and just replaced it with that, get rid of all this and just replaced it with that, it'll still work the same. So it's just an abstraction. So we just wrote it once here, and it does the same thing.

Executing CRUD Operations
So now if we did all this, we should now that we have our models, we have our controllers, we have our routes plugged up, we should be able to start this and start doing some CRUD on it. So let's check it out. So in order to check this out, the first thing we need to do is make sure we have Mongo running, so I'm going to type in mongod to make sure that's running. The server won't start without it. If you try to start the server without the database running, it'll crash. So make sure that's running. And then I'm just going to run npm start to start ours. It looks like my path is wrong. Is it up one more? API, it's util, not utils. Sorry. So there we go. So now our server's on. Then in another one, I'm going to go ahead and make some requests to it. So let's do a GET request. Let's do a POST request to localhost. Our port is 3000/api/users. Let's create a new user. And we know as of right now, user only has a username, so let's just say username=person. It looks like we have an error. Hold on. No error. I don't see any logs. Let me start that down and start it up. The typo is in localhost. The what? The typo's in localhost. There's a typo. Okay. Typos get me every time, man, every time. There it is. Localhost. Cool. There we are. Created a person. Totally worked. If I wanted to create a category, and the category has a name and it equals cats. It's categories, pluralized. That'll create cats category. Now if I wanted to get it, it should be as simple as GET localhost:3000/api/users. Give me all the users. There we go. I got a lot of users here because I added more to the database. So don't worry about all these extra users here. So it gave me all the users. So you might note it would be kind of hard to do CRUD with the postModel, and that's because of all of the stuff that's, I don't know how this thing keeps getting here. But it should not be here. I need to fix that. So it'd be kind of hard to do this here. Well, I guess we could because none of these are required, so I guess we could, although this should be required--author. So let's do that. Let's make a post. So what we'll do is let's grab a user's ID. We'll grab that. And then what we'll do is we'll say post to api/posts and author=that, title='learn node 3', and text='blah blah blah blah blah'. We created a new blog post. See, it belongs to this author here. And now if we did our populations correct, when I do a GET request for this blog post, what I would see back, I wouldn't see this author field here, I'd see the author object. So let's check that out. So now if I do a GET request with this POST's ID, I expect there to be an object on the author field with the author's object on it, the username and stuff. So let's check that out. So now if I say GET localhost:3000/api/posts/that ID, there we go. There's the author property. It populated it. That's what population does. It took that ID that is stored in the database. In the database, the post looks like this. The author probably is just an ID of an author, but when we call populate on it, it turns it into this. It gives us that author's object. So that's what population does. And if we had categories in there, it would do the same thing in categories, each one in the array. Is that starting to make sense now? I know I've talked about it a lot. This is the first time we're actually seeing it. So now we're able to do CRUD on all our routes. Stupid question. You may have covered it. The __v that's added to all those. Where is that coming from? That's coming from Mongoose. That's something Mongoose uses internally to determine, I don't know, I haven't looked into it, maybe the document version. It's not important. It's not important. I guess it is important if you ever wanted to make a __v property on your document, then you would have a problem. So if that's something you really wanted, you probably can't have it. Any questions on that stuff? So we all should be able to do CRUD now. And if you were having problems creating an author, for some reason this thing---and I even put it right here in the comments, array of IDs from the users. This should not be an array of IDs. I don't know why I even did that. This should not be an array on author. It should just be one author. Actually, I know why I did it because I was going to have it to where many authors can write the blog post at the same time. That's why I did it. But we're not doing that. I was thinking way ahead. I was writing a solution for step-20 on step-10.

Authentication Configuration
Just to recap, like I said, we're going to hop right in authentication. Let's go over what we're going to do for authentication. So what I'm going to do is I'm going to just push up this refactor or this abstraction that we made on step-10-fix just in case anybody wants to see it. But as you can see, there's so much more room to do these abstractions, so much more room. You could even---if you go look at the controllers themselves, all these can be abstracted too. They're literally all doing the same thing. There's only one method in here that's doing something different, and that's the post because it's populating right here. That's the only thing it's doing different, but that's just an option away, just passing in an option to populate this stuff. So you could even abstract this stuff out, so, hey, createRoutes. Also createControllerMethods. Done. It's the same thing. So I'm going to check this stuff in. (Typing) It's really hard for me to type because I'm so tall that there's an angle, so that's why I'm messing up--push origin step-10-fix. So that's up there if you want to pull it down and check it out. So now this is where it gets kind of hard and tricky, and a lot of stuff is going to be going on here. So git co step-11. There's 11 steps. That's crazy. So there's a lot of new things happening in here. So I'm just going to walk through---I added a ton of stuff in here. So I'm going to walk through all the stuff that I added. So if you were to start the server---first of all, do an npm install. I added tons of stuff, so just make sure you do an npm install because I'm 100% sure that you want to have the stuff that's in here. So that's the first thing to do. Make it a good habit that when you start switching branches or pulling from GitHub or forking and cloning, and there's a package. json, just run npm install. So once we have that, we'll do an npm start. I'm not sure this will actually start up or not. I don't know if the code that you have to fix this is actually breaking this. But let's see. So one thing to notice is that I put these log tags in here, so you'll see you have better clear visibility on what's being logged or not. So there're some emojis or something in there. So if you do logger. log now, it'll always have this tag on it that says log, and it's blue now, not purple. And if you did logger. error, you'll see a thing that is red and has Xs on it. It'll tell you it's an error. So it's easier to spot out. So I added that to the logger that can be conditionally turned on and off. I also added the ability to seed the database. So when you start this database up, it will seed it. And it'll tell you what's it's seeded with--Seeded DB with 3 Posts, 3 Users, 3 and Categories. But before it does that, it'll delete the database. It'll drop the database first, then it will seed the database with three things. So if I stop it and start over again, there'll still only ever be three in there at a given time. That also can be conditionally turned on or off in our config file, and I'll show you that. So that's there. Again, if you want to see some events, uses of promises and stuff, if you go look in util/seed. js, the file that I'm actually seeding the database is about a hundred lines of promises. So you can check this stuff out if you want to see how I'm doing stuff here. But that's just if you want to look at it. And then also if you go to config, config. js, I added some filters for our JSON Web Tokens, so I'm adding how long I want them to expire. In this case, it's 10 days in minutes. So it's, what, 14, 000 minutes? I don't know. Something like that. Maybe more. But 10 days in minutes. And then I'm adding a JSON Web Token secret, so I need to pass it in through the environment, or I'm just going to default to gumball for now. You should not do this in production. You should put this in your file. It's just not something you should do, but we're not running a production right now. So I'm just going to leave that there. And then in development, there's a new file. This was actually added a couple of steps ago, but there's a new property for db, and this is where we just store it. We're just like, alright, for development, we're going to connect to this database. And then for testing, we're going to connect to the testing database. It's a different database. This is why the config file is awesome. We can change this stuff off based on the environment. And we know these files get loaded in depending on what environment we're running in. So we don't have to think about it. So when we run our tests, if we just say process env = test, and then we run the server, we know for sure this file will get loaded up and merged with the config file. And if we go to server. js, you notice it's using config. db. url, which could either be that testing one or that development one. We don't really care. It will do it depending on the environment, so that's great. And right underneath it, if (config. seed), so if you said, yes, seed the database, it will seed the database. And that also is part of config. So if you go to development, it says seed: true. So in development, seed the database. So all that stuff is there. That's stuff you will not be dealing with. That's the stuff that I added. So if you start looking at it and you're wondering what's going on, that's stuff that I added that you don't have to work with right now. What we're going to be focusing on is authentication. So now there's a new folder called auth. And there's just a lot of stuff going on in here. So let's start at the beginning--auth. js. So here's where we're going to do all of our JSON Web Token stuff. Everything related to authentication is going to happen in here. But we're going to use it elsewhere in our application, but the creation and the definition of it's going to happen in this file as far as the middleware, the functions, the signing, the checking, all that stuff is going to happen here. So let's walk through some of the packages. JSON Web Token--that's this package right here. It's not the official JSON Web Token. I don't think there is an official one, but it's the one that you should use for Node. It's called jsonwebtoken. And this is what we're going to use to sign and verify our JSON Web Tokens. ExpressJwt is a wrapper around JSON Web Token, and all it does is it just verifies your tokens for you. We can just call jsonwebtoken. verify ourselves, but expressJwt makes it work really great with Express middleware so we don't have to do it, and it's built by the same two people. So Auth0 built JWT. They also built expressJwt. So they built both of them. So they work well with each other. And we're just getting our config. And there here, right here, we have this check config right here. This returns a middleware function for us. This is why expressJwt is awesome. We pass in the secret, and it returns a middleware function that can look on the request. authorization and determine if the token is valid or not. And then we just get our user model here because we're going to need our user model for authentication purposes of course. So if you scroll through, there're a couple of function arguments not built out. Some are halfway built out. The one that is fully built out is this signToken one. So this is what a signToken looks like. We can say jwt. sign. And all we do is we create an object with an _id property. I use _id because Mongo uses an _id. That's the only reason I put _id there. It's just an object. You can put whatever you want in here. But I just put _id, although I'd rather have it just be ID, but if the database is going to say _id, I'm going to make sure it's the same. I've run into so many problems where I'm like, I hate using _id. I'm going to use ID. Then I get errors because of mismatched things. So I just keep it uniform, and when I refer to ID, I'm talking about _id. So I did that. And then we also need to pass in the secret, which is config. secrets. jwt. We've set that in our config. And then here's the option to where we can expire this thing. I also put this in the config wherever I had the expire time. So it expires in minutes. I put 10 days in minutes right there. So that's going to return the signToken. If it's signed, it'll return the string. So we'll use that as the utility method.

Exercise 11
So what you all are going to be doing, we have three functions that we have to build out. One is partially built out. Two, not really. The two are not built out at all. But this one is the decode token. So this is going to be a middleware that we're going to use when we want to check the incoming requests token, and it's job is to do exactly what it says, it's to decode the token. It's to take the token with the secret, turn it back to what it was originally, or at least attempt to. And if it can't, it should let us know so we can send an error back. So I'll walk through what's happening here. You can read the comments, but in short, remember I was saying earlier the token should be on the authorization header, but optionally it could also be on the query string. This is what this check is doing. It's like, okay, if we have req. query and req. query has an access_token property, they probably put the token on there. So let's grab the token off of that, and let's attach it to req. headers. authorization. Now the weird thing that's going on here is you see this word Bearer. We didn't talk about this. And then I'm adding the token to that. So in the spec, what's happening here is that, at least this checkToken thing at least is looking for the token string with a word called Bearer, capital B, just like this, Bearer with a space after it followed by the token. That's actually in the spec. If you go read the JWT spec, most of these libraries are expecting to see Bearer, space, the token. So that's why that's there. If you got rid of this or just did that, it wouldn't work. Even if this was a valid token, it won't work. So this is I guess a way of namespacing that this is a JSON Web Token because there are so many other tokens you could put out there on an authorization header, I guess, so Bearer maybe is a way to namespace it. But it is expecting that. So we attach it to the authorization header. And then checkToken takes in the request, the response, and next. And because the authorization header is on the request, checkToken will do one of a few things. It will either call next if the token is valid. So it's like, Cool, this token is valid. I'm going to call next. And it'll go to the next middleware. If it's not valid, it will call next with an error. So it'll still call next, but it'll pass an error like Unauthorized. If it is successful, it'll grab whatever was spit back from the decoding of the token and attach it to req. user, which in our case will only ever by an ID or only ever signing an ID. So the ID's going to be attached to req. user. So maybe it will do req. user. _id, and you will get the ID. And then it'll call next. So all this is done for you. You don't have to work with this. This is good. What you will have to do is these two things down here. So getFreshUser is exactly what it sounds like. So now that we've got the token, we've got the ID back, now we want to create a database and get the user with the ID so by the time it gets to our controller, the controller can just say req. user, and it has the user object on the request. That's what this is going to do. Again, I said up here it does attach the ID to req. user, but that's just the ID. We can now use that ID to get the full user from the database and replace req. user with the actual user document. So by the time it gets to the controller method, the controller can just say req. user, and it knows everything about the incoming user. So that's what you're going to do inside of this function. It's heavily commented so you can just read through it. But, really, all you're going to do is query the database. You have access to req. user inside of here because this getFresh middleware is always going to run after decodeToken because we're going to use it that way. So just assume that you have req. user here and it's an object with an _id property. Given that, you can query the database and find the appropriate user and attach it to req. user. If you don't find the user, one of two things happens. We get into those edge cases where either they figured out your secret, they made a JSON Web Token, they sent it in, it decoded perfectly, and then it came here, and then you looked in your database for req. user. _id and there was nothing in there, then one of two things happens. That's not a real request from one of your users, or the time between they got that signed token and this time, the user doesn't exist anymore in the database somehow. Maybe you deleted it, I don't know. So do that and be sure to call next because this is a middleware function, so you have to call next. That also means if you have an error in your database query, you call next and pass in the error. And I'll leave it up to you to decide what to do if the database goes to the database, does not return an error but doesn't find a user either. So I'll leave it up to you to decide what you want to do there. And then exports. verifyUser, this is going to do something similar but a little different. This is actually checking the passwords. This is where we're doing the sign-in. So this is giving a username and a password. It's going to look up the user by the username, grab its hashed password, and check to see if this password after its hash is matching with the saved hashed password. So as far as hashing a password, you don't have to do that. I have a method for that. I'm going to show you that. We haven't gotten there, but it's in there. You will not be hashing passwords yourself. This will be calling a function that we already made. So you'll be doing those two functions in auth. js. And then if you follow me into api, user, userModel, we get into that stuff that I was talking about, the middleware with Mongoose and then teaching Mongoose new methods. So we have this one middleware up here that says UserSchema. pre('save'). So this happens before---any time before we create a new user, this function will run. So what's happening here is it's converting the password to an encrypted password. It's encrypting the password. That's what it's doing. That's all it's doing. It's like, Give me the password. I'm going to encrypt it. So we also added a password field up here too. There's type of String and also required. So it's overwriting the plainTextPword with an encrypted password. And then it's calling next. So if we go down and look at these methods, we have authenticate, which takes a plainTextPword and will return true or false if this user's saved hashed password matches the hash plaintext password. So this is perfect for sign-up. So this is what you would use in verifyUser. It even says it right here--use the authenticate method on the user document. So this is the authenticate method that it is talking about. And then encryptPassword just takes a password and generates a salt and it encrypts it synchronously, which is probably not the recommended approach, but I wanted to keep this as simple as possible. You probably want to do this asynchronously to avoid time attacks. But we're going to do this synchronously. So that's what's going on here. Any questions on this stuff? You don't need to touch anything here, but I just wanted to give you some context on what's happening. All the stuff you're going to be touching is auth. js. For how long? I've still got a little bit more to show, then we'll start. So auth. js is where you're going to be touching. If you also go look at the other files like auth. controller, sorry, controller. js and routes. js, some other stuff going on in here. Inside the controller, there's a signin method. You'll also be doing this one. And this one's just going to---you can assume req. user will be there from the middleware that we're going to assign. So we can just create a token and send it back to the client. So that's all this is going to do. It's just going to be like, Okay, get the req. user, get the ID from that, and create a token and send it back to the client. And if you go look in auth. js, we have this signToken thing here that will sign a token. We just need to send it back. And the way we want to send it back is we want to send back an object that has a token property, and it's value is the token. That's what we want to send back. So it'd be something like that. So this'll be two lines. So if you go look at the routes, this is the route that's happening. So we have a new router. On signin, we want to do controller. signin. But we need to do something before this happens. We need to verify the user because they're trying to sign in. So that's where that method verifyUser comes in. Right here. That's a middleware function. So complete that, add that middleware here. Make sure we're signing a token and sending it back. And then complete these two functions. So one more thing---so that's all you're going to have to do, and you can do this without a thing I'm about to show you. But to make it easier, if you want to, or you can wait until the next step, on GitHub, there's another repo on the Frontend Masters, github. com, that we did during the two-day course earlier this week, and it's angular-components. On the---where is it at? It should be a blog branch. I need to push it up actually. We'll wait until the next step for this, and then we'll push it up. So I have a client app for you guys so you can actually play with the blog and see the API and how that stuff works. But I'll push it up after lunch so you guys can see it. It's on a different branch. So knowing that, let's get started. We've got 30 minutes, and that'll bring us---yes? Just a quick couple of questions. Somebody's asking if they need Python to run npm for this step? No, they should not need Python. They're getting an error --- They're getting an error. --- I'll try to follow up with them and check. And then somebody else said, Could you speak briefly to placing encryption/decryption methods on a model versus putting them in something like Passport. So, I guess when we talk about Passport because Passport's job is to authenticate, I guess you might think it does make sense to do that. But now you're putting the logic that is going to be the logic as far as authentication, as far as hashing and stuff that the database needs to work, you're putting that in something like Passport, which I guess is safe, but maybe you want to switch out Passport tomorrow, and now you have to move that logic. Or maybe you're doing so many different types of authentication schemes in Passport, and you have to write the same thing over and over and over and over again in different schemes, or you have to build an abstraction around Passport so you don't write it over and over again. I still wouldn't put it in Passport. Passport is more like---I wouldn't give the signing of my tokens to Passport. Passport is more like, I'm going to handle OAuth for you, or I'm going to handle a local sign-in. Passport's going to do what we did as far as allowing us to get access to the incoming password or username and email. But as far as the signing and checking of it, you can do it in Passport, but the thing that's calling that method should still be your document in my opinion, although there is no wrong or right way. You can still do it in Passport, and that's the beauty of having it on the model here, our userModel, because it's on an instance of user, we have access to user inside of Passport. In Passport, you will query, you'll get the user, and then you can just call user. authenticate or user. encryptPassword inside of Passport. So there's really no loss there. But I would just still---I think it's all about where you define it, not where you use it.

Exercise 11 Solution
Anybody want to explain to me what this function is doing? Anybody want to take a guess and just tell me? I already told you, so I'm not going to tell you again. I just want to know. If nobody has any questions, then that means everybody knows what this function is doing. (Inaudible) So, it will look for the token on req. headers. authorization, and then because we set it up up here up top, we already set it up, it already knows the secret because we told it up here. It's holding the secret in an enclosure, and it's going to try to jwt. verify this token with this secret. And if it finds it, it's going to grab whatever object is returned and attach it req. user and then call next. If the verification process fails, it'll call next with an error. If it doesn't find the token, it'll call next with an error. So let's just start with the one that you probably were doing first, and that's verifyUser. So anybody want to tell me what verifyUser is doing? What was it supposed to do? What was verifyUser supposed to do? I hope everybody knew what it was supposed to do because you just tried to make it. So if you didn't know what it was supposed to do, that'd be really hard. Yes? It's supposed to say, Is this user in the database? Right, and what else? And were the credentials correct? Right, so it'll check to see if the user exists in the database and if the password they supposed to me is the same password that they signed up with. That's what this is doing. And then it attaches the result of that to req. query. Yes? This kind of came up back before when you were talking about decodeToken. He's asking where is it being used? We're not using it currently right now. We will on step-12. Good question. That was the question I was hoping somebody would ask me, Where are we using this thing? Because we aren't using it anywhere. We just made it. But it's not being used. So verifyUser has absolutely nothing to do with tokens. This is just passwords right here. This has nothing to do with JWT. So this is my solution for it. So what I do, first, I make sure that there is a username and a password. And if not, I just send back a 400 You need a username and password. Also, you should be doing this validation on the front end as well. So you shouldn't even let the forms even submit without the username and password, but this is just to catch it anyway. So we've got two types of validation saving those db queries. And the status code for 400 is resource. Let me see. I have all the cheats right here. Let me see. Bad request. So I think that's appropriate. I don't know why I couldn't remember that. And then if that's true---and then I put this return keyword right here so it doesn't continue to go down here. You could also just put else if you wanted to. I just don't like that sometimes, so I just put a return. So stop. You could also just put the return in front of this, and it'll still work. Whatever you want to do. And then I say user. findOne with this username because we all know usernames are unique. We did that. We only want to query things that are unique. So I'm going to find the first user or the only user whose username is username. And then grab that user. So if it didn't error out, but there is no user because, remember,. then is a promise resolution, so this will resolve as long as there was no error. But that doesn't mean that there is also a user. The database could have gone, this Mongoose could have gone to the database, searched for a user, didn't have an error, but came back with no user. That's not going to throw an error if there's no user. So we need to check to see that there's actually a user there. So if it's not an error, sorry, if it's not a user, then I'm going to set a 401 No user with the given username. And you can see this time I did an else statement because returning a promise is kind of weird as we saw. So else, and then what I do is I say user. authenticate(password), which I told you about. If you go look in the userModel, authenticate is this, it takes in a plainTextPword, and it will return this method, bcrypt. compareSync, which will take the plainTextPword, and hash it, and see if it matches the password that's already saved. It will return true or false. That was already there for you. And, remember, I said this was on the methods. So when you say UserSchema. methods, that's on the instance. We went over this. So that's how I was able to say user. authenticate. So I'm saying, Hey, user, authenticate yourself with this password because it's on the methods, which means it's on the instance. Does everybody follow me there? Because these two methods authenticate and encryptPassword exists on UserSchema. methods, every instance of a userModel can call these methods. And when I say the keyword this, I'm referring to the actual instance. So in this case, when we say user. authenticate passing this password text, and now we're coming down here to console. log this, this keyword right here, it would be this user. So I say, Hey, authenticate yourself. If you're not authenticated, if the passwords don't match, 401 Wrong password, else it did match. You're good to go. There was a user, the passwords did match, I guess you are who you say you are, req. user = user, next. And then error handling. So, remember, I said with promises, you can either call. catch, or you can also pass in a second callback to do optional error handling. That's what that is right here because this version of Mongo is using end promises, and I don't think they have a. catch or a. field. They probably do, I probably don't know it enough. But I know if you do this, it'll catch the error. So what do we have on this? Any questions on this one? This one's kind of tough. I saw a lot of people like huh. I'm curious, what do other people do? What else did you guys do? Everybody did it like this? Yup? There's a question. Is there a reason why you don't use error middleware and set status sending back a message? Is there any reason I don't use error... So the reason I did it here. That's a good question. So this question was, Could I just use error middleware like we've been doing before and just send a message back? Yeah, we could totally do that. But I guess the reason I did it here is because, one, I haven't registered this middleware, verifyUser, anywhere, so I have no idea in what middleware stack it's going to be. So depending on what router it's placed in or what route it's placed in, I have no idea what error handling is going to come after it. The only guarantee I do have is if I set up globally like on server. js, like this one. This is the only one I'm guaranteed to know that it will hit because this is after everything. And I also want to do a specific error for these conditions. So if I wanted to send it to global error message, I would have to send along some type of metadata along to let the error middleware know that this error's coming from verifyUser. Maybe I'll put a different message on it, or I'll put a different type on it or something like that. So I can check and be like, If error. type equals fromVerifyUser, send back the status code of this. So you can totally do, and it might be better. But it was just I would have to figure out how to check for those different types of errors with the appropriate error messages. An even better approach is just to abstract or what I would do is I'd make a middleware that just mocks out error handling forever, and I would just have something like---it'll just be req., you know, or it'd be like req(bracket)404(bracket), and it'll just send back a 404, and you'll give it a message, and it will send that message back. I would do something like that. So if that looked kind of funny to you it's because I'm using brackets syntax because it's a number. I can't say req. 404. That won't work. So I have to say req(bracket)404(bracket). Any other questions on this? On verifyUser? You look like you have some questions? You have some questions. I have a question. Thank you. Yes sir, there we go. Line 75, it's calling next after it sets the user on the request. And that'd server. js. I see auth is the last app. use. That's true. So how does...? What's next? Yeah, that's a good question. Let's follow it. So auth, we'll start right here. And then let's go to where it's being pulled from, which is auth, routes. js. So it's been pulled from here. This is the router right here. Are you following me there? Here's verifyUser, that's the method that was calling next. So when it calls next, it goes to the next function, which is this one. So that's where it's going when it calls next. It's going here. Because, remember, we can put middleware in between this stuff too. Remember, we can put in an array of middleware here. We can put another middleware here. We can put a limited middleware here. It doesn't matter. And every time we call next, it's just going to go to the one to the right of it. So this is route-specific middleware. So that's why I was like middleware is very powerful. So when we call next, it'll go here. Good question. Any other questions on this guy? And then back to what I just showed you. Of course, this is where you would use verifyUser. You'd verify the user before you'd sign them in because when we get to controller. signin, that's where we're actually going to sign the token. We don't want to sign the token for somebody who hasn't even given us the appropriate username and password combination. So we want to verify that they are who they say that are first before we give them a token. Does that make sense why we have verifyUser here? Let me check the passwords. First, let me see if they have a username and password. Make sure they have a username and a password. Then also make sure that there is a user with that username. And then check that the two passwords, the hashed passwords, match each other. And only if all those conditions meet are they who they say they are. Then I'll attach you to the req. user, and you can go forth. So those are the only conditions that this'll work. So that's how we're able to say if somebody goes to /auth/signin, we must verify them first, and then we can sign them in. So now if we go to the controller method, this one, we have an exports. signin, which is the controller method for the sign-in. And because if we go to verifyUser, we notice we put req. user here, we attached req. user, we now have access to the---so whatever comes next after this, which is the controller. signin as we just saw, it can now call req. user, which is what this is saying here. So req. user will be here from the middleware, verifyUser. Then we can just create a token and send it back for the client to consume. So we can use the signToken method that exists on the auth object. So if we just require auth, that was already made for you in auth. js, the signToken right here, it just takes an ID and it returns a token. That's it. Give it a Mongo ID, and it will sign it and give you the token back. That was already there for you. So that's what I did. I just required it and just did. signToken here. And then I'm saying token = signToken, pass in the ID, which is rec. user_id because we got the req. user, and then just send back the token. So I send back an object with the token property with the token value.

Testing the Authentication
So let's check to see if that works. So, first, what we'll do is let's just go get a user from seed. We'll use this person. We'll grab their username. All the passwords are test. So I'll come over here and say http and then POST to sign up, localhost:3000/auth, /auth because if you go to server. js, /auth right there, /auth. And if we go to that /signin, so /auth/signin. /Auth/signin. And then what we want to do is POST username=Jimmylo and then password=test. There we go. And then we get a token back. See how that works? If we look at the logs on the server, we've got Successful 200. So like yeah, yeah, that worked. Everything worked. You're good. Now if I change it, if I was like, Okay, let me try to sign in again, but I'm going to put the wrong password in. So what I expect to see if I, I've got so many things open, what I expect to see with the wrong password is this. I should see Wrong password. That's what I should see because what would happen is the verifyToken would work or the decodeToken would work. I'm sorry, we're not using tokens. Never mind. Let's do it higher. So what would happen is there is a username and password, so it'll skip this. It'll find the user by the username, which is correct because we gave it the right username. This will never happen because there is a user, so it'll come down here. And then this is where it will fail. It'll be like, Whoa, those two passwords don't match. So because of that, I expect to see this. So let's check that. So Wrong password, there it is--Wrong password. And then if I also decided to do it with no password and no username, I expect to see You need a username and password. And that's exactly what I see. And is there another edge case. Now if I give it the wrong username but the right password or any password, let's just give it a completely wrong username, I should see No user with the given username. So let's see that. No user with the given username. Everybody following me there? Any questions on this stuff? Yes? What are the benefits to using Passport versus doing it manually this way? And then he's saying he didn't know if you had time but could you show how to switch out the custom middleware with Passport. js. Passport--so there's a little more overhead with Passport but for good reasoning. If I were to build my own, I would probably use Passport because these days most applications have OAuth sign-ins with third-party providers like Facebook or Twitter. And building that yourself is doable, but if you're not familiar with how OAuth works and how the double handshake and all that stuff works and all that good stuff, you'd probably use something like Passport. So if you're only doing like a local sign-in like we're doing now, maybe Passport doesn't seem like it's worth the overhead. But, for instance, you probably have more than one strategy as far as authentication, so Passport actually---it's like you write it once and then it just has diminishing returns on how hard it is to add another feature to it because it's the same thing. As far as having time, if we have time at the end, I have some stuff I want to get to, we can get to that because it's not too difficult. But the only difference with Passport and this one in my opinion, there's going to be a lot more overhead with Passport, but it's literally doing the same thing. You're still going to, in fact, you probably would just copy this, this whole method right here, and paste it in Passport. It'll do the exact same thing. The only thing you do differently is instead of calling next, you just have to tell Passport that you're done. That's it. And then you have to---we also have to disable sessions because Passport uses sessions by default, and obviously we're not using sessions. So we have to disable that. So there's a little bit more overhead just for one strategy. But for multiple strategies, it's definitely the best. And if I had to do it, I would use Passport. Any others? He was asking about if you could show how to switch that up, but if you don't have time for it today, maybe you could push it to the repo later. If I don't have time to show it today, I will definitely push it to the repo, and I'll probably even add in another strategy so you could can click to login with Facebook or something like so you can see how that works. Yes? If you grant another token, does that kill the old token? Or are they both still valid? So let's say you post a sign-in, you get a token. And then you post a sign-in again, you get another token. If you try to access a resource with that older token, that's still valid, right? Yup, it's still valid. It's not like there can only be one valid token at a time. Because a server's stateless. All it knows---it doesn't keep track of tokens. It just knows that if you give me this token that was signed with this secret, I guarantee you I will give you what it used to be before it was signed. That's it. And it's not expired of course. So you can have more than one token. So if I made this token, and then I made this token, they're both valid tokens. I could use either one of these for this user to go get my stuff. And they'd both work. If someone gets your secret, they could extend the life of a token, right? If someone gets your token secret, you have bigger problems than extending the life of it, but yeah. That's why they expire because what's stopping you from just making a JSON Web Token and posting to my database and acting like the user? Nothing. (Inaudible) So we have to expire them. You've got to have a secret and stuff, so we just need to have those things expire. Some people are wondering if you use Redis for authentication to store sessions? No, I don't use sessions. But if you were to use sessions, Redis is a great choice. It's a simple key-value store, perfect for things like sessions. But I don't use sessions. Any other questions on that? It's kind of crazy how it all works together. It's like it almost feels like there's just no way that's going to come together at the end, and then somehow it just comes together. That's how I feel sometimes. But it just came together. But it makes sense. If you walk through it, and you look at the things that it's checking for, it makes sense. It's not like there's something hidden except for this thing. That thing's kind of hidden. But I told you what that's doing. Everything else is in plain sight of what's happening. So the next thing that you had to do was if you didn't do this, this is fine because we didn't use this in this example. So if you didn't feel comfortable writing this because there's no way to even test it, that's fine because we're going to use it on step-12, but I wanted you to write it to get ready to use in step-12. But if you didn't do it, that's fine. We're going to use it on step-12. So this method, getFreshUser, like I was saying, it's job is to get a fresh user because when we decode the token, all we have is the ID, the _id, we actually want the entire user. So by the time our controllers are called, they can just say, Hey, I want to know who the current user is, and if they look at req. user, it'll be the entire user object, not just the ID property. That way they don't have to do another database query on top of the query they're about to do in the first place. It's already done. So that's all this is doing. It's just querying the database for this thing. So here's the edge case of somebody sending us a token that passes our validation because it was signed with the same secret and everything, but for some reason, there doesn't exist a user with that ID in our database. So we're like, Nope, you're unauthorized. You did everything right except for the IDs just don't match. Else req. user is user, so this one is pretty simple, and just call next. Any questions on that one? And we're not using it anywhere, so if you're like, Where are we using it? We're not using it yet. Great, great, great. I think that was all you had to do. That was all you had to do. So knowing that, are there any questions around authentication as far as JSON Web Tokens, as far as the passwords, how we do that, as far as Mongo and Mongoose using these schema methods or these pre-hooks, anything surrounding that? I want to make sure we answer that stuff now before we start moving in because we're going to start moving in to a little more abstraction. So I want to make sure everybody's on a good understanding of things that might be confusing.

Securing Routes
Identifying Sensitive Routes
So now if we go back and look at those other methods like--- in auth. js like decodeToken and verifyUser, I'm sorry, decodeToken and getFreshUser, we're actually about to use these now. But we've got to think about---it's going to go down to what resources do we want to protect. So let's just go and look at them. Let's just go and look at category. Let's look at categoryRoutes. Are there any routes in here that you think that you should be authenticated to access? Post. Right. You should definitely be authenticating when you're going to create a category. I agree. Anything else. Delete? Definitely you should be authenticating delete for sure. And probably put. Put, updating a category for sure. That's about it. Everybody else should be able to get all the categories or get one category. I agree. Now what about---let's go to the postRoutes. And then for this one, same thing or something different? Probably the same. It's about the same. Everybody should be able to get one and get all but only authorized people should be able to update, delete, create. And then for users, there's some extra stuff going on in here. And then for users, what about this one? Probably don't want to get all your users. Probably don't want to get all the users. What about get one user? What if I want to see---what if I go to the blog, and there was a link here that says Look at all of our authors. Isn't that get all users? So there may be a way, maybe you want to getAll users, but you don't want to show all the information in the user's schema like their passwords, stuff like that. Here's their password, hashed, but it's there. So maybe post? So who should be able to create a user? Anyone can create a user, right? Yeah, anybody can. On a real blog, no way. You'd have to be invited. I'd have to type in your email, You're invited to write on the blog like WordPress. But in our scenario, yes, anybody can go to our website and sign up and start publishing. So, yeah, anybody should be able to create, whereas that was different with the post. Only authenticated people should be able to create, so that's why I wanted to talk about it. What about update a user? Who should be able to do that? Only that user. Only that user. So not only should you be authenticated, but you can only update yourself. So that's different. But what about if I'm an admin, and I want to update your stuff? You'd go into the database. I've got to do it from the database. (Inaudible) We're not there yet. We don't have role-based authentication schema anyway, so there's no admin. We're both users anyway, so I don't have super powers. What about delete? Think about that? It's deep. Have to be authenticated. Authenticate yourself for now. So I just want you to think about that stuff because now you're going to have to write the middleware in the places that they need to be so this stuff works. So if go back to auth. js, the two middleware functions that we need are going to be decodeToken and getFreshUser. But I want you to remember something. The order is very important here because decodeToken should be like our first line of defense. It's job is to decode the token and attach req. user or it'll attach to whatever that object is that it decoded to req. user, which in this case because of sign is just an object with IDs on it. So that should be the first thing that we do. And then right after that before we get into the controller, we should get the fresh user, and that's because if we go look at our controllers, let's just take an example of userController, it's expecting not getOne because it's getting ID from there. But, let's see, where is one that's... Not this one, not this one. This is a bad example. Let's go look at post. Right here. So this one right here because the post, we need to update this, but remember the post has an author field and needs to know what author is creating it. So if we didn't do that on the front end, put the author key there, we'd have to do that here. And that'd be fine because we know who the author is because it's req. user. _id because they're the only ones to create this post, so they create it and it's there. So params is a way to get the ID of the resource that's coming in. What I'm saying is getFreshUser will just attach the user of the incoming request. It doesn't matter what request we hit, if we use the getFreshUser middleware, it will attach the decoded token, turn it into---it'll search a database for that user, and attach it to req. user, which can be helpful in most controller operations. Maybe you need access to the entire user to do things. It's very helpful. One place that it's very helpful now that we're using JSON Web Tokens is that, let me ask you this, how would I get myself? If all I had was a JSON Web Token on the client, how would I ask the server, Hey, give me my own user object? How would I do that? We know how to get one user object, and that's /api/user/_id. I don't have the ID. All if have is the JSON Web Token. Well, if you decode the token, it has an ID. Where would you decode the token? On the client? On the server because that's where the secret is. Right, so we don't have a request for that. We don't have a controller for that is what I'm saying. What would you hit? What route would you hit to do that? Because if we do a get to the user, it'll give me all the users. If I do a get/id, it'll give me the user for the ID, but I don't have the ID. So I can't do one of these. You'd have to make a new route. Have to make a new route, exactly. What would that route do? Take the token. Right. The route would --- Be like me, and then it'd take the token. --- exactly. You'd make a /me, which is a common thing you see in tokens. So it'd be api/user/me, and all that would do is just send req. user back. That's all it would do because it would already use this middleware, getFreshUser, which I already found the user before it went to that /me controller. So all me would just be like req. json req. user or res. json req. user.

Understanding CORS
So there're a couple of things we need to talk about before we work on this. The first thing, let's get that other repo up and running because that might take a minute. So if everybody---I recommend you do this. I guess you don't really have to. You can test the API from whatever tool you've been testing. But if you just want to have an app that actually shows the data and stuff, I think it'd be really cool. If you go to GitHub or fork or clone this repo, angular-components. I'll give everybody a little bit to get that URL then we'll go forward. They're asking, Can you send the user when you first send a JSON Web Token and store it in local storage? Yeah, you could totally send a user on the first time. There's nothing wrong with that. If you want to, yeah, you can send the user. But then what if that user object gets updated, and now you have stale data? Having a stale token is okay because there's really no such thing as long as it doesn't expire. But there're use cases for both. Sometimes you might want to do that. I can see that happening with maybe a mobile application or maybe if you have offline capability, that'd be really great. And blogging, you probably do have offline capabilities. So it all depends on how important is it that your data is always up to date. And a little while back, somebody was bringing up about pre-hooks. He wasn't sure if you'd mentioned whether pre-hooks in Mongo only work on save and not on update. I mentioned that. They only work on save, never on update. He wanted you just to elaborate on that. I think it is as simple as it sounds. They did that for a reason. They don't want---you have weird side effects. For instance, if you go look at our userModel and on save is like, Before saving, encrypt the password. So let's say I create a user. Before it got saved, it encrypted the password. Great! I got the same user like a day later, and I updated its username. Now it's going to come back in here and encrypt the password again. The password never was changed, so that's what this check is for. This check is like, The password's not modified. That's great! But the whole point of save is just this is a one-time thing. I only want to change it when it's first created. I think it was designed by choice. I'm not sure of the exact reasoning behind it, but for me, it kind of makes sense because on update, you might have unexpected side effects because you're changing different properties on that update, whereas this is like, Here's a new instance created. It's almost like you're subscribing to the collection and not subscribing to changes on the model itself. The pre('save') is like, Alright, if anything changes in this collection, let me know, and not like, If anything changes on this model, let me know, which I think is what that person is thinking of. So it's not pre('save') on the actual instance. It's listening for stuff on the collection when the instance is saved. If we fork or clone this, this will probably be helpful. And then to get started with that one, so if you're on that one, the first thing you should do is npm install. Get in the habit of doing that. There's a lot of stuff on this one. This one's built using ES2015 and Angular and Webpack and Gulp, all types of crazy stuff. So what you npm install, you can just type in npm start, and you'll see some output here. Don't worry about any of that stuff and keep waiting for it. It's building. It's building all the files. And then, boom, it spits this stuff out. So if you just go to port 4500, you'll see the app. What is npm start do? What is npm start do? Good question. So I think we have it on our API as well. So if you go look at the package. json, there's a field that says scripts, and it's a shortcut. So if I type in npm start, run this command. Npm test, run this command. It's just a way of abstracting away your build system so people don't have to know---they don't really care what tool you use. They just type in npm start, and it should start the thing. If you're using Gulp or Broccoli or Webpack or Nodemon or whatever, if they type in npm start, it should work. So in the case of that app that we just downloaded, it's using Gulp in the Webpack, so npm start calls Gulp. Yup, Mark? Asking about if you're using object ID for user ID, are there security concerns sending back the MongoDB object ID in plain text. Are there security concerns? First, where am I doing that? Let me see. I'm not sure exactly where I'm sending back that---you mean on all the requests? Well, I mean, it is as much of a concern or at least as much of a concern as sending back IDs on a SQL database. So if you have Postgres, you're sending back the IDs. I think for most applications, you need the IDs of things. That's how we set up relationships on a client. So if it is a security concern, then every single other database that sends back IDs is a security concern. It's not unique to Mongo. We definitely need the IDs to identify things instead of relationships. Passwords, though, probably not. And by default, we are sending back the hashed passwords. If you've looked, if you've stepped up and looked, you'll see that we're sending back the hashed passwords. So we'll have to get around that. Where was I? So, here if we go to localhost:4500, you should see the blog. And if you started it up, and if you were curious and you looked in the console, actually, if you click on blog and then you look in the console, you'll see that it actually went and got all the blog posts on my server. This is the mock data that I wrote or the mock data that's in your C database. It pulled it up, and it got it. Everybody see that? So you have the data here. And if you click on it, it'll just show you the blog. Yes? Quick question going back to that last one. So let's just say that you do have something that's more sensitive like orders, and let's say that your IDs happen to be sequential versus these Mongo IDs which are a little bit more GUID like. I presume there's somewhere in middleware or somewhere where you'd say, Hey, if you're trying to get order 2, and you're not really part of order 2, you shouldn't get that. There's some logic you'd have to go within to kind of mock that back out. Yeah, you could totally do that. That's more---yeah, you could do that. There're ways that you can do that. You can set up subdocuments, or you can send up harder restrictions or do some pre-hooks on this type of stuff like, Hold on, let me check before I do this. You could totally do that. So, again, this blog is getting the data from localhost:3000, which is our server. So if I go look at the server, you'll see that there it is. It went and got it. If I refresh the page, you'll see it'll get it again. And it got it again, 304. So in order for that to work, there's something that we need to understand. And I'm just going to go over it briefly because I think people may know about it already. I'm sure a lot of people know about it. Who am I kidding? So in middleware, appMiddleware, we added two more middleware. One is important, but one is very important, and that's CORS. Does anybody not know what CORS is? You don't know what CORS is? So, CORS is Cross Origin Resource Sharing. So by default, if I'm on localhost:4500, and I'm trying to access a route on localhost:3000, the browsers aren't going to let me. They're going to be like, Nope, you can't do it. And it's a security concern. So ways around that include things like JSON-P, which is still pretty widely used, or you just have your server enable CORS. And what that does is, so in Chrome, when Chrome makes a request to your server, it actually makes two requests for one request. It does what's called a pre-flight check. A pre-flight check is just like there's another verb other than, let me see, there's another verb other than get, post, put, and delete. There's one called options. And an options request is what the browser will send to the servers. It's like, Hey, am I allowed to make a request to you? And the server can say Yes or No. So if responds back with a 200, it's like, Yeah, you're okay, which is CORS enabled. So now you can share these resources across different domains, different origins. Or it can be like, Hold up, let me check your domain to see if you're on the white list. Or let me see if you have this. So it can do different things. And then it's like, No, no, you're not allowed. And then Chrome will come back to them like, Nope, you just weren't allowed. So to show you what that means, if I get rid of this right here, so I got rid of that, and then did the server restart? If I refresh, there it is. So Chrome threw an error, and it says cannot load. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 4500 is therefore not allowed access. It's because we didn't enable CORS. Enabling CORS is really easy. It's just accepting the pre-flight check and setting up the appropriate headers, which include this header that Chrome was freaking out about. So it's like, You didn't say that Access-Control-Allow-Origin. So this is a middleware that I downloaded, npm install cors, and it just does that for you. We could do it ourselves, too, because it's really simple. But it's something that does it for us. So by enabling that, I now am able to share resources across different origins. Now I refresh, and it's like, Yeah, you're fine. Yeah? And does that allow any origin then? By default, yeah. Any origin. But the CORS middleware takes options. It'll take a white list array, only white listees or black listees or whatever. So we have CORS in there. Any questions on CORS? That's very important because if you're going to build an API that other people are going to consume, it should probably be CORS-enabled. If you have nginx upon your server, though, normally you're doing a CORS configuration there? Yes, so if you have a proxy like nginx on it, then you would deal with it there, which is a good idea. Yes. Nginx is awesome! So we've got CORS. And I guess this is worth mentioning the other one, this method override one. This is just, quite honestly, I don't know exactly what this one does. If anybody knows exactly what this one does, let me know. I just know that I've always used it. So it has something to do with the put and the patch or something like that. I'm not too sure, but I put it there.

Testing the UI
We'll have that running, and then the important stuff is now if you try to go to admin, and if you aren't signed in, it'll bring up this form. Oh, snap, you're not signed in. So you cannot go to admin unless you're logged in. So then let's log in with one of our, or let's try to log in with one of our scaffolded users and see what happens. So if we go here, I'll try to log in with this person. And the password is test. Hit SIGNIN. It goes in. Everybody see that. It just went in. So that's great, but also watch this. So now if I go back, and I say username is that, password is this, and I enter. It's like, Oh wait, nope, now you're unauthorized. So that's the sign-in stuff happening. That's the stuff that we already made. That was the thing that we just made, the verifyUser stuff. So that's sign-in. We already made that so this should work for you. The thing that probably is not going to work is signup. So if you go to signup, and we sign up---I guess that does work. Oh, wait, I have a token. That's why. I'll get rid of this token. Actually, did I enable that? Let me look real quick. I probably forgot to take it off. User, userController, and then post. Yeah, I fixed this one. So this should work too. I forgot. I was thinking of something else. So signup should totally work for you as well. We didn't really need anything to sign up. But if you join me in userController. js, you'll see a difference than what it was a couple of steps ago because userController. js on the post method used to just be, let's just create a new user and send it back. But now it's doing something a little different. What's it's actually doing is creating a new user based on whatever req. body is. So this is going to return an instance of the userModel of Mongo or Mongoose. Actually, I don't know why that's even there. This gets to happen on pre('save'), so we don't really need this here. I think I made a refactor and forget to get rid of it. But it won't hurt to have it. But we actually absolutely don't need it. So I'll just leave it. And then save the user, which will call hashedPassword. But for some reason, I'm doing it already. And then send a token back. So we also want to send a token back on signup. We already did it on sign-in, now we're doing it on signup. So that's what we're doing here. Again, we don't need this because the pre-hook is going to fire before this. The pre-hook will fire before this, and the pre-hook does this already. Actually, we don't even have something called hashedPassword anymore, so that's like a complete refactor. We're not even using that. So, again, this is the signup method. This is the new post for user. You can no longer create a new user resource like you could before. You actually now have to do this. And that's what you just saw when I signed in. So just to demonstrate on the terminal, that's http localhost:3000, whereas before we could say api/users/, and it was like, Yeah, I'll just get your username=that. And that would create a user. Now it's like, Nope, oops. That's not going to work. You can't do that anymore. You actually have to give me a password now too. What does that even mean? I don't even know. Let's see what's happening. It looks like we have an error here. Cannot read property, undefined. I forgot to put a return here. So that should be an error. Let's try that. There we go. So now it's like, Cool, now it created a user. She's got to give me a password, whereas before no password, it was just, Yeah, just go ahead and create. Nope. Now it's like, You have to give me a password. And, again, it's all good. Any questions on that or why I had to put that return there? Otherwise, it broke. One return key broke everything because what happened was it called next, but there was no return in front of this, so it went down to this line anyway. But because there was an error, there was no user, so that's why it was like, I can't read ID of user because it did call next, which called next, but the execution in this context continued to flow down here because I forgot the return or to do an else. And there is either an error a user or an absence of a user, so that's why it freaked out. So just make sure you put a return in there.

Exercise 12
So your objective now that we have all this stuff signed in is that I want the ability to--- so once I'm signed in. Actually, let's make a new one--sara and 123. So once someone's signed in, I need to be able to come in here and make a blog post. So I'm like, This is my new post. And I'll start typing in some stuff for my post. And I click Done. It does work. Did I already do that? I thought I stopped that. Hold on one second. Am I on the fix branch? I am on the fix branch. Why is all that working? That should not be working. So this is what it's what it should look like when you're done. I just showed you all the answers. I'm like, Wait, this stuff should not be working. I'm like, What are they going to do now because I'm pretty sure---I'm on the fix branch. It seems like a lot of you knew that too. But that's good. I found some errors on the fix branch, so if you want just pull this one down in 5 seconds. That's great. I don't know what you're going to do now because---what are you supposed to do? Git push origin step-12-fix. Pull that one down because I just made some changes. Just do a git pull, and it'll pull down all the branches. You don't have to specify the branch if you're not a Git person. Great, so now let's look at what you will be doing if you haven't seen the answers already. So, this is what you will be doing now. First things first is this post thing is still already here. That should be taken off too. What you will be doing is if we go into these prospective routes here, remember we talked about maybe 10 minutes ago about the different routes we need to lock down. That's what you're going to do. You're going to use the middleware that we created in auth. js, the getFreshUser and the decodeToken, to, first, lock down the route that we need locked down. So if you put decodeToken on any route, it'll lock it down. And then immediately after, if you put getFreshUser, it'll attach the user to the req. user. Let's see how that works again. So if you call decodeToken, which is a middleware, if you put that in front of any route or any middleware stack, anywhere middleware can go, it will try to find the token. And if it finds it, it will attach the object that token decodes to to req. user. If it doesn't find it, it will error out. And then immediately after that, the next middleware that comes in that series, wherever you put decodeToken, if you put rec. user, I'm sorry, if you put getFreshUser, it will then grab the user ID that the decodeToken just made and look for that real user in the database, not just the ID, and attach that to req. user. So it'll overwrite req. user with the full user object. And then it will call next. So if you put those two in that order, you're guaranteed to have the token decoded and the full user already there before you get to your controller. Now, remember, we can put any number of middleware we want on the route. We can put an array of middleware, we can put comma-separated middleware, whatever we want. If you put them in that order, decodeToken followed by getFreshUser, I can guarantee that's how it's going to work. So knowing that, go into the appropriate resource route files and add that middleware stack that I was just talking about, one or both or none, depending on what you think, we just talked about which ones we should lock down, and do that. Just remember it can take an array of middleware. It can also take comma-separated middleware. But we just have to make sure we put it before the controller. So, for instance, if I had a middleware, I would put it here. So if I wanted to put a middleware on a GET request to /api/category, I would put the middleware here. And then I'd put a comma. If I wanted to put another middleware, I'd put another one here, and I'd put a comma. If I wanted to put three in here, I'd put three middleware in here, and I'd put a comma. So that's how you would put the middleware on the specific routes. Is anybody not following me there? So this is where I'm putting the middleware. I'll just make one right now so you can see. So if I said---let's do it on post. So if I go to the postRoutes, I'm just going to put one right here. So I'm just going to make an end-line middleware with an anonymous function. And I'll put a comma here. So just by doing this, I now have middleware on here, so I can say req, res, next. So I'm just going to say logger. log('HEEEY in middleware'). Then we're going to call next. So this is going to happen before I get all the posts. So let's check that. So let's go to the terminal output. And if I refresh this page, I should see that. And I didn't see it. Wait, something broke. Let's see. Let me see. I broke something. Did I leave CORS off? It looks like I left CORS off or something. CORS isn't enabled because you have to do it. That's why it's not working. Sorry. I already told you how to do that, so now you know how to do that. But I'm just going to do it right quick so I can show you what I'm talking about. If you don't have this, just npm install it, npm install cors. It should be in the package. json, so you should be good. So I'll refresh that. Do you need to overwrite too? We should totally do overwrite, but I don't need it for what I'm trying to show you. But, yes. There we go. Let's check it now. Server Error, 500. Typos, man. Those typos. See the error log though? It's pretty cool. It's easy to spot. There you go. HEEEY in middleware. Had to solve some of your code to get it to work, like pulling my teeth. So just put any middleware you want right here. If I wanted another one before the controller works, I'd put another one here. So using those two middleware that we talked about in auth. js, line them up so that we protect the resources. So, for instance, one protected resource we know we want to protect, you should never be able to make a post if you're not logged in. So there's no way I should be able to do that. So we know for sure decodeToken should be there. So that means we should be expecting the token to be on that request before you make a post. Do we actually need to refresh the user there? Maybe not, maybe we don't need an extra database query just to create a host. It depends on what you're doing in that controller method, but at the very least, we definitely need to verify that. So let's do that for, what is it, 2 now? Let's do that for 30 minutes, and then we'll come back at 2:30.

Exercise 12 Solution
Why do we have both an index. js file in the root directory as well as a server. js file in the server directory? They both seem to be doing the same thing. Are they? Let's take a look. So index. js. It's the entry point to our server. What is it doing? The first thing it's doing is booting up the config, which I think is very important. Get that thing ready. The second thing is it's requiring our app, our server application. And then it's listening on the port. So this is actually starting our server. If we go look in server, server, I don't see an app. listen in here. So if they're the same thing, if I come in here, and I say node server/server. js, I get the database. It's seeded, that's great. But the server didn't start up. And that's because it's in index. js. And the reason we did that is because if we go back to when we talked about testing this yesterday, I needed to export the app for testing, and that's why I have this comment down here--export the app for testing. So because I had to export the app for testing, that means I need to create another file in order to start the server. I could also just start the server in this file and still export the app. There's nothing to stop me from doing that. But I want my test to be in control of whether or not I want to start the server or not. So it's just a way of having more control on what is turning the server on or off. And also server. js is connecting to the database. It's seeding the database. It's setting up all the middleware. It's setting up error handling, whereas index. js is just starting the server. That's all it is. It's like, I'm just going to start the server. I'm just going to load up the config. That's all I'm doing. There's a little difference. But good question. Keep them coming. Any questions before I get started on this stuff? Everybody just want to see it? You probably already looked for it. So now let me check out to the fix. What is all this? Whatever, I'll push it up. I'll push this stuff up right quick. So now if we check out to the fix branch, which you might already be there, step-12-fix, so how does this look like. Well let's just start at the beginning of the categoryRoutes. So my approach was this. I just wanted to show you a simple way, I wanted us to understand exactly how middleware works. This is probably not the way I would do it in my application, but this way demonstrates how middleware works. So the way I did it was I just made an array, and I placed it in the middleware that I want to run next to each other. And then I just placed that array on any route that I want to use that on. So the one that we definitely need for sure is the decode token. That's doing the verification. The other one, auth. getFreshUser, is not necessary, but it's great because this guarantees us that on any---what this means is, first, because we do auth. decodeToken, that means we're looking for a token. And that means if this passes, that means there was a user. So what I'm saying is if there was a user, let's just go ahead and get the full user while we're here anyway. So that means on any request or any controllerRoute we have access to req. user. That is not the same as the params. The params/id will look at the ID and give you the resource with that ID. But that resource is not always the user. Like, for instance, in this case, this param ID, this isn't going to give you the user. This is going to give you the controller with that ID. This will give you the user. So now we'll have req. controller, I'm sorry, req. category and req. user. We'll have both of those. So that's why we did that. Is it necessary? Only if the controller method is relying on it is it necessary. In our examples, I don't think any of our controller methods were relying on it, maybe one or two. We'll see in a minute. So it's not necessary. I just think of it as it may be nice to have. But if it's an expensive database query to go fetch the user, you probably don't want to do it. Or maybe cache it, I'm not sure. But it's nice to have it. So, as far as locking down the routes categories, only authenticated folks should be able to make categories, so I'll put it there. Only authenticated people should be able to update a category, so I'll place it there. And only authenticated people should be able to delete a category. Everybody else should be able to get one category or get all categories. If you can imagine in a WordPress blog, it lists all the categories on the right or whatever. You can click on them, and it'll show you all the blog posts that relate to that category. Something like that. Any questions on categories? Anybody disagree with the routes that I chose to lock down or have any opinion on other routes, or maybe you locked down everything? Now if we go into the postRoutes, this one's pretty much the same thing. Again, I have this array, and I'm locking down the same routes. On the create a post, on update a post, and delete a post, you should be authenticated. What happens if I have a post that has an author on it or a user, and then I delete the user? Does the reference to that ID in the post stay there? Think about that. Do I now have to go find the post with that ID and get rid of it? Or will Mongo just handle that for me? Is it atomic? That's a really good question. The reason I was asking is that I ran into that the other day, and I wanted to know if anybody else knew of the top of their head. Well Mongo doesn't deal with it because they don't know about relationships. Mongo definitely doesn't care. Will Mongoose do it? Yeah, that'd do it. They'd get rid of that reference. Would they then replace it with null? I don't know. It's just not there anymore. Or I could be wrong. Someone prove me wrong. I haven't use the Mongoose since like version 3 or something, and now they're almost on 5. So maybe they changed it. But it definitely was the case. So userRoutes. This is the only one that's different. So, first, I added the route that we're talking about for me. So if I want to get me, let me verify you first, and then I want to getFreshUser. So this is where getFreshUser actually does come in handy because by the time I get to controller. me, I can just return req. user. I can say res. json, req. user, done. I don't have to do anything else in that controller because getFreshUser already got that thing for me. So we can go look at that if we go look at the controller,. me. That's literally all it's doing is sending that back. Do you need toJson? We'll talk about the toJson in a minute. I'm glad you asked. I was just like, Is anybody going to ask me about that? Yes, we'll talk about that in a second. So the routes that I chose to lock down here besides the me were only the put and delete. So you should be authenticated if you want to update a user or delete a user. But if you want to get one user, I'll let anybody do it with the ID. If you want to create a user, yeah, I have to let anybody do that because that's signup. So if I require you to be authenticated to sign up, then you would never be able to sign up. So I don't want to put that there. And then get all users, yes, I'll allow anybody to get all users for the sake of a blog of being able to look at all the authors and seeing what they wrote about. Any questions there? So, back to the toJson thing. Where is it at? So I made a new method on the UserSchema that's called toJson. And all it does is it uses the toObject method that you can call on a document that's built into Mongoose. So that's going to convert it from a document, which looks like a JavaScript object. I was saying this before, when you retrieve something from a database using user. find and all those things that come back, they look like regular JavaScript objects. But they're really not. They're actually documents that have all these atomic operations on them like. save and. remove. That's not a regular JavaScript object. So if you call a toObject on it, it's like, Okay, cool, I'll remove all those atomic operations and literally just give you a regular JavaScript object, which will have the same properties on it. It's not going to change any of this stuff. All this stuff will be there. It's just going to get rid of all the other stuff that comes along with documents like. save,. remove,. populate. So you can't do that. So that's what toObject does. So I do that first, and then I delete the password property on it so I don't send back the hashed passwords on all the calls. And then I just return the object. So that's what toJson is doing. So it's making sure I don't send back hashed passwords. So that's one way to do it. This is how you would do it on an instance of a document. And the way you would do it as far as a query on our populate the author, I could put a comma here and say, You know what? Only give me the username property of the author. I don't want everything. If I got rid of this, and it was like, Just give me the author, it'll give me the entire object, which is the username and the password, the hashed password. But I'm like, I just want the username. Don't give me the password. So that's another way to do it during our population. And then there's also another way to do it during queries, which is to, I'm not sure if I'm using it anywhere else, let's see, I might be using it here, you can use the. select method on a query, and you can put negative (-) in front of the field you don't want it to select. So if I say -password, it means don't select the password. That's another way you would do it on the query. So those are the three ways you can do it. On the document, I made a method, on the population, I just pass in the properties that I want, on the regular query, I can use the. select method and say -the field that I want to exclude, and then call exec. then. So then all those will do the same thing. This is ensuring that I actually never see a hashed password in my data. Any questions on that stuff? Somebody was just mentioning it appears an authenticated user can update another user's account if they know the ID. Yup, that's totally true. So, an authenticated user can update another user's account if they know the ID. That is totally true because we haven't set up any of that. So if we go into userRoutes, user ID, put, we're going to put here, there's nothing stopping an authenticated user who knew somebody's id/id from coming in here and changing this stuff. You're right. There's nothing stopping that. How would you get around that? Off the top of your head, what would you do to get around that with all the stuff you know about Express? Depends on your requirements. Huh? Depends on your requirements, right? You might want them to be able to so. Right. It all depends on your requirements too. So on a role-based system, which most blogging platforms are, you have authors, editors, admins, and they're all users, but maybe you want a user with an admin property to be able to update a user with an author property. So it all depends. In our case, they're all users. There's no role-based. So maybe it's dangerous. But how would you, how would you check for that. How would you prevent that? You could just do an if or. merge, say if user ID equals update. id, would that work? Yeah, you can do that. What's a better way? You don't get any better. You sure? You sure it doesn't get any better? What if you can do that before you even get here? What if you make that check before you even get to this controller function? It's just some middleware or something? Yeah, you just make a middleware. It's like, Hold up, let me make sure these IDs match up. You know what I mean. Let me make sure the req. params. id equals req. user. _id. And if they don't, get out of here because on this put, you have req. params. id, so you get this ID of the user you're trying to update. And then you also have req. user. _id, which is the user that sent the request. So you see if those two match inside of a---you're going to put that right here. You just put it right here. You just make some middleware that would check those two, like, If they don't match, res. send unauthorized. Like editing yourself or something. Yeah. Another approach is you can just get rid of this ID thing. You just would not have IDs. That way, people can't update anybody else but themselves. So if you wanted to update yourself, you would just do a PUT request to /me, or you would just do a PUT request to /users, and then I would know who you were because your ID is on req. user. It wouldn't really solve the problem, but it would hide the IDs. It would hide the IDs. I would never be querying the database for an ID. Unless you updated it later. It would never happen because the reason this happens is because, if we go to params, I'm querying the database for an ID. But if I never have params, if it's gone, and the only way I know about an ID is off req. user, and the only way I know about req. user is off of a decoded JSON Web Token, I'm guaranteed that the ID that I'd be looking at on req. user is the person who actually signed in. Whether that's you or not, that's not my problem. Somebody might've got on your computer, but I know that it is the person whose username is this and whose password is this. So you see that a lot too with token APIs. They'll not use the /id stuff anymore when your only access resource is about yourself. Then they'll bring the ID stuff back when the access resource is about other things. So it's a little different.

Exercise 12 Solution, Continued
So this should be working. So if you go, npm start, that's still running. We should be able to come in here and have that right. So if I go to admin, it'll go to admin. But just to show you that this is working, if I open up this, the console, I go to resources, I get rid of the JSON Web Token, Angular is saving this by the way if you're wondering how that got there, and then I refresh, and if I click on admin, it'll be like, No, no, you've got to go sign in. I don't have an account, so I'm going to sign up. This is the thing that we just made, so let's test that out. Let's sign up for an account. That worked. It brought us to admin. Now if we go look back at the resources, you'll see that the JSON Web Token is there now. It's this thing right here. That's the JSON Web Token. You see that? And what I want to show you is what is happening with every single request. Remember, we said the JSON Web Token must be sent on every single request. And it must be on the authorization header. And it must have Bearer, space, the token, or on the query param. If we look at the output of our terminal here, it's definitely not on the query param because if it was, it would show it right here. If it was on the query param, it'd show it right here. So it's not on the query param, so we're assuming that it's on the header. Also, here's that options request that I was talking about as far as CORS. You'll see that it's saying OPTIONS, OPTIONS. That's the pre-flight check that Chrome is sending to make sure that we can access these resources. So now let's do this. So I'm going to say my new blog post, love to write javascriptssss. I like them JavaScripts. So if I hit DONE, that totally created it, and my blog is there. But let's see what that looked like. Wait, I guess I need to have that open when I do it. Otherwise, it won't do it. Let me go down here. That's really annoying. So let's go back to admin and try that again. So I want you to see what the headers are, so another post, blah, blah, blah, blah, blah. And DONE. So that made a post. Is this the POST request? No, that's a GET request. Is that the POST request? Here it is. So here're the headers right there. See that? So here are our heeders that we sent--authorization header, Bearer, and then the JSON Web Token. That's Angular doing that. So before every single request, Angular goes into local storage. It looks for the thing in local storage with the key that I gave it, which is in this case, it looks for anything with this key, ngblog-token, and if there's something there, it grabs the token. And then it attaches it to the header authorization property as Bearer, space, header before the request goes out. Can you show that again in the code? In the Angular code? Yeah, or is that against the rules. It's not against the rules. Does anybody want to see that? I don't know. This is a long class. Anybody want to see that in Angular? Or you can just tell me where it is, and I'll look at it. It's on the blog branch. Go to shared. js. It's in that file. You'll see it. Everybody with me on how that works? Yup, Mark? They're wondering how does this all work with API key-style authorization. Can you just treat the API key as a pre-built token of the username and password? How does this work with the API key style? So API key is not the same thing as this. So what we're talking about is user authentication and stuff like that. The API key is more like an application, identification, and authorization. So API key is like, I have this API server, and let's say it has, I don't know, three clients. We have a web client, we have an Android client, we also have an iOS client. So in order to only allow requests to come in from those three clients, we might make API keys for those three clients. Maybe they all have their own different API key; maybe there's just one API key. That's not the same as the JSON Web Tokens, which are what the users would use once they were already authorized on those clients. So the JSON Web Tokens are for the users or for any type of authentication you would use, whereas an API key is like, I want to authorize this client to use this API. So could you use a JSON Web Token for an API key. Yeah, I guess you could do that, but that's completely different than what we're talking about. You would still put that on a header too more or less. Then someone else is asking for you to talk about slugs and Slugify. Slugify is awesome! I'm not using Slugify here. So the reason I'm not using Slugify here, there's actually a module in Node called Slugify that, for instance, you see the title of this blog post is called 10 reasons you should love IE7. It's space delimited, but if I click it, and you look at the URL, it's dash delimited. So that's a slug. You would totally do that on the back end. But when I made this front-end thing, we didn't have a back end. The first two days we made this, it was all Angular, so I had to do this on the front end. But on the back end, yes, you would turn this into a slug. There are Node modules that do it pretty easily, but if you're going to do it yourself, the code is actually in that Angular repo. But really all I did was just ran it through a regex that looked for a space and replaced it with a dash. That's all I did. But a proper Slugify would probably lowercase everything and stuff like that. But there are Node modules that do it, and you should totally do that on database, and you should probably save the slug in the database on the model next to the other stuff on the post. But, again, we didn't do that. But you should totally do that. Any other questions? Yes? What've you got? Well, it's (inaudible). So it's attaching that JSON Web Token to every request, right? Yup. So let's say you're requesting to some other website, and you'd provided some authorization header, it'd be overwriting it with the JSON Web Token, right? If you made a request to another website --- --- and you're like, Oh, this website wants this authorization, so you supply that, and then you send it. Well, it's going to intercept that and reroute the JSON Web Token. But you can turn it off on a route basis. I have it set up to when we do the HTTP, you can set it --- You'd have to change this URL? --- and you can say don't authenticate this call. You can do that.

Deployment
Deployment Overview
I had to cut some stuff. I cut the real-time thing because that actually takes a long time, but it will be in the repo. So if anybody wants to look at that stuff, it'll be in there as far as the sockets, having web sockets and being able to write up blog posts in real time with somebody else. That's going to be in there. You can look at the code for it. The thing that I thought was more important was to get in was deployment. So that's what we're going to do now. So we have some notes on deployment. I have some notes on protecting your routes. I forgot I had that. We didn't need it though. We talked about it already. So deployment--deployment's actually really easy. I probably didn't even need to write notes on this in my opinion. But what we're going to do is I'm going to talk about this stuff, and then we're all just going to deploy the app together. You can follow along with me and just watch me, or you can do it on your computer. But we're just going to do it together and walk through the processes of what it takes to deploy a Node app. And we'll just, I don't know, let's use Heroku. It's probably the easiest. With AWS, we'll be here forever. So deployment with Node is relatively easy. All major, this is the first typo I've had today. I promise, this is the first typo. No, I had one earlier. Only two typos today. That's actually really good. So all major platforms support it these days and adhere to conventions to smooth the process even more. Some things to consider when deploying: Use envs for secrets; don't check them into source control. Don't check your secret stuff into source control. Once it's there, it's there forever. I don't care if you checked it into GitHub and you're like, Wait, hold on. Let me get that out. Okay, you got it out. But there is this person who has built this service that just listens to all the hooks on GitHub, every single thing that comes into GitHub, and he listens for this stuff, and he logs it. He logs everything. So that event was already sent out. So whoever's listening to that public API on GitHub already got it even though you already took it off. So it's still there. The chance of them using it? Probably not. But I'm just saying, it's never gone. So the only way to get around that is to just to change your secret. Then you've got to go change your stuff. So just don't put it on GitHub. Make sure you're error handling. We talked about that. That's going to keep your server running. So if you're being weary of errors, try/catching, set up middleware, anywhere you think there might be an error, you probably want to handle it. Otherwise, your server's going to see it, and it's going to crash. And if your server crashes with, I don't know, if your server crashes with, where's it at, with five people in here writing their blog together, it's not going to be fun. So handle those errors. Make sure all your dependencies are being installed. So a misconception is people will deploy, and they think that the thing that they're deploying to installed all their dependencies, but it really didn't. For instance, you might have a global dependency that your app is relying on. I don't know what that might be, maybe you're using Gulp to build your stuff. But you're using a global version of Gulp on your computer, so when you deploy it on Heroku, Heroku does an npm install, Gulp is not in the package. json because you're using it globally. And then you tell Heroku to do a Gulp build, and it's like, What's Gulp? I don't know what that is, because you never put it in your package. json. You were using a global version. So make sure all your stuff is installed. So anything that your application needs, make sure it's in a package. json. Speaking of which, devDependencies and dependencies. So by default, what Heroku will do, and I think most other platforms do to, when they run npm install, they actually do something like this, they say npm install --production. And what that does is it only npm installs stuff in the dependencies section. It's only going to npm install this stuff. It won't npm install this stuff, the devDependencies or maybe even peerDependencies. I'm not sure if it does that. PeerDependencies has gone away anyway. But for sure, only install that. So if you were relying on something, again, like Gulp, if you're going to tell Heroku, I want you to install everything, do a Gulp build, but Gulp was a devDependency, it's going to be like, I don't know what Gulp is. I never installed it. So, again, make sure that all the dependencies that you need are installed. And it all comes down to what you need to happen before you deploy. Some people like to build before they deploy. Some people like to have their code built during deployment. So it all depends on what you're doing. If you have a CI, and your CI is testing and it's building, or maybe you just give it to Heroku, and Heroku does the building, or maybe you build it locally and give it to Heroku, I'm not sure, that all depends on what you're doing. Again, if you're going to have your platform build it for you, make sure it has access to all your build tools. Heroku and AWS don't have Gulp just hanging around waiting for you to use it, or Webpack or Grunt or whatever you use, it's not just there chilling. They've got npm for sure, but they don't have that other stuff. You can also freeze Node modules by running npm shrinkwrap. Npm shrinkwrap will just freeze the versions of the dependencies so every time you run npm install, they don't go fetch the latest. It's like, Freeze everything to be this version, and that's it. And you can do that. And don't hardcode things like development URLs. For instance, in our userController, let's say we made a call to Facebook in here. We were like, Oh, yeah, Facebook or like, I don't know, otherServer. get, and it was like some URL here. This is a bad example. It was also another port. We have another server and another port that was localhost, and it was on port 5000. By hardcoding that in, what happens is now when we deploy this server, and when this route gets hit and then tries to hit localhost:5000, it's going to be like, What's that? It's not going to work. And then if you deploy the server that's on 5000, it's got its own URL, then it changed too. So don't hardcode these things. You can pass those in with environment variables. Anything you need to change on a per-environment basis should be an environment variable. And then you can use the config to change those things. Another thing you don't want to hardcode is database URLs, stuff like that. So we did a hybrid approach of where we hardcoded the database URLs but only for a specific environment. So if we go to our config, like development. js, it has this database URL. Yes, it's hardcoded, but this URL will only ever work in a development environment, which is fine. We don't really care. This is exactly what we want. Testing. js--this URL is hardcoded, but it will only ever be here during testing environment, which is probably also fine. But maybe you run your tests somewhere else, and they have a different environment variable for that. So you need to add that here. But for production, you definitely don't want to hardcode that. Production will be an environment variable because you're going to be binding to some hosted database. Like on Heroku, they have hosted Mongo things with other services--MongoSoup, MongoBeta, whatever freaking Mongo thing they have on there. You'll be binding to some environment variable there for your URL. So that's why I didn't put anything here. We're going to do that next. And ports, ports is another one. So, again, development, I think we already took care of this. Process. env. PORT. We don't know what port we're going to be on. It's whatever the thing we're going to deploy on says what port we're on. And they always put it on this. If there's a platform to use, it's that. It's on the PORT environment variable or default to 3000, which is why ours is on 3000. Any questions on that? Another good practice is to put stuff like this in an environment variable too like this time and days. What if we wanted to go change this? Now you've got to go redeploy just to change this one line. It is an environment variable because I could just change the environment. And then the environment will just restart, and it's still good. So stuff like this is great. Put in an environment variable.

Deploying to Heroku
Like I said, I'm just going to go through deployment. I think it's better---I wasn't just going to have notes and like, This is how you deploy, and this is this. But it's so much better if we just walk through it, especially if you want to follow along on your computer, or you just watch me go through it and watch me stumble through all the nuances that everybody goes through because that's just what happens. So let's do it, let's just go to Heroku. And especially if you never deployed on Heroku before, I think this'll be great to see somebody who thinks they know what they're doing how to do it. So that'll be really cool. So let me see. Don't be trying to count my password. I see you all over there. So let's just make a new one. We'll make a new app, and we'll call it ngBlog-api. Only lowercase. We'll use this convention then, there you go. Create App. Now Heroku kind of upgraded. Now they're integrated with GitHub so you don't have to do anything anymore. Before you had to do some stuff, but now it's just attach it to GitHub, push it, it's good, which is what everybody else does, so I don't know why it took them forever, but they got it, they got it. So now first you need to make sure you have this Heroku toolbelt. So I need to do that. I know I have it, but I just need to make sure I'm logged in. So I'm just going to say heroku, what was it, login? There we go. So now I'm logged in. Stop doing that. There we go. And then we need to add the remote URL for Heroku. Our version of Git is so out of date. I thought I updated that. I guess now. I went into Heroku's office a couple of weeks ago. They have a really nice office. I don't know if anybody's been there. It's ridiculous. It's bamboo everywhere. Everything's bamboo. It's really nice. They have this nice rooftop room where we had a party. It was really nice. So now we've got that. And we can verify it if we type in git remote -v. We'll see that, oh look, there's a remote URL by the name of heroku, and it's our API. So they got that. And then let's just go ahead and make sure I've got everything committed here--git diff. That's not important. Let's just stash it. Great! So we have a clean thing here, and now all I have to do is just say git push heroku master. Now who thinks here if I push this Heroku that it's going to work the first time? It's just going to work the first time? I know it's going to fail, but I want us to see the error, so let's just do it. What is it? Push heroku master. So let's just push it. I just want you to see the logs. It's like, Node. js app detected. Great! And then it injected these environment variables into our app. And then it's like, You didn't tell me what engine you were running, so I just figured it out. I'm restoring any cache that was there from last deployment. It npm installed some stuff. And now it's attempting to launch the app. And it said it did it. It totally did it. So now if we go to heroku open, application error. It looks like it crashed. So what we can do is we can say heroku logs -t, let's just do logs. Let's see what happened. So it went in here. It ran node server. js. That's not the command I wanted it to do, so that's probably why it crashed. It should be index. js. So it broke right there. Why did it do that? Why did it run server. js? That's because---I don't know why it did that to be honest. I would have thought it would have run this because it's supposed to run npm start, but I guess not. But I don't know why it did that. So what we need to do is we need to make a new file on here on the root, and we'll call it proc, p-r-o-c, file. This is something that Heroku wants. And what we can do in here, we can say web: and then give it the command that we want to run, index. js. I think that's the format that it wants. I think that's the format that it wants. I might have to look at it. Let's look at. I'll say procfile Node. js heroku. What's the procfile guy? Oh, yeah, that was it. So it says it defaults to node server. js if no scripts. start entry is present but server. js. So I just said node index. js instead. That's step one. I got that out of the way. Another thing it was freaking out about, if we go look at the output, it's saying something about couldn't find the appropriate engine or something like that. Where did it say that? Did I pass it? Wait, hold on. Here we go--engines. node: unspecified, engines. npm: unspecified. So you can tell it which version of Node you want this to run in. By default, it uses the latest, which is 12, so we don't have to put anything. But what that means is come in here and say engines, and then you can say node, and then you can put what version of Node you want it to run. But I'm not because this is going to run the latest. So we're fine. So we got that. So now if I deploy, is it going to work now? Everybody think so? I didn't see any other errors. Let's check it out. So you start this, get a commit, add --all, -am'chore'. And then we'll just do git push heroku master. Everything up-to-date. I know why. I know why. Heroku pushes the master branch by default. We're on step-12-fix. That's why. That's why it's freaking out. It's deploying the master branch. It doesn't matter what branch we're on here, it will deploy the master branch, which is really weird. So we need to git checkout master and git rebase origin/step-12-fix. I think that's good. Let's check it out. Is that the right thing? Yeah or no. Hold on. Let's see. I need to push this up, step-12-fix. Now let's check out the master. Come on, there we go. You know exactly what I want. I don't why you're tripping. Let's just do a rebase. I think we're good now. We're good. It even gave it a little Heroku logo. That's dope. So now if we push the Heroku, let's see what happens. And I knew that I needed the master branch because it said everything was up to date. I knew everything wasn't up to date because we just made a whole bunch of changes. That's why I knew it was on the branch, and there was some weird stuff going on. Then I remembered after running run into that error or that problem 30 times that it only does the master branch by default. Watch this thing break on the bcrypt. Watch. Watch it break. Then we'll just be in the same problem you were on Heroku. Then we'll just give up. We can blame Windows again. I don't know. I don't know if this is going to do it. Let's see. It better. This thing's on a Linux box somewhere. We'll let that build. Somebody's asking if you use GitFlow? Yeah, GitFlow's awesome. For some reason, I don't have it in this environment. I messed up my Git. I deleted it and put some other thing in there. But, yeah, GitFlow is great. I like GitFlow. But then again, I'm not that good at Git either, so I don't know. I might just start using GUIs now. I have a few, I think I have tower. Do I? Is it called tower? The GitHub one is okay, but there're better ones out there. It looks like everything is working so far. Verifying deploy. It deployed it, now it's trying to check it to make sure it did it. It looks like it did something. So before we go look at it, let's go look at our dashboard here. Let's refresh. And let's go to Activity. It looks like this guy's been deploying stuff. It looks like me. He's been doing some work in there obviously. He's earned his keep. Let's check it out. So let's say heroku open again. That's going to open us up. Oh, another application error! So we can say heroku logs and see why. Let's see what happened. Starting process with command 'npm start'. It freaked out on npm start. Why did it run npm start when I told it to do something else? I'm not sure why it ran npm start, but that's an easy fix. Let's come in here and just do node, man, that's all I want you to do. Don't do anything else. So that'll fix that. Another quick thing we can do instead of having to deploy it every time, we have this other thing that we get from Heroku called foreman, which is a local, it's like how your app would run Heroku if it was on Heroku. And we can just say foreman start, and that's going to start our app on port 5000. And it's going to run it like Heroku would run it. So if we go look on port 5000, Cannot GET, of course, because we didn't have a request for that. But if I say what about api/users, can I get some of that? Yeah, you can get that. So our API's working. That's great.

Configuring the Deployment
So we're almost there. I'm just showing you through all the stuff. I don't want to just be like, Here's how to do it, and then you forget how to do it. I want you to see these problems and how to resolve them. Great! So now we've got that. Can anybody think of anything else that we might need? There's like one big one, a huge one. Maybe I'll just show you. Let me stop this. And now let me try to run the API again. Now I'm just going to run it locally. Let's see what happens. What's that? No Mongo? Yeah, no Mongo. We didn't tell Heroku that we wanted Mongo. It's going to try to connect to some database. And we also don't have our production database URL. If we go look in our app, there is no production database. There's production. js, but there's no db. url. There's nothing here. So it will just throw an error inside of server. js. It's going to do config. db. url. There is no config. db in production. js. So this will just actually just error out. It will be like Cannot read. url if undefined. It will get that error. So what we need to do is, one, let's create a db thing here. We'll copy this one, go to production, we'll put it here, we'll paste it. And then we need to get rid of this with something else. So to do that, it's pretty easy in Heroku, at least it used to be. Let's check it out now. And we can go to Resources, and we can say Find more, yes, find more resources. And we can go find the closest Mongo thing that comes up. They used to have so many of them. Here we go, compose. I think they just got bought up by IBM, did they not?, two days ago. $18 a month? That's not what we want. We want the free one. There it is. That's the one we want. So I can just type in this command here, or I can also click a button somewhere. Where's that button? I guess they don't have that button anymore. So I can just use that command and come down here. I can just type that in. Great! So now we have Mongo added. Now all I've got to do is get that URL. Do I know the URL of this Mongo database? Nope, no way. But I do know the environment variable because it will tell me if I go read the docs right somewhere here. Oh, here we go. It will be MONGOLAB_URI. So that's our URL right there. So I'll just copy that guy, and then I can come back in here on the production. js, and I'll keep that there as a default. But what I really want to do is process. env. that or URI. Is that what it was or URL? URI. URI, okay. So that's going to be our URL or whatever that is. You see how that works? That's how I get my database URL. But if it was in production, we wouldn't want to provide it or would we? No, we wouldn't. It's going to break anyway. It's still going to break. Yeah, I guess you really don't need that there. What I would do is I provide it an or, and I have another environment variable here and another environment variable, three backup ones just in case. That'll get loaded. We also need to verify that Heroku is, in fact, running in production mode. So what we do is, why did it log me out? I don't even know. Let's go back in. And we can do this because Heroku actually makes it pretty easy if we go here, and then blog. If we go click on Settings, we can look at all our environment variables right here. So there is the MONGOLAB one that we just added. We can edit; we can add more. So let's just make sure. I'm sure it is on by default, but let's just guarantee that it's on production. So we'll say production. I'll also go ahead and add in my JWT secret. What's the name of that? It's called process. env. JWT. So just capitalize JWT. I'll call it JWT, and it will be called kittensBacon, kittensBacon. So then we've got that. Are there any other environment variables that we need to put in? Port's going to be given to us, so we don't have to... I think we're good there. On production. js --- On production. js --- --- you should remove that or thing. --- Yeah, thanks dude. That would've broke. So we'll save that. When you hit Save, it'll refresh the server with the new environment variables. Yes? Port's not listed there. It's not listed there, but it's there because it's dynamic. It's not a set value. It might be 12345 today, and it'll be 546789 tomorrow. So they just don't list it. Good question. I think that's all of the things that we need. I can't think of anything else, so I honestly think this one's going to work. So let's see. Now I'm actually trying to make it work. One more thing, one more thing. No, we're good. We don't need that. Just making sure we have all of our dependencies. So git, what was it?, heroku push, git push heroku? There we go, git push heroku master. And let's see what happens. It definitely put it on production. And then what we're going to do is we're going to say heroku logs --tail, which will keep the logs open for me the whole time. So that's great--State changed from starting to up. So that's a good sign. When it says up, that's means it's great. I haven't seen an error yet, so I'm guessing this is running. And let's check it. So if we go to, where's it at?, this guy. Refresh. That's what I'm talking about. It looks good, 404, that's exactly what I was expecting to see. Api/users/nothing. Great, empty array. That's exactly right. There's nothing in the database. It should be an empty array. So now let's add some CRUD to it. You've got a question? There's a question on does the connection between your Node app and the Mongo database have to go all through the internet, or are they talking to each other via the datacenter's internal network? Say that question again. The database and the Node app, are they talking over a public interface, or is that internal to the Heroku's network? They're talking through the internet because the database is hosted somewhere else. So the database that we're connected to is through MongoLabs, and MongoLabs is hosting that database somewhere else, and it's talking, it's definitely somewhere else because Heroku isn't hosting that database. The database that we just added, you can go to the website and add it yourself. It's just like Heroku has this marketplace of all these services to show you all this cool stuff, but all it really is is just a service that you can go get yourself but for free on Heroku, super cheap, because Heroku makes everything free except for Compose, which is weird, because I've never seen anything in Heroku that wasn't free for the base level. I don't how Compose got away with that, but Heroku must really like them because I've never seen it. So now let's check it out. Let's grab this URL and let's do some CRUD on it. So, let's go here. I'll keep this log open so we can see it, and we'll do the CRUD over here. So let me clear the log. There we go. So http, do I do s? No, I don't do that. That'd be cool if you had to do that. So http, that URL/. Wait, we need to do a POST, right? Let's do a POST to that URL, and we'll do a---let's create a user. So username=scott password=12345. You need to change the route? The user's route? What did I put? You just had the base. Thanks. That's probably why we had a 404, api/users. There we go. I got a token back. Totally worked. So now if I refresh this, I should see myself. So one more thing I wanted to show you as far as managing this stuff. Actually, no, never mind. I was going to show you how to look at the database. So if you look at the database, you just click on whatever---in this case, it's MongoLab, but it can be whatever. If you click on MongoLab, it'll take you to their website, and you can go through the database. You can also connect to this database through the terminal just like we did before, and they give the command. It says it right here. If you type this in right here, it will allow you to connect through the terminal, and you've just got to replace it with your username and password. But I'm not going to do all that. But then here's our database. It has one user, which is me, right there, and there's my hashed password.

Q&A
Q&A Part 1
So now is the time for us to open up and ask questions about anything that we've been exploring the last three days. You can ask me anything about Node, APIs, Express, Mongo, Mongoose, or anything in general. Yes? As far as API design goes, I've heard some people say, let's say you're on the Netflix home page, and it has all of the movie titles, they say if you do a request for each one of those titles, it's going to be a lot of requests because they'll add parameters at the end with, oh, I want a group of six. Stuff like that. So what I'm wondering is how should you balance how many parameters and stuff you should put on and how RESTful you want to design your API? There are common patterns like sorting, filtering, ordering. Those are common, and limits. And then if you're doing something like pagination, then you have a cursor where it's start and end, so you can figure out what pages you're on. So those are common ones. And then as far as the properties, it depends on what type of properties you want people to be able to search by. If, for instance, if the user---all we have is a username and a password here, but what if we had multiple properties on here? And it also depends on what did you index. So if you've indexed the username, it might behoove you to allow people to search by that username through a query string so you can get that benefit of that constant time lookup, that lookup speed of the index field. So I guess it all depends, but there are the common ones like I said, and then it's going to be up to you depending on what you want the user to search by. Maybe you don't want the user searching by their Facebook access token, so you don't want to put that there. But really what would happen is you would build an agnostic query builder that doesn't know about what the query parameters are and, actually, it doesn't care. And that's where Mongo kind of shines. We didn't get into the advanced querying of Mongo because I told you that's a whole other thing by itself. But Mongo will allow you to pass in different query parameters like that, and if you match them up exactly to req. query. params and pass it into a Mongo query, you can pretty much get whatever they pass in, and then you can leave it up to Mongo to decide if that is a valid parameter or not, so you don't have to do the checking yourself. For instance, on my user, hold on, where's my user? Let's go to user, I only have a username and password. But if somebody typed in a parameter looking for an h, Mongo's not going to find anything with that on it, so I don't have to check for it, although I could. You see what I mean? I could leave it up to Mongo to figure out if it's going to find something with an h property on it, which it's obviously not because no users have an h property on it. So you could totally do that. That would look something like this. So, for instance, I want to get users, but I want to limit to 20, and I want their age to be equals, and then you might do some encoding here just like, this obviously isn't valid, but you'd do greater than, something like that. You can do all types of things in here. You can even pass in a JSON string. So it's up to you. There is no limit on what you can do as far as the query params. What does your client need? What data do they need? So, it's very, very much up to you. A good example if you want to check it out is Parse, Parse API. They have one of the best APIs I've seen. So I'd check that out. Yes? Some questions are rolling in here. What's the most effective way to identify the right module or library to use in Node when there're so many? Are there sites or anything that help you? So the way I do it. If it's really, really good, there will be blog posts about it. You just won't be able to---if it was something really good, and you Google, How do I do this in Node?, it'll be the first thing to come up. If that's not the case, if it's not obvious, then what you do is you find something that you think is good. The first thing I do is I click on the GitHub, that 404, totally not going to use that. So then I stay in npm. I'll start googling stuff. And then a big indicator if something is great is when it was last updated. So if I click on this, this thing's got 246 stars, relatively okay. It's got a link to a website that's been hosted somewhere. That means it probably put some work into it, or they're just trying to market. I don't know. The README looks pretty sophisticated. It looks like it's kept up to date. So I guess it all depends on how well done does the README or the repo look like. It was updated 17 days ago. That's pretty current. So that's a good indicator that it's being used. So I would say a combination of the stars on GitHub, the last time it was updated, if you can find any blog posts, if you can find anybody talking about it. But if it's something that's just like two stars, updated four months ago, the README has two lines in it. But you think it's exactly what you need, probably not the thing. I'd rather make my own thing than use that. So it'd be pretty obvious if this was popular. Just look at the activity. Stars, watches, update times, and nice is the README. This is a pretty good README. This person put a lot of time into it. Yes? How does MongoDB performance compare with enterprise-level databases like Oracle? Oh, man, I don't know anything about Oracle, so I cannot compare the two. I've never had to use Oracle in my entire life. But I do know if you had Oracle, it comes with a DB administrator that handles it for you. Doesn't it come with a person? Don't you think with Oracle, it comes with a person that handles it for you? I can say that Mongo is very performant because it's based off of an eventing system kind of like Node. So as far as performance, it's actually pretty fast, but it doesn't mean it's the best. Speed is not everything when it comes to database. It's all about all types of other stuff. Is it ACID compliant? What are the reads? What are the writes? What is it good for? Is it better for the reads or the writes? There's a lot of stuff that goes into a database, but as far as --- Is the API usable? --- Is the API usable? Can a human use this thing? That's why I like starting with Mongo a lot because it's a hybrid of --- Exactly. --- a lot of things that it's easy to get started with. Yeah, Mongo is very easy to get started with, whereas if you've never studied relational databases, and the first time you use a database was like, I'm going to use Postgres or SQL, you might have a hard time understanding why this stuff---what is a migration? What is this? What is that? If you've never studied databases, that stuff doesn't make sense to you, whereas Mongo is like, Just connect, and you're okay. Give me JavaScript. So it's a lot easier setup. So it's pretty fast because it doesn't have to do things like join tables and stuff like that. But, again, it's not the best thing for everything. So I guess what they're asking, following up, if you're shipping an app in production with a huge amount of users, can Mongo support that? I don't know what a huge amount of users is. And like I said, I don't think it comes down to how much it's storing. It's coming down to what you're doing with the data. Are you going to be reading more than writing? What are you going to be writing? How many concurrent users? How many concurrent writes are you going to have? I think that's more important than the amount of shared data that it's going to store. I've heard problems with Mongo where people were saying that sometimes things wouldn't write. I've never run into that problem personally. But, again, I've never built a big data platform either. I'm not a big data person, so I cannot comment on that. But I've also heard other things about SQL and stuff. So the pros and cons are, Mongo's easy to get started. It's really great for prototyping. You can probably get away with using it in production because it's really good. But then, again, SQL probably overall is going to have better performance, Postgres or SQL. But you actually need to know how to use it. It's only going to be good if you know how to use it, if you know what you're doing. If you don't know how to administer a relational database, then you're not going to have fun with it. I think people tend to overthink scalability because they think, Oh, my app's going to be huge. Right. Right, but then they actually run into issues, it's with the company's not worth --- You got funding and you can fix it. So it's not even a problem now. Just use it. I've never had a problem with Mongo. I've built client work with Mongo. I've built production work with Mongo. it, but I've never had problems with it. More stuff rolling in on that. So when building a back-end API like this, why use NoSQL database over a relational database? Mongo seems pretty much trying to replicate most of the functionality of a relational database. I think you kind of just covered that. Yeah, Mongoose is trying to---because the argument was like, Oh, Mongo doesn't care. You're right. Mongo doesn't care about the database. Mongoose is like, But we want that same thing as we get with relational databases without the overhead. So we're just going to attach to Mongo. So, yeah, but it's not exactly the same though. On Mongoose, you have a schema that's guaranteeing you that the data's going to be saved this way, whereas in a relational database, it has nothing to do with the ORM. It's the database that's saying, This is how it's going to be saved. Relational databases have fixed width columns, so it's the database that's saying, This is how it's going to be, whereas Mongo, it still just doesn't care. You just have this driver on top of it, this ODM, this ORM that's doing all that validation. So it's really not the same thing. It's more on a higher level. It's just very abstracted away. So you get the same result, but the same thing is not happening. But there are pros and cons. Postgres uses JSON now, so you can just throw JSON and Postgres now whereas you couldn't before. So there're tons of support for that. And it also depends on what you're doing with your data. For a time series type of data, I don't know, Mongo's pretty good, but you probably want a better database for time series. It also depends on the type of data. And then there's geospatial support. Mongo has pretty good geospatial support but definitely not as good as Postgres. Postgres has some of the best geospatial support. So it all depends on the type of data you're having. Can you elaborate more on the time series data if you're working on something like that? What would you recommend the most? I can't recommend anything as I've never worked on time series data, but I can show you the best one. Super easy. Best time series database. That didn't come back as I thought it was going to do. But I can't think of one off the top of my head. Not Influx. That's not the one. I can't recommend ones as I've never had to deal with time series databases. But there are some good ones out there. I wouldn't recommend something like Postgres or something like that. I wouldn't recommend a relational database like that. How about something like Firebase or MongoDB? Firebase? Or MongoDB? I wouldn't recommend Firebase. I like Firebase because they're real time. I wouldn't recommend them as a datastore, like this is where I'm going to store all the data for my application. Times series data? No. You can't query it, so you'd be screwed. If you had somewhere where you processed all the work (inaudible) once the processing is done in time series, maybe Firebase is good for that? Well you can't process. But just to present the data once you're done processing in some other place, could you be able to present the data? I don't know. I wouldn't use Firebase for that. You're limited on what you can query. You can't say, Give me this specific thing at this specific time. You can't do that. It's just like, Give me all the things. If you want to do that filtering and stuff on the client, you can do it if that's what you're talking about. You could totally do that. You'd just be like, Firebase, dump me the thing, and I'll do it over here. Yeah, you can do that. But for more fine-grained control, you're like, I want the database to do this sorting and filtering stuff for me, Firebase isn't meant for that. That's not what it's meant for. So then Mongo is better at that? Mongo is definitely better at that than Firebase, but there are still better things out there than Mongo as far as time series database goes. I just can't think of any because I've never used them.

Q&A Part 2
This kind of goes back to where I think we were talking about any authenticated user can change anything in the application. But somebody's saying that you can update other users in this app anyways because the request. user object from app. paramsId gets overwritten by auth. getFreshUser. Let's see. Yeah, actually it does. And then so he's just saying that's not intentional. So how can you avoid loading the request like this? Make a different object name, not user. Call it req. something else, req. author. You just have the namespace it I guess. But, yeah, that is unintentional. I didn't realize it until he just said it. But, yeah, that would definitely happen. You'd just have to give it a different namespace, just not put everything on the user. Another question just in general. What are some ways to scale the MEAN stack? Well you could just throw more money at it if it's on Heroku. Scale up the dinos. Here, I'll show you. This is the easiest way to scale. Let's see, where is it at? Where's that button. Here we go. So if I come over here, and I click this button, that's probably the easiest way to scale. No, you don't want to do that. So, as far as horizontally or vertically scaling, the easiest way is definitely clicking this button. That's if you don't mind spending the money. But there are ways as far as getting, I don't know, you have huge datasets, so you start getting replicated sets. So you start replicating the database and doing that stuff every night. And then you might start sharding the database on different indices, so let's say we have a user's table, and we start sharding on alphabetical order from A through D. We're going to take this and stick it over here. Or we're going to grab these and stick these over here. So we're running them on different machines. And then when we query, it'll go to the appropriate one. So that's one way. Another way is just load up more instances. So you can throw more money into it and beef up stuff vertically, or you can just be like, I'll just keep these lower-level/mid-tier ones and just go out horizontally and just buy more of those. So, I'm definitely no expert on that. But from my experience, because I'm not a DevOps person, I'd just throw more money at it. So I don't really have a better answer than that. Another question was, let's see, what would you recommend for a beginner to read up on and master some of this material. So, there's this really good blog that I like to read. It makes sense to me, scotch. io. So if reading is your thing, if you wanted to read, then I would definitely recommend scotch. io. This stuff has some---look, Node and MongoDB on Heroku. That's what we just did today, and it was just published. So this is a good blog post. If I do read blog posts, it's mostly stuff on here or random people's blogs. This one's really good. They love MEAN stack. They wrote a book on MEAN stack, so they know it pretty well. So if reading was your thing, and that's what you needed to do, I would do this. Any other questions? Any npm modules you can recommend for interfacing with MySQL? Sequelize is good. There's a better one, though, than Sequelize. Let me see, before I recommend it, let me make sure it works for SQL and not just Postgres--bookshelf, bookshelf SQL. Let's see. Yeah, I think it's Bookshelf. So Bookshelf is probably the most popular one, and Sequelize is probably the next best one. If you're familiar with Backbone, then Bookshelf will feel like home. It's made by the same people. It looks like Backbone. Actually, it looks different. They've updated it a little bit. But it still kind of looks like Backbone. But that's the most popular one, then Sequelize. Do any of those handle mssql? I have no idea. Sequelize. js does. Sequelice. js does. This one doesn't. It says Postgres, MySQL, and SQLite3. Anything else? I'm kind of parsing through all of them here quick. So here's a good repo to go look at some awesome Node stuff. It's literally called node awesome. If you go here, it's just a readme of awesome things in Node. So if you ever need something awesome, just go read this like, I really need something really nice for the file system. Oh, here we go. All the stuff you need. What about build tools. Oh, yeah, that's it. And the guy who made this is---I think he's a group of people, this guy. But he's very well known. And he keeps that list updated, two days ago with 7, 000 stars. So I'm sure it's a good list. 7, 000 stars for a readme is ridiculous. Yup? What do you think about Elasticsearch and Kibana? I don't know what Kibana is, but Elasticsearch is awesome. I use it a lot. Most apps these days need some type of functionality like Elasticsearch, and it's pretty cool because it's open source so you can post it yourself, and then there're tons of Elasticsearch as a service platforms out there. Heroku has some of them. So if you need that real-time search, need the power of Google in your app, then, yeah, Elasticsearch is awesome. You just throw stuff at it and get it later. I really like it. It's pretty simple to use. I actually tried deploying my own hosted one before. I didn't have too much luck, but then, again, that was a couple of years ago before I knew what I was doing. So I might try it again. So, yeah, I recommend Elasticsearch. I can't recommend the other one. Anything else here? Any thoughts on clustering Node? Yeah, so you can cluster Node. So in Node if you wanted to use clusters, you would just npm install, or, I'm sorry, you'd require the cluster module, which is actually brand new. It's not brand new. Let's see. There we go. Stability: 2. It's unstable according to these docs. Maybe these docs are out of date. But you can use the cluster module. I don't know. I'm kind of biased, not biased, but I'm kind of neutral on this because I like the fact that Node is running on one thread, and it's evented IO. But at the same time, I'm like, I wish it had more power to access more of these cores. So the cluster allows you to do that, but then, again, you have to manage that stuff. Stuff gets kind of, gets out the wonk if you're not familiar with working on multithreaded platforms especially if the platform is multithreaded and asynchronous at the same time. You could run into some trouble where you start having threads being blocked by you doing a while loop that never ends, you know what I mean, and you're just stuck. So I'm kind of unsure about it because I never really used it in production. I've built some stuff with it just to learn about it, but I don't really have strong opinions for or against it. But if I had to do something that's CPU intensive, I probably just wouldn't use Node to be honest. I would use Python or Gulp, something that was heavy. I'm not going to build some sensitivity analysis machine learning algorithm in Node. It probably would work, but it'd be really hard, and you'd have to be really, really good at math. So I'd just go somewhere else. They want just a quick recap on module. exports versus export, just the elevator pitch. So module. exports is like, I'm going to export this entire file. Module. exports is like, Nothing else is going to be exported except the thing to the right of this equal sign on module. exports. You can think of it like this--module is like the file, exports is an object. And you can put whatever you want on exports. And if you use exports by itself, it's still just putting whatever you want on exports. But when you require, exports gets attached to module. So at the end, it's still just module. It's just exports is like, I want to export many things, so when I require it, I'll have an object with all those properties on it. Module. exports is like, Whatever I require is going to be whatever module. exports was. It's only going to be that one thing.

Q&A Part 3
Question: If I was building a large application with multiple application modules, should I write one monolithic Node app or build multiple Node apps with some sort of messaging between the modules? So there's a new trend for everybody using an SOA, a service-oriented architecture, where we have that set up where everything's a service that does just one small thing, and we have a messaging system, some queueing system where we communicate between these two, or maybe we build some type of HTTP interface. So that's the thing that's trending, and it's great. It's very flexible. I like that approach. But at the same time, having one huge monolithic Node app, if that's where your skill level is and that's where---if you're talking production, I'd probably go SOA, service-oriented architecture. But if you're talking about like, I was going to build this pet thing so I could get a feel for Node, I would start there. I wouldn't go out and start building all these microservices everywhere for my to-do app. I wouldn't do that. But eventually if you're talking about production and scalability, you should have these independent things, and they should just do one thing, and they should do one thing very well. They should have a very clean interface for those through some type of queueing or messaging system or through HTTP or whatever protocol you choose. But that's definitely where the world of back-end is going. It's going towards that approach for good reasons. Yeah, it's nice for us. We have WordPress on the front-end, and then our stacks layer is on Node, and if stacks goes down, that goes down. You just reboot stacks, and WordPress does its thing with caching all that stuff so the website's still up, but you don't get your progress tracking showing up. The progress bar doesn't show up. Exactly. It's nice to separate things as small areas of concern in case something goes down or whatever, your app can fail gracefully. Exactly. That's really good. That's a really good point. That's a good point. But there's also overhead with dealing with everything. So whatever works for you, do it. But definitely look in at least knowing what an SOA is and knowing how it works because ultimately if it came down to like, What were you going to build for this production thing and this startup, it'd probably be a service-oriented architecture or at least leaning towards it. I really wouldn't want to build this huge monolithic Node app that's serving jTemplates with the Angular application. It just sounds horrible because now you have that huge app that's serving a web app, and then now you also just made an iPhone app a month later with the Android app, and it's talking to the API that's also serving static assets. It's just a nightmare. So just don't do that. Are you using RabbitMQ? I've used RabbitMQ for the measuring system between those services, but lately I've been using PubNub, which has been really cool. But RabbitMQ is really great too. Anything else here? I'm asking if anyone has any questions. I'm giving them a few seconds to respond. Anybody have any questions here as far as the deployment? I kind of went through it kind of fast, but I did show you---I'm glad I got to show you all the gotchas in the deployment because I forgot one of them, the whole master branch stuff, I actually forgot about that one. So it's great that we did that. Well that was actually pretty simple as far as deployment goes. Most services aren't that simple. Azure is kind of simple. AWS is definitely not that simple. But most of them are pretty easy. Heroku is probably the easiest. Yeah? Did you say PubNub or PubNode? PubNub. It's a real-time --- global data stream network? --- yeah, real-time thing. This thing right here. When I first used PubNub, it changed my life. I didn't even use HTTP anymore. Now when I'm going back to HTTP and making regular HTTP requests, and I'm just like I don't even want to do it anymore. I just want to put everything on PubNub. And, in fact, I actually built an app for a client a while ago where everything is just PubNub. There is no HTTP. Everything is just real time, even the authentication. Do you use nginx for static files? Yeah, that's perfect. So putting a proxy on top of your Express, so if you had an Express web server whose job was to serve static assets, then putting your proxy in front of it, one like nginx, which works very well with Node, that's be great because now your API doesn't have to get hit just to serve some static assets, whereas nginx could. So it's really great. I think Heroku has nginx support built in because Heroku is just AWS with more money on top of it. And then AWS allows you to host your own nginx, which is pretty cool. So, yeah, I do recommend using nginx for those static assets to save the heavy lifting for the API calls and not just assets itself. And it's pretty easy to set that up with nginx. Any recommendations for style guide or code quality checkers? Oh yeah, for sure. JSCS, that's all you need. This is the bees' knees. So this one's really good. Not only will it look deep into your code for style guide, it will actually change the code for you. It'll be like, Oh, you actually meant to indent two. Let me do it for you. It'll change it for you. It's ridiculous. JSCS, JavaScript, I don't know, what does that stand, oh, Code Style. There we go. JavaScript Code Style. And what's really cool is they have these rules, or, I'm sorry, where's the page? They have these presets that are built in. So big popular companies like Airbnb, which arguably has the best JavaScript or the most well-known JavaScript style guide out there, you can just use their presets built into your config. So you can just starting writing code like Airbnb or Google or whoever you want. Or you can make your own. jQuery style guide, they've got all that stuff. So this is the best one. But it also doesn't follow all the rules you might get out of something like JSHint. So I recommend using this in combination with something like ESLint, which is like JSHint but just newer and it allows you to do things with ES6 and stuff like that. So a combination of those two will be great. And, of course, the style guide I do recommend is Airbnb. They just have a really good style guide. They just updated it to ES2015, which is great. They still have a reference for ES2005 back here. But as you can see, it has 22, 000 stars, so it's a pretty good style guide. I highly recommend it. What protocol is PubNub using? Is it web sockets? It uses whatever's the best one available on the platform. So because of that, you can use PubNub on a TV, a smart watch, Internet of Things. Whatever is the best for what it's on, it'll use that. So it'll also do multiplexing on a single TCP connection. So if you were on the latest and greatest, it will use web sockets. If you were on a Samsung TV, it might just do long polling. It depends on whatever route it runs on, which is really, really great. Are you using socket. io or some other socket library? Yeah, if I implement sockets myself, which is rare these days, socket. io is definitely the way to go. It's probably the best one out there, and there're so many wrappers for it. If I were doing sockets myself, I'd use that. It's pretty straightforward and really, really well documented and pretty much well known. If you run into a Node performance issue, how would you debug it? Are there any specific tools you use? There is a Node profiler. Let's see. Oh no, I forgot the name of this company. Let me see. Oh, PM2, PM2. That's what it is, Node PM2. How could I forget that? These guys are all about production in Node in all types of stuff. So they have dashboards and stuff where you can monitor all this stuff and all types of open source modules to help you with that. And most deployment platforms you go to offer Node monitoring and performance, stuff like that. Heroku not so much compared to other stuff, but if you went to Nodejitsu, which is like a Node-only hosting service, I've never used them, but I'm guessing they might have something like that. But these guys are here, Keymetrics. They're pretty much on point on that. And they have open source stuff that helps you look at that stuff. Can you give some recommendations on how to handle errors in production? Yeah, good question. So, man, I've got so many tabs open. Somebody just sent the link for a program called OneTab. Thanks. OneTab. OneTab is sweet. That just has one tab? OneTab is a Chrome extension, and you press it, and it takes all your tabs and puts them into a list, and so you can just refer to it later. Got it, got it. It becomes your Start page, and so you can see all the stuff that you have in progress or whatever. I ought to look it up. So error handling in production. We kind of did some of the good stuff already that's setting up global middleware that whenever we call next, we know for sure it will go here. So this is like a try/catch of our server almost. The other thing is we can just wrap the entire file in a try/catch. No, don't do that. I was just trying to see if anyone---no, don't do that. Don't wrap your file in a try/catch. I've seen people do that. Just don't. They're like, I'll just wrap this whole thing in a try/catch. No, don't do that. There's this thing in Node called, I don't know the name of it because I don't think anybody even uses it, but previously what we've been doing is if you try/catch this synchronous execution of code to help prevent the errors, like, for instance, signing a token, stuff like that, you should try/catch that stuff. And then for asynchronous stuff, which is probably happening inside of a callback, just make sure you call next. That right there is going to get you far. Also, you can tap into the events on Node. So when Node is getting ready to shut down, like process. on('exit'), so this is like, Oh, Node is about to shut down, maybe it was for an error or something, you can do stuff here. I would say you should probably restart it, but it's probably shutting down for a good reason, so you don't want to restart it, but you can at least see what's going on. As long as you're just aware of where the errors might happen and preparing for those things, you should be fine. There are better ways. Like there's this thing called, and it's actually from PM2, I want to say PM2 Forever. I don't know the name of it. Oh, wait, here we go. I guess PM2 or Forever. So these are other things that will run your Node server forever. It just won't stop it. If something happens, it'll just put it back up. It's like Nodemon for production almost. Forever. Forever. We use Forever. There, they use Forever. There we go. So anytime an exception happens, it just logs into a file and restarts the server. What about Node debugger and that kind of stuff? So I don't like Node debugger because I think it's really bad. But I think I told you guys about the debugger on day one, the node-inspector. So if you were going to debug anything, inspector, I would just run node-inspector. Oh, you've got to run it against a file I guess. So if you run node-inspector against, let's say, index. js, it'll give you this URL that you can hit, and it will go to Chrome, put this in Chrome, I think I showed you guys this earlier, and it'll load up Chrome dev tools, allow you to go through the code and stuff. But I'm a console. logger. That's just me. I just log everything. That's just how I do it. Sometimes I get to the point where I'm just like, I'm just going to start logging stuff to a file and go look at the file. I just like reading through the logs better than having to debug, which is weird because on the client, I do use the debugger extensively. But on Node, I just hate using it. I don't know why.
