At the core of developing an e-commerce website or application is a thorough knowledge of how to use a payment gateway. In this course, PayPal Integration Using Node.js and Express, you will learn the skills you need to create high-quality e-commerce applications no matter what tool you use to author them. First, you will discover how to build a bare-bones website for Sasquatch Habitat Rentals using Node.js, Express, and MongoDB and learn how to install and set up PayPal into your Sasquatch application. Next, you will learn how to create single payments, look up order details, and learn the fundamentals of how PayPal payments function. Finally, you will explore how to create a recurring payment, also known as subscriptions, and attach it to your Sasquatch application. When you are finished with this course, you will have a foundational understanding of payment gateways and PayPal knowledge that will help you immensely as you move forward to create your own applications, whether personal or commercial.

Course Overview
Course Overview
Hi everyone. My name is Dallas Lones, and welcome to my Pluralsight course, PayPal Integration Using Node. js and Express. PayPal allows us to process online payments and is a key part of most e-commerce applications used today. Learn the fundamentals of PayPal while creating a baseline e-commerce application. The major key topics covered in this course are how to install PayPal into your application. In this section, we'll install PayPal to our web application, as well as create a baseline e-commerce app for Sasquatch Habitat Rentals. Single purchases. With single purchases, we will set up a single payment. This is along the same lines as a product online in an e-commerce store. Recurring purchases, also known as subscriptions. Recurring purchases allow us to set up subscriptions. We can change the amount, as well as how often the subscription is billed. And refunds. By the end of the course, you will be comfortable installing PayPal into an application, create single and recurring payments, as well as have a fundamental understanding of how PayPal works. Before you begin this course, I highly recommend you have a basic understanding of JavaScript and Node. js. I hope you'll join me to learn PayPal and master your skills with payment processing and e-commerce applications, only on Pluralsight.

Introduction to PayPal
Introduction
Hello everyone. My name is Dallas Lones, and today I'll be teaching you how to use the PayPal REST API using Node. js and Express. Keep in mind that we're learning PayPal's API, meaning that you can hit the same endpoints and get the same results, even if you aren't using Node. js. If you wanted to, you could create an e-commerce application completely with front end, yet that's bad practice. We want to save our users transactions. After this video, you will be able to add PayPal to your website or application and use it as a payment gateway. This video will cover creating a server, creating a MongoDB CRUD service, single payments, order history, order refunds, and recurring payments, also known as subscriptions. To help with the wildlife community, we'll be building a Sasquatch Habitat e-commerce application using Node. js, Express, and MongoDB. It is highly recommended that you have a basic understanding of the following before you begin this course, HTML, JavaScript, and Node. js. If you don't understand those core languages, feel free to keep up, as I'll be explaining things in great detail. So what is a payment gateway? A payment gateway is a gateway that allows users to make online payments using their cards or other forms of payment. One of the main reason we would use a payment gateway is for security. When you use something else as a service that handles your online purchases, you do less work, and the service provider stores all of the sensitive information. When developing anything, you need to ask yourself, is this data sensitive? Credit card information is extremely sensitive and should only be stored if at least the minimum precautions have been taken. If a hacker steals all of your user's card information, you are the one who is liable if any money is stolen. This is why payment gateways are a lifesaver. They specialize in storing and processing payments, as well as user information. Payment gateways have precautions for their precautions, to ensure the safest transaction possible. In short, a payment gateway is a service that handles online purchases and stores sensitive user information. So what is PayPal? PayPal is a payment gateway and is possibly the most popular payment gateway used today. You can learn more about PayPal by going to their website at paypal. com. To do any transaction on PayPal, you first need to create an account. PayPal has two types of accounts, business and personal. Personal is for a personal transaction, such as buying things securely from an e-commerce website. Business is for business owners who want to receive payments into their account. Business has two plan types, Standard or Pro. With Standard, PayPal hosts your checkout, customers leave your site after checkout, and then return after purchase, and setup is easy and no shopping cart is required. With Pro, you can host and customize your online checkout, customers never leave your site for checkout, you can control layout, colors, and more, and it's compatible with most shopping carts. Now even though you might assume with Pro that you don't have to pay a fee per sale, that's not the case. PayPal charges 2. 9% of every sale, and a 30-cent charge. Buying is always free, yet selling costs a little extra. In short, PayPal is a low-cost payment gateway option that can be used with multiple stacks and is a secure, effective way to handle payment processing for any of your application needs. In this course, we will be building an e-commerce application that allows users to purchase habitats for Sasquatches. Why Sasquatches? Well, when dealing with financial data, you want to make sure you are triple checking everything. Every time you mistype the word Sasquatch, you can be reminded of how serious financial data is. In the real world, financial data mess-ups can get you in a massive amount of trouble, and even sued. When dealing with financial data, pay attention. This Sasquatch project will include single orders, order refunds, purchase history, and recurring payments, or subscriptions. At the end of this course, you will have a solid understanding of how the PayPal REST API works, as well as be fluent enough with it to add e-commerce to your application. In the next chapter, we'll create a Node. js Express server using MongoDB to create the framework skeleton for what we'll be building.

Docs and Setup
In this video, we're going to learn where the documentation lives for the PayPal REST API, as well as see how to set up a PayPal application in the Developer dashboard. Open a browser and navigate to developer. paypal. com. If you haven't already, create a developer account and log in. Click on the Dashboard to view our Dashboard page. It's located under your username. This is where all of your developer configuration settings live. We default to the My Apps & Credentials page where we can see our REST API apps, if we already have some created. If you don't already have an app created, you can click on the Create App button. This will take you to an app creation wizard. Notice that we must enter in an application name and then select an account to be the primary owner of this application. By default, PayPal gives us two types of accounts, a buyer and a seller. If you don't have accounts to select from, you can click on the Accounts link under the Sandbox tab to create some test accounts. By clicking on the profile tab, you can set custom profile attributes for your test accounts. Remember, if you don't have any test accounts, you want to create a buyer and a seller to test with. If we go back to the My Apps & Credentials page, we can now create an app and give it a seller as the official owner of this application. Click on your newly created app if you haven't already. This is where all of your configuration information lives, such as Client ID and Secret. Notice the Sandbox and Live buttons. This allows us to switch from live to testing. Pay attention to these when developing, as you always want to use a test account. Switch to live when you want to send your app to production. Now to see where the docs live, click on the API Reference link on the very top to view the list of available docs. We want to see the PayPal REST API docs, so click on the API Reference under the REST API column. By clicking on the Payments API, we can see examples of how to use the Payments API namespace. Remember, this is just an API, so that means all we have to do generally is match the parameters given by the docs to what we're sending, just like a sending a registration form on a website using AJAX. Here is a list of all the Payments API calls we can make with the parameters that are requested for the calls to work. Notice on the right are examples of how to make a successful API call. The beauty of these docs are the examples. All we have to do is copy and paste, then make our parameters dynamic instead of static, and we're in business. We'll go more into the docs later, yet if you're thinking, oh my, that's so much information, don't worry; we're going to build a wrapper for the REST API, and in doing this, you're going to learn what each API call does and how it works.

Creating the Server
Introduction
In this module, we'll be building the back-end server using Node. js, Express, and MongoDB. First off, we'll build the routes for our Sasquatch Habitat application with Node. js. Second, we'll build our front-end views. Finally, we'll plug in MongoDB and create a CRUD service. At the end of this chapter, you will have a working Sasquatch application ready for PayPal integration.

Creating the Express Server
Let's get started. Okay, so first off, create a folder on your desktop called paypal_demo. Go ahead and open up that folder, and if you're on Windows, you can click on the path bar and type cmd and then hit Enter, and a terminal will open up in the root of that folder. If you're on a Mac, go ahead and open up a Terminal and then cd into the folder we just created. A cool trick with a Terminal is to type the name of the editor you want to open followed by space, and a period then slash. This tells the editor to open a project with this root as its main directory. In this case, we type atom, space,. / to open the Atom IDE in this root directory. Once Atom is open, create a file and name it server. js. Go back into the Terminal and type npm init and then hit Enter. This will initialize your package. json file and write a lot of the setup code required to set up a Node. js application. Press Enter for everything you see, unless you see errors such as, you can't have capital letters in your name. Once this process is done, you'll see the Terminal back to normal. Once this is done, type npm i, space, express, space, body-parser, space, mongodb, space, --save, and then hit Enter. This will install our server dependencies. Okay, so now that our dependencies are installed, let's go ahead and install them on our server file. To do this, we use the require method that Node provides. In our case, we're going to require express, another instance of express, yet we're going to fire it so we can have an instantiated Express server injected, body-parser, and finally fs. Then at the top, let's finish our IIFE and pass in an anonymous function where we rename our required variables to express, server, bodyParser, and fs. Next, we need to set up our middleware so we can parse forms, as well as display public files like images or CSS files. First off, we'll say server. use, bodyParser. urlencoded, and then pass in an object that has an extended property that we'll set to true. That handles our body and form parsing. Let's move onto to displaying public files. To do this, we use Express's static method and pass in a folder name that we wish to be our public folder. Anything in this folder will be accessible by just going to the name of the file on your website. For example, yourwebsite. com/coolpic1. jpg. In our case, we'll name the folder pub. We haven't made it yet, but don't worry; we'll get to that in a bit. Next, we use the. listen command to start our server. We say server. listen and pass in our port, which we set to 8080, and our IP, which we set to localhost. Finally, we pass in a callback function that returns a success or error message. If we have an error, we'll console. log the error. If we don't have an error, we'll just console. log that the server is online. Okay, so our server is listening, yet we don't have any routes. Let's create our home route. To create a GET route in Express, we use the. get method. This method takes in two parameters, a path for the route request and a callback to handle the response. In our case, I'm just renaming the request and response objects to req and res. Then we'll use file system, or fs, to readFile in the directory, templates, and the file, home. html. We haven't made home. html or the templates folder, yet we'll get to that when we create our view. The readFile method returns a callback with an error message and the results of the file. We then send the contents of this file, making sure to call the. toString method to convert it from a buffer to a string using the res. send method. Sweet, our home route is complete. Once we create our view, we will be able to see that file as our home page. Next, let's copy our home route so we can create all of the routes as placeholders so we'll know which routes we need to code. I'll paste it in and then remove all of the file system stuff so we have an empty route. Keep in mind that not sending anything to the response object will result in the server sending you a web page that never loads. We will fill in all of the response data, yet for now, we'll leave them blank. Our second route we'll route to success/:orderID, where the orderID is a parameter that we can convert into a variable using bodyParser. We'll create a cancel route with an orderID parameter, an orderdetails page, with an orderID parameter, a refund route with an orderID parameter, a recurring_success route with a planID parameter, a recurring_cancel route with a planID parameter, a recurring_orderdetails route with an agreementID parameter, and finally, we'll create our POST routes using the. post method. We'll create a buysingle POST route, and lastly, a buyrecurring route. Now that our route placeholders are set up, we can give them the variable that are going to be needed when each route does what it's supposed to do. In this case, we'll add a variable called orderID and assign it req. params. orderID. This grabs the orderID from the request path and assigned it to our variable, orderID. Go ahead and copy that variable and paste it into every route that has the orderID parameter. For our recurring routes, we use planID and agreementID. Recurring_success has a planID, which we create a variable for and assign it to req. params. planID. Copy and paste that for the recurring_cancel route, as it has the same parameter. The recurring_orderdetails route requires an agreementID to work, so we'll rename this variable to agreementID and assign it to req. params. agreementID. Buysingle has a variable, yet it comes from a form post. We can access this using bodyParser's req. body. Create a variable called Quantity, and assign it to req. body. Quantity. Our buyrecurring route doesn't pass anything down from the form, so we don't need to set any variables up for now. So that's it for our placeholder routes. Let's go ahead and make the templates folder and create a file inside of it called home. html. We're ready to start creating our home view and have all of our server's routes set up for our Sasquatch application.

Creating the View
In this video, we're going to create out home. html view, as well as add some awesome squatchy styling to our application. We're going to be building our forms so that when we post to them, our server can listen and do things depending on what was passed in. Open home. html inside of your templates folder. I've written some CSS already, so you can enjoy a nice, squatchy experience while learning. So if you follow along, we'll have a nice web page in no time. Go ahead and create a style tag where we will insert the styles for this page. We'll start with the html tag, setting its color to white, its text shadow to 0, 0, 2, black, background-size to 100% x 100%, and background-image to /img/squatchy. jp. Don't worry about where this file lives yet because we're going to get to that shortly. Then we'll set our paragraph tags to have a padding of 5px, a background-color of rgba 1, 1, 1, 0-. 5 to give it a nice gradient. Next, we'll create our ul rule, setting padding-top to 5px, padding-bottom to 5px, and background-color to rgba 1, 1, 1 0. 5. Moving along, we'll create an h2 rule with a color of 1d1d1d, as well as an h3 rule with the same color. Next, we'll create our own custom class called btn. We'll give it a border-radius of 5px, a border of none, padding of 5px, a color of white, and a background-color of 1d1d1d. Then we'll create a hover effect for it by setting its hover action to turn the color green. That it for our styling. Go ahead and minimize the style tag so we can have more room and focus. Let's create the HTML. First, we'll create our HTML tag, and inside of it, create a div tag. This will be where all of our content lives. Second, go ahead and create an hr tag and an h2 tag that has the text Help Save the Sasquatch Population. We'll then follow that with another hr tag and then create two empty forms. The first form we'll give the attribute method and that we'll set to POST and the attribute action, which will be the route that this form will send its data to. In our case, it's /buysingle to hit our buysingle route. Inside of this form we'll create an h3 tag with the text Buy Habitat Starter Kit. Underneath it, we'll type $10. 00 to display the price of this purchase followed by a break tag. We'll then type Quantity as our makeshift label, followed by an input type of number with name Quantity, the value 1, and style width of 50px, and the class of btn. After that, we create another input, yet with the type of submit, the value of Purchase, and the class of btn. This will submit our first form. Let's give our users more information about what they're purchasing by making a list of things that this package comes with. Create a p tag under the break tag and type the text, The starter package comes with everything your adopted Sasquatch needs when living in the wild. Under the p tag, create a ul tag with four li tags, Month Supply of Food, Month Supply of Water, Month Supply of Grass Bedding, and Month Supply of Toys. That's it for our first form. I'm going to paste the second, as it's fairly straightforward, to give you some practice typing forms. It has the method of POST, the action of buyrecurring, and a single input type of submit. This is because we only need to hit our route instead of send things to the server for us to complete the recurring payments. Let's clean this up a bit and then create a folder called pub, and inside of that a folder called img. If you have access to the exercise files, you can copy and paste the picture squatchy. jpg into the pub/img folder. This will let our CSS use it as it's in the pub folder. Finally, we can test our newly created Sasquatch view. Open the terminal and type Node server to start our Node application. Remember, it's listening on localhost post 8080. And there we go, here's our very basic, fancy, responsive, Sasquatch application. Now we can start to add functionality to our server by creating services. I'll see you guys in the next video.

Creating a MongoDB Service
In this video, we're going to be creating a service for MongoDB CRUD operations. Once this service is complete, you'll have a reusable service for doing any CRUD operations you need. Let's get started. To begin, create a folder called services in the root of our application. Remember, the root is where our server. js file lives, aka, the starting file of our application. Inside of this folder, create a file called mongoService. js and then open it. We'll begin with an IIFE just like in our server file, and start off with injecting our dependencies. We'll first inject module. exports so other files can access to the objects or methods we attach to module. exports. Then we'll require MongoDB to gain access to MongoDB's functionality. We'll then finish off our IIFE by passing in an anonymous function, giving module. exports the alias of mongoService, and mongodb the alias of mongodb. Go ahead and create a variable called connectionString. This will be the data MongoDB requires to connect to a database instance. Usually, sensitive data like this lives in process. env variables. This is to keep it harder for hackers to access your information. We'll assign connectionString to process. env. mongoConnectionString. Or if that doesn't exist, we'll use MongoDB's local connectionString, mongodb://localhost:27017/, the name of your database. In our case, we want to use paypaltesting. Now don't worry if the database doesn't exist. MongoDB will automatically create it for us. Now that our connectionString is complete, we can create our first connection method. Create a variable called Connect and assign it to an anonymous function, passing in a single parameter, cb, as a custom callback to fire once the database is connected. We use MongoDB's Connect method, passing in our connectionString to connect to our database. It passes us back the database in a return method that holds an error message, if there was one, as well as the open database connection. Once the connection is open, we return our callback with the error message, if there was one, the database object, and an anonymous function that fires the db. close method. When you're doing anything with databases, you want to make sure that your connection never stays open. If you open a connection, close it when you're done, or you will eat all of your resources and make your server cry. This is why I pass a close method at the end, for the caller of this method to close it once the operations are complete. Okay, so we're done with our Connect method. We can now use this method to open a database connection, do things with it, and close the connection. Let's attach a method to our mongoService object, aka, our module. exports object, so that other files can use it. We'll call this method Create, and it will be responsible for inserting things into the database. This method has three parameters, a colName, a createObj, and a custom callback to fire once the insertion is complete. We then use the Connect method, passing in a callback that gives us the error, if any, database, and a close object that we can use for our insertions. Once we're connected, we have access to the database object. We use these db. collection method to find the collection we're talking about. In this case, we pass in colName so we can have our insertions be dynamic, depending on the collection name passed into this method. Next, we use the. insert method, passing in our object that we wish to insert into the database. This can literally be any object, or even JSON. Then we have a success callback that gives us an error message, along with our results. We fire our callback with our error, if any, and our results, then return our close method to close the database. We're done with our Create method. Let's move on to our Read method. Go ahead and attach a Read method to our mongoService object. This method has three parameters, a collection name, a find object, and a custom callback. Just like before, we use the Connect method to open a database connection. We also use the db. collection, passing in our custom collection name. Then, instead of using the insert method, we use the find method, passing in our find object. The easiest way to convert a find cursor object to an array is by using the toArray method. Finally, we pass in a response callback that gives us access to our error, if any, and our results. We fire our callback with the error and results and then return the close method to close our database connection. That's it for our Read method. Let's go ahead and attach an Update method to our mongoService object. This method has four parameters, a collection name, a find object, an update object, and a custom callback to fire once the update has occurred. Again, we use our Connect method, gaining access to our database object. We use the db. collection, passing in our dynamic collection name and then use the. update method. This method has three parameters. The first is the find object, the second is the object that holds the updates, and the third is the success callback, giving us an error message, if any, and the results of the update. Notice how I use the $set property and give it the value of my updateObj. This is so that when I update, MongoDB won't delete the whole file and replace it with just the new updates. It will keep the old updates and replace only the new information. We fire our callback with the error and result objects and then return our close method. That's it for our Update method. Let's make our final method, the Delete method. Go ahead and attach a Delete method to our mongoService object. This method has three parameters, a collection name, a find object, and a custom callback. Just like before, we use the Connect method, the db. collection method, and then this time, we use the. remove method, passing in our findObj. This will remove anything that matches our findObj. Finally, we pass in a success callback, giving us access to the error and results objects. We fire our callback with the error and results objects inside, and then return our close method. Congratulations, we've completed our Mongo service, and have a fully working CRUD service to use later in our development. Now remember, if you're trying to access the database by your Node server, the database instance has to be running. Awesome, we now have MongoDB ready to rock and a service that can use it like a champ.

Summary
In this chapter, we set up an Express server with routes, along with created a MongoDB CRUD service. We used Express by npm installing Express, as well as bodyParser, by npm installing bodyParser. Then we set up our middleware by calling server. use and passing in the objects to handle that middleware call. Using Express's. get and. post methods, we created routes and used req. body and req. params to access the information being passed to the server. We then created our awesome Sasquatch view, creating our design and our forms. Finally, we created a MongoDB CRUD service by first creating a Connect method using Mongo's Connect method, a Create method, using Mongo's Insert method, a Read method by using Mongo's Find method, and an Update by using Mongo's Update method, and finally a Delete method by using MongoDB's Remove method. Our server is built and is ready for PayPal integration.

Integrating PayPal
Introduction
In this chapter, we'll learn how to integrate PayPal into our Node. js Express application. After this chapter, you will understand how to do these operations: purchasing, recurring payments, order history, refunding orders, and more. At the end of this chapter, you'll be well on your way to becoming an e-commerce master. Keep in mind, the next chapter is very rough. PayPal has a lot of objects that need to be set up to be happy, so we're going to make functions that scaffold these objects for us. Get prepared to do a lot of typing, yet hold onto the thought that once this is done, you'll have a reusable service to execute PayPal actions.

Creating the Configuration
In this video, we'll be building the config service that will scaffold our config object. After this video, you will have a working service that returns a configured object so PayPal can use it. This is a key step when developing in PayPal, as this holds our PayPal connection information. First off, go ahead and create a file in our services folder called config. js. We'll start this file off with an IIFE, passing in module. exports and then renaming it to configRepo. We do this so that other files can read the methods that are attached to our module. exports method, now called our configRepo. We'll attach a method called SetConfig to our configRepo object and then pass in the parameter paypal. Next, we create a variable called config and assign it an object that has the properties host, which we set to API. sandbox. paypal. com; port, which we set to an empty string; client_id, which we set to our client_id in the dashboard; and client_secret, which is also found in the dashboard. We then use the passed-in paypal. configure method, passing in our config object. To find our client ID and our client_secret, we must go to developer. paypal. com and log in, and then click on Dashboard. We default to the My Apps & Credentials page, where we are displayed our REST API apps. If you don't already have one created, we need to create one. Click on the Create App button to create an app. Name the app and give it an account to tie to as the holder of this app. If you don't have any accounts already, go to the Sandbox, Accounts page, where you can create an account. By default, you should already have two test accounts, one for buying and one for selling. Notice the types that are set to my accounts, business and personal. So that's it for our config object. Now the other files can use this to connect to a PayPal account.

Integrating Single Payments
In this video, we are going to make a payment service that will handle all of our PayPal payment operations. First, we're going to make methods that scaffold objects for us to use when using PayPal. Then we'll create the actual PayPal methods to create and execute the transaction. The key thing to remember with payments is that we first need to create a payment, then we execute the payment. Creating the payment will reroute us to PayPal's website, where they authorize the user for login and payment credentials. Then, after everything has been authorized, PayPal sends the user back to a return URL, where we can then execute the payment. Remember, create a payment first, then execute it. We'll see examples of this in a bit. First off, let's create a file in our services folder called paymentService. js. We'll open it with an IIFE, just like we did before, and then pass in our dependencies. Our dependencies are module. exports. paypal-rest-sdk, which is how we access PayPal's functionality. We'll npm install that later. Our Mongo service. We'll give these the aliases paymentService, paypal, mongoService. One of the first things we need to do when accessing PayPal is to set up its configuration. We created a file earlier to do this for us, so all we have to do in this case is to run the config method. We only need to do this once, as the server will inject PayPal service on startup. To do this, we require. /config. js. SetConfig, passing in paypal as the only parameter. Now that our config is set up, we can start to use PayPal and create payments. To begin, let's add the CreateItemObj method to our paymentService, aka, module. exports. This method scaffolds an item and returns it. It has three parameters, name, price, and quantity. First, create a variable called itemObj and assign it an object. This object has a name property, which we assign to name; a price property, which we assign to price; a currency property, which we assign to USD; and a quantity property, which we assign to quantity. We then return the itemObj, and we're done with this method. Next, we'll attach another method to our paymentService object called CreateTransactionObj. This object has four parameters, tax, shipping, description, and itemList. Inside of this method, we'll create a variable called total and assign it to 0. 0. We'll then create a for loop to iterate through our itemList. (Typing) For var i = 0, i < than itemList. length; i++. Then create a variable called newQuant and assign it to itemList i. quantity. If our newQuant is greater than or equal to 1, we plus equals itemList i. price to the total, else total = itemList i. price. Outside of our loop, create a variable called transactionObj and assign it to an object. This object has an amount property that we'll assign to an object that has the properties total, which we assign to total; currency, which we assign to USD; and details; which we assign an object that has the properties tax, which we assign tax, and shipping, which we assign shipping. Finally, under the amount object, we add description, which we assign description and item_list, which we assign an object that contains the property items, which we assign itemList. We then return our transactionObj, and we're done with this method. Now that we're done creating our object creation methods, or scaffolding methods, we can move onto our PayPal methods. (Typing) Let's attach the method CreateWithPaypal to our paymentService object. This method has four parameters, a transactionsArray, a returnUrl, cancelUrl, and a custom callback once the payment has been created. Inside of our CreateWithPaypal method, create a variable called dbObj and assign it to an object that contains the properties OrderID, which we assign to an empty string; CreateTime, which is also an empty string; and Transactions, which is also empty. We have a default order object ready to be inserted into MongoDB. We can use our mongoService. Create method to insert this object into our database. We pass in our collection name as the first parameter, which is paypal_orders, then our object that we wish to insert, our dbObj, and finally, a success callback that gives us an error message and our results. Now you're probably asking, why do we have to save to the database before we create and execute the order? This is because when we execute the order, we need the created orderID. The process in which the returnUrl and cancelUrls are created make it so we need to provide a valid identifier for when we return with a success message. Inside of our create success callback, go ahead and create a variable called paymentObj, assigning it to an object with the properties intent, which we set to sale; payer, which is an object with the property payment_method, which we assign paypal; redirect_urls, which we assign an object with a return_url that we assign to returnUrl + / +, our inserted results. insertedIds 0, which is the first element in an array of insertedIds that our create service returns to us in the result. A cancel_url, which we assign cancelUrl + / + results. insertedIds 0, and then a transactions property, which we assign transactionArray. Now that our payment object is created and ready to rock, let's create the payment using PayPal. To do this, we use the paypal. payment. create method. The payment namespace in the PayPal object is responsible for creating and modifying anything payments. We're using the create method inside of the payment namespace to create a payment. We pass in our payment object, along with a success callback, where we gain access to our error and response objects. If there was an error, we return our callback with the error, else, if there was not an error, we assign our dbObj to an object with the properties (Typing) OrderID, which we assign response. id; CreateTime, which we assign to response. create_time; and Transactions, which we assign to response. transactions. Now that our PayPal payment was created, we need to edit the earlier inserted order to update and match the new dbObj we just made. To do this, we use our mongoService. Update method, passing in paypal_orders to access our orders collection and an object with _id, which we assign results. insertedIds 0, our dbObj that we wish to provide as an update reference, and finally, our success callback with our error and results objects. So when we created the initial paypal. payment. create, we were provided with a response that gives us access to a URL that we want to reroute our users to so they can authenticate their PayPal information and payment settings. Now that we've updated our order in the database, we can do a loop from the initial paypal. payment. create success results object to find the URL we need to reroute our users to. We want to loop through our response. links. length, and if our response. links i. rel equals approval_url, we return our callback with our error object, if any, and our response. links i. href. This will return our callback with the correct link so we can send our users off to the safety of PayPal. Congratulations. We're done with the hardest part of this file. Remember, creating a payment is not finishing a payment. We have to execute a created payment to finish the actual payment. Next, attach the GetPayment method to our paymentService object. This method will be responsible for getting our created payments information. We can pass in two parameters, a paymentID and a custom callback, once we've gotten the payment data. We use the paypal. payment namespace again, yet use. get this time, passing in our paymentID and a success callback. (Typing) We'll then return our callback with our error, if any, along with a payment, aka, results object that was returned in the success callback. That was easy, right? Let's move on to actually executing a payment. Go ahead and attach an ExecutePayment method to our paymentService, giving it three parameters, our payerID, a MongoDB orderID, and a custom callback to fire once the execution is complete. Create a variable called payerObj and assign it to an object with the property payer_id, which we'll assign payerID. Then we'll use our mongoService to read our order from the database to get our payment information. We'll insert paypal_orders as our collection and an object with _id, which we assign new ObjectID and pass in our Mongo orderID. Finally, we pass in a success callback, giving us access to the reads error and results objects. If we have results, else there were no results, return our callback with the error message, no order found for this ID. If results we use the paypal. payment. execute method to execute a payment, passing in our results 0. OrderID. Remember, our read returns an array, even if there is only one result. We then pass in our payer object, an empty settings object, and a success callback, providing us error and response objects. If there as an error, return our callback with the error. If there was a response, create a variable called updateObj and assign it to an object with the property OrderDetails, which we assign response. We then need to update our MongoDB order with the new execution details. We do this with our mongoService. Update method, passing in paypal_orders. An object where _id is assigned to new ObjectID where we pass in our Mongo orderID, our updateObj, (Typing) and finally a success callback, giving us access to our error and update results objects. (Typing) Return our callback as null as the error message and orderID. Our executing of payments is complete. Now let's create a refund method. Attach a method called RefundPayment to our paymentService object. This method has three parameters, saleID, amount, and a custom callback to fire when the refund is complete. Create a variable called data and assign it to an object with the properties amount, which is an object that contains the properties; currency, which we assign to USD; and total, which we assign to amount. We then use the paypal. sale namespace, using the. refund method to refund a sale, depending on the saleID. We pass in our saleID as the first parameter, then data, followed by a success callback giving us access to our error and refund response objects. We return our callback with the error, if any, and the refund information. That's it for our payment service. Pat yourself on the back for making it through that. I forgot to add our MongoDB objectID reference to this file. So if we quickly go down to the bottom and require mongodb. ObjectID, and then go up to the top, giving it the alias OrderID, we can then use this functionality. Now we're ready to plug in this service to create and execute payments.

Integrating Single Payments Repository
In this video, we're going to create a repository that uses our payment service to initiate a payment and execute a payment. We're also plugging in our repository into our routes so that we can gain PayPal functionality and execute our payments to save the Sasquatch population. First off, create a folder in the root called repos, and then create a file inside of it called squatchPurchaseRepo. js. We'll start this file off with an IIFE, just like normal, and inject module. exports, paypal-rest-sdk, mongodb. objectId, (Typing) services/mongoService, (Typing) and services/paymentService. We'll then give these the aliases squatchPurchaseRepo, paypal, ObjectID, mongoService, and paymentService. Our first method we'll attach to the squatchPurchaseRepo is the BuySingle method. Go ahead and attach a BuySingle method to the squatchPurchaseRepo. This method has seven parameters, purchaseName, purchasePrice, taxPrice, shippingPrice, itemCount, description, and a custom callback once the payment has been created. Inside of this method, create a variable called transactionsArray and assign it to an empty array. We'll then loop through our itemCount, (Typing) creating a variable called itemObj, which is equal to our paymentService. CreateItemObj, passing in our purchaseName, purchasePrice, and 1 for quantity. We'll then push our itemObj into our transactionsArray using the. push method. Outside of our loop, create a variable called transactionItemObj, and assign it to an array with one element. We create this element using our paymentService. CreateTransactionObj, passing in our taxPrice, shippingPrice, description, and our transactionsArray. We'll then use our paymentService. CreateWithPaypal method, passing in our transactionItemObj, our successUrl, (Typing) cancelUrl, (Typing) and a success callback, giving us error and results. If we have an error, return our callback with the error, else, return our callback with null and our results object. To test this, go into server. js and browse until you find the route, buysingle. This is the route that will perform the creation of a payment. We need to create all the variables that are needed to create a payment. Next, we'll create a variable called purchaseName, which we assign to Single Squatch Habitat, purchasePrice, which we assign to 10. 00, taxPrice, which we assign to 0, wouldn't that be awesome, shippingPrice, which we assign to 0, that would also be awesome, and description, which we assign to Single Habitat Sasquatch Starter Kit. Before we do anything with our squatch purchase repo, we need to include it in our dependencies. Go to the bottom where we insert our require statements and require our repos/squatchPurchaseRepo. Then up top, give it the alias squatchPurchaseRepo. Now that we can use the squatchPurchaseRepo, go back down to the buysingle route and type squatchPurchaseRepo. BuySingle. We pass in our purchaseName, purchasePrice, taxPrice, shippingPrice, quantity, description, and finally, a success callback, giving us our error, if any, and a URL that we can reroute our users to. If there was an error, we want to respond with JSON using the. json method, passing in our error message. Now remember, this is only for educational reasons. If you do this is production and show the whole world your error messages, you will make the Sasquatches cry. Do no show detailed errors in production. If there was not an error, we res. redirect to the URL that was provided in the success callback. So when the user is taken off to PayPal, and everything checks out on their end, they're sent back to a success URL. If we don't add anything to our response in our success route, our users will never leave PayPal's site, and they will be stuck in a perma-load kind of thing. To fix this, we'll quickly hop up to our success. get route and send the orderID to the response. Now, if we open our terminal and start our server using Node server, remember that an instance of Mongod has to be running for this to work, we can open localhost 8080, set our quantity, and then click on Purchase. This will then take us to PayPal, if you're logged in. It won't ask for login. We'll see what a login looks like in a bit. It will then send us to our success URL if everything checks out. Notice our price is $30, so it got our quantity. And then here's our order ID that MongoDB uses as its unique identifier. When we are returned our success callback, PayPal adds something to our route's query string. Notice the question mark, followed by paymentid and payerid. PayPal provides us with this information so we can save it for later use. Remember, we only created a payment. We need to execute the payment before the money is exchanged. Let's go back into our squatchPurchaseRepo and add another method into our squatchPurchaseRepo object called ExecuteOrder. This method has three parameters that are required to execute an order, payerID, Mongo OrderID, and a callback to fire once the order is executed. We then use our paymentService. executePayment method, passing in our payerID, Mongo OrderID, and a success callback, giving us error and response objects. (Typing) Return our callback URL with the error and response objects, and we're done. Then open up server. js and browse for the success. get route. Remove the res. send method and create a new variable called payerID, assigning it to req. query. payerID. Remember, this comes from a route query that PayPal modified and appended to our URL. We then use the squatchPurchaseRepo. ExecuteOrder method, passing in the payerID, orderID, and a success callback. (Typing) If there was an error, response. json the error, else, if there wasn't an error, res. send h1 Order Placed, close our h1, Please save your order confirmation number, (Typing) plus, results,. orderID. So if we restart our server and go through the payment process one more time, we can see our success page telling us our confirmation number, aka, or orderID in MongoDB. Let's go back to our squatchPurchaseRepo and attach a CancelOrder method. This method has two parameters, an orderID and a custom callback that fires once the order is cancelled. This cancel isn't cancelling an already-created order; it's the cancel that happens when a person clicks the Cancel button when on PayPal's website. We use our mongoService. Delete method, passing in our paypal_orders collection, an object with _id, which we assign to new ObjectID, passing in our orderID, and finally, a success callback. (Tying) Lastly, we return our callback with our error and results objects. (Typing) To test this, go back to server. js and browse for the cancel route. We use our squatchPurchaseRepo. CancelOrder, passing in our orderID and a success callback. (Typing) If there was an error, we res. send There was an error removing this order, (Typing) else, if there was not an error, we redirect to the home page. Restart the server and reload the page. Make a single payment, click on Cancel when on PayPal's website, and watch it reroute to the home page. This means our order in the database was removed successfully. Next, let's go back into the squatchPurchaseRepo and add the GetOrder method to our squatchPurchaseRepo object. (Typing) This object has two parameters, orderID and a custom callback. We use our mongoService. Read, passing in paypal_orders, _id, assigning it to new ObjectID, passing in orderID, and a success callback with our order error and our payment object. (Typing) If there was an order error, return the callback with the order error, else, if there was not an order error, we use the paymentService. GetPayment method, passing in paymentObj 0 because our read returns an array,. OrderDetails. id and a success callback. We then return our callback with the error, if any, and results objects. To test this, go back to server. js and find the route orderdetails. Use the squatchPurchaseRepo's GetOrder method, passing in the orderID and a success callback. If there was an error, we respond with JSON and the error, else, if there was not an error, we respond with the order details, aka, results, in JSON format. Restart the server, reload the page, go through a single purchase again, and then copy your order confirmation number. Then go to your URL and change the route to orderdetails, slash, your order ID. Next, let's work on refunding a payment. Inside of our squatchPurchaseRepo, we want to append another method to our squatchPurchaseRepo object. This method is called RefundOrder, and it has two parameters, orderID and a custom callback. We'll use the squatchPurchaseRepo's GetOrder to get an order, passing in our orderID and a success callback, giving us access to our order error and our order. If there is an order error, return our callback with the error. Then create a variable called saleID, assigning it to order. transactions 0. related_resources 0. sale. id. This is how we get the sale ID from our order. The sale ID is PayPal's unique identifier, whereas our orderID is MongoDB's unique identifier. Create another variable called refundPrice and assign it to a number, passing in order. transactions 0. amount. total. (Typing) We then use our paymentService. Refund method, passing in our saleID, refundPrice, and a success callback. (Typing) Return our callback with error and refund objects. (Typing) To test this, go into server. js and browse to the refund route. Use our squatchPurchaseRepo. RefundOrder method, passing in our orderID and a success callback method. If there was an error, we respond with the error as json, else, respond with the refund information as json. Restart the server, reload the page, and create an order. On success, copy the order ID and then route to the refund/, the order ID. Now you can view all of the refund information. Congratulations, you created a payment service, as well as a repository that uses it to create and execute payments. You can now create orders, execute orders, refund orders, cancel orders, and get order details.

Integrating Recurring Payments
In this video, we're going to create a recurring payment service to enable recurring payments, using the paypal. billing plan namespace. Recurring payments, or subscriptions in PayPal, are known as plans and agreements. First, you need to create a billing plan, second, you need to create a billing agreement, and third, you execute that agreement. Remember this order, as it is key to PayPal working nicely. First off, let's shrink the routes we already finished and leave the routes we need to make. Now that the routes are cleaner, we need to create a service in our services folder called subscriptionService. js. We'll start this file off with an IIFE, standard procedure, and start filling in the dependencies. We'll pass in module. exports, paypal-rest-sdk, and our mongoService. (Typing) Then, we'll add the anonymous function, renaming our dependencies to subService, paypal, and mongoService. The first method we're going to attach to our subService object is going to be called CreateBillingPlanAttributesObj. This method will have eight parameters, planName, description, autobill, cancelUrl, returnUrl, planType, setUpFee, and paymentDefinitionsArray. Create a variable called billingPlanAttributes and assign it to an empty object. Return billingPlanAttributes. Inside of billingPlanAttributes, create the properties name, which we assign planName; description, which we assign description; type, which we assign planType; merchant_preference;, which is an object with the property auto_bill_amount, which we assign to autobill; (Typing) cancel_url, which we assign cancelUrl; return_url, which we assign returnUrl; initial_fail_amount_action, which we assign CONTINUE; max_fail_attempts, which we assign 1; setUp_fee, which we assign an object with the properties currency which we assign USD, value, which we assign setUpFee, and finally, outside of the merchant preferences, we make a payment_definitions, which we assign to paymentDefinitionsArray. (Typing) Next, we'll add another method to our subService object. We'll call this method CreateChargeModelObj and pass in two parameters, amount and type. (Typing) Create a variable called chargeModelObj and assign it to an empty object. Return the chargeModelObj. Inside of chargeModelObj, we create the property amount, which is an object with the properties currency, which we set to USD, and value, which we set to amount. Under amount, we set a property type, which set to type. (Typing) Let's attach another method to our subService object and call it CreatePaymentDefinitionsObj, (Typing) passing in name, price, type, chargeModels, cycles, frequency, interval. We then loop through our chargeModels. length and append chargeModels i. amount. value to our price variable. (Typing) Create a variable called paymentDefinitionsObj and assign it to an object with the property amount, which is an object that has a currency property, which we set to USD and a value property, which we set to price. Under the value property, create a charge_models property, assigning it to our chargeModels; cycles, which we assign cycles; frequency, which we assign frequency; frequency_interval, which we assign interval; name, which we assign type; and type, which we assign type. We then return our paymentDefinitionsObj, and we're done with this method. Next, we'll add yet another object creation method to our subService object. (Working) We'll call this method createBillingShippingObj, and we'll pass in six parameters, addrOne, addrTwo, city, state, postal, and countryCode. Then create a variable called billingObj and assign it to an empty object. We return billingObj and then insert the properties, line1, which we assign addrOne; line2, which we assign addrTwo; city, which we assign city; state, which we assign state; postal_code, which we assign postal; and country_code, which we assign countryCode. Let's create another object creation method. We'll add another method to our subservice called CreateBillingAgreementAttributeObj. We'll give it the parameters name, description, startDate, planID, paymentMethod, and shippingObj. (Typing) Then create a variable called billingAgreementAttributes and assign it to an empty object. Return the object and then modify it, giving it the properties (Typing) name, which we assign name; description, which we assign description; start_date, which we assign startDate; plan, which is an object that has an ID property which we assign planID; payer, which is an object that has a property payment_method that we assign paymentMethod; and shipping_address, which we assign shippingOBj. (Typing) Okay, so that method is done. Let's attach another one to our subService object. We'll call this one createAgreementUpdateAttributesObj (Typing) and pass in the parameters name, description, and shippingObj. Create a variable called updateAttributesObj and assign it to an empty object then return it. Inside the updateAttributesObj, we assign the properties op, which we assign replace; path, which we assign to slash, value, which is an object that has the properties description, which we assign description, name, which we assign name, shipping_address, which we assign shippingObj. And that's it for this method. Finally, we're done with all of our object creation methods. We can now focus on creating plans and agreements. Attach a CreatePlan method to our subService object. This method has the parameters billingPlanAttributes and a callback. Creating the billing plan is actually very straightforward. We use the paypal. billingPlan namespace and the create method to create our billing plan. We pass in the billingPlanAttributes and a success callback containing our error and billingPlan object. We then return our callback with our error and billingPlan objects. Now as long as the billingPlanAttributes object that we pass into the create method is the right object, PayPal will be happy. This is why we spent so much time building methods that scaffold these objects for us. Now that we can create plans, let's create a GetPlan method. Go ahead and attach a GetPlan method to the subService object and pass in the parameters billingPlanID and a custom callback. We use the paypal. billingPlan namespace once again and use the get method to get our billingPlan. We pass in our billingPlanID and a success callback. Lastly, we return the callback with our error and billingPlan objects. When we create a plan, before we create an agreement with that plan, we need to change the plan's state to active. Attach a method called UpdatePlanState to our subService object, passing in the parameters billingPlanID, status, and a custom callback. Then create a variable called billingPlanUpdateObj and assign it to an array containing a single object. This object has the properties op, which we assign to replace; path, which we assign to path; and value, which is an object that contains the property state, which we assign status. (Typing) We then use the paypal. billingPlan namespace with the update method, passing in our billingPlanID, our billingPlanUpdateObj, and a success callback. (Typing) We return the callback with our error and response objects, and we're done. Now that we have methods to create a plan and update its status, we can create a method that creates an agreement. Attach a method called CreateAgreement to our subService object, passing in the parameters billingAgreementAttributes and a custom callback. Use the paypal. billingAgreement namespace with the create method, passing in our billingAgreementAttributes and a success callback. (Typing) Return our callback with the error and billingAgreement objects, and that's it for this method. So we can create an agreement. Let's create a method where we can cancel one. Attach the method cancelAgreement to our subService object, giving it the parameters billingAgreementID, cancelNote, and a custom callback. Create a variable called cancel_note and assign it to an object with the property note, which we assign cancelNote. We then use the paypal. billingAgreement namespace with the. cancel method, passing in our billingAgreementID, cancel_note, and a success callback. (Typing) Return the callback with the error and response messages, and we're done with this method. We can create and cancel an agreement. Let's make a method where we can get an agreement. (Typing) Attach a method called GetAgreement to our subService object, giving it the parameters agreementID and a custom callback. We use the paypal. billingAgreement namespace once again, with the. get method, passing in our agreementID and a success callback. Return the callback with our error and billingAgreement objects, and we can call it a day for our GetAgreement method. Finally, we have plan creation and agreement creation. We need to execute the agreement before the payment can actually take place. Attach a method to subService and name it ExecuteAgreement. Give it the parameters paymentToken and a custom callback. We use the paypal. billingAgreement namespace, using the. execute method. We pass in our paymentToken, an empty options object, and a success callback. Return the callback with our secure objects, and execution is complete. (Typing) Our last method we'll attach to our subService object will be called UpdateAgreement. This method will have the parameters billingAgreementID, billing_agreement_update_attributes, and a custom callback. Use the paypal. billingAgreement namespace with the update method, passing in our agreementID, billing_agreement_update object, and a success callback. We return our success callback, and we are completely done with this file. Congratulations, you made it through the hardest part of this course. You now have a reusable service that handles subscriptions, including plan creation, agreement creation, agreement execution, and updating agreements.

Recurring Payments Repository
We need to include our new subscription into our dependencies. We require it down below and give it the alias subService above. Now that we have our subService added to squatchPurchaseRepo, we can use its functionality. Attach the method buyRecurring to our squatchPurchaseRepo object. This method has the parameters planName, description, setUpFee, and a custom callback. (Typing) Create a variable called planObj and assign it to an object with the property PlanID, which is an empty string. Use our mongoService. create method to a plan in our paypal_plans collection. We passing in our planObj for the data to be inserted and a success callback. (Typing) In the success callback, create a variable called returnUrl and assign it to http://localhost:8080/recurring_success/ + results. insertedIds0. This will append our new agreement ID to our success URL. (Typing) Create a cancelUrl variable and assign it to local:8080/recurring_cancel/ + results. insertedIds0. (Typing) Next, create a variable called chargeModels and assign it to an array. Inside of the arrays, we use the subService. createChargeModelObj, passing in 0 for the price and TAX for the charge model type. We then do the same yet pass in SHIPPING for the second charge model. (Typing) Next, create a variable called payment definitions array and assign it to an array that has an object we create using our subService. CreatePaymentDefinitionsObj method, (Typing) passing in Squatch Maintained Habitat Rental for description, 10 for the price, REGULAR for the type, chargeModels for the charge models, 12 for the cycles, MONTH for the frequency, and 1 for the frequency interval. Then create a variable called billingPlanAttributes and assign it to subService. createBillingPlanAttributesObj, (Typing) passing in planName, description, YES for autobill, cancelUrl, returnUrl, fixed for the type, 0 for the setup fee, and paymentDefinitionsArray for our payment definitions. (Typing) Finally, we use our subService. CreatePlan method, passing in our billingPlanAttributes and a success callback. (Typing) We use our mongoService. Update method to update our recently inserted plan. We can find it by inserting a find object with the property _id, which we assign results. insertedIds0, (Typing) and then pass in an object with the property planId, which we assign to newPlan. id and then a success callback. We've created the plan in PayPal as well as in our database, yet we need to change the state to active before we can create an agreement with our plan. We do this by using our subService. UpdatePlanState method, passing in our newPlan. id and ACTIVE as the state we wish to set it to. We then get a success callback with our error and update results. In our success callback, create a variable called shippingObj and assign it to subService. CreateBillingShippingObj, passing in 1 Boulder Lane for the address 1, an empty string for address 2, Boulder for the city, CO for the state, 80301 for the ZIP, and US for the country code. Then create another variable called agreementObj and assign it to subService. CreateBillingAgreementAttributesObj, (Typing) passing in Squatch Maintained Agreement for the agreement name, Maintained Squatch Habitat Description for the description, (Typing) new Date, passing in Date. now + 5000 * 60 for 5 minutes into the future for the creation time, newPlan. id for the plan ID we want to create this agreement from, PAYPAL, which is our payment method, and finally, our shippingObj. We then use our subService again, using the. create method, passing in our agreementObj and a success callback. Just like when making a single payment, PayPal will provide us with a set of links to reroute our users to. We need to loop through our links to find which one is the correct URL. We'll create a for loop to loop through response. links. length, if the response. links i. rel == approval_url. Return our callback with error, if we have one, and response. links i. href. The buyRecurring method will create the billing plan, set the plan to active, and then create the billing agreement. Remember, we need to execute the agreement before payment starts. So that was probably one of the hardest things in this course, yet as long as the correct values go into the methods that create the objects that PayPal requires, PayPal will be happy. Now that we have billing plan and agreement creation out of the way, let's execute our agreement. Attach the method ExecuteRecurring to our squatchPurchaseRepo, passing in the parameters token and a custom callback. We use our subService. ExecuteAgreement method, passing in token and a success callback. Then we return our callback with the error and results objects. The token object will come from our success query that PayPal has kindly modified so we can access it. You'll see this in action in a bit. Now that we can set up subscription with agreements, let's attach a method to our squtachPurchaseRepo called GetRecurringDetails so we can see the details of executed agreements. This method has the parameters agreementID and a custom callback. We use subService. GetAgreement, passing in our agreementID and a success callback. We then return our callback with error and results, and we're done with the GetRecurring method. And now the moment you've all been waiting for. Let's add this new functionality to our server routes. (Typing) Browse server. js until you find the buyrecurring route. We'll use our squatchPurchaseRepo. BuyRecurring method, passing in Squatch Plan as the plan name, Recurring Squatch Plan as the details, 0 for the setup fee, and a success callback. If there is an error, we res. json the error, else, if there is no error, we res. redirect the plan, aka, the URL that leads our users off to PayPal. Let's modify the recurring success route so that we're not permanently stuck in PayPal. We'll create a variable called token and assign it to req. query. token. This is where we get that token I was talking about earlier. It comes from PayPal in our success route query string. Next, we use our squatchPurchaseRepo. ExecuteRecurring, passing in our planID, token, and a success callback. If there was an error, we respond with the JSON showing the error, else, we respond with JSON showing the results of the executed added agreement. (Working) Okay, finally we can test it. Go ahead and relaunch the server, reload the web page, and click on Purchase Recurring. This will lead you to PayPal and authorize you for payment. It will then return you to the return URL, where you can see all the fancy information they return back to us. For some practice, modify the recurring cancel route so it removes the plan from the database. Remember, this route isn't cancelling an already-executed agreement; it's just the URL the user comes back to when they click Cancel or don't have the authorization. Finally, let's work on our recurring order details route. We use the squatchPurchaseRepo. GetRecurringDetails method, passing in our agreementID and a success callback. If there is an error, we respond with the JSON showing it. Else, if there is no error, we respond with JSON showing the recurring order details. So if we restart our server, reload the page, and then execute a recurring payment on our success page, copy the ID property, this contains our agreement ID that we can use to get the details of this agreement. If we route to recurring_orderdetails and then paste our agreementID, we can then get our agreement details. Congratulations, you've made it through creating subscriptions. If you're sharp, you've noticed that we didn't include updating agreements or cancelling agreements in our squatchPurchaseRepo. We did however create the methods to enable this functionality if you were to set them up. I'll leave that to you as some homework for everyone to hone your new skill set. You helped us save the Sasquatch population and learned a great detail about subscriptions using PayPal.

Summary
In this chapter, we learned how to use the PayPal REST SDK. We learned that the payment namespace is responsible for making single purchases, and the billing agreement namespace is responsible for recurring payments. We created methods to build the objects that the payment methods and billing methods require to work, as well as built a repository to use this functionality, then integrated this repository into our server routes. They key things to take out of this chapter are the payment namespace is responsible for payments. First, you must create a payment and then execute it. The billing agreement namespace is responsible for recurring payments. First, you must create a plan, then create an agreement using that plan, then execute that agreement. Before you create the agreement, you must modify your plan to be active.

Summary
Summary
Pat yourself on the back. You've made it through this course and are on your way to being a PayPal expert. Let's take a brief moment to go over what you've learned in this course, as well as some of the most important topics to take out of this. First off, we created a Node server using Express and body-parser. Then we created basic routes to prepare ourselves to fill in later once the PayPal services were complete. The biggest thing to get out of that chapter is that body-parser is responsible for parsing forms. We used req. body, req. params, and req. query to get information being sent to the server. Second, we made the view for our web application, adding some styles and our awesome Sasquatch background. We set up forms to post to certain routes, as well as inputs to capture our quantity. Third, we created a MongoDB service that you can reuse for any of your Mongo CRUD operation needs. The biggest thing to get out of our Mongo service is that you want to always close the database connection once you're done with it. Fourth, we installed PayPal using npm and installing the PayPal REST SDK. We then set up our dashboard on developer. paypal. com, setting our application and test accounts. Remember, sometimes those can take up to three days to actually save. Fifth, we made a service for a single purchase and payments. The key thing to take out of that was when making a payment, we first need to make the payment and then execute it. Creating the payment will not finish the payment; it must be executed. Sixth, we made a recurring service for recurring purchases, using the billing agreement namespace object provided by the PayPal REST SDK. The key thing to get out of that was first, you need to make a plan. set it to ACTIVE, second, you make an agreement, and finally, you execute that agreement. If you don't follow that process, PayPal will result in errors. We also made a Sasquatch repository, which took all of our service methods and put them into action so we can easily call them for our routes. I hope you enjoyed this course, and we'll see you in my future courses. We did it. We saved the Sasquatches.
