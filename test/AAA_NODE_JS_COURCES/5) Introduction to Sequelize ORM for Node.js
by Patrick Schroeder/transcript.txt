At the core of developing any website or application is database management. In this course, Introduction to Sequelize ORM for Node.js, you will learn the skills needed to create high-quality Node.js apps that use SQL as their database. First, you will learn how to include Sequelize into a Node.js project configured with SQLite. Next, you will explore how to customize models, perform CRUD operations, and form associations. Finally, you will put it all together to build a full-stack JavaScript application using Angular on the frontend. When you're finished with this course, you will have a foundational understanding of how to use Sequelize in Node.js to create high-performing applications.

Course Overview
Course Overview
Hey everyone. My name is Patrick Schroeder, and welcome to my course, Introduction to Sequelize ORM for Node. js. I'm a JavaScript developer and entrepreneur. I love to learn about new technologies, build cool apps, and share my knowledge. In this course, you will learn how to use Sequelize ORM in a Node. js project. Sequelize is an amazing tool because it makes it so easy to interact with the most popular SQL databases such as Postgres, MySQL, and SQLite. The first part of this course will cover the fundamentals of Sequelize. This includes building a new project, adding models, building model associations, and performing CRUD operations. In the final module, we'll put it all together and build a full stack JavaScript application using Angular on the front-end. By the end of this course, you'll know how to incorporate SQL databases using Sequelize into any Node. js application. This course was made with the beginner in mind, so even if you have little experience with SQL or Node. js, you will still be able to follow along and learn a ton. I hope you'll join me on this journey to learn about building Node. js applications using Sequelize here, at Pluralsight.

Features of Sequelize
Introduction and Overview
Sequelize makes it easy to connect to the most popular SQL databases using plain JavaScript objects. My name is Patrick Schroeder, and welcome to my course, An Introduction to Sequelize ORM for Node. js. This course will be broken up into two sections and six modules. The first five modules will be dedicated to getting you familiar with all of the core features of Sequelize. This includes building a new project, setting up models, and creating associations. In this section, we will be using our browser window to view responses in JSON, along with an SQLite database viewer to browse entries in our database. In the final module, we'll put everything together and build the backend for an existing Angular application. In this app, you'll be able to view books and users. We can click on this Edit link, which will take us a user page. From there, we'll be able to add books to a user's reading list, along with being able to save a favorite book for that user. Now before we fully dive in, let's discuss what technologies we'll be using and what you should already know prior to taking this course.

Prerequisites
This course was made with the beginner in mind, but there are a few prerequisites for this course. You should already be familiar with the basics of JavaScript including arrays, variables and objects. You should already have Node. js installed on your machine. I will be using version 8. 11. 1 on a Windows 10 machine. I will also be using Visual Studio Code as my preferred text editor, but you are free to use whatever editor you like. There are also a few 'helpful to know' items for this course. It will be helpful if you already have some prior experience working with an SQL database. However, I will be covering the basics of SQL in this module for those of you that have no prior knowledge or experience. It will also be helpful if you have worked with Angular in the past since this is what our frontend will be based on for the final project. But, again, not completely necessary since I will be providing you with the completed frontend code base and mainly covering the building our of API.

What Is Sequelize?
So what is Sequelize? Sequelize is a promise-based Object Relational Mapper that makes it easy to interact with SQL databases inside of a Node. js project. When we say 'Object Relational Mapper, ' this just means that we're able to define a JavaScript object model which Sequelize transforms into a corresponding SQL table with columns and rows. This saves us the trouble of having to write complex SQL queries needed to interact with our database. Sequelize is a popular open source project available for download here on GitHub. Sequelize is also available via npm, which makes it very easy for us to add to any Node. js project. Throughout this course, I will be referencing the API documentation located here at docs. sequelizejs. com. These docs provide excellent examples for many of the helper methods we'll be using when connecting to a database, building models, and accessing our database tables.

SQL Database Explained
Sequelize connects us to the most popular SQL databases such as MySQL, Postgres, and SQLite. If you've never worked with or have limited knowledge of SQL databases, this clip will provide a basic overview. SQL databases are used pretty much everywhere. They are extremely prevalent on the web. They are commonly referred to as relational databases that store data in tables. These tables contain columns and rows. Each column is given a name and a data type. The data type defines what kind of value the column can hold such as integer, string and date. Each entry into a table is contained inside of a row. Each row is given a unique identifier known as a primary key. When using Sequelize, this primary key is automatically generated and inserted into the column with the name of ID. SQL Tables can be associated. So, for example, we can have a Users table and an associated Posts table so that for every post that's added, we can save the user's ID in its own column. Then when we retrieve that post, we can also get back all of the data for the user that is associated. The response of this association in JSON would look something like this. This is called a join. Joins are a very powerful feature of SQL databases and will be covered in depth in our module on associations. So to review: SQL databases contain tables. These tables contain columns and rows. Every new entry into a table is added as a row and has a unique identifier known as a primary key. When using an SQL database we can join together two different tables to send back data from both tables by referencing a primary key.

Sequelize Uses Promises
Sequelize is promise-based by default. A promise in JavaScript represents the eventual completion (or failure) of an asynchronous operation, and its resulting value. Because JavaScript is single-threaded, if we were just to make a request to our database without a promise or callback, our browser would be locked up until some response was given back. Sequelize uses the promise library called Bluebird internally. This means that we can use any of the methods found on this bluebird website when making requests to our database. The two main functions we'll be using throughout this course are then and catch. The then function is chained on after a request is made and, if the request is successful, will contain an object with the resulting data set. The catch function is chained on after the then function and contains an error object in the event that an error has occurred. And here is some example code. So, first, we find the user using a request method of findById. The then function is chained on to the request and contains in its argument the response data on success. The catch method will be called in case there is an error and will contain a response object that we can access via its argument. Now if you're already familiar with Node. js, you may be aware of the newer async/await syntax that simplifies this promise structure. For the sake of consistency in this course, I will be using the promise structure shown in this slide. However, if you wanted, you can pretty easily refactor all of the code using async and await, which would make the previous slide look like this.

Benefits of Sequelize
Now that you're up to speed on what what Sequelize is, let's go over the main benefits of using Sequelize in your Node. js projects. The first major benefit of using Sequelize is that it provides us with many useful methods that save us the hassle of writing lots of boilerplate code. All of the popular SQL database engines like MySQL and Postgres already have their own npm libraries that we could use in our Node. js project. But by opting to use Sequelize as a middle man, we're able to perform the same types of functions with far less code. Another big benefit of using Sequelize is that all the code we write is JavaScript. This saves us from having to write often times pretty complex SQL queries. Sequelize provides us with a very robust API that we can use to build models and query or mutate data. When using Sequelize, we get built-in, under-the-hood security, such as automatically escaping replacements to prevent against SQL injection attacks. Sequelize isn't going anywhere. It has been around for many years, is actively maintained, and has a large community of enthusiasts on Stack Overflow to help answer any questions. There is even a CLI tool that you can download to help with project setup and with database migrations.

Summary
In this module, we covered the fundamentals of what Sequelize is along with what benefits it offers. This included a review of SQL databases. And also an introduction to promises, which are used by Sequelize when receiving a response from our database. In the next module, we'll be setting up a brand new project, creating our first model, and syncing that model to a database.

Sequelize Setup
Introduction
Sequelize makes it easy to interact with SQL databases when working with Node. js. My name is Patrick Schroeder, and welcome back to An Introduction to Sequelize ORM for Node. js. In this module, we'll walk through setting up a new Sequelize project using the SQLite database. Once our project is set up, we'll begin working on our User model. Models are at the heart of Sequelize, and they define the key-value pairs that create our tables and columns. Once our model is in place, we'll sync our model with our database, create some data, and then view the results. We'll finish up this module discussing what types of data can be submitted to our database and how primary keys are unique identifiers automatically generated that are used to keep track of our table rows.

SQLite Installation
When building a new Sequelize project, we first need to decide on which database we want to use. Sequelize gives us the option of using four of the most popular SQL databases. These four are MySQL, Postgres, SQLite, and MSSQL. Since we'll be developing our project locally, the database we use needs to be installed on our machine. To get you familiar with Sequelize, I have decided to use the SQLite database. SQLite is a great option for building our examples because it's a simple lightweight database that can be accessed via the command line. You can already find SQLite preinstalled on many Apple OS X operating systems. Since I'm on a Windows 10 machine, I'm going to walk you through the download process from my computer. This process is very similar to Windows 8, and if you're on a Mac, SQLite is either already preinstalled, or you will be able to download it very easily by following one of the download links here at sqlite. org/download. html. I'm going to download the zip file under the Precompiled Binaries for Windows, which includes a command line shell and is the third option down. Once downloaded, I'm going to right-click on the download and extract the files. I'm going to go into this folder to find a tools folder, which contains our executable files, and rename this to sqlite3, and then move this folder into my root C directory using cut and paste. Now I also want to edit my environment variables to include the path to this folder. The reason I'm doing this is that I want to be able to run the command sqlite3 from my terminal, and it will open the SQLite database. So in order to do that, I will go into my sqlite3 folder, copy the location of my folder right here, and then navigate over to where my environment variables are located, which is under my Control Panel, System, Security, then Advanced system settings is where I can find my environment variables link. Then I will highlight the path here and click on Edit, then click on New, and paste in the SQLite folder path. Click OK to exit out. And now I want to test out creating a new database. I can do this by opening up any terminal console. And in this case, I'll just bring up my Cmder for Windows console window. And I can type the command sqlite3, which is first going to provide some info on the version I'm using, and it lets me know that I'm connected to a transient in-memory database. And this just means that any open database will close when our connection to the sqlite3 closes. There are a number of available commands that we can access by typing. help. We can use any of these commands here to create and manipulate an SQLite database. So let's test this out by creating a new database inside of our sqlite3 folder. I will first exit out of SQLite by typing. quit. Then I will move into the location of my sqlite3 folder, which is located at the root of my C drive. And then I can use the sqlite3 command plus the name that I want for my new database to be, which will be testDB. db. A new database has now been created inside of my sqlite3 folder, but if I navigate into the folder, you can see that there's nothing there. So the database is actually hidden before it's used or accessed. So in order to access the database and reveal its presence, I can hop back into my terminal and execute the command. databases. This is going to list out all of the SQLite databases and reveal our newly created testDB file.

Project Setup
With SQLite now set up on our machine, let's get to work on building a new Node project. I'll be using Visual Studio Code on a Windows machine. I'll also be using Cmder inside of Visual Studio as my preferred terminal window. You can find out more about this tool I'm using cmder. net. A few advantages it offers is built-in Git and a better visual interface. Working now from my terminal, I'll cd into my desktop. From there I will create a new folder using the md command, and the name of this folder, which is pseq, then I'll cd into this new folder. I'll create a new file now by typing touch and then server. js, which will be the entry point to my Node project. I can create a new package. json file by using the command npm init, and then use the --y flag to pre-populate the package. json file with some basic info that you can see right here. Next up is to install the packages we'll be using. I'll be using Express here so that I can easily create a server and some routes. I can do that by typing npm i express. We'll be installing Sequelize, and then we also need to include the database. Each database has its own package that needs to be included. Since we're using SQLite, there is a package called sqlite3. Then I'll use the --S flag to save these libraries to our package. json file. A quick note here on the sqlite3 download, you can find more info about this package on the npmjs. com website. This package can be used by itself to create and manage an SQL database in Node, or we can use this package in conjunction with Sequelize so that we can avoid having to write these SQL statements. Now hopping back into my editor, I'm going to add my project folder into Visual Studio Code. And now I'm going to open up my server. js file and include into it first Express, and then Sequelize. I'll add in a variable reference to Express so we can create its server and routes along with the reference to a port number that I want to run my project on, which will be 8001. Notice here that we've also downloaded sqlite3 from npm, but we do not need to reference the package in our server file as Sequelize will take care of this import automatically. At the bottom of this file, I'm going to include now the code to create a new Express server and also print out a message to the console when it successfully connects. My Auto Save feature is set to On here in my Visual Studio Code so my files will save automatically. Then I'm going to open up my terminal using Ctrl+` and test out this code by typing npm start. And here we can see the message that our server is running on port 8001.

Connecting to Database
And now we're ready to connect Sequelize to our database. I can do this by first creating a variable reference named connection, which will store a Sequelize instance. The Sequelize instance is a constructor function, hence, the new keyword, and once I add in these parentheses, our IntelliSense tells us exactly what our Sequelize instance expects. It first expects the name of our database, which is a string, and then a username and then a password, which are also strings. Now these three arguments are required, but since we're connecting to a local SQLite database, these three arguments can actually be any bit of text that you want. So in our case, I will just enter db, user, and pass. The fourth parameter is an optional object that we use to assign certain database values. I'll close out the Explorer here now to give us some more room. And inside of our object, we will need to first assign a hostname, which will be localhost, the dialect, which tells Sequelize which SQL database we're using, and in our case, it's SQLite, and since we're using SQLite, we also need to include a storage key, which is the path to where we want our database file to exist. It's going to exist in our root directory inside of the pseq folder. And this file name can be anything you want so long as its extension is sqlite. And, lastly, I do need to add in an operatorsAliases set to false. This will prevent us from receiving certain deprecation warnings inside of our console. With our Sequelize instance all set up, we can now test it out. To do this, I can use the connection reference,. authenticate, to force open our database. And then I'll pass in log messages upon successful connection, along with a catch error message in the event our attempt at connection fails. I'll reopen my terminal window and kill the server using Ctrl+C, then restart it by typing npm start. And you can see here we get a message indicating a successful connection. And you can also see that we get a db. sqlite file created and added into our project. You've now set up a new Node. js project connected to a server and created a new Sequelize database instance that uses SQLite. Great job! The next step will be to actually start using our database.

Models
The power of Sequelize lies in its ability to map JavaScript objects into SQL tables. In order to achieve this link between objects and tables, we define models. These models are then mapped or transformed into the tables and columns inside of an SQL database. So, for example, we can define a model with the name of User, then add to that model key-value pairs of name and bio. These are what's known as attributes. The key name will map to an SQL column, and the value will be the type of data that's allowed inside of the column. The model name of User will be mapped to an SQL table, and it will automatically be pluralized, so User becomes a Users table. And the table will then contain columns called name and bio. Any data stored here will match the data type defined in the model. I'm going to now walk you through creating a new model in the next slide, and then we'll create the model inside of our project. When creating a new model in Sequelize, we first need to define a variable that will hold our model reference. The typical naming convention here is to capitalize on model name and make it singular. We set this equal to or Sequelize connection reference and then use the define method. The define method creates our model instance and accepts two arguments. The first argument is a string, which is the name of our model, and it should match our variable reference name. The second argument is an object. This object will contain all of the attributes that get mapped into our SQL database. Back in my Visual Studio Code, let's now create our User model. I'll start out by declaring a reference for my model as User, then set this equal to my Sequelize connection. define. The define method accepts two arguments. The first is the name that I want to give my model, which will be User, and then I will create an object and list out two attributes that will correspond to my SQL columns. The first attribute will be called name, and it will have a data type of STRING. The second attribute will be called bio with a data type of TEXT. With our model in place, now we just have to sync the model with the database.

Sync Database
In order for our models to be turned into tables inside of an SQL database, we need to call on the sync method. We can call sync either on the model itself or, more commonly, call sync on our Sequelize connection. When invoking sync, we're also able to pass it an optional object. This object can contain a few helpful properties such as logging. When logging is set to console. log, we will be able to see in our console the raw SQL code that is being used to create our table and columns. To better understand how to use the sync method and some of the options available, let's now take a look at the Sequelize docs. We can find the documentation here at docs. sequelizejs. com. When searching these docs for the keyword sync, we get a few results. Let's click on the first one under Database synchronization. Here you can see a few examples of when sync is called directly on the model, and here is an example of when sync accepts an optional property of force set to true. This will drop the table first, and then re-create it. We can find the other optional properties by again searching sync, and this time clicking Public Methods. And here we can find all of the other options available to us. We'll be using the logging and force properties in our examples. Let's now add the sync method to our project, and check out the response. Hopping back into my text editor, all I need to do is chain the sync method onto connection, and then I can pass it the logging property with the value of console. log. I'm also able to now remove the authorize method since calling sync will perform the same function. Then I'll go into my terminal and run npm start. And now you can see that we get the raw SQL printout that Sequelize used to create a new table called Users and also create columns for a name and bio that match our attributes defined above. Also notice that we have a few other columns here which are ID, createdAt, and updated. These three columns are always automatically added every time a new table is made. CreatedAt and updatedAt contain a timestamp for when a new row of data was initially made or updated. The ID field is a primary key that uniquely identifies a row. And we'll have a whole video on understanding more about these primary keys coming up soon. With our Users table created, let's now take the next step and add in some data.

Test with Data
With our table created, let's now add in a new row of data. In order to add data into a table, Sequelize provides us with the create method. We can see an example usage of the create method on the homepage of the Sequelize docs. To use it, we just need to chain the method on to our model and then pass into it the attributes defined on our model along with the data that we want to add. Back in my editor, I'm going to use the create method on my User model after my model has been synced. Since Sequelize is promise-based, I can very simply chain on a then function. And inside of this function, I can call the create method on my User model. We need to make sure that we use the same attributes that have been already declared above with a name that's a string, along with the bio that's also a string. I'll open up my console window now and kill my server, and then restart the server, and view the results. And here you can see that a new user has been added to our table with the attributes we defined inside of create. Now in order to better see what's inside of our database, I'm going to download the SQLite browser. It's a small compact download and available for both Windows and Mac users. To follow along with me, you can navigate over to sqlitebrowser. org and choose the installation that's right for you. Once the installation is complete, you can open up the viewer, and it should look like this. We'll first click on Open Database. And from there select the SQLite database that currently exists in your project. And right away I can see an overview of the database structure. If I click on the Browse Data tab, we can now see all of the tables that have been created along with its status. Currently, we only have a Users table, and it does include the newly formed row of data that we just added in.

Data Types
When creating our attributes, we define key and value pairs. For every attribute created, we must define a data type that specifies what type of data is allowed. You are probably already familiar with many of these data types. These included strings, integers, date, array, Boolean, among many others. To get a full list of the data types allowed by Sequelize, we can head on over to the docs, search for data, then click Data types under Model definition. And here we can see a full list of all the data types that we can define for each of our attributes. Notice how each one of these is prefixed with the Sequelize keyword. You've already been assigning data types to attributes on our User model using STRING and TEXT. TEXT is actually the same thing as STRING except that it allows for storage of a longer string of characters. Whenever adding new data into a row, it must match the data type defined in our model. So, for example, if we were to try and add a new row of data to our Users table with an array value instead of a string, our server crashes, and the data never gets added.

Primary Keys
Primary keys are an essential feature of all SQL databases, and they serve two main purposes. First, they uniquely identify every row of data that's submitted to our database. And, second, they are the reference point that's used when forming associations between tables. And we'll have a whole section on forming these associations later on in this course. Primary keys are auto-generated, auto-incremented, and they cannot contain null values. In the case of Sequelize, a primary key is created automatically under the column name of ID. After creating our first user, Sequelize assigned to the ID column a value of 1. Here I've added in a new user named Bob. And the ID field now has a value of 2. Now we do have the option of defining a primary key with a name other than ID if we want. To show you how this is done, I'm going to search the Sequelize docs for primary, then click Primary keys. In here we can find two examples. In the first example, we have an attribute named uid, and if we need to define more than one property for our attribute, we can use an object. We always need to define the type. Then we can use the property called primaryKey set to true. And here another property called autoIncrement is used to make sure the integer values are added one at a time. Here is another example using UUID. UUID is a data type that stands for Universal Unique Identifier 36 characters in length. So let's go ahead and test out using UUID inside of our User model. Back in my editor, I'm going to first add the force property set to true insight of sync. This will drop my Users table and then re-create it. I'll then go up into my User model and create a new attribute of UUID. Open up an object with a type property of UUID and a primaryKey property of true. I also need to add in an additional property here of defaultValue with the type of UUIDV4. If we don't assign this default value here, then this column will be null. Then I'll restart my server. And here you can see in the console that a new user was created with a UUID column and a value that contains a unique identifier.

Summary
In this module, we covered all the requirements for getting started with the Sequelize project. We started out by connecting our project to an SQLite database. Then we built a User model that was transformed into an SQL table. You added in new data to our Users table using the create method and observed the output in our database viewer. And, finally, you got familiar with the types of data allowed to be submitted, along with the purpose of primary keys. You've come a long way and are now very familiar with the essential building blocks of Sequelize. Next up, we'll be discussing how to customize our model attributes and perform validation.

Customize and Validate
Introduction
Hello, and welcome back to An Introduction to Sequelize ORM for Node. js. So far, we've created a new Sequelize project, and added a Users model with two attributes. A lot of the time, we don't want to just submit to our database any data that comes our way. We may want to first perform some validation such as making sure our user has submitted a valid email. In this module, we'll cover the options available to us to customize our model, how to perform validation on attributes prior to data being added to a database, and how to use before and after hooks to encrypt or customize data before it gets to our database.

Customize Model
Sequelize provides us with a few optional properties we can use to customize our model. One of these is called a freezeTableName. When this property is added to our model and set to true, the name we give our model will match the name of our table. Let's now go into the docs so you can see the different options available, and then we'll add a few of these to our existing user model. I can search the docs for freezetable, and then we have to scroll down a little bit until we get to the options. And this is where we find all the different property options we can use on our model. Here is an option for timeStamps. It's a Boolean, and when set to false, our createdAt and updatedAt timeStamps won't be automatically created. Here is the freezeTableName option. When this is set to true, our table name will not become pluralized. Let's now add a few of these properties to our User model. The option properties we just looked at are actually a part of the define method. That means that we can add these globally so they're added to every model we create or just a specific model. In order to add these options globally, I can add in a new property to my Sequelize object called define, and this define is the same as the define method that is used on our model. Then inside of our Sequelize define, I can open up an object and add in any properties here. So we'll just add in freezeTableName set to true. Make sure that your sync method still has force set to true so your tables get dropped. And then start up the server. And here you can see the table name now matches the model name. Let's add one more option directly on our model. When using any of these options on our model, we have to declare them in a third parameter as properties on an object. We'll choose the property timeStamps set to false. Then I'll kill and restart my server. And here you can see our User table did not create an updatedAt or createdAt fields.

Attribute Qualifiers
Sequelize provides us with a few attribute property qualifiers that allow us to customize attributes before they become columns. These include properties used to assign a primary key, assign a default value, or to make sure submitted data is not null. If we decide to use one of these properties, then they are placed in an object in the value field of an attributes name. Inside this object, we always need to first specify the data type, and then we can go ahead and place any of the preapproved qualifiers below. You've already used a few of these on our User model in the previous section, such as when we placed a primary key property on user ID attribute and assigned a default value of UUIDV4. Defining the other property options available to us, I can search the docs for freeze, which brings us to a list of available options. Notice how these are defined using dot notation of attributes. column and then the name of the property used on our attribute. The three that you'll use the most often we have already discussed, and these are allowNull, used when we want to make sure that the column contains some data, defaultValue, and primaryKey. Now if we scroll down a little bit, we get to attributes. validate. And this is the property we'll be using to perform many types of validation on our attribute.

Validations
We may want to validate data as it's coming in to make sure it matches our requirements. Sequelize makes it easy to perform these types of validations by implementing a long list of validator's from validator. js. Returning back to the Sequelize docs, remember, we took notice of this validate property. The description here reads that validate is an object of validations to execute for this column every time the model is saved. It can be either the name of a validation provided by validator. js, a validation function provided by extending validator. js, or a custom validation function. In order to find all the possible validations provided by validator. js, I can search the docs for validations and click the link under Model definition. This brings us to an explanation and example page for how to deploy a large number of different types of validations. These built-in validations allow you to easily verify if the input is in valid form. For example, you can check if the user has submitted a valid email address, a properly formatted URL, or valid credit card numbers. In order to run validation, we first need to add the validate property to a currently existing attribute, and then we can add any number of these validation properties. If the submitted data does not meet the specified constraint, validator will send back a custom error message, or we can create our own message. If we want to create our own error message, it must be in this format, so, first, a validator that we're using, and then an object with a property called args, which contains the actual validation we want to perform, along with an msg property with a string of what the error message should be on failed validation. Let's now test this out and add in a few validator's to our User model. I'll add in a new validator to my name attribute by opening up an object and declaring a type of STRING. Then I'll add in one of my validator properties. Now in order to add in any of the validator options, I need to set the value as an object. And let's use the len validator here. So len accepts an array of two values. The first value will specify the minimum number of characters needed for validation to pass, so we'll put in 3. The second value is optional and will specify the maximum number of characters allowed. Since I want to will allow no max values, I'll just leave it blank. I'm going to add in another validator here to my bio attribute. We'll use the validator called contains so that our content must contain the word foo. But, you know, on second thought, I want to make sure and send back a very clear message as to why this validation did fail. To do that, I need to turn the value of contains into an object with an args and a message property. The message will let the user know that there is a validation error, and the field must contain foo. In order to see our failing validation, we could use a catch method after creating a new user, and then log it out to the consul, but it's actually going to be a lot easier to see what went wrong if we use an Express route and then send the message back as JSON to view in our browser. So I'm going to create a new route using app. get, the two parameters of req and res, which will contain our request and response objects, then copy over my user from down below, making sure to comment out this area. Then paste it into my route. Then edit my username to Jo so it will fail validation. And when the user is created, I will send the response to my view in JSON. And if there's an error, I'll both log out the error to my terminal and also send the error over to my browser along with the status code of 0404. Now when I start up my server and load up my app on localhost 8001, here we can see an object with both error messages, Validation len on name failed. And then we have another error object with the more helpful message, Validation error, field must contain foo. Using the validate property is a simple way to perform many types of validations on our attributes. Let's now discuss a Sequelize method for modifying data before it gets to our database using hooks.

Hooks
There are times when we may want to modify data before it gets to the database. In these cases, Sequelize provides us with a function called hooks. Hooks, also known as lifecycle events, are called before and after events in Sequelize are executed. There are four different internal Sequelize lifecycle events we can take advantage of. BeforeValidate is used before validation has occurred. AfterValidate is used after validation has occurred. BeforeCreate is used after validation but before the column data has been created. And afterCreate, which is used after the column data has been created. To use a hook, we add the property hooks as a third parameter to our model after all of our attributes have been declared. All four of our hooks are used as a function. The first three types of hooks accept a parameter that represents the model object while the afterCreate hook also accepts a parameter that represents the final response object. A common use case for hooks is when we need to hash a user's password before it's sent to the database. Let's now walk through a few examples of using hooks inside of our project. In our User model, I'm going to first remove the validation for name and for bio. I'm going to change name attributes to first, then add in a new attribute of last with the type of STRING along with another attribute called full_name, also with a type of STRING. We defined our hooks as a third parameter of our model definition. We're currently setting timeStamps to false in our third parameter. So I'm going to change this to declare our hooks functions. Then I'll just add in our four different types of hooks and log out an appropriate message for each one. I also need to create a new user so we can see these log messages. So I'll just scroll down below my sync method, chain on a then function, creating our user with a first, last, and bio. Now I'll run my server and check out the response. Here you can see the various log messages corresponding to each part of the lifecycle process. Let's now try out a simple example using the beforeCreate hook. So I want to take the values for first and last and combine them to populate the full_name attribute field. BeforeCreate accepts a parameter that represents our User model. Then inside the body of this function, I'm just going to combine the user's first name and last name. Here I'm using ES6 backticks and string interpolation. Now I'll just kill and restart my server. And here you can see the creation of a new table with a full name column that includes the name Joe Smith.

Review
In this module, we looked at the different ways we can modify, validate, and customize data before it's sent to our database. We first reviewed some of the built-in properties we can declare in a third parameter used to modify our model. These included using the properties of timeStamps and freezeTableName. Next up, we looked at a few of the built-in attribute qualifiers such as allowNull, primaryKey, and defaultValue. We then discussed how to perform validations on our attributes using the validator. js properties. This provided us with easy-to-implement built-in validators that were placed in the value fields of a target attribute. And, finally, we discussed how we can use hooks functions to modify data before it gets submitted to our database. Now that we have the basics of setting up a project, adding a model, and submitting data, let's now learn how to perform CRUD operations to query and update our data.

Performing CRUD Operations
Introduction
Hello. My name is Patrick Schroeder, and I would like to welcome you back to An Introduction to Sequelize ORM for Node. js. So far, you've learned how to create a Node. js project that uses Sequelize to interact with an SQL database. You then mastered how to build Sequelize models that are mapped into SQL tables. In this module, you will learn how to interact with database entries to perform CRUD operations, to create, read, update, and delete database items. We'll first start with a bulk import of database items so we have some data to work with. We'll then look at five different Sequelize methods that will do the work of retrieving, updating, and deleting items. For these examples, I'm going to be creating different API endpoints in our project using Express, and then display the results of our requests inside of our browser window. These API endpoints are going to be very similar to the actual API endpoints we will be using in our final project.

Add Sample Data
I'm going to first generate some sample data for our database. This will be done using the website generatedata. com. Keep in mind that this is just for example purposes, and it's an easy way for us to insert some mock data. My column names will be name, email, and password. The data types will be Names, Email, and Alphanumeric. Under examples, I'll select Passwords for the password column and Alex of any gender. The export here will be JSON with a simple data structure. I'll generate 100 rows and change the output to Prompt to download, and then click the Generate button. I'll then open up this newly generated file inside of my Visual Studio Code, and I'm going to save this file as users. json in the root of my project folder. You can see here that this file is an array of JSON objects with keys of name, email, and password. Let's now modify our Users model attribute to match the values here. So back in my server. js file, I'll start off by requiring in my _USERS file referencing it with a variable of _users. Next, I'll scroll down into my Users model and add in the attributes to match what's in the users. json file. So I'll remove the currently listed attributes, then I'll add in a name attribute, which is of type STRING. I'll add in an email attribute with a type of STRING, and also include a validation property checking that it is a valid email. Then I'll add in a password attribute with a type of STRING, and also add in a validate property checking that the data is alphanumeric. I can now import my users data into a Users table by calling the method bulkCreate. Let's check out the docs real quick and see a definition first searching for bulkCreate. And you can see here that it accepts an array of records with an optional second argument. And this method will create and insert multiple instances in bulk. Pretty straightforward. Hopping back into my code, I can chain a then method onto sync calling bulkCreate on my User model and passing in our _USERS reference that we imported earlier. On success, I'll print out a log message. And on error, I'll just send the error back to the console. I'm going to remove the force option since I don't want to drop the table after it's initially created. And I'm also going to comment out the logging portion so I can easily see the success message in my console. And now I'll restart my server. We get the success message in my console, and I'm going to view the resulting dataset inside of the SQLite browser. Open up the database in our folder, then click Browse Data. And here you can see the 100 rows of users that have been added into my database.

Create Method
In order to add an item to our database, Sequelize gives us the create method. We've already used the create method a number of times when adding items to our database. So for this example, I'm going to simply walk you through a typical Post request made to an Express API. This is going to be pseudocode since we don't have a client just yet. In my code, I'm going to first change the route here from index to post, and then change the request from get to post. Typically, we'll be receiving some data from our client, and we can access that data using the req parameter. So I'll create a new variable here called newUser and set it to equal req. body. user. Body is a parameter on the request object we use to grab a hold of the data being sent to us. And then we can submit the newUser object inside of our create parameter. And this works just fine, but if you prefer more clarity, you can instead pass in an object and specify first the attributes on our model with the values being passed in from our newUser object. Now keep in mind that this is just pseudocode, and this route is not going to work. It's just meant to prepare you for what our Post method in our example app is going to look like.

Find All and Filter
In order to query our database, Sequelize gives us the findAll method. With this method, we're able to retrieve all rows from a specified table, and we're also able to filter data using the where operator. In this video, we'll be building an Express route and displaying results in our browser. Back in my code, I first want to comment out the code creating my bulk users. Now I'll just go below my User model and create a new route using the get Express method naming this route findAll. And then I'll add in my function with the req and res parameters. Inside the function, I'll use my User model and chain on the findAll method. At this point, I can simply invoke the method, which is going to retrieve all database records located in the Users table. I'll copy over the then and catch handlers from above. Let's test this out by restarting the server and navigating over to localhost:8001/findall. And here we can see the JSON printout of all of the users in my SQLite database table. Okay, that's great if we want to retrieve all the users in our table. But what if we want only a certain subset of users? For these types of scenarios, Sequelize provides us with the where operator. Back in my code, I'll add in a pair of curly braces to create a new object. Notice here, we can hover over the findAll method, and we get some great IntelliSense explaining exactly what this method does. When using findAll, we can search for multiple instances of a table row using the where object. Inside of this where object, we can add keys matching any of our attributes along with the value of what we want to search for. We can see here that there are a number of operators we can pass in to refine our query. A full list of these operators can be found in the Sequelize docs searching for where, then scrolling down a bit to find the different operators. In order to use any one of these operators, we will need to first include a reference to the Op method on Sequelize, and then wrap the operator we want to use in an array prefixed with Op. Back in our code, let's test out this where functionality by passing in our name attribute along with the value of David. I'll restart my server and refresh the page, and here you can see we get back the single record with the name of David. Now let's do an example using one of our operators. For this example, let's get back all the records of the name attribute that starts with D-A-V. So, first, in order to use the Op method to narrow down the query, I need to import it from Sequelize at the top of my file. Now to filter my name attributes, I need to change the value of name into an object. I need to then define my Op key in an array. And when I add the dot, you can see of bunch of possible methods that pop up. I'll use the like method to match all the records that start with D-A-V. The percentage sign at the end acts like a wildcard. So any entries that start with D-A-V plus any other values will appear. Then I'll restart my server, navigate back to my route, and here you can see that we get back only the two entries with the name attributes starting with D-A-V. So now I would like to encourage you to take a minute here and try a few of the other operators based on what's in your own database file and observe the results in your browser. And when you're done, I'll meet you in the next lecture to discuss how to find a single record using the findById method.

Find One Entry
Every row of data that gets inserted into our table is automatically assigned a primary key that serves as a unique identifier for that row. In Sequelize, these are added to the ID column. They start with the number 1 and are auto-incrementing. We can use these unique identifiers to easily query for a specific record using the findById method. Back in our code, let's test out the findById method by creating a new route. This will be a get request at the location of /findOne. The second parameter here is the same as above. It's a function that takes a req and res as arguments. Then we'll chain on a findById method to our User model, passing in the primary key of the record that we want to see. I'll copy over our success and error responses from above, then restart the server, and when navigating over to localhost:8001/findOne, here you can see that we get back our user with the ID of 55.

Update Entry
In order to update any row in our table, Sequelize gives us the update method. To update an item, we first call the method update on our model with the first parameter of this method being the attributes we want to update. This example updates the user's name and password. The second parameter will find the entry we want to update using the where operator. When using where, we're able to pass it an object with the key being the name of the attribute. In this example, we're passing req. params. id. So in a typical application, we'll get the attribute's ID value from a parameter in the URL using Express, and this is how we do it. One caveat here is that we will not be getting back the updated user's object in the success response. Sequelize will only send this back the number of attributes that were affected by the update. And that's why I've name the response here as rows. Let's now hop in the code and work through our example. I will first copy over the findOne route that we've already defined and turn it into an update route. I'll change the route to point to update and change the request to be a put request. And then I'll change the findById method to instead be update. The first parameter here is an object. Normally we'll be submitting data from the client, which will be req. body, but in our test case, we will hardcode in some data by declaring an object with the name of Michael Keaton, and also a password named password. The second parameter queries the table using the where operator and pointing to an ID of our choosing. In this case, we'll change the user with an ID of 55 so we can compare it to our findOne route. Then I'll change my response from user to rows since we're only going to be getting back a number of affected rows from the response. Remember that currently our user with ID 55 is named Christian. So if the name gets changed to Michael Keaton, we know that it's working. And now, let's start up our server. In order to test out this new put route, I'm going to have to use Postman instead of Chrome. So here I've opened up Postman standalone app, which allows me to run tests to different API endpoints and see the results. I want to run a put request on localhost:8001/update. Then I can click send. Here you can see we have an array output of 1 and a status code of 200. So it looks like it worked, and when we refresh our findOne route, you can see that the name of our user has been updated to Michael Keaton as expected. You've now learned to create, read, and update database items using Sequelize. Great work! Now it's time for the last piece of the CRUD puzzle, removing database entries.

Delete Entry
In order to delete an item from our database, Sequelize gives us the destroy method. We can use destroy very similar to findById. So for this example, I'll copy over the findOne route we defined right here and then change the route name to be remove and change the request method to delete and then change findById to destroy. Destroy accepts only one parameter, an object that points to the record we want to delete. We can locate the user we want to delete using the where operator, and then use an object to specify the ID attribute we want to delete, which will be the user with an ID of 50. On success, we will not get anything back. So I can remove the response object, and, instead, I'll just send a message to the client saying User successfully deleted. Now let's start up the server and test out our new route. For this example, I do need to use Postman again to make the delete request. So I'll open up Postman, change the request to delete, then add in my new route, which is localhost:8001/remove, and click send. And here you can see that we get the success message indicating our user has been deleted. If you want to double check, you can just open up the SQLite database viewer. And notice here that the user with an ID of 50 has been removed.

Summary
In this module, we discussed the Sequelize methods we can use to perform CRUD operations to create, read, update, and delete database entries. We used the create and bulkCreate methods in order to add items to our database. We then used the findAll query method to grab all the records from our Users table. The findOne method was used to find a specific user based on their ID. The update method was used in order to update an entry. The first parameter was an object containing the attributes we wanted to update. And, finally, we used the destroy method to remove a user from our database. At this point, you have a project set up, a model in place, and an understanding of how to perform CRUD operations. And now the last piece of the Sequelize puzzle is understanding how to create associations between tables.

Associations
Introduction
Welcome back to An Introduction to Sequelize ORM for Node. js. At this point, you've now learned almost all of the essentials of how to create an SQL-based application using Sequelize. We have just one more very important topic to cover, which is associations. In this module, you will learn what associations are and how they are used to create table joins. We'll cover the three different types of associations that can be made. These include one-to-one associations, one-to-many associations, and many-to-many associations. We'll cover the four different methods that Sequelize gives us to create these associations. And then we'll use each one of these methods in our project to build an API using Express.

Associations Explained
So what exactly are associations? Associations form relationships between tables. These relationships are used to create table joins. A join in SQL simply merges data between two different tables. So, for example, you might have a Users table and a Posts table. Each table contains an ID which is its primary key, along with a few other attributes. In my Posts table, I may want to save a reference to the user that's made the Post. All I need to do is add in a column that holds that the primary key of the user. And then whenever that Post is retrieved from the database, I also get back the user with any attributes I want. The response would look something like this. I get back my Post with an ID along with the title and some content. We've also saved a reference to the user who has an ID of 2. Additionally, we get back that user along with their attributes. Creating an association between tables is a two-part process. First, we define our association between models. In our current example, we say Post. belongsTo(User). BelongsTo is one of the methods Sequelize gives us to form these associations. This line of code is added after we define our models. When forming this association, a userId column will be automatically added into the Posts table. And, second, whenever we perform a query on our Posts table, we need to add the include property inside the query with the associated model as the value. So if we wanted to fetch a single Post by its ID, we would also include the User model in an array like this. In this example, we would get back all of the users attributes. If instead we only wanted to get back certain attributes, then we would wrap the value of our include in an object, first, specifying the model and then the attribute. Here we would only get back the user's name along with the Post entry. Let's now add a belongsTo association between User and Post in our project.

Add belongsTo() Association
Now that you understand the basics of forming associations between models, let's build a new model called Post and create an association to User. Back in our code, the first thing I'll do is remove all of my CRUD routes except for the findAll route, which we'll be editing. Now I'll create a new model called Post. For this model, I'll define the ID as its primaryKey. Then I also need to add in a defaultValue with a type of UUIDV4. And then I'll add in two attributes--title of type STRING and the content of type TEXT. Then I'll scroll down and place my association right above the connection saying Post. belongsTo passing in User. I'll also add a comment here indicating that this method will add a foreignKey called UserId into the Post table. We can test out the association by creating a new Post with an attribute of UserId set to 1 along with a title and content. Let's now create new route so we can view the data. I'll just edit the existing findAll route, renaming it to be allposts, then inside the function, I'll call findAll on Post. I'll replace the where statement with our include property referencing my User model and change the response object to match the name of our response. Now with everything set up, I can restart my server. And, first, I'll check my database. And here you can see that a Post table has been created with a reference to the user with an ID of 1. In my Users table, the user with an ID of 1 is named Hakeem. So now let's navigate over to our allposts routes, and here you can see the response object is our newly created Post along with our user Hakeem and his other attributes.

Foreign Keys
When building our belongsTo association, a UserId column was created. This is what's referred to as a foreign key. The foreign key is automatically generated for us and is Pascal cased. However, we may want to give our foreign key a name of our own choosing. In order to do this, all we need to do is add an object as the second argument of our belongsTo method with a key of foreignKey and a value of whatever we want the name to be. Let's head back into our project and customize our current association. I'll add a comma after User, define an object with a key of foreignKey and a value of lowercase userId. Then I'll uncomment force set to true so my tables get dropped. I'll uncomment the bulkCreate function so my users get added. And comment out our project. create function. Then I'll run my server, open up the DB viewer, and here you can see that a foreign key of lowercase userId has been added to my Posts table.

Model Alias
Sometimes when creating associations, it makes sense to create an alias for our model. An alias will re-name the model when it's used as an association. So, for example, in our current Post response, we get back a user with their attributes. We might want to rename User to something else in our response such as UserRef. In order to do this, we first need to add a key-value pair to our object. The keyword as is the key that creates the alias, and the value is the name for our alias. Additionally, we also need to make sure that any time we include the User model to our query, we reference the alias using the as property. Now that you understand how to create an alias, let's give it a try in our project. So back in my project, I'll add my alias using the as property, plus the name of my alias, which will be UserRef. Next, I'll change how I include my user in my allposts route by turning the include reference into an object. This will contain a key of model and then referencing first the User model with an alias of UserRef. Now in order to test this out, I need to make a couple of adjustments below. So, first, I'll cut out and paste my bulkCreate function right below sync and uncomment the block. Then I'll uncomment my Post. create function and change the UserId attribute to lowercase so that it matches my newly changed foreign key. Now I can restart my server and navigate over to my allposts route. And here you can see that my return object has now been updated from User to UserRef.

Types of Associations
So far we've only discussed one type of association. This was a one-to-one association of Post to User. But there are actually three different types of associations that we can form between our tables. In addition to a one-to-one association, we can also form a one-to-many association or a many-to-many association. In order to understand the differences between these, let's compare each one. When forming a one-to-one association, we use either at the belongsTo method or the hasOne method. HasOne is essentially the same as belongsTo except that it puts the foreign key in the opposite table. So in our example of Post to User, a foreign key of PostId would be placed in the Users table when using the hasOne method. When our associated model is retrieved using a foreign key, we will always only receive back a single item. In order to form a one-to-many association, we use the hasMany method. The method syntax for creating a hasMany association looks identical to belongsTo or hasOne. In a one-to-many association, a user in this example might have many Posts. So for each Post made, a foreign key of UserId will be placed into the Posts table. When a user is then created, we received back an array of Posts for all the individual Posts an associated user has made. In a many-to-many association, we use the belongsToMany method. When forming this type of association, we use the belongsToMany method on both models. This will then create a join table that contains just two columns. Each column will contain the primary key reference for each of the models. The response that we get back when either of these tables is included will always be an array of items. Let's now fully walk through building a one-to-many association.

One-to-Many Association
Building a one-to-many association is very similar to building a one-to-one association. You first need to define the association between models using the hasMany method. In this example, a Post can have many comments. When the association is created, a foreign key of PostId will be added to the Comments table. You can optionally add an alias or a foreign key as a second parameter. When making a request, you must include the associated model, along with an alias if there is one. The response we get back when making a query on Post will contain an array of all of the comments that have been added. Let's now jump in the code and build a hasMany association. I'm going to make a couple of adjustments here first. I'm going to remove this freezeTableName property in our connection, so now we'll get the pluralized table names created. I'm also going to remove this ID field from Post. This will just make it easier to reference a PostId when we create our new comments. Now I'm going to create a new Comments model. It will have just one attribute called the_comment of type STRING. and now let's create a new association for Post to Comment. Since a Post can have many comments, I will say Post. hasMany passing in my Comments model along with an alias of All_Comments. I'll also make a note here saying that a foreign key of PostId will be placed in the Comments table. Now let's create our route. I'll just copy over this allposts route and then make a couple of edits. It's going to be a Get request made to a route named singlepost. Inside my function, I'll reference the Post model and use the findById method. We'll find the Post with an ID of 1. Then in order to get back all the comments associated with this Post, I'll include the model along with an alias. And I only want to get back the attribute of the_comment. Now let's create some mock data. I'll still be creating a bulk users here. Then we'll create three new Posts. To do this, I'll copy over my first Post creation two more times. The first two Posts will be associated with our user of an ID of 1. The third Post will reference the user with an ID of 2. And then I'll also create two new comments. So I'll this copy these from Post and then edit. Remember that the Comments model now contains a reference to a Post in the form of a foreign key named a PostId. We'll set both of these to the Post with an ID of 1. And then I'll put in some filler text for each of the new comments. I forgot to adjust my Post title and content for Posts 2 and 3. So I'll do that now. And now I can restart my server. Notice in our database viewer, we have all the new tables created, including two new comments with a PostId referencing a user, along with three new Posts. When we visit our newly created route at singlepost, you can see that we get back a single Post along with the two comments containing only the attributes we've assigned. But, remember, we also have a belongsTo association made of Post to User. Here we can see that we get back the associated userId, but we didn't get back any of the models data. To make sure that we get both associated models data, I can simply add a comma to our include, add in and another object with the model of User, along with the alias. Now I'll go down and comment out force so our tables don't get dropped, and I'll also comment out the create methods we use in order to add in our initial data, kill and then restart the server, refresh my page. And here you can see that our Post response now contains both the User model and the Comments model associations.

Many-to-Many Association
The last type of association we need to discuss is the many-to-many association. When creating this type of association, we need to define a relationship between two models using the belongsToMany method. We also need to make sure to define this association on both models. It is a common practice here to include an alias, although it's not required. It is, however, required to include a through property with value of what a new join table will be called. The join table in this example will be called UserProject. What this will do is create a brand-new table called UserProject that contains a foreign key to reference both the project and the user. So two new columns will be created called UserId and ProjectId, and this is what it will look like. Notice here that the name of the table does not get automatically pluralized and, instead, matches exactly what our through name is. Retrieving a user or project is very similar to previous examples. We just need to call one of our query methods like findById to retrieve the user, and then include the Project model along with the alias. And just like in previous examples, we can ask for only certain attributes in the response. Here is an example of what the response will look like based on the previous slide. Our user with an ID of 1 gets queried and includes an array of two projects that have already been associated with this user. It also includes the alias we've given of tasks. When creating a many-to-many or a one-to-many association, we are also provided by Sequelize getter and setter methods. These methods allow us to perform essentially CRUD operations on individual members of an association. There are a total of seven Get and Set methods. But let's look at the four most commonly used. These are set, add, get, and remove. Set is used when initially creating an association, and it accepts an array of IDs. When using any of these methods, the syntax is camelCasing with first the name of the getter or setter, followed by the name of the model or alias. Add is used to add a single member to an association. Get can be used to find all associated members. And remove can be used to remove a single associated member. And here is the example syntax. So after creating a new project, we then want to add a few new workers to this project. We can do this by chaining on the setWorkers method onto the response, passing in an array of IDs that we want to add. So, remember, we're using workers as an alias for our user. Now inside our database, what you'll see is something like this. Inside the UserProject table, we'll have two new rows added associating two users with a project. Now after a project is created, we may want to add a new worker to that project. To do this, we can use the addWorkers method. So here we're using a put request. Then inside the function, we first find a project by its ID, and then we take that found project and chain on the addWorkers method, passing in the ID of the worker we want to add. Okay, so now that you understand this concept, let's jump in the code and try it out.

Many-to-Many Example
Back in our editor, the first thing I'll do is create a new model called Project. We'll give Project a single attribute of title with a type of STRING. Next, I'll scroll down to create our new belongsToMany association of User belonging to many Project and Project belonging to many User. I'll make the through table named UserProjects and add aliases to both associations--Tasks for User and Workers for Project. I'll also add in a comment here as a reminder that a UserProject table gets created with the IDs of ProjectId and UserId. Now I'll create two new projects after syncing my tables. The first project will have a title of project 1, and then I will setWorkers 4 and 5 to be included with this project on creation. I'll also add in another project here with the title of project 2 without setting any workers. I can run my app now and expect to see two new tables created along with the new database entries. Now I'm going to open up my database viewer, and here you can see that a Projects and UserProjects tables were created. If we take a look inside UserProjects, we see the first project created has an ID of 1 with two associated users. Okay, great! Now let's go back in and test out adding a single worker to project 2. Before I forget, I'll comment out the code used to create these new projects, then I'll scroll up and add in a new route called addWorker. So I'll copy and paste one of my routes from above. We'll make this a put route with the route of addWorker. Inside the function, I'll call findById on the Project model passing in the ID of 2. Then I'll take the response and chain on the addWorkers method adding the user with an ID of 5. We won't be getting a response object to work with. So, instead, I'll just send back a text response of User added. So now I can kill and restart my server. And since we're using a put method, I have to use Postman. The route is localhost:8001/addworker. And here we get back our success message of User added. And then if we take a look at our database viewer, here you can see that a new user with an ID of 5 has been added to project 2. Let's do one more example for how to query our users and get back all their projects while filtering for attributes. This route will be called getUserProjects. Here I'm going to find all users in my database only retrieving the attribute of name, then include the model of Project along with the alias we've assigned of Tasks while only getting back the attribute of title. We'll display the results in JSON and catch any error. Now I'll again kill and restart my server, navigate in my browser to localhost:8001/getUserProjects. And here you can see a printout of all users with just their names, as well as any associated project titles.

Summary
This module was all about associations. We explored the various types of associations that can be formed using Sequelize. This included forming a one-to-one association using belongsTo and hasOne, forming a one-to-many association using hasMany, and forming a many-to-many association using belongsToMany. We discussed how these associations create a new column with a foreign key containing the ID of the associated table. We then used our browser along with Postman to test routes and see what the response looks like in JSON. You now have a firm grasp on the fundamentals of using Sequelize inside a Node. js project. Now let's do something fun. In the next module, you will take what you've learned and build out a backend API using Sequelize and Express for an already developed Angular frontend.

Demo Application Using Angular
Introduction
Hello, and welcome back to the course. In this final module, we'll build a full stack application. We'll be using Angular on the frontend and Express along with Sequelize on the backend. The frontend code will already be provided to you so that we can work together on building out the API connecting Angular with a database. This means that you don't have to know a lick of Angular in order to follow along, although if you do want to know what's happening on the frontend, there are a number of amazing courses here on Pluralsight to get you familiar. You can find all the code to follow along here github. com/jakblak/Sequelize_BookStore. Here, I have provided you with the starter files located at the master branch along with the completed files located in the finished branch. Let's take a look at our demo app. First, when a user enters, we'll display a list of books retrieved from an SQLite database, along with a list of users. From here you'll be able to edit any of the users to add books to their reading list or to assign a favorite book. You can also find links to add a new book or to add a new user.

Project Setup
Before we get started, it's a good idea to install or upgrade the Angular CLI tool insider your terminal by typing the command npm i -g @angular/CLI. And now with the Angular CLI installed, let's now download the starter code. You can find the starter files for this project here at github. com/jakblak/Sequelize_BookStore. We can clone this repo by hitting this Clone button and then copying the GitHub link. Now inside of Visual Studio Code, I'm inside of this bookstore folder, and I can type the command to git clone pasting in the address of our GitHub repo, space dot, and this will make sure that a new folder doesn't get created. Now I can open up my Explorer, and we can see that we have a server and a source folder. And let's start off by opening up this package. json. Now in order to run our project, we can simply type npm start. And this is going to first start our Angular server and then start our Node server. Here we have the dependencies for Angular, and here we have the dependencies for Node. Inside of my server file, what I'm doing here is I'm just starting a simple Express server first loading up my Express middleware, then any APIs, and then starting the server. Inside of this API folder is where we're going to be declaring all of our routes. So if we look in this index. js file, we can see that we're just sending first off a get request, which is going to display the message hello world, and then we're going to load up our API user. route, which can be found in this user, and then user. route. So this user. route that we've defined right here, we'll load up the route at api/users, which, again, is right here. And then it's going to call the function controller. test, and this controller is found in the user. controller folder. And you can see the function called right here. Inside of this source folder is where we have our Angular files, and for the most part this already has a lot of code for you. So if we look inside this user folder inside of this user-edit folder, we have a user-edit. component. ts file. And this is where a lot of the logic will be for our application. Now as you can see, we are getting some red squigglies here. So let's fix that by including our npm modules. To do that, I'll open up my terminal, close this window, and from here, you can either type yarn, or you can type npm i. So I will just type yarn, and this is going to download and install all of the packages found in our package. json file for both the Angular frontend and our Node server. After downloading the Node modules, you may need to close and reopen your workspace in case you get any errors. And now you should see this node_modules folder. In order to run my project, I can type npm start. This is going to run both my Node server and our Angular server first running port 3000, and this is what you should see when you load up our application. We'll have Books with just one book here. We'll have Users, which will display two mock users. If I click on this Edit button, it's going to show us User and a couple of form fields, and then we also have links where we can add book and add user. And let's also look at what's happening on port 3000. So port 3000 is running our Node server, and here we get the message hello world, and then we can also navigate over to api/users, and we can see that we get our initial route user route works!

Database Setup
Now that we've explored our project, let's add in Sequelize and set up the database. To do this, we'll first need to add in a few modules. So inside my terminal, I'll type yarn add sequelize sqlite3. You can also use the command npm i instead of yarn if it's not already set up on your system. Now I'm going to create a new file that will serve as the entry point to our database. So this will be inside of the Models folder. So I'll right-click, and New File. And it will be called db. js. Inside of this file, I'm going to copy over and then edit some code from the Sequelize repo. So I'm over here at github. com/sequelize/express-example. Then inside this Models folder, we'll have this index. js file. This file will do two things for us. First, it's going to create our connection to the SQLite server. Second, it's going to load up and sync all of the models that we create. So I'll click Raw and then copy over the code, and I'll paste it inside of my db. js file. Scrolling up to the top here, the first edit that I'll make is to remove both environment and config. And then I'll also remove this if-else statement. This project is just for development, so I'm going to hardcode in my Sequelize connection. The connection code that I just pasted in is the same as you've used in previous modules, first connecting to our localhost, defining the dialect as SQLite, and setting up a storage file. Now in order to test this out, we need to have at least one model already created. So inside of my models, I'm going to right-click, New File, and let's name this file favorite. js. In our project, we will have a favorite model, and I'll paste this in as it's really simple. It's only going to have this one data type called title. The syntax here is a little different from previous examples. Instead of using Sequelize, we're using data types, and then we're going to be exporting this entire module. Now what will happen is this db. js file is going to iterate through all of the files contained inside of this models folder, and it will create all the models from the files that we've created. So when we sync the database, we should see one new model called Favorite created. So let's go ahead and do that now inside of our server. js file. Close out these other windows. So what I'm going to do here is just replace this app. listen, which runs are Express server, with db. sequelize. sync. So this is going to sync our database, and then it's going to run our server. This DB right here is a variable that's going to reference our db. js file that we just created. Now let's test this out by running our server, and you can do that by typing the command node server. js. So you can see here that we got our Favorites created. If I open up my Explorer, we now have a db. sqlite file. And let's open up our browser, and open up our newly created database inside of our Bookstore folder, click Browse Data, and here you can see that we get our new Favorites model created as a table inside of our database.

Create Models
Let's now finish up adding in our models. But before we do that, I'm going to kill my server and then add force set to true inside of sync, which is going to drop and re-create any tables. Close out my server, and then inside of my models folder, I'm going to create two new files. The first one is going to be user. js for our User model, and the second one is going to be book. js for our Book model. Inside of my user file, I'm first going to define a module. exports passing in Sequelize and data types. Then I'll define a function, and inside this function, I will declare a variable of User equaling sequelize. define naming my model User. We'll supply our User model with one attribute called name, and adding some simple validation, forcing the user to submit some data for this attribute. And here we can also define any associations. So for this model, I'm going to define two associations, the first one associated to Book and the second associated to Favorites. So we can say user. associate is equal to a function that accepts a parameter of models, and here we define the associations. So we need to use this models parameter, then specify the model. So the model is User. It's going to belong to many. So this is belongsToMany, passing in the model that we want to associate with. So we have to use this models parameter. Book, which we'll create here in a second. We'll be creating an alias, so this will be named Reading, and then we also need a through property, which will create a join table called ReadingList. For our other association, we can say models. User. hasOne, so User will have one Favorite. So we can say models. Favorite, and this association will put a foreign key of UserId inside of the Favorites table. And then we need to return our user, and that's it. And now for our Book model, I'm simply going to copy over this file that we've created, paste it into Book, and I'm going to hit Ctrl+H, which is Cmd+H if you're on a Mac, and I want to find all the references of User and replace it with Book. I'm going to simplify the attributes here, and we'll just have a title and author and a year attribute for our book. Book will have one single association, and then we just need to change the alias. So book will be associated to User, and instead of Reading, we'll have Readers. And I also need to change the association from Book to User. Okay, so that looks good. Let's now start up our server and see our newly created tables. Inside of my terminal, I'll just type node server. js. And now I'll open up my database. And you can see we have a Books table, a Users table, and a ReadingList join table. And also notice inside of this Favorites table, we have an association to our User as UserId.

Seed Database
And now let's go ahead and seed our database with some data. You've already been provided with two JSON files to perform the seeding. They can be found here inside of the models/seed folder. Let's open up the books. json file. Here you can find an array of objects that contain a title, author, and year to match what's found in our book model. We also have a users. json file with just a name property that matches what's found in our User model. Now let's create a seed file inside of this seed folder, which will be called seed-db. js. We start off by requiring in our models, which is located in the db. js file. And, next, we import our two JSON files containing our data. In order to use this in another file, I will define a module. exports, which will contain an object with one function called insert. The insert function will take the models we've imported and first use the User model to bulkCreate _USERS data from the users. json file. And then we will do the same thing for our Book model. So we'll take the models folder, chain on Book, then bulkCreate our _BOOKS. And then on creation, we will get the response, and we'll just send back a message of Success adding users and books. And I do need to fix these curlies just like that. And then, of course, we'll also catch any errors, and we'll just log them out. And now all we need to do is add the seed file into our server. js file. So at the top here, I will require in our seed file, and then at the bottom here, I can chain on another then promise in which I can call seed. insert. And this should do the work of seeding our database. Now I'll open up my terminal and type node server. js. We get our message, Success adding users and books. Now I'll reopen my SQLite database, and here we get our data for our books along with the data for our users.

Show All Books
With our database seeded and table set up, I can now remove this seed method, and I'll comment out force. I want to display all books when a user first enters our site. So let's now create an API route to perform this action that our frontend can connect to. So, first, I'm going to define an API location for books. So inside of my server/api folder, we have an index. js file. So let's open that up. And, first off, let's remove this initial get request. So below my users API, I'm going to create a route specifically for books, which is going to be located at api/books. We're going to reference a file called book. routes, which is located in a book folder. And now let's create both that folder and file, which is going to be located inside of this api folder. So I'll right click API, click New Folder. This will be called book. Then inside of book, we'll create two new files. The first file will be called book. routes. js, and the second file will be called book. controller. js. Let's first look at this book. routes file. We'll start off by requiring in the modules that we'll need. First, the controller, then Express, and then our router. And at the bottom, we'll declare a module. exports to export all the routes that have been created. I'll create just one route in this file, which will be a get route located at allBooks, and we'll use a method that we'll create here called allBooks inside of the controller file. Now let's create this allBooks method. So inside of our controller file, we'll start off by requiring in the db. js file referring to it as models. And then we'll add in a single method called allBooks, which will look inside of the Book model to grab all the books and then send them back to the client in JSON. And now we just need to edit a couple lines of code in our frontend to make this work. So close out these files, and let's open up our src folder, under book. This will be in the books folder under the books. component and books. html. So here is our HTML, and this is hardcoded. So what I'll do is comment that out and then uncomment the code down here, which is going to iterate over the book and books, which we've already defined in our component. So inside of this component, all I need to do is uncomment the method that calls on the allBooks bookService. And let's just quickly look at this bookService which calls getBooks. And right here is where we're accessing our api/books route, and then we call this getBooks method, which calls on the allBooks route that we created. So now let's start up our server using npm start. I'm just going to load up both are Node server, as well as our Angular server. And here you can see that our books are now being displayed from our database.

Single User Route
Let's now create a new route to get and display all users right here. We'll also be changing this edit link so that it goes to a specific user. Back in my terminal, I'll first kill my server. And then I'm going to open up our user. routes file along with our user. controller file. And let's remove this exports. test method. And I'll also remove this initial get route. So here I'm going to start off by creating a new route for all users, which will use a method called allUsers in our controller file. No inside of our user. controller file, I'll paste in first a reference for our models and then the method that we'll be using to get allUsers. This method will look inside of the Users model and send back all users in JSON form. And now let's edit the Angular code in order to display all of our users. So I'll close these two files, and then we'll look inside of our src folder. And this will be inside of users. We'll open up our component and our HTML file. So this file does the work of displaying all users, and I will comment out what we already have. And then at the bottom here, I will uncomment the row that will iterate over all of our users and display them. Notice you that we have a router link that's going to route to an individual user passing in that user's ID. So I do need to edit this user--routing. module, which can be found inside of the users folder. In here I have the path, which is currently at edit--user, and I'm going to change this to :id. So this colon acts kind of like a variable reference for whatever gets passed into the URL. So now when the user clicks on edit-user link, it's going to take them to the UserEditComponent. So let's open up that UserEditComponent here, and we'll also open up the HTML file. Now for this HTML file, I'm going to go ahead and just remove everything here at the top. And then I'm going to scroll down to the bottom, and I'm going to uncomment everything up to the second to last line. So now let's look inside of our UserEditComponent. So at the top here, I'm going to get rid of this foods for loop, which was just displaying some mock data. And then I'm going to scroll down into this ngOnInit and uncomment these lines. And, first, we're going to get the ID from the parameter within the URL, and we'll be to pass it into this method called getUser. This getUser method that we've defined will call on our userService in the form of a getUserDetails method passing in the ID that we get again from the URL. So let's look at this getUserDetails method, which can be found in our userService. So here is our userService, and here is the getUserDetails method. So let's now create this corresponding route in our server. I'll close out our open files and scroll up into server, then let's open up our user. routes and our user. controller. So inside of our user. routes, I'll add in a new get route. This route location will be at :/id. And notice how this matches our frontend route with the colon making our ID a variable. Then we're defining a new method called singleUser. So let's go ahead and create this singleUser method inside of our controller. So I'm just going to paste this in. And what this does is it grabs the ID from the URL using req. params. id. So now we have the ID of the user, and then we're going to pass that in to user. findById in order to grab that user, and then send it back in the form of JSON. And just one more thing that we need to do here is inside of our users folder, inside of our users. component, I need to make sure that we are grabbing all users so that it gets displayed inside of our HTML. And now I can go ahead and start my server saying npm start. Okay, so here we have all books. If I click on users, now we get displayed all of our users. And let's click on this Edit button, and here we get redirected to our single user. You can see that the name correctly displays as Ashton, and he's our first user in our database.

Save User Book
In our application, we're currently displaying a user's page. Here we have a drop-down option for submitting a book to this user's reading list. So when a user submits a particular book, I want that book to then be displayed below in their reading list. In order to do this, we're going to be associating a specific user with a specific book, and this will be done inside of our ReadingList table that we've already created. Back in our editor, let's now open up the user-edit. component, and we'll also open up the user-edit. html file. So inside this component, we already have the user ID and the book ID. We also already have the saveBook method, which performs the action of linking a user with a book. Right here we're defining a variable of ID, which is an object that contains the book ID and the user ID. We then pass in the ID that we've defined into our bookService via the method saveUserBook. This saveUserBook method performs a post request to the books API passing in the object that we've defined containing our user ID and book ID. Let's now create this saveUserBook route inside of our book routes. I'm now going to close out the bookService and the HTML file. And now I'm going to open up inside of our book routes the book. routes and the book. controller. Instead of my book. routes. js file, I'm going to add in here a new post route of saveUserBook, which is going to reference our controller with a method called saveUserBook. Now let's go into the controller, and I'll scroll down and create a new method called saveUserBook. So for this method, first, I create a couple of variable references for what's going to be passed in for our book ID and for our user ID. Next, I call on our book model to find a specific book and then take that book and add into it a reader passing in the user's ID. On success, I respond with a success message, and also catch any errors. And now we can run our server by opening up the terminal and typing npm start. Then back in our application, I'll click on Users, click on our first user, and I will add a book to our user clicking Submit. I'm going to open up our terminal, and here we can see that we do get our success message, Success, book added for User! And let's also open up our database viewer. So if we click over to our reading list, here we can see that we have our UserId 1, which is Ashton, with the BookId of 2, which is the book that we just submitted.

Display User Books
Now at this point, we're able to grab a single user and submit a book to their reading list. However, it's not showing up right here. So let's go ahead and fix that. So what we need to do is open up our user. controller, and right here we're grabbing the user and sending the user back. So what we want to do is with our user include all the books that they have submitted to reading. So since we're using a join table, we can add a comma right here. And here is where we can include our model. So what we need to do is include a reference to our book model. So we'll say model is models. Book, and then, remember, we're using an alias for our many-to-many relationship of Reading. And that's all that we need to do. However, I'll also go ahead and specify a couple of attributes that I want to get back. So with our user, only send back the attributes of title and author. So now when we make a request for this user, we'll also get back their list of books under the property name of Reading. My server's already running here, so let's check out our app. We'll go ahead and refresh my application, and here we get displayed the Moby Dick book that we've already added. Now let's add in one more. We'll add in Life of Pi and submit that. And, boom, you can see it appear right away. Let's also take a look at our console. And in order to better see this object that we get, let's just copy this over into a JSON viewer. So over here at this website, I'm just going to copy this in, click Format, and here we can see under Reading we get an array of the two books that have been added to this user's reading list.

Save User Favorite
In the last clip, we displayed all of a user's books in a reading list. One thing that's cool about this many-to-many relationship is that once we've associated a book with a user, we don't have to worry about submitting the same item over and over again. It will only get displayed the single time. Hence, our database will only have a single reference. Below this Add to Reading option, we also have a Favorite Book option. So for this feature, we have a user with a hasOne association to a Favorite model. So let's code up that functionality now. And now back in our editor, I'm going to open up our user-edit. component along with our user. service. So here in our user-edit. component, we have a method called saveFavorites. This will pass along both the book title along with our user ID to the service that's called saveUserFavorite. Here is the saveUserFavorite method. This will in turn access an API endpoint called saveUserFav passing along the book title and user ID. So let's now create this saveUserFav endpoint inside of our user. routes file. So we'll open up our user. routes and are user. controller. So inside of user. routes, I'll create a put route located at saveUserFav that will use a controller method also called saveUserFav. Now inside of her user. controller, I'll add in our saveUserFav method. First, I'll set variable references both for title and for user ID passing this data into my Favorite model using the create method. Here I'm able to use an ES6 syntax shortener for when an object key matches its value. So if we take a look at the Favorites table, notice here that the column names match what we're passing into our object of title and UserId. And then I'll respond with a success message, along with catching any errors. So since my server is still running, let's take a look at our app and see if this works. So I'll open up my console, and we will submit a new book. Hit Submit, and here you can see that we do get a success message with the Life of Pi book added for our user. But notice how it doesn't actually get shown in our browser window. And the reason is because we haven't included it into our model when we're retrieving our user. So now all we have to do is include this Favorite model up above right here. So what I can do is just include a reference to our Favorite model as a second object to our include. And that's it. So with our server still running, I should be able to just refresh the page, and here you can see that our favorite Life of Pi book has been added.

Add New User
In the last clip, we created the logic to add a favorite book for a specific user. One thing to note here is that unlike the many-to-many relationship, we can keep on submitting the same book over and over, and it actually does get saved to our database. So to show you what I mean, let's open up the console window, and I'm going to copy over this object that we're getting back. And let's take a look at what it looks like inside of this JSON viewer. And I'll hit Format. So this favorite is sending back the ID of 4. So let's see what that looks like inside of our database. So inside of our database viewer, let's open up this Favorites table, and here you can see that we've saved Life of Pi three times. And it's only responding with the most recent saved book. Now if this were a real application, I would perform the logic on the frontend first checking to see if a user has already saved a book under their ID, and if they have, then I would perform a put request and replace that book with whatever new book the user wants to save. So now back in our application, there's just one more thing that I want to do for this project, and that's going to be to add a user. So back in our code, let's open up our user. routes and our user. controller. So I'll start off by adding in this new route, which will be a post route for add a user, and we'll create a new method called saveUser. So inside of our user. controller, I'll scroll all the way down and enter in our saveUser method. This will simply save name as a variable for request. body. name and submit that as an object to our create method on our User model. And then it will send back a response of JSON with our user. So now let's look at our frontend files inside of this add-user folder. We'll take a look at our user. component. So inside of our user. component, we have a saveUser method for which we're passing in a formValues parameter. And this is just going to be the username that the user submits. So we'll send that off to our userService, and then we'll redirect the user back to our main page, localhost/books. So with my server running, let's go ahead and test this out. We'll go ahead and refresh the application. And I'll add in a new name here of Tony. Click Submit. Click on our Users menu, and scroll down. And here you can see that our new user called Tony has been created. I'm going to leave this last bit of logic up to you, so go ahead and see if you can't add in the method to adding a new book, as well as any other functionality that you might like to add.

Conclusion
I'd like to thank you for taking the time to go through this course here on Pluralsight. I hope you feel like the investment was worthwhile and you now have more motivation to build your own projects using the technologies that we've covered. Now when looking at deployment options for stack, DigitalOcean has a very affordable plan that includes Postgres support. Another good option is for Heroku. Heroku offers support for Node. js apps along with Postgres. And Amazon offers a variety of products including AWS and RDS for Postgres. And I'd like to thank you once again for taking part in this course. Please feel free to leave a comment or question in the discussion area below. And I'll see you in the next one.
