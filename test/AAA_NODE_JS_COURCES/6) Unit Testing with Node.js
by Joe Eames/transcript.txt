Unit Testing is one of the best ways to improve the quality of your code. This course will walk you through all of the fundamentals of unit testing in Node.

Introduction
Course Introduction
Hello. I'm Joe Eames and welcome to Pluralsight's course, Unit Testing with Node. js. I have long been a proponent of testing and have spent more than a decade teaching testing, unit testing, and test driven development in many different languages and platforms. This is one of my favorite subjects and something I'm extremely passionate about. I'm absolutely convinced that every project can benefit from effective unit testing and I hope that through this course, you will come to learn not only how to unit test in Node, but also why, and I'm grateful that you have chosen to spend this time with me. I'm sure you will find it to be well worth the effort. This course is a how-to guide on unit testing with Node. We will cover all of the basics of unit testing in Node, including the tools and techniques, the whys and wherefores, and the tips and tricks as well. We'll talk about how to unit test all of the typical pieces of Node, how to use unit tests to give you confidence in your code, and we'll also see how to write effective and easily maintained unit tests. We start out with this introductory module, which will cover some basics and theory about unit testing, then we'll talk about the tools that are used when unit testing Node, then we will get into the meat of this course, which is actually writing unit tests for your code that will include business logic, I/O promises, and lots more. This course is meant for Node developers who have anywhere from no experience with unit testing and want to learn from the ground up, to those who have quite a bit of unit testing experience, but want to round out their skillset. If unit testing in Node is an interest of yours, then this course is for you.

Course Repository
Because of the nature of open-source development and Node in particular, things change and they can sometimes change fast. Meanwhile, producing updates to video courses can be a long and difficult process. Because of this, sometimes a course may get out of date. In order to handle that issue, I've created a repository on GitHub for this course. This repository contains any files necessary to follow along with the course, but most importantly, it contains information on the status of the course, as to whether or not it is out of date for any reason, and if so, how to work around the problem until a fix to the course is published. The web address of this course's repository is shown here. Please take some time now and go visit this URL to make sure that the course is up to date. You will see a page like the following that will either say that the course is up to date or that is it out of date, and if it is out of date, how to work around the problems until an update is published.

Why Testing Is Important
With all things, it's important to understand why we do something, so why should we do testing at all, especially unit testing? First, testing gives us more confidence that our code is correct. That gives us two big benefits, we can be more sure that we don't have any bugs in our application, and if we ever need to come back and change functionality, we can be more sure that we aren't breaking anything so long as our tests still pass. This can be especially helpful when we come back to some code after months or even years, or come to code that we haven't written ourselves. Second, writing code that is testable also causes us to write better code. If code can be unit tested, then it is more modular and has simpler interfaces that would normally be the case without making it testable. Third, the tests themselves become a form of documentation about the code, and unlike other types of documentation, tests can never go out of date since they run against the live code, so they are always current. These benefits should definitely not be underestimated. Adding all these advantages to a code base can mean a lot of savings in development and maintenance costs. In most objective studies, unit testing is proven to be more effective in the long run than going without unit tests.

Introduction to Unit Testing
Imagine a typical scenario for a class registration website. We have an endpoint that is called when we want to register students. That route code we write handles when that endpoint is hit by a web request, then it passes the information, such as student ID and class ID to the student object's register method. This method would do things like check the student's schedule to make sure that a slot was available, check to see if the student has met the prerequisites, and then check to see if the class has any openings. If all that is good, then it tells the schedule object for that student to add the class to the schedule, and that method would then call into Mongo and save the changed data to the database. In a typical call chain like this, there are many pieces of logic that need to be tested to give us confidence that we have written the code correctly, and if we make any modifications, that a test will alert us if we have broken any functionality. There are two different types of tests available when we are testing functionality in our code. The first is unit tests, which is what this course is about. These tests test a single unit of code. This phrase, single unit of code, can be a little bit vague, but in most cases, that means a single method or function call. The second type of tests are called integration tests. The best way to define integration test is, that they test more than a single unit of code, so basically an integration test is anything that is not a unit test. Now there are many different subtypes of integration tests, and even the names of each of the subtypes is not something that is generally agreed upon, but for the purposes of this course, we will call all tests that aren't unit tests, integration tests. Let's first look at how an integration test might test this functionality. A typical integration test would start at the beginning and test the entire set of functionality. That means that it would first make sure that the database was in a correct state, the user had an opening in their schedule, the class wasn't full, and the student had all the prerequisites, then it would call the entry point, and wait for the call to complete, and then check the return value. Of course, it might also want to check the database and make sure that the proper data had been saved to the proper places as well. This is really great because an integration test like this truly makes sure that our code is working correctly because we're using the code exactly as it is used in a production scenario, with all the units of code working together. This might make us think that integration tests are superior, but they actually have some serious drawbacks. The two main drawbacks are time and the combinatorial problem. First, let's talk about time. There are several factors which contribute to the amount of time an integration test takes. We'll discuss the most common two. The big one is the time it can take to set up the database. If a database is part of your integration test and you want to make sure that it's in a pristine state for every test, then resetting it for every test can take quite some time. Another big problem with integration tests is crossing process boundaries. In our example, we were crossing at least two boundaries, first we're making an HTTP call to start off our test, then the test needs to call to the database. Of course, if our test itself also calls to the database, then that takes time as well. Crossing each of these process boundaries can take time. This may not be a big deal with a single test, but with hundreds or more tests, this can really add up. The combinatorial problem is a matter of multiplication. Imagine that in a single integration test, you are testing five different units of code and each of these has three branches. If you want to test every possible scenario, then it will require 243 different tests. If each test takes only 1 second, it can take you about 4 minutes to run every test. This isn't a problem if you will only run your test suite once a day, but that's certainly not the idea. If you change some code and want to know if it broke something, you don't want to wait until the end of the day, you probably want to know immediately. Unit tests, on the other hand, address all of these previous problems. Remember that a unit test only tests a single unit of code. This is done by drawing boundaries around the unit of code we want to test, and when necessary, providing fake implementations of collaborating code. This is typically called mocking. This means that unit tests are fast because there is no database to deal with and no process boundary crossing. Typically this means that unit tests run in milliseconds and it's not uncommon at all to be able to run hundreds of unit tests in less than a second. That means that you can run your unit tests each and every time you change your code on every change, and you will instantly know if you broke any tests, and the combinatorial problem goes away because since you're testing each unit in isolation, then testing 5 different units of code, each with 3 branches, only requires 15 tests instead of 243. Unit tests do have some drawbacks however. First, unit tests don't test that you wired up your units together correctly because they test each unit in isolation. Second, making code unit testable requires that you design your code to be testable. That means that you have to design your code appropriately and if you don't, it won't be testable. Usually this leads to superior code, but it does require thinking about. In general, these drawbacks are far smaller than the advantages of unit tests, which is why unit tests are almost universally considered to be a good idea on software projects. I have personally practiced unit testing for many, many years, and I can say without reservation that testing your code is a good idea and if you're not doing it now, it's time to change.

Summary
In this module, we talked about this course, the course repo and who it's for, but most importantly, we talked about why we should test and went over the basics of unit and integration tests, and the tradeoffs of each. In the next section, we'll look at tools used when writing unit tests with Node, and how to install and use them.

Tools for Unit Testing Node
Introduction
Hello! I'm Joe Eames, and welcome to module 2 of Pluralsight's course, Unit Testing in Node. In this module, we're going to be talking about the different tools we use for unit testing Node. This will include both the libraries that we use when we're actually testing Node and task automation tools that we use in order to run our tests. These automation tools let us run our tests whenever we want and also watch our files and automatically rerun our tests whenever there's a change. This can be very advantageous because we now immediately know if we've broken anything as soon as we make any changes. In this module, we'll start off by talking about Mocha and Chai. Mocha is the testing framework we will use with Node and is the most popular one currently in use. There are some other frameworks used, but none are nearly as common as Mocha. Chai is the assertion library used by Mocha. Chai gives us the syntax to verify that things happen the way we expect. We'll become very familiar with Chai in this course. Next, we'll cover Sinon. Sinon is a mocking library and by far the most common one in JavaScript. It is extremely powerful yet easy to use. Then, we'll cover Gulp. Gulp is one of several different task runners that we can use to run our unit tests and automate them so that they run for us whenever we change our code. And, last, we'll cover Grunt, which is another task runner just like Gulp. Both of these task runners are very popular, so it's beneficial to know them both since you're likely to encounter both of them in typical development shops.

Introduction to Mocha and Chai
In this section, we're going to learn Chai and Mocha. Now, we're not going to cover these two libraries exhaustively. We're just going to learn the basics of working with them. The first thing we'll need to do is install them. So, here I've got a blank directory named mocha-chai that I've recently created. And inside of that directory, I'm going to install Mocha and Chai. Now that I've got Mocha and Chai installed, I also want to install Mocha globally so that I can use it from the command line. I'm not going to execute this command right now because I already have it installed, but this is definitely something that you'll want to do. Before we continue on, it's a good idea to see where the documentation for Chai is. This is the website and documentation center for the Chai library. I highly recommend that you check it out when you have time. A few good things to look at are in the guide. You should look under Assertion Styles at expect and should. And then in the API, you should look at the sections under expect and should. This gives you comprehensive coverage of the complete variety of syntax that you can use with Chai when doing expect and should assertions. Those are the types of assertions we will use in this course. Assertions are the way that we tell the code what we assume to be correct. And if it's not, our test will fail. We'll see that in just a minute. Chai does support other types of assertions besides expect and should, but we're just going to use expect and should in this course. If you're interesting in other types of assertions, I highly recommend that you check out more about Chai. The documentation for Mocha, on the other hand, is found here. Mocha is a lot simpler than Chai. It's simply a test runner and has very simple syntax. So, even though it's a good idea to check out the documentation for Mocha, it's not something you're going to need to refer to often. Now that we've seen the documentation, let's go ahead and write our first test. I'm going to use the Visual Studio code editor. This editor was recently released and is a nice lightweight editor. Very similar to Sublime. There's no particular reason that you need to use any editor over another. You should definitely use whatever is your preferred editor. That means that you can work with a full-blown IDE like Eclipse or Visual Studio or a lightweight editor like Sublime or even something simpler. Use whatever tool you prefer. Here in my empty product, I'm going to create a new file, and I'm going to name that test. js. I'm going to start out by adding use strict at the top, always a good idea, a lot of jshint direction, and then I'll import Chai. In addition to importing Chai, I'm also going to create a shortcut. Since we're going to be using Chai's expect function a lot, I'm going to make it a little bit simpler to use by creating a shortcut for it. And since I'm going to be using Chai's should expressions, I need to call chai. should. At this point, we're ready to begin writing a test. Of course, a test is useless without some code to test. Normally we would write our code inside of a different file, but for simplicity, I'm going to write the code inside of this same file. I'm going to write a simple function called isEven, which takes in a number and returns whether or not that number is an even number by calling modulus 2 on the number and comparing that to 0. Mocha and Chai use the BDD style expression of tests, which always start with a describe function. The describe function takes in two parameters. The first is a name or description of the tests. I'm going to write in unit tests. The second is a callback function that it will execute. This describe function allows me to separate out my tests into different sections. For example, if I was going to test the student object, I might pass in the name student, and, later on, I might have another describe with the name of class. Next, we'll write our first test. And I'll clean up this extra describe and change the name of this describe back to unit tests. The it function takes in two parameters just like describe. The first is the name of the test, and the second is a callback function. This callback function contains the actual test. By convention, the name of the test will be a phrase which starts with the word should. In our case, we're going to test that the isEven function should return true when the number is even. And since we're testing the isEven function, let's go ahead and rename our describe from unit tests to isEven. Now that we have our tests created, we can go ahead and write the code for it. We'll do this by calling the isEven function itself and passing in an even value, and then the magic of Chai happens. Because of this line of code here, all objects in JavaScript now have a new property named should. From that should, we can chain other properties, which allow us to test something about this return value. In our case, we want to assert that the return value for the isEven function when given a for should be true. So, after should, we add be and true. This will make our test pass if isEven returns a true in this case, and it will make it fail if isEven returns a false. Now, since I'm using Visual Studio code, I can go ahead and do something kind of cool and add a reference to the d. ts for Mocha, which will now give me IntelliSense on my describe and it functions. Let's go ahead and run our first test. I'll save the file and go back to the command line. And from here, I'm going to type in Mocha and then the name of the file that I want to test. Once I do that, Mocha will run all the tests inside of that file and report out to me whether or not they've passed or failed. You can see here that the name of our describe and our test has become very useful documentation for our code. It even reads like a full English sentence. If I just read this off, isEven should return true when number is even, it tells me something about my code and is in effect documentation about my code. Let's go back and add another test. This time we'll check that it returns false when the number is odd. This time we're going to use the expect assertion. Expect is a function which we pass a value. In this case, we'll call it isEven, passing it a 5, and at this point, we get the same properties that we have on should. I'll check that that's false, save my tests, go back and run them again. And now Mocha has run both my tests and told me that they're both passing. IsEven should return true when number is even, and isEven should return false when number is odd. If we go in and break one of our tests, and run our tests again, Mocha will report out to me that there was an error. One of my tests is now failing, and it tells me which test is failing. Should return false when number is odd is failing. This, of course, is extremely handy because it lets me zero right in on my failing test. I'll go back and fix that, run my tests again, and we're back to a passing state. In the next section, we'll learn about setup and teardown for our tests using beforeEach and afterEach.

Setup and Teardown
In this section, we're going to learn how to do setup and teardown for our tests using beforeEach and afterEach. Let's start by adding another function to test. This will be the add function. Of course, the add function takes in two parameters, num1 and num2, and returns the two numbers added together. I'll create another describe naming this add without setup and teardown. And I'll create an additional variable, and then I'll create a test that adds to that number. Now, I'll make a mutating change and then assert that num is the correct value. If I save and run my tests, you can see that all of our tests are passing. Now, I'll go back and add another test. This test tests that when adding 7 to 5, I get 12. Now, if you've been watching, you've probably seen that this test is going to fail. And if we save our file and run our tests, you'll see that, indeed, it does. It says that expected 17 to equal 12, and the failing test is should be 12 when adding 7 to 5. Going back to our code, we can see why that is. I've initialized the variable num here in line 31, but in the first test, I mutate that number here, and in the second test, I expect it to have the initial value again. Now, this may be a less useful example here, but in more complex tests, say when creating a class and assuming that that class is in its initial state, you're going to want to reset to the initial condition every time you run each test. So, let's fix our code, and we can do that by calling beforeEach. BeforeEach takes a single parameter, which is a callback function, and it executes this callback function at the beginning of every test. Now, we'll move our code from here into the beforeEach function, and then move the declaration outside of the beforeEach function. And now if we save and run our tests, we're back to a passing state. There is a corresponding afterEach function which you can use to run code after each and every test.

More Mocha Features
In this section, we're going to look at some additional functionality and features of Mocha. One of the things that we've seen is that we can use describe functions to group our tests. But we can also nest describe functions in order to group them on multiple levels. For example, if we wanted to take all of our tests and group them all together under a section called number tests, we could do that easily. I've added the opening describe. I'll take all this additional code down to this point, indent it one level, add in the closing curly brace and parenthesis, fix a couple of linting errors. And if I save and run my tests, you can see that we've grouped our isEven and add without setup and teardown groupings inside of the number tests grouping. And we could do this as many levels deep as is necessary. Another thing that we can do with mocha is we can skip certain tests if we need to. Let's say, for example, we've decided that this second test down here is no longer necessary, and we want to skip it. Perhaps this is temporary, though, and we don't want to delete it. We just want to skip it for now. We can add a call to it. skip instead of just it, save that change, rerun our tests, and you can see that it's now being skipped. Mocha tells us that three are passing and one is pending, which is essentially its way of saying it's been skipped. There's a simpler way of doing this instead of adding a call to it. skip. You can just change the it to an xit, and we get the same functionality. We can do those same exact things to describe functions. So, if I want to skip this second describe, and now it's skipping both of those tests, and the same thing with x. Another thing we can do is tell Mocha that I only want to run a specific describe or a specific test. We can do that with the. only function off of the describe or it function. You can see at this point, it's only running those two tests. If we add that same thing to the it, we've got the same result. We're now running just that one test. I highly recommend that you be very careful whenever doing this because if you accidentally check in this code, then it's only going to run that one test, and you're no longer going to know whether or not your code has broken anything because most of the tests aren't being run. So, this is definitely a feature to use sparingly. Now, so far we've only had one test file that we've been running. But what if we have two test files that we want to run? I'll go in and add a new file, and I'll call this moreTests. And I'll add my necessary header. Now, I'll just create a simple describe, and I'll create a simple test. And I'll save that in my other file and then go back out to the command line. And if I want to run both of those files, I just type in Mocha and list both files that I want to run. And you can see that it's now running all five of the tests that I've created. This is great, but after you create more and more test files, this can get pretty tedious. So, one of the things that Mocha does is it, by default, will look for specific kinds of files. So, if I type in Mocha without any parameters, you can see that it's just running my test. js file. So, by default, it will look for a file called test. js in the current directory and run that file. That's only going to be useful if I've got one file and I name it test. js. But what we can do instead is go in and create a new directory called test and then put both of our files inside of that directory. Then I can go back to the command line and just run Mocha, and it will look inside of that test directory and run all js files that are inside of that. So, in most cases it's a good idea to put all of your files inside of a directory called test. Another thing that Mocha could do that's really nice is watch the files and rerun them whenever they change. And in order to get that to work, you just add the -w flag to Mocha. And it runs the tests once. And if I go back in and change one of the tests and save, you can see that Mocha has already run and let me know that I've broken something. I can go back in and fix it, and Mocha runs again, and everything's good. So, there're a few additional things you could do with Mocha that can make it really convenient when unit testing your code.

Sinon and Spies
In this section and the next two, we're going to be learning about Sinon. Sinon is a JavaScript library which allows us to isolate the code that we're testing. When unit testing code, it's critical that we only test the single unit of code that we care about. In order to do that, we must isolate it from its collaborators. That can be very difficult, but tools like Sinon make this job much easier. In this section, we're really only going to be looking at the more common pieces of functionality of Sinon. And this course won't go that deep into Sinon. So, if you do want to learn more about it, you can always check out the documentation, which is here at this website, or you can check out my course on testing client-side JavaScript, which has an entire module devoted to Sinon. So, let's start off by deleting our moreTests file. And then I'm going to add to my test directory another file. And this one I will call sinonTests. I'll start with my standard header. Now, at this point, I need to install Sinon, so I'll go back to my command line, and I will install it using npm. And once that's done, I can go back in here and add it right here. And I'll go down here, and I'll create a new describe. This will be for my sinonTests. And following along with our theme of a class registration website, we will use a student object in our tests. And as we mentioned before, we want to use beforeEach functions to make sure that our classes are in a pristine state. So, in my beforeEach, I'll initialize the student object, and I'll start off with the dropClass method. Now, let's assume in our example that the dropClass method takes in a class Id and a callback. Then it does some work. And after it's done, it calls the callback. So, I want to test that this dropClass method will call this callback. So, let's create a describe for that. And inside of this describe, we'll create a test. And now I want to call student. dropClass passing in an arbitrary class Id. And then I need to pass in some kind of a callback. Now, in this case, I don't really care what the callback is and the functionality of the callback, I just want to pass in some callback and test that it actually got called by the dropClass method. So, I can create a function, and I can pass that function into the dropClass method, but I don't have any way of knowing that it's been called. What I could do is initialize a Boolean variable and then inside of my callback, set that to true. And now I can set an expectation and test that it was true. But that's certainly a lot of code that I had to write by hand. And what if I needed more complex situations? What if I wanted to test that it was called a certain number of times? Or what if this callback took in some parameters, and I wanted to test that it was called with certain parameters? This is the kind of scenario where Sinon shines. So, what we're going to do is create what's called a spy. A spy is simply a function that Sinon will watch and be able to tell whether it's been called, how many times it's been called, and what parameters it was called with on each invocation. Now, I'll pass that spy into my dropClass function, and I can change my expectation to say that spy was called should be true. And now if I go to the command line and run my tests, we now have five passing tests, and our new test, student. dropClass, should call the callback is passing. Now, let's imagine another scenario. Let's imagine that I actually have a callback function that I truly do want to pass in and have its functionality execute, but I still want to watch it and determine whether or not it was called. Well, Sinon call help us out with that too. In this test, I want to pass in a function that logs to the console and make sure that that actual function gets called. So, we'll call that function onClassDropped, and our implementation will simply be to log out to the console. Although on a more realistic situation, this might have other side effects that we care about. And now I want Sinon to watch this particular function and make sure that it's called. So, I'll create a spy again. But instead of passing in no parameters, I'm going to pass in the function that I care to watch. And then I'll call student. dropClass passing in a 1 again and the spy, and then check that the spy was called. And what Sinon has done is the spy that it created is wrapping around my onClassDropped function. And internally it will call the onClassDropped function when the spy itself is invoked. So, we'll go back to the console, run our tests again, and now I have six passing tests, and our new test is passing. And you can see right here that that statement has been logged out to the console. And the third scenario that I want to show is using a spy that wraps around a method of an object instead of just a loan function like this onClassDropped function was. So, for this scenario, let's assume that we've got another object called schedule. And this schedule object has a dropClass function itself as well. And for this function's implementation, again, we'll just log out to the console. And let's fix this spelling of that. Now, let's change the implementation of our studentDropClass function. And let's assume that instead of just taking in a callback, it could either take in a callback or an object. And if it takes in an object and discovers that that object has a dropClass function, then it will call that function. It's a little bit of a contrived situation, but it's useful for showing off the functionality of spies without breaking our previous tests. So, let's check and say if callback. dropClass, and we will not-not that, which will tell us whether or not that function exists on the object, and if it does exist, we will call cb. dropClass. Otherwise, we'll just invoke cb as our callback itself. So, now at this point, we haven't broken any of our tests, and we can prove that by running them. We have seven passing tests, but our new latest test is just an empty test. So, let's make this work by calling student. dropClass. And this time instead of passing in a function, we will pass in the schedule object, which has a dropClass function on it. And now we want to check that schedule. dropClass was called, but schedule. dropClass isn't a spy we want to spy on it. In order to spy on it, we can't simply wrap it as a spy using Sinon. spy and then pass in the function, which would be schedule. dropClass, because that will create a spy that's wrapped around the dropClass function, but inside of our code here where we call the object's dropClass function, we're invoking it on the object. The spy that gets created will just be a loan function. The dropClass method on the schedule object won't be replaced with a spy. And we can show that by going to the console and running our tests. And we'll get a failure that we can't read property "should" of undefined. And if we go back to the code, we'll realize that the called property doesn't exist on the dropClass function on the schedule. But, fortunately, Sinon has a way to replace the method with a spy. And we do that by passing in two parameters. The first is the object that the method's on. The second is the name of the method as a string. In this case, Sinon will go in, grab the method, wrap it in a spy, and replace the method with that wrapped spy. And if we save and run our tests again, everything's passing. So, that's how we use Sinon spies to watch functions to determine whether or not they've been invoked. In the next section, we'll learn about Sinon stubs, which are a little bit more advanced versions of spies.

Sinon and Stubs
In this section, we're going to learn about Sinon's stub functionality. Where spies are a way to watch a single function, stubs are a way to watch an entire object. Because we most often work with objects and not just loan functions, it's usually more common to use stubs than spies with Sinon. So, first, I'm going to go in and have Visual Studio code and my Mocha referenced so that I can get some IntelliSense. And then let's add in a new suite of tests. We'll add another describe, and we'll call this one student with stubs. And so let's create our first test. We're going to basically recreate the same scenario we created at the end of the last section where we need to pass in our object and monitor one of the methods on that object and make sure it gets called. But this time we use a Sinon stub instead of a spy. So, I'll create a stub, and when I call Sinon. stub, it'll pass in a function, and I don't pass in an object and the name of the function. I just pass in the object itself. At that point, Sinon goes through every method on that object and replaces it with a stub function. The stub function has pretty much all the same functionality that a spy does. So, I can call student. dropClass, and I can pass in just that method. But one thing that's different is I'm no longer going to pass in the schedule object. The stub object that I created right here is a brand-new object that I will use in place of the schedule object. So, I can pass in stub. dropClass, and then I can check to see if it's been called. And let's run our tests. And we can see that our test is passing. So, it is, indeed, watching that stub and able to determine whether or not it's been called. One thing to note a stub does not call the inner implementation of the underlying method. So, even though the schedule. dropClass function that we've written right here logs out to the console, when we run our test, it's not actually logging out to the console. There's no log right here on this test. And because the stub is an object, we can also call it the same way that we called the schedule object up above and just pass in the object itself. And our code will determine that it has a dropClass method and call that. Run the test again, and we're still passing. Now, you may be wondering what the value of stubs are if they pretty much just do what spies do. But they actually have a lot more functionality than spies do. One of the things that we can do with stubs is we can control how they function. So, let's go up to our student object, and let's add a new method which we will call addClass. And that takes in a schedule object, and it checks the schedule object to see if the class is full. And if it's not full, then we'll do whatever needs to be done to register for the class and then return true. And if it is full, then we'll return false. And so now we need a classIsFull method on our schedule object. We'll go down and add that. And we'll just hard code this to return true. And now we'll go down and add a new test, and we'll capture the returnVal of the call to student. addClass passing in the schedule. And in this case, we want to test that if the class is not full, then we should get a true return value. Unfortunately, our classIsFull method always returns true, which means the class is always full, and we cannot test the scenario of when the class is not full. And if we save and run the code, then we get our failing test because it is expecting false to be true. So, this is where the power of stubs comes in. Let's stub out schedule, and we'll take the stub. classIsFull method, and we'll tell it that we want it to return false instead of true. And now the classIsFull method on the stub will return false, so we replace this schedule with the stub that we've created. Go to our command line and run our tests again, and our tests are passing. So, that's an example of the power of stubs. You can control them a lot more than you can spies. And since they work on an entire object, they're often a lot more convenient than spies as well. They're basically a superset of what spies do. In the next section, we'll look at the last major feature of Sinon, which is mocks. And we'll see how to use them as well.

Sinon and Mocks
In this last section, we're going to learn about Sinon's mock functionality. So, let's create a new describe. And we're going to mock our schedule, so we'll just name our test mocks schedule. And mock is different than a stub or a spy in that you can set up before the code actually runs some expectations. You can say that you expect that a certain method is going to be called a certain number of times, and then when you're all done, you simply verify the mocks, and then the test will pass or fail based on whether or not all the expectations were met correctly. So, it's a way to test some fairly complex scenarios. In most cases, mocks aren't needed, and most people find that stubs do just fine for pretty much all their testing needs. But there are some scenarios where a mock can be a lot more useful. So, it is good to know about mocks and how they work. So, we'll create a mock object, which is a call to Sinon. mock. And we pass in our object, which will be our schedule object. And that's the object we're mocking. And then we'll create an expectation is the mockObj. And we can say that we expect that the classIsFull method is going to be called once. Now, if we call student. addClass and pass in our schedule, it will run the code. And notice we're not passing in the mockObj, we're actually passing in the real schedule. Sinon has, again, kind of like with the spies, modified the actual object. And now we can verify our expectation by calling expectation. verify. And we go to the command line and run our tests again. And we can see that our test is passing. It's actually checking and making sure that classIsFull gets called once. And so if we go in and change our expectation and say that we expect that classIsFull gets called twice, then we go back to the command line and run our code again, we'll see that that test is now failing. We expected classIsFull to be called twice. It was called once. So, let's go back and change this back to once. We'll save and run our code one more time. And our tests are now all passing. So, that's the basics of Sinon. It's basic functionality, which is spies, stubs, and mocks, and you'll mostly use stubs in your general testing, but there will be times when you use spies. And, occasionally, there could be times when you might want to use a mock. But for the most part, stubs will do what you need.

Using Gulp to Test Node
In this section, we're going to use Gulp to run and watch our tests. Gulp is a task runner that's very powerful, and you can use it to automate just about any kind of task. Gulp is often used as a build system for web projects. And in this demo, we're going to use the basics of Gulp, but we're not going to learn a lot of the details. If you're interested in Gulp, I highly suggest you check out one of Pluralsight's courses on Gulp. To get going with Gulp, we have to start by installing it. And we'll do that by npm install Gulp, and we'll install it globally to begin with. And then we're also going to install Gulp locally in addition to a couple of other modules, gulp-mocha and gulp-util. Now that those are installed, we're going to go back to our project And then starting off with the same project that we've been working with previously, this gives us an existing set of tests that we can run. And I'm going to create a new file called gulpfile. js. I'm putting this in the root of my project. The gulpfile. js file is a JavaScript file. So, inside of this file, we can write any kind of JavaScript that we want, but we typically follow a fairly set pattern. We're going to require in Gulp. I'm also going to require in gulp-mocha and, finally, I'm going to require in gulp-util. Now that I've got the proper libraries imported, I can go ahead and start making Gulp do things for me, and I do that with the gulp. task function. This takes in two parameters--the name of the task, which I'm going to name this task mocha because it's going to run my Mocha tests, and then a callback, and this callback is going to return. And we'll start out with calling gulp. src, and that tells Gulp to load up the following files. And I'm going to give it a file pattern of test/*. js so that it will run all of the js files inside of my test directory. And I'm going to give it a second parameter, which is some options. I'm just going to tell it read:false, and then I'm going to pipe that into the Mocha function, which is that gulp-mocha module. And that takes in again a list of options. And I'm going to choose a reporter. The reporter formats the output when we run the tests. And I'm going to ask it for the list reporter. There're a lot of different reporters that you can use. You could check out the documentation if you want to see what some of the other reporters look like. And then I'm also going to listen to the error event. And if it does have an error, I want it to log out, which is where I'm going to use that gutil and call log. Now, of course, before this will run, I've got to fix this little typo here. And now I can save and run my tests. We'll go out to the command line. And I'm going to type in Gulp and then the name of the task that I created, which was called mocha, and execute it. And we can see that I've got ten passing tests. The formatting of the output is a little bit different than we're used to with Mocha. That's because of that reporter that we chose. But mostly you just look at the bottom and see how many are passing and how many are failing. Now, another thing that we can do is get Gulp to watch the files and rerun the tests whenever they change. So, let's add another task, and this one we'll call watch-mocha. And in this case, we're going to call gulp. watch. And we give it an array of file patterns, so I want it to watch my source files, which are going to be in any directory, and they're going to have a js extension. And I'm going to also explicitly tell it to watch the test directory. These essentially do the same thing, although it's nice to have it in two different specifications because that way if I move the test files or the source files around, I know that I need to go in and change the paths. And then I give it a second parameter, which is another array of the tasks that I want to run when watch detects that something changes and I want to run the Mocha task. Now, this is great, but it won't run my Mocha tasks right at the beginning. It's only going to run them if something changes, and I want them to run once as soon as I tell it to watch Mocha because I want to see if everything's passing before I start changing any files. So, I'm going to tell Gulp to run the Mocha task. And now if I go out to the command line, and I run gulp watch-mocha, you can see that it's run all of my tests, but it's now watching. So, if I go back and go into my tests and make a change, and let's make this one start failing, as soon as I save it, go back, and we can see it's already rerun the tests and reported out that one of my tests is failing. Go back and fix it, and go back to the command line, and everything's passing. Now, one more thing that we can do with Gulp that is really nice is to set a default task. So, we call gulp. task, and we just name the task default, and that will Gulp if I ever call Gulp without a second parameter, then this is the task that I want you to run or series of tasks that I want you to run. In this case, we just want to watch. So, we'll call the watch. mocha tasks. And we'll save and go back out to the command line. And this time, I'll just call Gulp, and you can see it's running the watch. mocha task by default. And so there's our introduction to using Gulp to test with Mocha.

Using Grunt to Test Node
In this section, we're going to show how to use Grunt to run and watch our tests. Grunt is really similar to Gulp. Their syntax for their config files is a bit different. But other than that, they pretty much have the same capabilities. So, for most people, the choice between Gulp and Grunt comes down to a more personal choice or just using whatever's already on the project. So, we'll need to start off by installing Grunt. And we install that by first installing the grunt-cli, and we install that globally. And then we need to install Grunt locally. And we also want to install grunt-mocha-test, which will let us run Mocha. And we also want to install grunt-contrib-watch. Now that we're done with that, we'll go back into our project. And just like with Gulp, we're going to create a config file. But instead of gulpfile. js, this is called gruntfile. js. So, we'll start off with our standard use strict. And then we set a module. exports with a function that takes in a Grunt object. So, again, the syntax is a little bit different than Gulp. Then we call grunt. loadNpmTasks. And we're going to load in that grunt-mocha-test, and we're going to do the same thing to load in grunt-contrib-watch. And you have to load in the tasks before you can use them when you're using Grunt. So, again, mocha-test will let us run Mocha from Grunt, and contrib-watch will let us do the auto-watching that will rerun our tests whenever something changes. At that point, we call grunt. initConfig, and we pass in a JavaScript object. And the keys of the top level this JavaScript object is going to be are tasks that we will run from Grunt and the names of the tasks. So, I want a task named mochaTest. And that is an object that takes in a couple of key value pairs. The first one is going to be test. And this tells Mocha what files we want to test and any options we want to give it. So, we'll give it an options, and we'll tell it the reporter. This time, I'm going to give it a reporter spec. And the second parameter is the source, which is the list of files we want to run in our tests. So, that will be test and then all the js files inside of that. And now that we've got that done, we can go out to our command line, and we can call grunt mochaTest. And that will run our tests once. Now, let's set up a watch task. So, after our mochaTest task, we'll create a new task called watch. And this one has a key called scripts, which has two keys--files, which is an array, which is a list of files, and we'll watch all the JavaScript files, and then the tasks to run, and we want to run our mochaTest task. So, we've got that created. We can go back to the command line and type in grunt watch, and you can see that it's running. It hasn't run my tests yet. It's just running and waiting for a file to change. So, we'll go back in. Go to one of my tests and make a change. Let's make this one fail. And if we go back to the command line, we can see it's already run. We've got one failing test. Go back in, fix it, and back, and it reruns the tests, and everything's passing. And, of course, just like with Gulp, we can set a default task. And we do that outside of initConfig, we say grunt. registerTask. And the first parameter is default, and the second parameter is the task we want to run, which is watch. And if we go back out to the command line and just type in grunt, then it goes ahead and runs the watch task for us. So, there's a basic introduction to using Grunt to run your Mocha tests.

Summary
In this module, we went over the different tools that we use to unit test Node. We started off by looking at Mocha and Chai. Mocha is our test runner, and Chai is our assertions syntax. They work together to let us author the tests that we're going to run against our code. After that, we looked at Sinon, which is a mocking library and by far the most popular and comprehensive mocking library for JavaScript that exists out there today. We also looked at Gulp and Grunt. Those are two different task runners that are very popular in the JavaScript world both in Node and on the client side. And they let us run just about any kind of tasks. But when testing, what they can do is let us run our tests and automate them. You can do that with just Mocha by itself, but oftentimes you've already got a Grunt or Gulp build going anyway, so it's nice to be able to add the testing of your code to your Grunt or Gulp build. In the next section, we're actually going to start into the meat of our course, which is testing our code. And we're going to look at testing the different kinds of common pieces of Node that we might want to test.

Unit Testing Your Code
Introduction
Hello! In this module, we're going to be working on unit testing our code. That means we'll actually be writing tests against existing code. I'm going to use preexisting code that I've already written, but the code that I'm writing is far less important than understanding the lessons about writing unit tests for your code. In this module, we're going to cover the following topics. We'll start off with talking about how to test business logic and how to write good tests and make sure that your business logic itself is testable. Then we'll talk about how to test exceptions. There can certainly be places in your code where you will throw exceptions, and you need to be able to test that logic. Normally when you throw an exception, that fails a test. But with Mocha, we can manage that and are able to test code that throws exceptions. We'll also talk about finding edge cases and using our tests to find problems in our code and then using the tests to guide us into writing fixes for our code. After that, we'll talk about IO and Async operations. IO is typically an asynchronous operation in Node. And there are other asynchronous operations in Node that aren't directly IO related. We'll talk about how to test those with Mocha. After that, we'll talk about mocking our code. Mocking is very important to enable us to isolate the one unit of code that we want to work with. Sometimes this unit is a single class. Sometimes it might be two or three classes. But we need to make sure that we're only testing the code we want to test. And mocks enable that so that we don't test other code that we don't want running in our tests. Then we'll talk about testing promises, which has a few unique capabilities in Mocha. And, finally, we talk about test coverage, which gives us the ability to see what code we have tested and what code we haven't.

Testing Business Logic
In this section and the next couple of sections, we're going to talk about testing business logic. I've prepared some code that's got some non-trivial functionality inside of it. This will help us write tests that are more indicative of what it's like to write tests against actual production code. Let's take a moment right now and look at that logic. We're going to start with our Student class. The Student class is relatively small. We have a create function here, which will create a new student given a name and a grade. And then we've got an advancedGrade function here, which will increase the student's grade by one level. And, finally, we have a toString function here, which will print out the Id of the student, a tab, and the student's name. Next, we have our Course class. Course has a lot more functionality inside of it. We still have the create function, which will create a new course given a name, a code, and a course description. Then we've got a registerStudent function, which will add a student to a students array. Then we have an unregisterStudent function, which will remove a student from a students array. Then we've got an addTimes function, which given a list of days and times will add those to an array of times and days that indicate when that class is available. Then we've got a showSchedule function, which will display the course schedule. And on line 77, we have a showStudents function, which will display a list of students registered for that course. Most of this code is fairly straightforward, but it will be useful in showing how to test non-trivial business logic. One thing we'll need to do before we begin testing our code is to install another library. The Student class uses the UUID module. Of course, we've already got Mocha and Chai installed, so we'll just go to our command line and install the UUID module. Once that's installed, I'm going to start up Mocha and just have it watch my tests. Immediately we can see that we've got 0 passing tests. So, let's go into the code and start writing some tests. I've got here two blank test files, the studentTests file and the courseTests file. Both of these look pretty much the same. We're bringing in the correct modules, and we've got an empty describe statement. Let's start by writing our first test for the Student. Our first test will test the create function on the Student class. Again, I'm using an English sentence to describe what the test does. And I'll create my student, and I want to pass in a student name, so I'll say John Doe. And their grade, we'll use 5. And once we've created the student, we can now test a few things. Let's make sure that their name exists. I'd like to test a few other things, but at this point, we've actually got a working test. So, let's save it and go out to the console, and we can see that we've got one passing test. And so let's add a few more asserts in here. So, I want to check that the name is what I expect it to be. At this point, I'd have to duplicate this John Doe string. I don't want to do that. I'd like to put those into a common variable. So, let's just go up to our describe, and let's create a var studentName and set that to John Doe. We'll create a studentGrade variable and set that equal to 5. And now we'll change our constructor to be studentName and studentGrade. And here we can verify that it matches the studentName. And let's also check the same thing on the studentGrade. And the last thing we'll do is check and make sure that the Student class created an Id. Again, if we go to the Student class, we can see that the Id is created by using the UUID module. So, we'll go back into our test and check that it exists. Since it uses a UUID, we can't check to make sure that it's a specific value, but we can at least check that it exists. So, let's save these changes, go back to our console, and we have an error. Student is not defined. So, I got a little spelling error. Back and fix that. And now that we've got that test written and working, let's write one more test about Student. We won't test everything we possibly could about the Student class. But let's write one more test. Let's test the advanceGrade function. So, I've got my test name written. And, again, I'm going to initialize my Student using the variables that I created. Now, you may have noticed that we've got some duplication going on. Line 28 is a complete duplicate of line 16. In both places, we just create a student object based on the studentName and studentGrade variables. So, you might think that what we could do is go in here and change this code, move this creation up inside of a beforeEach function. And, of course, we'd have to move the var and student up outside of it, and then we could move both lines of code out. That would be true; we could do that. But this is a case where we probably don't want to. And there's a reason why. Tests don't necessarily have to remove all duplication. When writing a really good unit test, one of the things that's important to see is the three pieces of a good test, which are to arrange, which means to set up the initial environment or state, to act, which is to make some kind of change to that state, and then assert, which is to test that your change produced the correct change in the code that you expected, an unexpected change. So, if we look at our first test, our arrange is on line 16 where we create the student. It's also our act because that's the place where the studentName and studentGrade get stored, so those two pieces are in the same place. If we were to remove that code out of the test and up into a beforeEach, if somebody came along and just looked at the test, all they would see is something like this saying, Hey should. exist(student. name), student. name. should. equal this, they would have to go up and look at the beforeEach to understand truly what's happening in the test. So, this is a case where I want this code to exist. There's a saying that goes along with tests--tests don't need to be dry, d-r-y meaning don't repeat yourself. Tests can be damp, meaning there could be a little bit of duplication if it really helps in keeping the test itself clear and readable. So, I'm not going to remove this code and put it up into a beforeEach and remove the duplication. I'm just going to leave the duplicated code in there. So, I've got my student variable I'm going to call student. advanceGrade. And this is our act in our three different phases of a test--arrange, act, assert. We've got arrange on line 28, the act on line 30, then I'll put our assert on line 32, which would be that the student. grade. should. equal the studentGrade variable +1. And I'll save that and go back to the command line. And we can see that we now have got two passing tests. So, there's the absolute basics of doing business logic testing. In the next couple of sections, we'll look at some more interesting examples and scenarios of testing business logic.

Testing Errors
In this section, we're going to learn primarily about testing errors, but we're also going to see a few other pieces of writing good unit tests. So, for our Course, just like the Student, we want to create a basic test that just tests that the Course. create function works well. So, we'll start right off with some variables--courseName and a courseCode, the description, and then we'll create our first test. And we'll create our course here at the courseName, the courseCode, and the courseDescription. And then we can check that the name exists. And let's also check that the code exists, and let's check that the description exists. We should also check that they match their correct variable names, but I'm going to skip that for now just to move on to something more interesting. The course itself also has a students array and a time's array, so let's check those. We'll make sure that they exist. And we'll also make sure that it's an empty array. And I'm going to use not equal in this case an empty array. But instead I'm going to use eql. The eql function does a deep comparison and compares values. Equal actually compares references. So, this would fail because this empty array is not the same empty array as the students empty array. So, if we were to leave it like this and hit save and go out to our command line, we'll see that we've got an exception. The assertion failed. It expected an empty array to equal an empty array, which you would think would work. But because it's doing a reference comparison, that's failing. So, we'll just change this to eql and save and go back. And now we've got our tests passing again. So, let's check that one. And we'll also check that the times is the same way. And go out and check. And our code is still passing. So, we've got that basic test written. Let's write a more interesting test. Let's test the registerStudent function. Now, since I'm testing the registerStudent function, it would be nice if I could group all registerStudent functions together, which I'd like to do. So, I'm going to create a new describe that will do just that for me. And I can just name the method inside of it as the name of the describe, and then I can write my test. And I'll create the course. And then I'll call the registerStudent function. And at this point, I need to pass in a student because the registerStudent function, if you'll remember in the course, takes in a student and pushes it onto the students array. So, I'm going to need a student. Of course I could go up here and create a student and give him a name and a grade. Of course, we'll probably want a 5th grader to be registered for this class and then pass that into here. The only thing that I don't like about this is creating this student is kind of tangential to what's going on. The course is very important. That's what we're testing. We're not necessarily testing the student. So, I'm actually going to move the creation of the student out of this and into a beforeEach loop. So, I want to cut that out, and I'm going to go up to the very top here of my course tests and create a beforeEach. And then create a student variable, which we set there on line 18. And then down in our code, we pass that into the registerStudent function. And now we can run our assert. So, let's check that the students array's length is 1. And let's also check that the first element of that index---we'll check the Id and make sure that that is the same as the student that we created their Id, which will let us know that it's the same exact student. And so if we go out to our command line, we can see that we got four passing tests. And what's kind of nice is if you look right here, we can see that under the course tests, there's a registerStudent section. And so if we read those off, we say course registerStudent should add the student to the students array, which nicely documents the functionality of our class. And now I want to add another test, but this time I want to test the unregisterStudent function. And I just want to test this portion of the unregisterStudent function right here where if we try to unregister a student that isn't actually registered for the class then we throw an error. So, my test is going to be that it should throw an error if we try to remove a student that isn't in the class. And so we'll create our course. And now we're going to write the expect function, and we're going to pass it a callback. The reason we do that is because if the code that we actually are writing inside of our test throws an error, then the test would normally just fail if our code throws an exception. But if I do it inside of a callback and pass that to the expect function and then I tell that expect function that I expect it to throw and it will capture that error, and it will actually fail the test if an exception isn't thrown. So, now inside of here, we can call course. unregisterStudent and pass in an Id for a student that doesn't exist inside of the students array for the course. But, of course, there are no students inside the array so anything we put in here is going to cause an exception to be thrown. And if we save our code and go out to the console, we can see that we've got five passing tests. So, that's how to handle capturing and testing exceptions that you expect to be thrown.

Finding Edge Cases
In this section, we're going to learn about testing edge cases. So, I'm going to start off by testing the addTimes method of the Course object. So, if I go back into the Course object, and we look at the addTimes method, we can see that it passes in an array of days and times. If we pass in a single one, it will turn it into an array. And then it just adds it to the times array. So, let's go back to our test. And we'll create a new describe. And then the test will be that it should add the given days and times to the course. And within here, we'll create our new course. And then let's create a day's array, which will be the array of days that the course is available on. Let's say Monday, Wednesday, and Friday. And let's create a times array, which will be at 10 a. m. and 2 p. m. And now that we've got that created, we can go ahead and call our addTimes function passing in the days and times. And then let's run some assertions. And because of the way the algorithm works, we're going to produce six total entries, two for Monday, two for Wednesday, and two for Friday. And we can check that the third one should be equivalent to an object that has a day of Wednesday and a time of 10 a. m. And if we save and run our code, we go out, and we see that we're getting an error. We expected two things to equal each other. And after looking at it a little bit, we see that we've got a spelling error. So, we'll go up and fix our spelling error and click save. Go back, and our tests are passing, which is great. But now that we've seen that spelling error, that causes me to think, Well, what happens if I add in an illegal day? In this case, it actually added the illegal day to the array. The way that I spelled Wednesday wasn't a valid day, but it still added it to the list of days and times. So, it'd be really nice if it only allowed me to add valid days. So, let's create a new test, and we'll say that it should not add a non-day to the times array. And we'll create our course again. And this time, our day will be an invalid day, and the time will be 10 a. m. again. And now we can set our expectation that if we call course. addTimes passing in that day and that time, that it will throw an exception. And if we save and go to the console, we can see that we got one failing test--should not add a non-day to the times array. At that point, we can go in and fix our course code. And I'm just going to paste in a quick fix for this, which is a valid list of days, and a check here that makes sure that it is a valid day and if not, it throws an error. Save that code. Go back out to the command line, and we have seven passing tests. So, this is a great way that unit testing our code showed us a problem, helped us discover a problem in our code, and also helped us fix it by writing a test that fails until we write the passing code. And that's an example of how to test edge cases using unit testing and how to solve edge case problems that you discover as you unit test your code.

IO and Asynchronous Operations
In this section, we're going to discuss testing when using IO. Dealing with IO presents some special challenges because typically IO operations are asynchronous. That means the test itself must be able to deal with an asynchronous operation. The class we're going to look at initially is this DataLoader. The DataLoader is responsible for loading data for the other classes. In this implementation, we're just reading files from the disk, but we could easily have an implementation that reads files from a database or a web service or anything else, which is a good thing about having a class like this which wraps your data access because the interface itself is generic. It doesn't matter what the underlying implementation is. This way we can change the underlying implementation from reading files on disks to reading files out of a database, and the other classes don't need to know. They simply operate the same as they always have. So, let's look at our DataLoader implementation and see what we've got. The DataLoader has a method called getStudent here on line 12, which reads a JSON file from a disk and then calls a callback with the resulting data. It's got another method called getStudentSync, which reads JSON files from the disk using the readFileSync method. Let's go ahead and write some tests for this DataLoader and see the kind of issues we run into when dealing with asynchronous operations. The first thing I'm going to do is write a test for the synchronous method. For this test, I'm going to call the DataLoader's getStudentSync method passing in an Id of 1, which will match the file that I've got on disk right here. That will instruct the DataLoader to read from that file on the disk. Then I'm going to add in some assertions. I'm going to assert that the student name exists and that the student name is the name that I expect. And I happen to know that the name inside of that file is John Doe. And now if I save the file then go to the disk and run Mocha, we can see that I've now got one passing test. Let's go ahead and write a test now for the asynchronous method. In this case, we're going to call dataLoader. getStudent passing in the Id and the callback. We'll just use an anonymous function there. We do need to pass in a student parameter, and then we'll check that the student's name exists. And then we'll check that it's the correct name. And at that point, this might look like we're done with our test, but we've got a problem here, and that is that the test itself is synchronous operation. This anonymous function callback that we've created will get called later on, but at that point the test has already run and decided whether it's passed or failed. So, in this case, even though the student's name really is John Doe, we could check if the student's name was Jane Doe, and if we save and run the tests, we're going to see that we have two passing tests. But in reality, this test isn't passing. These assertions would actually be failing the test. But since they're not running until after the test itself has completed, it can't fail the test. Thankfully, Mocha has a way to deal with asynchronous tests. We do that by passing in a parameter to our test callback, which by convention we call done. And once we do that, Mocha will not allow this test to be completed until this done parameter, which is a function, has been called. So, after we've run our assertions, we call done, and that lets Mocha know that the test has actually completed and to go ahead and mark the test as success or fail. And at this point, if we save and rerun the tests, we'll get one failing test because we're expecting Jane Doe but actually getting John Doe. Let's go back and fix our test, and now we have passing tests. So, this is the way that Mocha handles asynchronous operations inside of tests. It's a very simple method, but let's just deal with the asynchronous nature of IO and other operations inside of JavaScript.

Testing with Mocks
In this section, we're going to learn how to test with mocks. In order to do this, though, we're going to have to understand a bit more of the sample code that I've written because we're going to write some tests around it. So, let's start off by reviewing again our DataLoader. Our DataLoader has a couple of methods for students--the getStudent and the getStudentSync methods. It's also got two methods for courses--getCourseSync and saveCourseSync. You can see that these have empty implementations, which is fine because we're not going to use our live DataLoader. We're going to mock it out. So, these methods are used by the Course and Student objects. If we look into the Course object, we can see that it's very similar to the class we've seen already. It receives a DataLoader on line 3. And then on line 17, it calls the getCourseSync method to load the data into the object. It's also got a save method down on line 22, which will save the data back calling, of course, the DataLoader. saveCourseSync, which is on line 32. Now, the Student object is somewhat similar to the Course object. It receives the DataLoader, and it calls DataLoader. getStudentSync, and it also has a save method down on line 22, which will call the DataLoader. saveStudent down on line 32. Other than that, these two objects simply expose the data that they have and allow the Registration object to work with that. Now, let's go into the Registration object and look and see how it operates. The Registration object, when you create it, takes in the course class and the student class. And then when calling registerStudentForCourse on line 6, it will load the student and course up with the current data based on the student Id and course Id given in that function. Once it has them, down on line 13 it will check and make sure that essentially the course has openings by comparing the max size of the course to the current student count of the course. And if it's less, then it will go ahead and add the student to the course. If not, it will just return false. So, a very basic implementation. Now, let's write some tests around this registration object. I've created this empty testing harness inside of which we will implement our tests. So, the first thing we want to do is be able to test that save is not called if the course is full. Again, if we review the Registration object, we can see that course. _save is only called on line 15 if the course is not full. So, we want to verify that course. _save is not called. And that's what our test is going to do. So, I'll start by creating a Registration object, and I need to pass in a course and a student. So, let's create those in our beforeEach, and the Course. create function takes in a DataLoader, as we can see in our IntelliSense. So, I'm going to need to create a DataLoader. Now, I don't want to create a real DataLoader at this point because I don't want to read data from the disk. I'm unit testing here. I want to test the Registration object, although by extension I'll be testing the Course and Student objects, but I don't want to use a live DataLoader and be reading data to and from the disk. I would like to test a bunch of different scenarios, and I don't want to have to set up a bunch of sample data. So, I'm going to create a mock DataLoader using the sinon. stub function. Now, even though I'm creating a stub, we still generally call this mocking. Mocking is a very general term meaning using any kind of a fake object in testing. In Sinon, we can use spy, stubs, and mocks, but it's very common in testing to just simply call that process mocking. So, I'm going to create a new DataLoader. And now this DataLoader object that I've got is a stub based on the actual DataLoader, so I can pass that into my create on my course, and I can do the same thing for student. And once that's done, my Registration. create method can now take in the course and the student. Now that I have my Registration object, I can call registration. registerStudentForCourse and pass in a 1 and a 1 for the student Id and course Id. And then in this case, I want to make sure that the course looks like it's full when the code actually executes, which means that when the Registration object here in its code asks the course what the max size is and how many students are in the students array, then it needs to return numbers that work out, that indicate that the course is full. So, that's where Sinon stubs can come in very handy. We are going to use a stub to tell the DataLoader what to return when somebody calls getCourseSync. So, I'll say DataLoader, which is a stub,. getCourseSync, and I tell it that I want it to return an object with a max size of 2 and a students array which has an object with an Id of 2 and another object with an Id of 3. And then we'll return also an Id of 1 in this object. So, now when the Course object calls getCourseSync right there on line 17 in our Course class, we're going to get an object that has a max size of 2 and already 2 students registered. Now, we're not quite ready to go because we have to tell the stub DataLoader to do a few more things in order for this code to work. We need to make sure that if anybody calls saveCourseSync that we return true and if anybody calls getStudentSync that we return some valid data for a student object, so we'll give it a name of Susan and an Id of 1, and that should be most of the code that we need to give to the stub for it to work. And now we finally can set an assertion that verifies that we didn't call save. So, we'll say sinon. assert, which is a function in the Sinon library, say notCalled and pass it the dataLoader. saveCourseSync, which is the function that is called if the course can register, and we see that in the call to course. _save, and when we look inside Course, and the _save ultimately calls dataLoader. saveCourseSync. So, let's save our code and go to the command line. Run our tests, and we have three passing tests. It definitely doesn't call save if the course is full. Now that we've got that, we can write another test that checks that we do call save if the course is not full. We just copy and paste code one of the few times, and that's a good idea. And we'll change the max course size to 3, and we'll change this assert. notCalled to called. And, of course, we'll also need to change the name of the test to does call save if the course is not full. And with that, we can save our file, run our tests, and we now have four passing tests. So, there's a good example of using Sinon mocking with somewhat complex logic in order to isolate code so that we can test just a unit. And what's interesting about what we've done here is in our case, the unit that we're testing is not just a single class. We aren't testing just the Registration object; we're also exercising the Course and Student objects. But because they're very, very simple classes, it's really okay to consider them to be part of the same unit with the Registration object.

Testing Promises
In this section, we're going to learn about testing promises in Node. In essence, promises are just asynchronous operations, so the techniques we've learned already by using the done function will work with promises just as good as the work with anything else. But there are a few things that Mocha can do with promises that make them even easier to use. First, we'll start off by installing a promise library. In this case, we're going to use the bluebird library because it's a very popular library for promises inside of Node. Now, I've already installed Mocha and Chai, of course, and let's take a quick look at the code that we're going to test. On line 11, we have a dataAccess object with one method, getStudent. This method is a simple representation of a dataAccess method. Right now it checks to see if the Id is 3. If so, it returns a resolve promise with that student as the resolved value. If not, it returns a rejected promise with a string Invalid Student Id as the rejection message. Let's start by writing a simple test using what we already can do with the done function. In this case, we'll call dataAccess. getStudent passing in the magic value 3, and then we call the then function receiving back the student object that is fulfilled in the promise. And inside of here, we will check that the student's Id is 3. And then we'll call done. Now, if we save this code and go run our tests, we can see that we've got one passing test. Now, of course, this works just fine, but there are a few things that Mocha can do to make this even easier on us. First, since we're using a promise, if all that we care is that the promise resolves, we can actually just return the promise from our test. And so long as the promise resolves, then the test will pass. Running our code again, we have two passing tests. If I pass in a value that will cause the promise to reject, and run the test again, we can see that we have now one failing test, and the message Invalid Student Id was thrown. Now the case where all you care is that the promise resolves is probably a little bit less common. So, most likely, you will want to write tests more like our first test, which actually checks that the value is what you expected. And, as we've seen, that works just fine, but there's another library which will make it even easier to write tests against our promises, and that is Chai As Promised. So, I'm going to go out to the command line, and I'm going to install chai-as-promised. And then in order to make that work in my code, I'm going to require it in, and then I also need to call chai. use(chaiAsPromised). Now that I've done that, I get a fluent syntax that's been attached to promises. So, we can write a new test. Now, I still need to return out the promise. But now I can call should. eventually, which is the special syntax for promises, equal(student), and that checks that the promise eventually resolves with the student value. Let's save our code and run it. And we now have three passing tests. We can see if I go in and change this to something that isn't the student, like just an empty object, run the tests again, they're going to fail. So, there're some neat features inside of Mocha and chai that help us when testing promises.

Test Coverage
In this section, we're going to talk about test coverage. When writing tests, it's really a good idea to be able to test as much as possible. Obviously, the more your code is tested, the more secure you are in knowing that you aren't breaking anything, and the more documentation you have about your existing code. So, more tests are better. But like any human process, it's possible to make mistakes and miss things. It's nice to know what code you have tested and what code you don't. Now, just because code is tested doesn't mean that it's tested well. It's still up to you to make sure that you write good unit tests. But a coverage tool can help you know what code you've tested and what code you haven't so that you can find the holes in your testing strategy and plug them up. So, in order to get started with test coverage, we have to go out to the command line and install a new component. We're going to install the tool called Istanbul, and we're going to want to install it globally. And at this point, we simply run Istanbul from the command line. The commander on Istanbul is, of course, Istanbul, and then we give it the cover parameter. And then since we're using Mocha, we're going to specify the Mocha library. In Windows, we're going to need to specify the path to the Mocha library inside of our Node modules directory. And then instead of pointing it at Mocha, we'll actually point it at _mocha. If you're not on Windows, you probably only need the _mocha. And then we give it two dashes, -R, space, and spec. This is the magic command to make Istanbul work. For more information about Istanbul, you can see the official documentation. But this is all you need to get started. So, I'm going to execute this command, and we can see that it has print out to the command line a bunch of information about my code coverage. Down here at the bottom, it's giving me my coverage summary saying that I've covered 70% of my code or 44 out of 62 lines, 50% of branches, 62% of functions, and, again, 71% of my lines. What's really nice about this is that it creates a coverage report. It's created this Coverage directory right here, and if I go inside here, there's this lcov-report directory. And inside of that, it's created an index. html file. I'm going to open this up in a browser. And here's what it looks like. So, I get the summary here, the same summary we saw on the command line. And if I click into this Coverage directory, then I get information about specific files. So, I can see that Course is covered 64% and Student is 92%. So, let's go in and see what is uncovered in the Student file. And I click here, and I can see it's highlighted in red my toString function indicating that this line is uncovered. So, let's go back to our code, and let's write a test to cover that line. Again, I'll create my student. Then I'll call toString and capture it in a variable. And then I'll run an assertion on that toString. Save, and I'll go back to the command line and run my coverage again. And we can see that our coverage percentage has gone up. And if I go back to my report and refresh the page, we can see that I'm now covering 100% of the Student. js file. If I go to the coverage information here, Student is now green indicating that it has 100% coverage, where Course is still at 64%. So, you can see the benefits of having a coverage tool in place, and you can also see how simple and easy it is to have Istanbul running. It's also really easy to integrate it with your continuous integration server if you're running one of those or incorporated into your Grunt or Gulp builds. But it is extremely valuable and helps you zero in on where you're lacking your test coverage. So, I highly recommend using a coverage tool like Istanbul to help you out with your testing strategy.

Summary
In this module, we talked about a lot of different things in relation to testing our code. We talked about how to test our business logic. We talked about how to test exceptions in our code, about how to use our tests to find and fix edge cases, how to test IO and asynchronous operations, how to use mocking to draw boundaries around a code that we test, how to test promises, and also how to use unit test coverage in order to tell what code we are and are not getting tested. All these pieces together give us the tools that we need in order to unit test our code.

Course Summary
In this course, we've seen not only what unit tests are but the tools for unit testing and the strategies to unit test the code that we write in Node. All of this is nice, but it's useless unless we understand that unit testing code is extremely valuable, and it's extremely important. The confidence it gives us, the reduction in coding time and maintenance time is an extremely important thing and definitely not something to be underestimated. So, if you're not unit testing your code, take these tools, these techniques, and start testing your code today. I can guarantee that you'll be better off. And if you are testing your code, hopefully the things that you've learned in this course will help you to improve your testing techniques and be even more efficient and effective at testing your code. Thank you very much for watching this course. And if you have the inclination, go ahead and connect with me over LinkedIn or say hi over Twitter. And if you have any questions, of course, post them into the discussion section of this course. Thank you very much.
