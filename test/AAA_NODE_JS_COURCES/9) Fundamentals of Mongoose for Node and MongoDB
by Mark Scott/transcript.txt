Using Mongoose, an open-source Node.js package, you can learn to incorporate schema, models, and validation into your applications. In this course, Fundamentals of Mongoose for Node and MongoDB, you will learn a solid foundation upon which you can continue to build and become proficient developing applications which use Mongoose to communicate with MongoDB. First, you will learn to build a Mongoose schema and a model from that schema. Next, you will discover the relationship between a Mongoose model and a document instance of that model and how to query for data using a variety of helper methods and query conditions. Finally, you will explore how to make sure that data sent to the database is valid using built-in and custom validators. When you're finished with this course, you will have the skills and knowledge of mongoose.js needed to start building your own Express API services to save data to and retrieve data from MongoDB through Mongoose.

Course Overview
Course Overview
Hello everyone, my name is Mark Scott, and welcome to my course, Fundamentals of Mongoose for Node and MongoDB. Mongoose continues to mature and add additional functionality and improvements with each version released. In fact, Mongoose is now in its fifth major version. In this course, we are going to lay a solid foundation upon which you can continue to build and become proficient developing applications which use Mongoose to communicate with MongoDB. Some of the major topics that we will cover include how to build a Mongoose schema and a model from that schema, the relationship between a Mongoose model and a document instance of that model, making sure that data sent to the database is valid using built-in and custom validators, and querying for data using a variety of helper methods and query conditions. By the end of the course, you will have a good understanding of Mongoose and will be ready to start building your own Express API services to save data to and retrieve data from MongoDB through Mongoose. I hope you'll join me on this journey to learn more about Mongoose. js with the Fundamentals of Mongoose for Node and MongoDB course at Pluralsight.

Course Introduction
Course Introduction
Hi my name is Mark Scott, and welcome to this Pluralsight course, Fundamentals of Mongoose for Node and MongoDB. The term NoSQL is commonly used to describe a group of nonrelational database systems. NoSQL databases have been growing in popularity over the past number of years, and of the various NoSQL offerings available to us, MongoDB seems to be the clear favorite. You may have considered using a NoSQL database such as MongoDB, Couchbase, Firebase, or one of the many other offerings for one of your development projects, but you may have also been uncomfortable or weary of a database with such a perceived lack of structure where a hard and fast schema is not required. If you're coming NoSQL from a relational database background, some of these concerns are understandable. Let's try and take a different look at some of these concerns now. Think of a database as an empty filing cabinet, whether that be a relational database system such as SQL Server or MySQL or a NoSQL database such as MongoDB. When filing data in a relational database, things are structured and rule based. Every record must match the table's schema design. This is not the case with MongoDB. Simply put, you can place whatever you want into that filing cabinet. That freedom is what causes some developers to be nervous about using a NoSQL database, such as MongoDB. They're used to having the database set the rules and their application maps to and adheres to those rules often through the use of an object relational mapper such as Entity Framework, PetaPoco, ORM Lite, and many others. The goal of this course is to give you the building blocks needed to develop great web applications using Mongoose to easily store data into and retrieve documents from MongoDB in a structured manner. You can still think of this as a filing cabinet full of documents, but one that has some rules and structure to it. I say some rules because with MongoDB, you still have the freedom to store whatever you want, even if you are using Mongoose. The Node. js demo application that we will be building throughout the remainder of this course will effectively illustrate setting up a Mongoose schema, building a model from that schema, and validating data.

Prerequisites
Let's get started by going over some course prerequisites. While not completely required to gain benefit from this course, a general knowledge and understanding of Node. js and MongoDB would be helpful. Pluralsight offers excellent introductory courses on both MongoDB and Node. js. Links to those courses have been provided here. JavaScript, Node. js, and MongoDB all go hand in hand, so some experience with JavaScript is also needed to get the most from this course. Beyond that, the only other requirement is a willingness to explore and learn something new. So let's get started learning about Mongoose.

Why Mongoose?
If you have looked into using MongoDB on a development project or even if you've only seen a demo of it, there is a good chance that you've either used or have watched some else use a native MongoDB driver or that you're at least aware of it. There are official MongoDB drivers for many development languages such as C++, C#, Java, Perl, PHP, Python, Ruby, and of course, Node. js, which is what we will be focusing on in this course. So why then would we not just use the native Node. js MongoDB driver? Depending on the specific needs of your development project, there may be times when you do want to use the native Node. js driver. To find out more, visit this URL. A look at the mongoosejs. com website's home page may give us some insights into some valid reasons to use Mongoose over the native Node. js MongoDB driver. Quote, "Mongoose provides a straightforward, schema-based solution to model your application data. It includes built-in typecasting, validations, query building, business logic hooks, and more out of the box. " When making the choice to use Mongoose, you are ultimately utilizing the native Node. js driver for MongoDB as well. Mongoose is built on top of and relies on this driver to talk to the underlying MongoDB document database. Mongoose is an abstraction layer on top of the native driver's functionality, and as you know, abstraction layers, generally speaking, are there to make your programming life easier. Is that always true? Probably not. There is not a single best answer of why you should use or not use Mongoose in your application. But as you move forward through this course, the goal is that you will gain enough knowledge to know when to use Mongoose and when it may be best to use a native MongoDB driver. Since this course is on Mongoose, naturally, we have already made the decision to use the Mongoose object-document mapper for our demo application. Speaking of the demo application, let's take a look at that next.

Demo Application Introduction
As we move through the course, we will be building a small demo application that will be used to demonstrate and reinforce each topic. In the next clip, we will take a peek at the complete and ready-to-go demo application. For now, let's talk about what its purpose is. We will be building a Node. js application to store virtual standup notes. This will be similar to what you may be familiar within scrum or agile daily standup meetings where everyone gathers around and recites what they worked on yesterday, what they plan on working on today, and if they've experienced any blockages or impediments. Our demo application will log the same information, but will allow for teams to hold virtual standup meetings. Team members will be able to enter daily meeting notes at their convenience rather than meeting face to face in a conference room. The architectural approach that we will take for this demo project at a high level is to separate the user interface components from our backend services, such as our RESTful API, which will be responsible solely from getting data from and sending data to the database, and of course, to our front-end components. This will provide us with a good degree of separation of concerns. For the UI side of things for this demo app, we will be using Vue. js. And if you're not familiar with Vue. js, don't be concerned. The bulk of our development work through this course will be focused on the API side of things, and that is where we'll be using Mongoose. After completing this course, should you want to learn more about Vue. js, take a look at these courses offered on Pluralsight or just search for all Vue. js related courses at this URL.

Demo: Preview of the Demo Application
Now let's take a look at what our virtual standup notes demo application will look like at the conclusion of this course. Here we are in our demo application that we've named virtual standup notes. The MongoDB server is running locally in the background, and some sample data has already been added. We'll also need to start our Express API server by running yarn start at the Command Prompt. We'll be using yarn throughout this course, but feel free to use npm as well. Next, we will run the Vue. js web application by entering yarn serve here on a new Command Prompt tab. That kicks off the webpack build process and spins up a local web server for us. This application is meant to be very minimalistic so that we can focus as much as possible on Mongoose. Nevertheless, we still want to build upon a sound architectural foundation and also have an application that looks good and is usable. And as mentioned earlier, we will be using Vue. js and Vuetify, a Material Design library, to accomplish this on the UI side of things. On the home page here, you can see that we will be showing a list of meeting notes, the newest 12 only. When we dig into the code, you will learn how easy it is in Mongoose to build such queries. Also, on the home page here, we can see that we'll be adding in the ability to filter down the list by selecting a member's name. Say I want to only see my own standup meeting notes. I can select Mark from the list and filter down the results. Again, we'll see in code how easy Mongoose makes this possible for us. On the new note page, we can see the data entry from we will be using to save new notes to MongoDB through a Mongoose model that we will develop. What you may see missing from this form is a Date field. On the home page, we said that we will be displaying a list of the most 12 recently entered in notes. So where's that date value coming from? In the Mongoose schema that we will develop in this course, you will learn how to set up default values. In this case, we have defaulted the date of the note to the current date, so there's no need in this case to ask the user for it. Again, to keep things simple and keep the focus of this course on Mongoose, you'll notice that we do not have any authentication in place. The user is not required to log in. Members of a team will just simply select their name from a drop-down list; select a project that they are a member of or that they're currently working on; and enter what they did yesterday, what they're planning on working on today, and if they have any impediments; and then click Save.

Setting up the Demo Application
Introduction
Hi, my name is Mark Scott, and in this module, we will discuss and demonstrate what is needed to set up the demo application that we looked at in the previous module. Having the right software development tools can make a world of difference, so we will spend a little time in this module going over a few of the tools that you too may find helpful when developing the demo application. In the next clip, we will start looking at the frameworks and libraries we'll need for the API server project, as well as for the client or user interface project. At the foundation of both of these projects is Node. js. Next, the API server will be built using Express. js. This is also where we will be using Mongoose to communicate with our underlying MongoDB server. For the UI side of things, we'll be using Vue. js and Vuetify in material design framework for vue. js.

Frameworks and Libraries - Server
In this clip, we will start looking at the key frameworks and libraries that we will need to build our demo application. We'll start by looking at those needed for our API server project and then those for the client or user interface project. Our RESTful API server will be built using Express, so that will be a core framework that we need to get installed. To get Express installed for our demo project, simply follow these instructions from within the server project folder. We'll take a look at that in a moment during the demo portion of this module. We will also use ESLint to keep us honest and our JavaScript code cleaner and more compliant. We'll use the body-parser package to, as the name suggests, parse the incoming request body when doing actions such as POST. It will probably make more sense when we start building out a RESTful API server project, but we're also going to have cross-origin resource sharing issues because our client and server will be running on different localhost ports. To address these issues, we will install and use the cors package as shown here. To help us with development and debugging of our API server request, let's use morgan as our request logger. We're going to want a watcher to automatically restart our API server when we make changes in our code editor. A popular package to consider and use is nodemon. There are other options out there to consider, but for this project, we'll just use nodemon. And last, but certainly not least, is the start of the show, Mongoose. We'll not get far in this course on Mongoose if we don't get this installed. As mentioned earlier, we will be using Express. js on the server-side project as the framework on top of Node. js that we will build our RESTful API upon. A nice piece of middleware that Express provides for us is Router. We will be taking advantage of this when we build out the GET, POST, and other routes to our API. Speaking of routes, we will separate out each route by feature. And for our project, those features will be projects, which is where we'll be getting a list of active projects to select from; standup, which will provide us with a list of standup meeting notes, either sorted by the newest or by some other query criteria; team, which is the list of team members we will select from when entering in a new standup meeting note.

Frameworks and Libraries - Client
Now let's discuss the various client project packages that we'll be using. As mentioned in the previous module, the UI side of this course is not the primary focus. But that being said, for our demo, we'll still want a decent looking UI, and for this, we'll be using Vue. js, and in particular, the new Vue command-line interface tool, vue-cli, which we will install and use later on in this module to get the foundation of our client-side project laid out. Without going into depth on state management in Vue. js, we'll want to use a central state store to keep track of our application data. We'll be using Vuex for this. Our demo project will be following material design specs. The implementation of material designed for Vue. js that we will be using in this project is called Vuetify, and here are the instructions for installing that. It would also be a great idea to visit the official Vuetify website found at this URL. As you've already seen in the previous module when we previewed the completed demo application, Vuetify provides us with a large library of really good looking components that follow the material design specifications. Continuing on with the client project packages that we need to install, next on the list is Axios, which is a promise-based HTTP client that we will use to communicate with the Express RESTful API server. When from our client we need to retrieve some data from our MongoDB database through Mongoose, this is the vehicle we'll be traveling across that wire with. Once again, we won't be focusing too much on the UI side of things in this course, but we still want it to look good. One package that will help us out with the material design framework we've selected, Vuetify, is the material-designs-icons font package. An important package that we'll get installed when we install and use the vue-cli is webpack. You should not have to install this manually, but should you find yourself needing to, here are those instructions as well. As we go through the course and develop our demo application, you may notice other packages and libraries that we will use or discuss. But for now, these are the core packages that we will get our development efforts started with.

Helpful Tools
In this section, we will take a look at some of the helpful development tools we'll use through the development of our demo application. There are many really good lightweight text editors available to us now. Not too many years ago, the choices were somewhat limited. Now there are a number of really solid code editors, and a lot of them are free to use. For example, the editor that we'll be using in this course, Visual Studio Code, is free to all and available on Windows, Mac, and Linux. Visual Studio Code can be found at the link provided here should you care to download it and check it out. If you follow along in this course and use a different code editor, you'll be just fine. We will not be spending much time at all discussing webpack, but it is a key part of our client project. We will use the webpack template when setting up our demo application using the Vue command-line tool. It's good to know about webpack and what it does for you, but it's not necessary to have a deep understanding of it to get through this course effectively. Should you desire to dive into webpack a little deeper, look for the Webpack Fundamentals course here on Pluralsight. As we're developing our API, which will be the primary focus of the course, we will be using a fantastic tool to test that out with known as Postman. If you do not have Postman installed on your computer yet, pause the video and go to the link provided here. You'll want to get this installed and set up right away. When it comes time to design our MongoDB database, we certainly could do all that work through the command line, but we're not going to do that. If you're a lazy developer like I am, you'll want to look for a tool such as Studio 3T to help you out with the management of your MongoDB collections. In other courses, I've mention and used Robomongo, and you still may find that a useful tool, but be sure to get the newest version, which has been renamed Robo 3T. The rights to Robomongo were purchased by 3T Software, the same people that bring us the full Studio 3T product, which is what we will be using in this course.

Demo: Develop the Express API
Now that we've discussed some of the various frameworks and libraries we'll need both on the server and the client side of things, as well as some of the useful tools that will be used throughout the remainder of this course as we develop the demo application together, it's time to start developing our server-side Express API. Let's dive right in and get this going. Here in the demo project folder, we will separate the server and client projects by setting up a different folder for each. I've already created a client folder, as well as a server folder. Since we're going to first work on the Express API, we'll want to go to the server folder, so cd server. The first step that we'll take is to run npm init to generate a package. json file. You can accept the defaults on most of these questions or change them as you see fit. Now we can start adding in the various libraries and packages we need. Let's start with Express. Yarn add express. As mentioned earlier, we'll need to parse the inbound request, and we'll use the body-parser package to accomplish this, so yarn add body-parser. Our client and server projects will be running on different ports; and therefore, we will run into cross-origin resource sharing issues. To take care of that problem, let's bring in the cors library, yarn add cors. And of course, we need Mongoose. js, so yarn add mongoose. It's not required, you may want to consider linting your code as you develop. And for this course, we'll use ESLint, yarn add eslint. That gets ESLint installed for us, but it now needs to be initialized and configured. We do that by running the ESLint JavaScript file. We do that by entering node. /node_modules/eslint/bin/eslint. js --init. You'll be asked a number of questions about how you want ESLint set up. You may have different needs, so feel free to set up ESLint to your liking. It was also mentioned that it would be nice to log requests to our API server. And to do this, we'll use morgan, yarn add morgan. Last, but maybe not least, we want to use nodemon to listen for changes and restart our sever, so yarn add nodemon. Alright, that should take care of the core libraries and packages we need to get this server of project underway. To open up Visual Studio Code, simply type in code. and press Enter. Now that we're in Visual Studio Code, let's start by adding the file that will be used to orchestrate and kick everything off, the app. js file. To save some time, I'll paste in partially completed code for this app. js file from the finished project we saw in the introduction module, and we'll discuss it. At the top here, we're bringing in some of the core packages we installed earlier, express, morgan, bodyParser, and cors. This line is where we create a new instance of the Express application and assign that to the app constant variable. The next line is where the API routes are brought in, and we'll need to create that folder and set those routes up here shortly. Here is where we were telling our Express app which port to use, and if the port environment variable is not set, we're defaulting to port 8081. Next, we'll tell the Express app to use bodyParser and cors. We'll revisit this API line in a moment. On this line, we've set up morgan, the HTTP request logger middleware we've selected, to use the predefined format of dev. For more information on morgan and what options are available, see this URL. If users of this API service land on an unknown route, it's nice to let them know and to return our useable error such as this, 404 Not Found. We're not quite ready to connect to MongoDB, and that's coming up soon. So for right now, we'll just have the Express app listen on the port configured above and report that out to the console. Before we run and test this out, let's first set up some more folders and configure the package. json file a little more. The API routes will live in the api folder, so let's create that next. New Folder and name that api. Under this folder, let's set up a routes folder. Back out on the api folder, we'll create a new file and name that index. js. This file is what will be brought into the app. js file we looked at a moment ago and is used to organize all of the various routes that we'll be setting up. We'll need to bring in Express here, so const express = require express, and we'll also need the express router, const router = express. Router. For this demo project, we'll need three routes, one for the standup notes, another for the various projects the team members will be reporting work for, and the last one is a listing of those team members. Each of those routes will be set up in the routes folder. Let's stub those in now and come back to this index file in a moment. In the routes folder, create three new files, projects. js, standup. js, and team. js. In each of these new files, the module export will look like this, module. exports = function, where we're passing in the express. Router from the API index file we just looked at. With each of these route files, we will eventually be setting up the various GET, POST, and other endpoints needed for the application, and we will be pulling in and using Mongoose models, which we will develop in future modules in this course. For now, we'll just stub in a get route for each of these route files and revisit each in a later module where we will add in other routes as needed. Let's move back to the API index file now and finish that up. We need to now require each of the routes we just stubbed into the routes folder, and this is what that looks like. Notice that we're passing into each file's function the Express router as an argument. This allows us to pass the Express router into each route, adding in the needed GET, POST, and other routes, export that, and continue on down the road until we've completely set up all the necessary routes for the API service. Lastly, for this index file, we need to export the completed Express router. One last thing we need to do before we can test this, even though it will not do much of anything for us just yet, is to finish setting up the scripts section of the package. json file. Let's add in a start script and run our linter, and then using nodemon, run the app. js file. The run lint script isn't set up yet, so that's next. Lint and. /node_modules/. bin/eslint, and we'll ask that ESLint look in any folder for js files. Now returning to the Command Prompt, we can test run this and see what we get. Yarn start. You may notice a number of linting errors or warnings. At this early stage of development where we have things stubbed in, it may make more sense to turn linting off for the time being. That's completely up to you. Should you care to, all you need to do is remove this section of the start script in the package. json file. And returning to the Command Prompt, yarn start again, and we're good. Ignorance is bliss, well, for the time being anyway.

Demo: Vue.js and Vuetify
In this demo, we'll get our client user interface project started using the Vue command-line interface tool. We'll also add in Vuetify, the material design framework for Vue. js, and the other libraries previously mentioned, such as Vuex and Axios. One thing to keep in mind is that because the user interface and API server projects have been separated, there is no reason you couldn't use another UI framework such as React, or Angular, or whatever you like here. We will not be spending a lot of time with the UI side of things in this course anyway since that is not the focus. Let's open up a terminal window and get things started with the client project now. To install the vue-cli, simply enter in yarn global add @vue/cli. I already have this installed, so I'll cancel this. Feel free to use npm here as well, and that would look like this. To create a new Vue. js project using the vue-cli, simply enter in vue create and then the name of the project. Ours will be named client. Next, you will be presented with a few questions to answer. Rather than a preset selection, we'll manually select our features. Leave Babel selected, we will need the Vue Router and Vuex, and leave the Linter selected. For the Linter, select ESLint with error prevention only unless you prefer one of the other configurations. We'll just Lint on save and keep these configuration settings in dedicated config files. Once you get through those questions, the vue-cli is off and running, creating and stubbing in your new Vue. js web project. As it states here, this might take a while, so I will pause here for a moment and come back once this is done. The client project was successfully created. And as it shows here, we can test run this now by moving over to the client folder and running that using yarn serve. The first time you run this, you'll notice that it takes a moment or two as webpack is building and bundling up the various modules installed with the vue-cli create process. Now that that is done, we can open up a browser and open localhost port 8080. Not much to look at yet, but hey, it works, and now we have a foundation to build our client demo application upon. Let's head back over to the terminal window, and also using the vue-cli, get Vuetify installed, vue add vuetify. Once completed, you'll notice a number of files that were generated for you. But to help us out even further, we're going to be using a predefined layout as a template to build our demo application upon. To see where that is obtained from, let's go back to the browser, open up a new tab, and go to this URL. Vuetify has a handful of layouts that you can use to jumpstart your own projects with. The one-off selector for this application is the baseline layout, which among other things, provides us with a left navigation menu that expands and collapses as needed. The source code for this layout can be found here. Clicking on this link pulls up the associated GitHub repository. For this client project, all of this code was copied over and modified for this project's specific needs. We will not be doing that development work together in this course since, again, the focus is on Mongoose, but that code has been made available to you at this repo. Moving back to the terminal. As mentioned earlier, since we're using Vuetify, which is a material design framework, it would be helpful to have the material design icons available to us as well. That package can be added by entering yarn add material-design-icons-iconfont. We won't need this for a while, but we will need Axios later when communicating with the API, so let's get that added now too. That should leave us with a pretty good foundation to build the client project upon.

Setting up MongoDB
Introduction
Hello, and welcome to this module on setting up MongoDB. This module introduces you to some of the various MongoDB hosting options that are available, both cloud based and local hosting, and what will be used throughout this course. MongoDB itself will not be deeply discussed as this is covered in other Pluralsight courses. Just search for MongoDB in the Pluralsight library, and you will find a number of good courses. One example is the Pluralsight course Introduction to MongoDB, and that course can be found at the URL listed here. Lastly, we will up our local MongoDB database and collections, as well as import some seed or sample data that will be useful as we develop our demo application together. Let's get started on that now.

MongoDB Hosting Options
MongoDB is supported on a wide variety of platforms and operating systems including Linux, macOS X, and Windows, so you'll find a wide variety of hosting options to choose from. MongoDB was developed to run just fine on most commercially available computer systems and scales extremely well on these systems. So again, your options are pretty open. One thing to make note of is that beginning with version 3. 4, MongoDB no longer supports 32-bit x86 platforms. So you'll want to make sure that you're running a 64-bit system. Whether you choose to eventually host your database in the cloud or not, it's still a good idea to download and install MongoDB on your local development box. Simply go to mongodb. com and click on the green Get MongoDB button and select the platform and operating system that's right for you. Installation is straightforward, quick, and pretty easy. Another option to consider is to set up a virtual machine using a service such as Microsoft Azure. The process of downloading MongoDB and installing it will be the same as if you were doing it on a local desktop or laptop, but you do not have to purchase the physical hardware, and you don't have to set up the operating system. That's already done for you. Cloud-based virtual servers can be a very cost-effective option, but in most cases, you will still be responsible for maintenance and upkeep of the VM, such as keeping it patched and up to date. You will also be responsible for setting up the configuration and security for your MongoDB servers. Personally, I believe a better option is to use a database as a service or a cloud-based hosting offering, such as mLab. A couple of other really good choices to consider are MongoDB Atlas and Compose. There are certainly other cloud-based hosting offerings to consider, so do your research and pick the one that best suits you and your business needs and budget. Some services offer a free Sandbox account. The one we've selected for this project and demo application is mLab. They offer a Sandbox account with half a gig of data allowed on each, and that should be more than enough space to get our project developed, tested, and ready for production. That being said, by the time you watch this course, mLab may no longer be a valid option for you. During the development and recording of this course, mLab was purchased by MongoDB, and all accounts will eventually be migrated over to Atlas.

The Virtual Standups Database
For our demo application, we'll start with a local instance of MongoDB, and then towards the end of the course, migrate that to a hosted service in the cloud. For this course, we'll end up migrating our local MongoDB database to a cloud-based Sandbox account on mLab, but you should absolutely explore the other hosting options mentioned earlier, especially Atlas; however, if you're following along, feel free to use whichever cloud hosting service you feel the most comfortable with. It's time to build the virtual standup database locally to start with now. And as mentioned in the previous clip, if you do not yet have MongoDB installed locally for your particular operating system, this might be a good time to pause the video and go to the MongoDB website at the URL shown here and download and install the version appropriate to you. MongoDB has already been installed locally on this computer. So we're opening up a Command Prompt here, and I will be using Windows 10. We need to make sure that our local instance of MongoDB is up and running. We'll do that by entering mongod here. Now that we can see that MongoDB is up and running, let's take a look at our local MongoDB instance using Studio 3T. Once that is open, we'll want to get connected to our locally running database. In Studio 3T, you should notice a green Connect button. Click on that. There's also a Connect button on the top menu bar, and optionally, you can go to the File menu and select Connect there too. We should have our local MongoDB database running, and the name is local. Select that and press Connect. Now that we're connected, let's add a new database that we'll name virtualstandups. With this new database, we'll need at least three collections, standups, which will be used to store our virtual standup meeting notes; projects, which will be used to obtain a list of projects for the drop-down list we talked about in the course introduction module; and likewise, teammembers, which will be the list of active team members for whom the note entry is for. To add a new collection, we can simply right-click on the collections folder and select Add Collection, and this first one we'll name standups. Make note of the options here, but for our purposes, we can leave these as they are. Next, let's add collections for projects and team members. So that we have some sample data to work with during development, let's import some seed data into these three collections now. For example, to import team members, we select that collection, and one option is to click the Import button on the top menu bar. The file we want to import is in JSON format, so the default selection here is fine, next, click the green plus in the upper left here to add source files, and we'll start with the aforementioned teammembers. json file. The JSON files I wish to import are located here, but if you download the demo files, yours may be in a different location. Pressing Next, we get a preview of the import, Next again, a quick import summary, and then Start Import to bring that data into our selected collection. Repeat that process again for project and standups. I'll do that quickly here as well. Now that we have some sample data imported to work with, let's open up the standup collection of documents and examine a sample document and its structure. This document is pretty straightforward and simple, but it stores exactly what we need in our virtual standup meeting notes. You may notice that the order of the fields show here are not exactly the same order as what we saw in the completed demo. This doesn't really affect the document in any way. This is simply a sample document to illustrate what we will be building a Mongoose schema against. That's not to suggest that we are taking a database-first approach here. This is merely a peek at a document that we will end up creating through Mongoose in our demo application. With MongoDB and Mongoose, there is nothing restricting us from changing our minds and adding a document to this collection with a completely different structure in the future. So long as the application, which is our Express API server in this particular case, knows how to handle those changes, MongoDB, or our filing cabinet if you will, doesn't care what we put in there. We as the developer just need to know how to get our application data back out and work with it in whatever form we find it in. Before we leave this clip, notice that Studio 3T includes a Query Builder where you can manually build and test queries out or use the Virtual Query Builder as shown here. Also, make note of the Query Code tab near the Results tab. Here you'll find examples of exactly what is going on in the Mongo shell or select examples for other languages, such as JavaScript, Node. js as well. Another helpful feature of Studio 3T is that we can edit documents directly in a graphically friendly way. Let's take a look at how to do that right now. Say for example, if we wanted to change a document in the projects collection say from being active to inactive so that it no longer displays in the drop-down list. You would simply edit that here, setting the value to false and then perhaps validate it to make sure that the JSON format remains valid, and then save the document. It's that simple. One last tool that we will take a real quick look at is the predecessor to Robomongo, now called Robo 3t. Opening that up and getting connected, you can see that it's similar to, but not as full featured as Studio 3T. It's something to consider using if you have used Robomongo in the past or need a free and lightweight tool to work with your MongoDB database and do not care to solely rely on the command-line interface. Well, that's a quick look at our local MongoDB database and sample documents that we'll use as we continue to build our demo application together, as well as how we can use Studio 3T, or Robo 3T, to gain access to that data in a graphically friendly and useful way.

Next Steps
In the last clip of this module, let's consider some next steps to take. As mentioned earlier in this module, if you do not yet have MongoDB installed locally on your computer and if you want to follow along, this might be a good time to consider getting that installed. Once again, here is a look at the mongodb. com website where you can go and download the version appropriate for your operating system and platform. Towards the end of the course and as noted before, we'll be migrating our local MongoDB database to the cloud. If you want to follow along with that process, this might be a good time to go ahead and get a Sandbox account set up. And as a quick reminder, here were a few good choices to consider and the websites to go to to find more information on each. It's certainly not required, but we'll be using mLab for this course. But as mentioned earlier, mLab will within the next several months be migrating accounts to MongoDB Atlas, so please do keep that in mind.

Building the Mongoose Schema
Everything Starts with a Schema
Welcome back. In this module, we will start learning how to build a Mongoose schema. You'll also see that with Mongoose, everything start with a schema. We will discuss and look at an example of a simple Mongoose schema, as well as a more complex schema and discover what data types or schema types are allowed for use in Mongoose. And we'll start the next clip by comparing a traditional related database schema design against what that might look like as a Mongoose schema. Let's take a look at that next.

Comparison - Relational Database Schema
In this clip, let's do a quick comparison between a relational database schema and what that might look as a Mongoose schema. In order to think about the different approaches we can take between laying out a schema for say SQL Server, Postgres, or MySQL, let's think about something I'm sure we're all familiar with, a quiz. On the surface, you would think that a quiz would be pretty simple, right? Just a few questions and some answers. But as you can see from the example schema of what it might look like within SQL Server, it can get more complicated than you might expect. We have a table for the Quiz parent record, but a quiz can be part of any number of categories. Say for example, a quiz can be in a category named programming and another named JavaScript, so we will have our QuizCategories in one table and a joint table to allow for our many-to-many relationship. The quiz can have one to many questions, so once again, we separate those off into their own table. Think about it. A quiz can be multiple choice, true/false, perhaps other types too, so we have our QuizQuestionsType table to house the various question types we may need. Depending on the question type, we may have many quiz question options available, one or maybe more than one of those questions may be the correct answer. And we could probably normalize this even more, make it even more complex if we wanted, but we already have six tables here for our quiz system, so I think you get the point. Now let's take a look at how we may choose to do the exact same thing in MongoDB and how we may structure our Mongoose schema. We're going to store this same information, but all within a single document rather than six different tables. Okay granted, architecturally, you may still find it better to separate out the categories into their own collection of documents, but maybe not. It's completely up to you and how you design the application. You can now have an application-first view of things versus molding your application and data access layers to fit your data structure. Next, we will have an array of questions, each with their own question type and text and an array of possible answers to choose from. Nice and tidy if you ask me. When you need to pull up a quiz document, everything else, categories, questions, answers, it all comes along in one nice package, well, one nice document, that is, as we'll see in the next module on building models from our Mongoose schema.

Simple Schema Example
Now let's take a look at a simple Mongoose schema example. Let's say we want to build a schema for a customer document. We start off by requiring Mongoose so that we can gain access to the schema object, and next, we'll set up our example customer schema and all of the fields we need. This customer schema is really flat, and we're only allowing for a single address for this customer. We'll probably want to fix that. But as you can see, the format here is to simply pass in an object into the Schema constructor with the form of fieldName and SchemaType. With that said, let's take a look at the allowed schema types, or data types, if you will, within Mongoose. On the left is a list of allowed Mongoose schema types. You can see that these nearly directly relate to JavaScript data types. The one Mongoose schema type that may get your curiosity up a little is mixed. Earlier in this course, when I said with MongoDB, you still have the freedom to store whatever you want even if you are using Mongoose. This is the one place that that comes into play. We will not be using the mixed schema type in our demo application's schema design, but when you do need the flexibility to store a variety of data types within the same field, you can use the mixed schema type for that. Pretty much whatever you want goes in there. It's just up to you, the developer, to write code to deal with this.

Complex Schema Example
Let's make the example customer schema we looked at earlier a little more complex now. As before, we'll start off by requiring Mongoose to gain access to the Schema object. Now we're going to build out a parent customer schema with the name field split out into first and last names. Notice also that we're allowing for an array of addresses, but what is this addressSchema? One approach I think you will find useful is to separate out nested schema objects like this. We certainly could have defined the addressSchema details right here inside the address array, but this seems cleaner and more readable to me. One more thing to take note of here on this example is how we've now used an object as the schema type for both the createdOn and isActive fields. The object specifies the schema type, but also allows us to specify a default value. Now documents that are created from this schema will have the current date set and the isActive field will initially be set to true. Before we open up Visual Studio Code and start building out the schema for our standup meeting notes, let's revisit the quiz example we talked about a little earlier. You may have noticed the naming convention used in the example where we called the field questionType rather than just naming the field type. If you were to build out a Mongoose schema for a quiz document, it would probably look something like this. Again, notice the subdocuments are separated out into their own Schema objects. We're going to use this schema as an example of when things can unexpectedly go wrong for you based on how you may have named a field. You may have looked at this example earlier and said to yourself well, I would just have named it type rather than questionType, and that makes sense to me too. In a Mongoose schema, the use of type has a special meaning. As we saw earlier in this more complex customerSchema example, when we supplied a default value to the createdOn property, we specified an object as the schema type. But as we can see here, part of that object needs to be the data type the property will be cast to. In this example, it was cast to a Date data type with a default value of Date. now. Let's take a look at the previous quiz example, only this time, with the subQuestions schema property named type, which sounds better and makes sense. But what Mongoose is going to do is look at that property and say oh, I'm supposed to cast this question array as type String, and that's exactly what Mongoose will do. As you can see from this example document, that would be saved to MongoDB. If we attempted to use this schema, the desired results are not there. We're missing our question array and the answers array within each question object too. Not good. But you need, or want, the property to be called type, so how do we accomplish this? Here we are again with the same schema, and we've retained the property name of type in the subQuestions schema object, but here is the key difference. We're passing in an object just like we saw before with the customerSchema example. Now our document is saved to MongoDB as we would expect. You can see the questions array, the type, and text properties, as well as the answers array now, and that's much better. It's a problem that's easy to cause, but now you know how to easily correct it too. If you need a property to be named type, just be sure to pass in an object for the schema type, as shown here, and things will work out as expected.

Demo: Building the Stand-up Notes Schema
Now that we've looked at simple and more complex schemas in this module, it's time to start developing the schema files we will need for our demo application. We're going to want to create three new files, standup. js, which will be the schema file that models what data we want to store in our meeting notes; teamMember. js for when we're selecting who is entering the note from a drop-down list; and project. js, which we will use to retrieve a list of actor projects. We will create these schema files within a model folder. The reason for this is because as shown earlier in this module, the models we will need will be built from these schema files, so it just feels right to put these in a folder named model. Before we open up Visual Studio Code, let's do a quick review of the finished demo application. Just in way of review, here is the dialog used to create a new standup note. Let's analyze what data we need to capture, and as such, set up in our Mongoose schema files. We will need to create a field for the team member's name; another for the project they've done work on; and fields for the work completed yesterday, work they plan on doing today, and lastly, a field to capture any impediments that they've experienced. Earlier, it was said that we will only be showing the 12 newest notes, so you would think that we should have some type of Date field here. If you recall, we can set a default value on a Schema field, and that's exactly what we will do for the createdOn date value. So there's no need to ask the user for this data. There are two other schema files that we need to create, one is for team members, which supplied data for this drop-down list. The last schema file is for the list of active projects. Notice I keep saying active. So besides just having the name of a project, we'll also want to have a field that indicates whether the project is active or not. The rest of these fields belong to the previously mentioned standup schema. It's time to open up Visual Studio Code now and get these files created. To start with, under the server folder, let's create a new folder and name that models. Next, add a new file and name that standup. js. We need to bring in Mongoose to each of these schema files so const mongoose = require mongoose. Now let's create a new Mongoose schema and name this standupSchema. From what we just reviewed in the demo application, we will want these fields, teamMember; and we'll want to use an object for the type, setting the type to String; project; and since this is also of type String, I'll just copy this object; workYesterday; workToday; and createdOn with a type of Date; and here, we'll supply a default value of Date. now. You may notice that we are not defining an id field here, but you probably also noticed we had an _id field in the MongoDB document that we looked at earlier in the course using Studio 3T. So where is that _id field coming from if we're not defining it here? If you do not define and id field, Mongoose will create one for you automatically by default with the schema type of ObjectId. While a document's id field can be anything unique, including another object, generally, you'll want to let MongoDB create the id field for you as an object id. If, for some reason, you find that you do not want or need an id field, you can disable that by passing in a second argument to the schema constructor with the field name of _id set to false. I'll demonstrate this by setting up a schema we'll call noIdSchema. Let's give this schema one field name with the type set to String and the _id property set to false. This is what prevents Mongoose from having MongoDB create a default _id field. What you see above for the standupSchema is a fairly common way of defining a schema in Mongoose, but it's not the only way. The Mongoose schema object also provides you with an add method where you can keep adding key-value pairs to the schema as needed. To demonstrate this, I'll create an empty example schema object and then use this new schema's add method to add just the teamMember field type String. If so desired, you can add each field separately this way. So why might you want to do that? Let's explore a contrived example of adding in a field based upon some business rule. I'll comment this out first, and I'll set up a variable named useFullName, and just to demonstrate this, set it to true. This normally would be a real business rule here. If useFullName is true, then we will add a field to the exampleSchema like this where the teamMember object has first and last name properties split out; otherwise, we could just add in the teamMember field as we did above before. Can you think of some use cases where adding in fields into the schema conditionally could be helpful like this? Just keep in mind that the documents stored in MongoDB will vary in shape and that it's up to you, the developer, to build code to accommodate those differences. This code was just for example purposes and not something we'll actually want in the standupSchema, so I'll delete this now. Before we move on to the next schema file, do you notice anything missing in this one? Yeah, oops. We need a field for impediments here. Okay, sorry about that. Now in the models folder, add a new file and name it project. js. As before with the standupSchema, we need to require mongoose and set up a new schema we'll name projectSchema with a name field of type String, a description field also of type String, isActive of type Boolean used to determine if a project is active or not, and we can set a default value here of true. That's all we should need for this schema. So saving that and moving back over to the models folder, New File again, and name this one teamMember. js, require mongoose as before, name the new Mongoose schema teamMemberSchema, and besides the _id that comes along for the ride automatically for us, we should only need this name field here of type String. In the next module, we'll come back and further develop these schema files and export models from them, but for now, we should be in pretty good shape.

Building a Model
Introduction
Welcome to this module on building a Mongoose model. In this module, we will take what was learned about laying out a Mongoose schema in the previous module and build our first model based on that schema. We will then discuss Mongoose documents and subdocuments and the relationship between these documents and MongoDB documents within a collection. In the demo, we will build out our standup meeting notes model, construct a document from that model, and save it to MongoDB.

Our First Model
To illustrate building out our first model, let's start with one of the simple schema examples we looked at earlier, the customer schema. To build a Mongoose model from the schema, which is named customerSchema in this example, we simply need to pass into the Mongoose model method the name of the model and the schema we wish to build this model from. A third optional argument not shown here would specify the MongoDB collection name that you want your document instance of this model to be saved in. Since I have not supplied that here, Mongoose will provide a collection name from the model name given. Mongoose will attempt to pluralize the model name, so we may end up with Customers with an s rather than Customer for our collection name. If that's not the desired result or if the collection name already exists and perhaps you need to match that name, simply supply that third collection name argument, and you should be good to go. Keep in mind that you can build out any number of models against the schema definition, and as shown here, we can append on additional key-value pairs to our schema to customize it even further. Here we've taken our base schema and added on a discount code and then built a DiscountedCust model from that appended schema definition. Now let's take a look at where we left things off with our standup notes schema and what it would take to export a model from our standup.js model file. As with the previous example, we're simply going to pass into the mongoose.model method two arguments, the first being what we want to name our model, Standup in this case, and the second, the previously defined schema, standupSchema. The difference here is that we are not assigning this model to a variable, but rather exporting it, or if you will, exposing it, or making it available to other files that may require or include this module. We'll see that in action here shortly in the demo.

Documents
As mentioned in the introduction, we're now going to discuss Mongoose documents, and how they are constructed, and the relationship to MongoDB documents. A Mongoose document is a direct representation of the document saved in a MongoDB collection. That's a good thing for us, actually, because it eliminates the need for some type of object-relational mapping between mismatched systems. Mongoose is really more of an object-document modeling tool than a mapper. We've already learned that everything in Mongoose starts with a schema and that a model is built, or maybe we can say compiled, from a schema, so now let's talk in a little more detail about documents. A document in Mongoose in simply an instance of our model. In the code example shown here, we have a really simple schema named personSchema with first and last name properties. Next, we build a Mongoose model from the personSchema, which is shown here as the second argument to the model method. Again, the first method is simply the name we wish to give our model. We've seen this much in the previous example, so let's continue on with the code example. Here, we've created a single instance of our model and named this new document zevia and then supplied values to the firstName and lastName properties. Later, we'll see how to save and retrieve documents such as this to and from MongoDB through Mongoose.

Sub-documents
Now let's talk about Mongoose subdocuments. This would be a good time to revisit the quiz schema example we looked at earlier in the course. This is a good example of a document that houses subdocuments. Earlier, we were focusing on the shape of our document, that is to say our schema, and we look at how to build a model from that schema just a few moments ago. Since we now know that documents are simply instances of our model, let's take a look at an example of newing up a quiz document based off of a model built from this schema. For now, we'll only focus on one of the two subdocuments in the schema, categories. Let's first build out our Mongoose model, naming it Quiz, and passing in our quizSchema object. Next, let's create a new instance of the Quiz model and name it quiz1. You can see here that we are simply supplying values to each of the properties, and when it comes to our subdocuments, categories, in this case, we're only passing in a single category to the categories array of subdocuments. In a moment, we'll look at a more complex example of how to pass in multiple subdocuments. As a preview of things to come in the demo, here's how we save our document. Named quiz1 in this example, through Mongoose to MongoDB using the save method available to us on the Mongoose document instance. The callback parameter is optional, but we'll get into this in more detail later on in the course. So now let's take a look at a way, certainly not the only way, but a way to supply data to documents and subdocuments. We'll continue with our previous quiz model and start by stubbing in an empty categories array, and supply a couple of category objects, then an empty questions array, and also supply a couple of questions with subdocuments of question answers for each, pushing the questions and comments into their respective arrays. From here, we simply create a new quiz document, named quiz2 in this example, from the Mongoose model we've named quiz, and then pass in the categories and questions array object, our prefilled subdocuments, in other words. Again, this is just one example of how you may want to consider populating data in documents that have subdocuments within them.

Demo: Saving Documents
Now that you've learned about building a Mongoose model from the schema, and the documents and subdocuments are instances of the model, it's now time to open Visual Studio Code back up and develop the code to save a Mongoose document to MongoDB. We'll start by building each model from its respective schema. Once that is done, we'll develop the code used to save a Mongoose document to MongoDB. This will be done in our Express API, and we'll test that using Postman. Let's get started on that now. Back in Visual Studio Code, and to start, we'll open the standup.js file. All we need to do to obtain a Mongoose model from this schema is to add this line of code, module.exports = mongoose.model, and the first property here is the name of the model. We'll name this one Standup. And second property is where we pass in the schema this model is based off of. In this case, standupSchema, as defined above. Save this file, and we'll do the same thing for the two remaining files. Project.js, adding in module.exports = mongoose.model, name this one Project, and pass in projectSchema. And teamMember.js, also adding in module.exports = mongoose.model with a name of TeamMember and passing in teamMemberSchema. That was pretty easy, and we now have Mongoose models available for us to use. But where will we use these models at? Let's go back to the API routes we stubbed in earlier in the course and develop each of those out a little more now. Starting with the standup route, we only have the get route stubbed in right now, but since we're wanting to save a Mongoose document, we'll need a post route here now. Router.post with the path of /standup and a callback function with two properties, request and response. Now in the body of this function is where we start to make use of the Mongoose model we just finished. Let note = new Standup, and pass in the req.body, which will be a JSON object. We need to go back to the top of this file and add a reference to the standup model. Const Standup = require, and move back a couple folders, models/standup. Back in the callback function, note here is the Mongoose document instance of the Standup model we just required, and as such, we now have access to the model's save method. Note.save with a callback function where the first property is any errors that may be returned and the second, the note document that was saved. We can test to see if there were any errors returned, and if so, notify the consumer of this API endpoint, returning a status of 400 and the error object as JSON. Otherwise, we're good, and therefore, let's return a status of 200 and the actual note document as JSON. Just to save a little time, I'll paste in code for projects and team. The code is nearly identical to what we just looked at with the standup put endpoint, each requiring their respective model file and newing up an instance of the document from that model and then saving the JSON passed into the request body. Earlier in the course when we started developing this API server, we only asked the Express application to listen on the configured port. But so far, we haven't connected to MongoDB. It's time to do that now, or we won't get too far saving documents to MongoDB through Mongoose. We'll make those changes in the app.js file. First off, we need to bring in Mongoose, so const mongoose = require mongoose. Next, let's connect to Mongoose using the localhost connection string information, as shown here. This information will need to change when we migrate to the cloud, by the way. Next is a reference to the Mongoose connection. It would be helpful to see if there were any errors upon connecting to MongoDB through Mongoose, and that's what this line does for us. Now, once the database is open, in this callback function, we will log out to the console that we're connected to MongoDB, and then, as before, ask the Express app to start listening for the request on the port configured above. With all of those changes saved now, let's move over to the terminal window. Make sure that your local instance of MongoDB is running, as it is in this terminal tab now. Make sure you're in the server folder, and then run this Express API. We do that by running yarn start here, and after a moment we can see that the server is running on localhost port 8081. Now that the Express API server is running, we can test saving a document to it using Postman. Let's get that up and running now. Here in Postman, I have a test post already set up in this Mongoose course collection. Notice the URL is set to localhost port 8081 /api/standup. On the Body tab here, notice the JSON object matches our Mongoose schema, and therefore the model and documents built from that schema. I have some test data prefilled out here, and if we send this post, we should see a status of 200 OK and the saved document returned in the response body. To fully confirm this, let's open up Studio 3T and see if we can find this newly saved document. Once that opens and we get connected to local, we can open up the virtualstandups database and then the standups collection. This last entry should be the new one we just added via Postman, so we're good to go there.

Summary
In this module, we looked at some examples of how to build a model from a previously defined schema and discussed the arguments we pass into the Mongoose model method, which were a string which represents the name of the model and the schema object used to build the model from. Also, there is a third optional argument which allows you to specify and override the name of our MongoDB collection document instance will be saved to. Next, we examined the relationship between models and documents in Mongoose and how those documents relate to MongoDB collection documents. We then we looked at a slightly more complex example while populating the example quiz document with subdocuments. In the demo, we picked up where we left off with the standup schema by building a model from that schema and then creating a document instance from that model, testing that all out in Postman. In the next module, we will take things one step further and learn to query data from MongoDB using these same models. I'll see you in the next module.

Retrieve Data Using Queries
Introduction
Welcome to this module on retrieving data from MongoDB using Mongoose queries. In the previous module, we saw how to save a document to MongoDB using the models save method. In this module, we will be looking at the various methods to retrieve and update document. We will start by looking at the model methods find, findById, findOne, and where. We will then examine some of the methods used to update and remove documents from a MongoDB collection.

Documents and Helper Methods
You learned earlier that a Mongoose document is an instance of a model and that this Mongoose document directly represents the document saved in a MongoDB collection. In this clip, let's examine some of the model methods available to us and start with those used to retrieve documents from MongoDB including find, findOne, findById, and where. Let's start with the find method and some examples of how to use that. With each of these examples, we will start by requiring a model file so that we can gain access to that particular model's helper methods. In this first example, we're bringing in the standup. js model file. Also, with each example in this module, you'll notice at the top right of the page the method parameters available to each and whether they're required or not. We will not cover each parameter or possible option, but we will go through enough examples that I believe you'll get the general idea of how to utilize each of the various query methods that we will cover here. In this first example, we're simply calling the find method with an empty conditions object and no optional parameters. What this will do is return all of the documents within the collection associated with this model, which as a reminder, is defined in the schema. In our case, this is our standup collection of documents. When a callback is missing, as it is in this example, find will return a query object, which we are storing in the query variable. This query is not executed against the MongoDB database, at least not until you tell it to as shown here. In this next example, we are passing in a callback function, and while the find method still returns a query, it is passed to the callback and immediately executed. Callbacks have the signature of first passing in an err and then the results, which once again here, happens to be all of the documents within the standup collection. This example shows us passing in some query conditions now to narrow down our results a little. In SQL terms, this would read something like SELECT * FROM Standup WHERE MemberName = David. All documents found to match this query condition object will be returned in the results object. And if we have any errors, those will be returned here. You may not always want to return all available fields found in a document. In this last example, you can see here that a string representing the fields we wish to return are listed, memberName and impediment. Other fields within the document will not be returned in these results. Next, let's look at the findOne method, which as the name would suggest, returns only one document. This first example shows passing in a conditions query object asking for a memberName of David. The single first result found will be passed into the results of the callback function. As with the find method example we just looked at, you may not always want to return all available fields found in a document. So here again, in this example, we're passing in a string that represents only the fields we want returned, memberName and impediment. While find and findOne are very useful and will be used a lot within your applications, it's nice to also ask for a specific document by its unique id value. That's what the findById method does for us if that wasn't obvious by the name of the method alone. You'll also notice that the findById method parameters have changes slightly. There are no conditions to pass in because the only query condition is the id, nothing more. Each of these find methods can be chained together as shown here. FindById also returns a query object, which has an execute method, which takes in a callback function and so forth. This last example shows how you can ask for every field within a document to be returned, but the impediments field. Notice the minus sign of the beginning of the string here? Before we talk about our last query method, where, let's talk a little about comparison query operators. Those include greater than, greater than or equal to, exists in, less than, less than or equal to, not equal to, does not exist. In this code example, which illustrates the use of the greater than or equal to comparison operator, we're asking to find customer documents where the discount value is greater than or equal to 10. In some of the previous examples, you may have noticed that we were asking for a member name and then passing in a string. Here we're passing in an object that includes a comparison operator, or any number of comparison operators can be used. Simply place a comma between each pair. Let's take the previous comparison query operator example and see what that would look like if we were using the where method. As a comparison, let's take a look at the find method again. It's very similar. The where method also returns a query object that we can simply apply the greater than or equal to and less than query comparison operators to and then execute the query immediately via the callback function. Looking at the parameters here, the first required parameter is path. What exactly does that mean? If we compare the first find example to the where query example, you can see that the path is simply the name of the document field we are querying against. This could also be a nested path, say for example, discount. amount or discount. percentage. Because queries are chainable, we can continue adding on where methods as shown here. In this example we're also supplying the optional val, or value argument, asking for a zipCode of 12345.

Updating and Removing Documents
Now that we understand how to retrieve documents from MongoDB through Mongoose, let's talk about how to update and remove these documents as well. When thinking about updating an existing document, one approach we could take would be to simply perform a find, like this findById example, update the resulting document, and then save those updates; however, let's think about what is going on with this example for just a moment. We first have to find a document, and that's one call to the database. Then we have to make a second call to pass in the updated document, and that may be exactly what you need to do in some cases, but most of the time it will not be. So let's look and see if there is a different way to do these updates, maybe one that only calls the database once. Much like the model query methods we looked at in the previous clip, a Mongoose model also has methods to help us update and delete documents. Here are some of the model methods we will examine in this clip. UpdateOne, which updates one document; updateMany for those times you want to update a number of documents with the same data; deleteOne to remove or delete a single document from MongoDB; and deleteMany, as the name would imply, used to delete multiple documents that match the given query conditions object. We'll also look at findByIdAndUpdate, as well as findByIdAndDelete. Let's start by looking at the model update methods. And first up is updateOne. As with the previous examples we looked at, the parameters for this model method are listed above. For updateOne, both the query conditions and doc parameters are required. The standup model has been pulled in, and next, we set up the query condition object, asking for a standup document that has a memberName of Marry. Next, we set up the update document, what we wish the document found using the conditioning query to be updated to. Now we pass into the standup model's updateOne method, the condition query, and update document from above. There may be more than one document that matches a query condition, but with updateOne, it only updates the first one found. Since we have a callback function in this example, it will get executed immediately and any error will be passed back into the err object, and the full response from MongoDB will be passed into raw response. In a number of the find and update examples we have looked at so far, you probably noticed most have an optional options parameter that can be passed in. For more information on which options are available for the particular model method you may be working with, please take a look at the Mongoose API documentation and look look for Query-setOptions found at this URL. As shown here, not all options are applicable to all methods. We just looked at how to update one document. Now let's examine the model method used to update a batch of documents that match our query conditions, updateMany. It has the same required parameters as updateOne, a conditions query object and the update document object. In this example, the conditions query object is asking for any document that has an empty string in the impediments field, and we we'll be updating that to the string None, So you may be asking do you have to put the conditions query object and update document object in their own variables? No. This is just one code readability technique that you may want to consider. The bottom line is that these are just objects, and as shown here, can be placed as inline parameters and will work the same. Just like we have methods to update one or many documents, we also have deleteOne and deleteMany. Let's select the deleteOne first. In this contrived example, we have two inactive project documents with the name field values of Demo test. We only want to delete one of those and keep the second in place for reuse later. We just don't need two of them. The conditions query object is set and passed into the standup model's deleteOne method and only the first matching document is deleted. Any errors will be passed back. In this example where we examine the deleteMany method, we're illustrating a database cleanup operation where you may want to delete all inactive documents. There are a couple more update and remove methods that we'll briefly cover here before moving on to the demo, FindByIdAndUpdate and findByIdAndDelete. FindByIdAndUpdate does just what the name implies. As with the findById method we looked at earlier, the only condition we pass in is an id. And as with the modelUpdate method, we also pass in an optional update object here. The callback function, which is also optional is the same as the previous examples we have looked at. The official Mongoose API documentation recommends that unless you have a good reason for using findByIdAndRemove that you should instead always use findByIdAndDelete. So that's what we'll look at next. FindByIdAndDelete, which is also completely understood by its name, finds a document by its unique id and then deletes it. Options and a callback function are both optional.

Demo: Querying Documents
Before we open up the code editor, it would be helpful to take another quick look at the partially completed demo application in order to review the API endpoints we may need to develop next. As we saw before, when you're showing the 12 newest standup meeting notes here, it's an arbitrary number just so that we can illustrate limiting the number of documents returned. We also need to have the ability to supply a list of team members for this drop-down list. And if you recall, when adding a new note, we also have a list of active projects to select from, so we might as well go ahead and get that work done too. Now that we've reviewed the demo application, we can see that we're going to need the following API GET routes in order to query the MongoDB documents we'll need. We need a GET route to list out the 12 newest standup note documents entered, another route to get a list of team members for the filtered drop-down list, and while we're here, we'll go ahead and develop the route to get a list of active projects. Let's open up Visual Studio Code now and get that work done. Make sure that MongoDB is running locally, and as we see, it is here on this tab, code. to open up Visual Studio Code, and the api folder under routes will open up standup. js to start with, and we'll finish off this GET route that was stubbed in earlier in the course. The standup model has been required above, so we have access to the model's find method. We want the documents to come back to assorted by created date, so we can chain onto the query object returned by the find method asking the documents to be sorted by created On with a value of 1, meaning ascending order. We may actually want these documents descending, and if so, just change this to -1. Now we can execute the query object. And since this returns a promise, we can then into that, and using an arrow function to retrieve the returned documents, setting the response status to 200 OK, and returning the found and sorted documents as JSON. Now if something went wrong with this call, we can catch that error, and again, using an arrow function, set the status to 500 Server Error, and then pass back to the consumer of this API endpoint a JSON object with a friendly error message and the actual error that took place. Next, let's look at the team route. We first need to require the teamMember model. Now that we have access to that, as we just did with the standup note's GET endpoint, we will use the TeamMember model's find method, but this time, sort by the team member's name ascending, executing that query object, and returning the found TeamMember documents or handling any errors. What we need to do to get the list of active projects is nearly identical to this block of code, so let's copy this and modify as needed. We need to require the Project model here, so let's start with that, and then change the pasted in code a little here. Recall that we only want to list out the active projects, but currently, this will return all project documents. Let's build a query object to filter those down. Const qry =, and within this object, we only need the isActive field, and we want to be true, so we can use a comparison query operator, $eq for that. Now pass this qry object into the find method, and now we're only going to give back to active projects. Since we now have the ability to get a list of team members, we can return to the standup notes route file and build out another endpoint that allows us to get notes for a given team member's unique id. Router. get and with a path of standup/:teamMemberId. The colon here indicates a value that is being passed in as a parameter. The callback functions with properties of request and response are next as before. Now like we just saw with getting a list of active projects, let's build a query to get the standup notes by the teamMemberId, but before we do that, we need to make some adjustments to our schema and model file. Let's add a teamMemberId field to this collection with an object for the type, setting the type to a mongoose ObjectId and providing a reference to the teamMembers model file. MongoDB does not provide joins like a traditional relational database does, but we can reference other documents within our collection and store the ObjectId values to those in our document, which is exactly what we've done here with teamMemberId. Back in our standup API route now, we'll ask the query to find the _teamMemberId and cast the ID value provided in the request parameters as a mongoose ObjectId since that is its type as defined in the schema file. We'll need a reference to Mongoose to do this cast, however, so const mongoose = require mongoose. Now just like we did above, we'll utilize the standup model's find method. Sort by the createdOn date value, execute the query, and then pass the return documents and response back, or handle the error with a friendly message and error object passed back. Make sure that all these changes are saved and then open up our terminal window, change directories to the server folder, and now we can start the Express API server. With that running now and no errors found, let's open up Postman to test this work out. Let's first test getting the 12 newest standup nodes at this URL, localhost port 8081/api/standup. That looks pretty good so far. We have a nice list of standup notes here. Now let's try getting notes for a particular team member. As shown in this example where the teamMemberId is passed in as an argument, but where is this value coming from? Let's first test out the endpoint for getting a list of team members. And as you can see here, each document has a unique _id value. Send this GET request now, and things look good with this endpoint as well. We're only getting notes for this one team member as requested. While we're at it, let's test out the Projects GET request, and that looks good too. We're only seeing documents where isActive is true. I think we're in pretty good shape now with the documents and data we need for our application through this Express API.

Using Validation Middleware
Introduction
Welcome to this module on Mongoose validation. This module will introduce the built-in validators we have available to us in Mongoose. We will then introduce the concept of middleware and the development of custom validators. Next, we will discuss how to handle errors produced by the validation process and how to provide friendly error messages back to the application user. Finally, we will polish off the Express API server side of the demo application by adding in custom validation and error handling.

Built-in Validators
Let's start by looking at validation that's built into Mongoose. Because validation is defined in the Mongoose schema type itself, let's do a quick review of some of the more commonly used schema types. Those are listed here. All schema types have the built-in required validator, and we'll look at an example of that here next. Besides required, strings have the following built-in validators available as well: enum, match, minlength, and maxlength. Numbers have the additional built-in validator min and max. Now let's look at a few examples of using these Mongoose built-in validators for strings and numbers. We'll first look at some examples for the string schema type. In this example, we start with the simple customer schema we used before. This time for the name field, we've added in required: true. Notice again that we have passed the type in as an object to include the required validator with it. Not only can we specify that we want a particular field to be required right in the schema definition, but you can come back to the schema object later and add required onto a path with the schema. The path is simply the field name here. This example also shows adding in the optional customized error message. We'll talk about that more in the clips to come. Notice the signature method here where the first argument is a Boolean and then the optional message. Next, let's look at the match validator for a string. We first set up our regular expression stating that we only want to allow alpha characters, either upper or lowercase, but no numbers or other characters. The previous required validator is still used here, but we've added on the match validator as well, passing in the regular expression match object as its value. Next up, we have the enum validator for a string. As the name would imply, we are going to ask this validator to ensure that our string value is found within an enumerated list of strings, like the one shown here. If a string is entered that is not within the list, the enum validator will return false and pass a default error message for this validator to the callback. The number schema type has two other validators besides required. Those again are min and max. The first example here is used to illustrate the min validator where we've asked that our discount value of type number have a minimum value of five. Next, let's look at the max built-in number validator. With this example, we've asked that our discount have a maximum value of 60, and as you might imagine, we can use both numbers at the same time and therefore ask for a range of numbers between min and max values given.

Introduction to Middleware
Because the built-in validators we just looked at are an internal piece of Mongoose middleware, it would be good to take just a moment to introduce the concept of middleware. As you have already learned, a document is an instance of a Mongoose model. These instance documents have static helper methods available to them, some of which we have already explored in this course, such as the save method. Middleware are functions which are given control over the execution flow for the following methods: validate, save, remove, and init. We will only be discussing middleware for the save method in this module. You can think of middleware as sort of a detour on the execution flow highway on our way to saving our document. Earlier, we looked at built-in validators, and the one that is available to all schema types is required. Let's look at a validation middleware example of calling the save method on a document instance of a model based off of a schema where we have set required to true. As you now know, everything in Mongoose starts with a schema. So let's define a personSchema with three fields, first and lastName and status. The status field is just so we know if they're alive or dead. Next, we will build a model from the schema and then a document instance from the model, supplying values to the firstName and lastName fields only, skipping status. Now we will attempt to save the document. For our purposes of discussing the flow of execution, here's what would take place. Save is called; default value, if any, as defined in the schema are applied. In our example, we did not supply a value to status. It is marked as required; and therefore, the default value of Alive will be applied to that field. Now validation is performed. In this example, we are only exploring the built-in required validator, so the validation process looks to make sure that we have supplied a value to the firstName and lastName fields. If we have not, an err is generated and received by the callback. For the purposes of discussing the flow of execution around validation, here is what takes place. The model's save method is called; default values, if any, as defined in the schema are applied. In the previous example, we did not supply a value to status. It is marked as required and therefore the supplied default value will be applied to that field. Now a validation is performed. Again, in the previous example, we are only using the built-in required validator, so the validation process simply ensures that we supplied values to the firstName and lastName fields. If not, then an error is generated and received by the callback; otherwise, we're good to go, and the document will be successfully saved to the MongoDB database.

Custom Validators
Now let's look at how to build custom validators. While being able to ensure that a string, number, date, or other schema type has provided required data or that a number is within a min or max range is very useful. There are times when the built-in validators we looked at in the previous clip are just not enough. Thankfully, it's pretty easy to develop custom validators for Mongoose, and that's what this section is all about. For this example, we're going to reuse the previous personSchema, but this time, we've added a custom validator. Our validator is defined here, and we've chosen to also supply the optional errorMsg argument. As show here in this method signature, a validator will always receive the value you wish to validate as the first argument Custom validators must return true or false. True meaning the validation process passed, and naturally, false if it did not. Our sizeValidator is an array of two objects. The first is the validator function, and the second is an optional custom error message. If not supplied, a generic error message template will be used. We'll talk more about error message templates in the next clip.

Handling Validation Errors
We just saw an example of supplying a custom error message into a validator. Now let's take a look at how to handle those errors and notify the user that something went wrong, hopefully in an understandable and nice way. Let's take one more quick look at the custom sizeValidator we used in the last clip. Only this time, we'll intentionally violate the custom size validation rule and provide an obnoxiously long firstName for this Person document. When we save the new Person document instance of the Person model, validation will fail and an err object will be returned in the callback function. So what exactly does this err object contain? Let's take a look at an example of that now. This error JSON object is an example of what would be returned. Note that the custom error message here states String must be between 1 and 50, but wouldn't it be nice to tell the user which specific field this validation failed on? If the optional custom error message is not supplied, a generic error message template will be used. Not only are you allowed to completely customize the error message as we saw in the previous err object example, but you may also choose to customize the error message template for built-in validators, such as required or min and max for numbers. In this example, the built-in validation message for the Number. min validator, which is shown here, is being overwritten with a custom message. PATH is the field the invalid value was supplied to, and VALUE is the number entered by the user, and MIN tells the user what the minimum value actually is as defined in the schema. Taking one more quick look at this custom validator example from before, it's the same, except now we're telling the user which PATH or field name the invalid data was supplied to.

Adding Validation
Let's finish off the Express API server side of the demo application by adding in some validation. The standup schema currently has no validation at all. We're simply supplying the type of string on most fields and as type Date on the createdOn field with a default value set. Let's start by adding in the basic built-in required validator to our standup schema, which will leave our standup schema looking similar to this. We will test this out in Postman and show why setting required to true alone is not going to be good enough for our application. Take, for example, the workYesterday field. We've said that it's required so the user will have to enter something there, but a bunch of spaces is something, right? Just not what the business may want to see there. so we need to come up with a custom validator to test for that situation. That custom validator will be named requiredStringValidator, which is an array of two elements, the first being the test function, which returns true or false based upon the value passed in and test conditions set up. In this case, we're trimming the string to ensure that the user didn't enter a bunch of spaces then testing the length to see if it's greater than 0. If so, true is returned. If not, the second element, the Custom error message, is returned. And here is the standup schema once again, this time with the requiredStringValidator added into the workYesterday field as just one example. We will actually want to add this to the project, workToday, and impediment fields as well. The next custom validator we'll add in and test is for the teamMemberSchema. This custom validator is the size validator we've already looked at examples of in this module, but now we'll add that one in here to the teamMemberSchema to ensure that someone doesn't try to enter in a bunch of spaces again or a name that is just crazy long. Alright, it's time to open up Visual Studio Code and add in the validation we just about to talked to the demo application. We will start with the built-in required validation, which along with the custom validators, is already in place. Using Postman, we'll test first with just the built-in required validator in place then add in the custom validator to the standup and teamMember schema files. Let's get started on that.

Demo: Adding Validation
As noted earlier, the custom validators are already in place here in the standup. js schema file, as well as the teamMember. js schema file. But as you can see in each schema, we're not using them just yet. We will start our testing out with just the built-in required validator set to true and see what that does for us and why that probably isn't going to be enough for our business needs. Let's open up a terminal window and make sure that MongoDB is running. Next, change to the server folder and start the Express API server, yarn start, to kick that off. It will take a few seconds for that to spin up, but once it's done and the server is listening on localhost port 8081, we can open up Postman and test this out. I'll use the test POST previously set up to save a new standup note to the database api/standup. Only this time, in the body being sent in the request, let's change workYesterday to a bunch of spaces and send that POST request. Now we should open up Studio 3T, connect, and take a look at this new entry. Connecting to local, and then select virtualstandups, and then the standups collection, the last entry here is the one that we just posted, and you can see it was saved with all of those blank spaces. I'm going to remove this document now and return to Visual Studio Code where we'll add in the custom validator to address this problem. Back in the standupSchema, I'll add custom validation now, validate, and the name of the custom validator is up here, requiredStringValidator. We'll want this validation on other fields as well, so I'll just copy and paste that now. That's better. The custom requiredString validation is now on each of the fields that we do not want to allow users to simply enter empty spaces on. Now let's go fix the teamMemberSchema as well. We will do the same thing here in this schema, now using the sizeValidator custom validator. Validate: sizeValidator and then Ctrl+S to save this change. Let's take a look at the terminal window, and we can see that nodemon has restarted due to those schema changes. So we're good to go to retest this again in Postman now. This is the same test POST, and the spaces are still here. So let's Send this again now. And scrolling down, we can see the error message our Mongoose validation returned, so that was a success. While we're here in Postman, let's go ahead and test the change to the teamMemberSchema with the custom sizeValidator. To set this test up, I'll use the test GET to grab the list of team members, and copy one of these objects, and change this to a POST now, and clean this object up, and change the name to a random long string value, which is clearly more than 50 characters long. Oh, and we do not need this _id, and this needs to be JSON, not Text. Sending this post, and you can see that a 400 Bad Request error object was returned clearly telling us what the error was. The custom Mongoose validation we've added to the Express API server is working as expected.

Next Steps
Finishing Touches
Welcome to this module on finishing touches and next steps. We've gotten a lot of work done on the Express API server, and things have been tested successfully using Postman with the locally running instance of MongoDB. But at this stage of development, it's time to move the database to the cloud, or at least to an on-premise database server. In this module, we'll start by doing just that and migrate the demo application's MongoDB instance to a cloud hosted offering. To finish this course off, we will review the completed Vue. js client project and test that out against our newly migrated database. As mentioned earlier in the course, the focus here was on Mongoose, so not much time was devoted to the UI project. To wrap the course up, we'll look at some other resources and Pluralsight courses on Vue. js and other UI frameworks that you may wish to consider, as well as additional information on MongoDB.

Migrate to the Cloud
In this clip, we will start looking at some methods of migrating a local MongoDB instance to the cloud. One option you should consider and research is using the MongoDB package component, mongodump and mongorestore. These are utilities provided by MongoDB to back up a copy of your database, either a single instance or shards and then restore those backups. Also, some of the cloud-based MongoDB database hosting options that you will see provide their own migration tools. MLab and Atlas both provide documentation and tooling for migrating your database to their services. What we will use is the export and import features found in Studio 3T, which will allow us to export each collection as a JSON object and preserve the schema and data types. Let's open up Studio 3T and use it first to export the collections, including the schema and documents from the local virtual standups database; Then connect to the mLab sandbox account and use the import feature in Studio 3T to pull those collections into our cloud-based database. Let's make sure MongoDB is running locally first, and then open up Studio 3T, and first connect to our locally running instance of MongoDB, select the virtualstandups database, and then Export. For the purposes of this demo, we'll export JSON files and press Next. Likewise, here, we'll stick with the default of JSON mongo shell and click Next again. Now we're being asked to select a directory to export the selected database. Each collection will be exported as its own JSON file here. I'll export these to c:/Temp/export, and one last click on Start Export to get this process done. You should notice on the lower left, the exports are done on each collection, including the system indexes, which were exported to JSON files. Let's open up a browser and look at the mLab sandbox account we have set up. Once again, make note here that mLab is becoming part of MongoDB, meaning this account will soon be migrated to Atlas. Log in with the username and password. And the sandbox database that we'll be migrating this to is this one, virtualstandup. Notice that mLab provides you with a sample of the connection string here. This is primarily what I wanted to point out here. Moving back to Studio 3T. I already have that connection string set up here in Studio 3T, so let's get connected now. In the virtualstandup database, again, in the sandbox account, you can see 0 Collections. Click Import on the top menu bar. We just exported to JSON files, so we'll leave this set to JSON mongo shell and press Next. Now select the JSON Source files from the temp export folder. I'll grab all of these at once, and you can see that each JSON source is pointing to the correct collection. Click Next to see the preview, and Next once more for a summary, and now Start Import. Now let's confirm a successful import by opening up let's say the projects collection. That looks good to me. And teammembers, and that looks fine as well. I think we've successfully migrated to the cloud.

Review the Client Project
Now it's time to do a quick review of the Vue. js client project. Because this will be a quick review, I've provided the source for the Vue. js project for you to review and download at this GitHub link. After the review of the client project, we will look at some other trainer resources you should consider when it comes to a more in-depth look at Vue. js. Let's open Visual Studio Code back up, and now that we've migrated the database to the cloud using Studio 3T, let's be sure to change the connection string details in our Express API server project. Then we will do a quick review of the finished Vue. js client project. Code. to open up Visual Studio Code. And as mentioned before, now that we've migrated our MongoDB database to the cloud, be sure to change the connection string as shown here. As a reminder, this connection string was made available to us on the mLab website. Close the server project and open up the client project now. All of the code that we'll be looking at is in the src folder, and we'll start by reviewing the main. js file. This is where everything in the Vue. js application is kicked off from. Take note of the various imports here, Vue, of course, and Vuetify, and one of particular importance to the work we've done in the Express API server project is axios. Here is where we've asked Vue to make sure that axios is available globally throughout the application and set the base URL to our locally running Express API server running on port 8081/api. Calls to the API are made in the Vuex state store, which again, was imported here. Opening store. js, we can see that we're importing Vue and Vuex and then asking Vue to use Vuex. The state object is the place where we keep track of the application state, and the getters are set up to respond to any changes in this state so that anything that is bound to one of these getters will react to the state change. This next section is for actions, the methods we want to expose to expose to consumers of the Vuex state store, such as this import action, getStandups. Notice that it is using axios to call out to the API with a GET request to the standup endpoint. The response from that call is committed to the standup note's mutation, which we'll see here in a moment. And here is saveStandup, which is once again using axios to communicate with the API to post a new standup note to MongoDB through Mongoose. Here is the previously mentioned standup note's mutation, which is used to save the data payload. The standup note we wish to save in this case to the Vuex state store. The UI component that is bound to the associated getter will then react to the state change and rerender the list of standup notes. Moving back to the main. js file. Notice at the bottom of the file this render line where we're passing in App. This references App, which was imported above from the App. vue file. Let's take a look at that now. Vue files typically have three sections, template, script, and style. The template section is where you find the typical HTML markup as we see here. This is our base or parent Vue file that houses all of the other components. Speaking of components, in the script block, we have a Navigation component imported and registered in the components sections. In Computed, we see one example of wiring up the Vuex store getter, teamMembers in this example. Scrolling down more within the scrip block, you see methods. This is where we expose the various functions used to get data from the Vuex state store or perform other task. For example, notice getProjects and getTeamMembers here. These methods are used to dispatch a request to the store asking the store to call out to the API and get data. Then you take the state data accordingly. We want this to take place as soon as the page is loaded, and that is accomplished here in the mounted lifecycle event handler. Now let's take a look at this Navigation component, which is found in the components folder. This is just another self-contained Vue file with the same structure, template, script, and style blocks. This component is for the left pop-out navigation we saw earlier in the course when demonstrating the completed project. There were two other components in this project, StandupDialog. vue, which is the model dialog we'll use here in a few moments to enter in a new standup note, and the last component is StandupList, which is responsible for displaying the list of the 12 newest notes. Notice here with the notes computed property, we're getting this list of notes from the Vuex store. Back in the App. vue file now, and notice this block of code, router-view, within a Vue content component. This is where we inject other views such as the Home. vue as shown here in the router. js file. And the Home. vue is where we find the previously looked at StandupList and StandupDialog components being imported and used. That was a quick overview of the Vue. js client project. And now let's open up a terminal and test this out, making sure first that mongod is running, as well as the Express API server. And now, moving up into the client folder, yarn serve to kick off the web application project. Open up a browser and head over to localhost port 8080, and the application is up and running. And this data is now coming from the cloud hosted database. Let's try adding a new standup note now, and select a team member and project, and fill yesterday and today with filler text just to test, press SAVE, and we're good.

Other Resourses
As we close out this Mongoose Fundamentals course, and as promised, let's explore a few more training resources to consider. We went through the review of the client project pretty quick. And as noted earlier, if you would like to learn more about Vue. js and why you should consider it for your own web application projects, take a look at a couple of the Pluralsight courses listed here or simply use the URL shown here to search the Pluralsight library for all Vue. js related courses. Vue. js is growing in popularity, so it would be worth your time to explore it and learn more by taking one of these courses. And as a quick reminder, feel free to download the Vue. js client project for this course and review the code on your own time. This course obviously focused on Mongoose, but having a good understanding of the underlying database, MongoDB, is very important to. So listed here are a couple courses on MongoDB you should consider taking as well, or you can search for all MongoDB related courses at this URL. So what's next? If you have access to the exercise files, please consider downloading that and reviewing the source code for the Express API server project. And once more, you have access to the client project there at the GitHub link mentioned earlier. As things typically go with demo applications, the demo application for this was not overly complex, but was useful in discovering the basic principles and features of Mongoose. That was the ultimate goal of this course. Consider expanding on the schema files or come up with your own custom validators. If you're more familiar with React, or Angular, or another UI framework, consider developing a client project using the framework of your choice and have it communicate with the Express API server developed in this course. Lastly, if you would like to go into more depth on Mongoose, take a look at my prior course, Moving Forward with Mongoose. js. Despite it being for a prior version of Mongoose, the advanced Mongoose topics discussed there, by in large, still apply and will be helpful to you. My name is Mark Scott, and I hope that you've enjoyed this course, Fundamentals of Mongoose for Node and MongoDB.
